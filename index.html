<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rock Breakout — 冰雪＋烈焰皮膚 0823（金耀日蝕調整）</title>
  
  <style>
    :root{
      /* 共用設計 Token（各 Skin 會覆蓋） */
      --ink:#eaf2ff; --muted:#b8c7ea;
      --glass-1:rgba(255,255,255,.08); --glass-2:rgba(255,255,255,.06);
      --stroke:rgba(140,180,255,.28);
      --bg1:#13224a; --bg2:#081022;
      --hudGrad1:rgba(20,25,44,.62); --hudGrad2:rgba(12,20,42,.44);
      --stageGlass:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
      --panelPattern:none;
      --btnGlow:0 0 0 rgba(0,0,0,0);
      --hudBottom:96px;
      --heartGlow: rgba(0,0,0,0); /* 生命圖示光暈色（依 Skin 覆蓋） */
    }
    html,body{height:100%;margin:0;color:var(--ink);
      background: radial-gradient(140% 140% at 50% -12%, var(--bg1) 0%, #0e1a3a 50%, #0b1633 75%, var(--bg2) 100%);
      font-family: ui-sans-serif, -apple-system, system-ui, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:0 12px 24px}
    header{padding:calc(8px + env(safe-area-inset-top)) 0 10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:space-between}
    h1{font-size:clamp(16px,2.6vw,22px);margin:0 8px 0 0;letter-spacing:.4px;opacity:.95}
    .small{font-size:12px;color:var(--muted)}

    /* HUD 與 UI：維持結構，僅靠變數換膚 */
    .hud{position:sticky;top:0;z-index:30;display:grid;gap:8px;align-items:center;
      grid-template-columns:1fr;max-width:min(1080px,96vw);margin:8px auto 0;border:1px solid var(--stroke);
      border-radius:18px;padding:10px;background:linear-gradient(180deg,var(--hudGrad1),var(--hudGrad2));
      backdrop-filter: blur(8px);box-shadow:0 6px 28px rgba(0,0,0,.28)}
    .stats{display:grid;grid-template-columns:auto auto 1fr;grid-auto-rows:minmax(36px,auto);gap:8px 10px;align-items:center}
    .stats .wide{grid-column:1 / -1}
    .pill{padding:8px 18px;border:1px solid var(--stroke);background:var(--glass-2);border-radius:999px;min-height:36px;display:flex;align-items:center;gap:10px;color:#d7e3ff;font-weight:650;font-size:15px}
    .pill b{color:#fff;font-variant-numeric:tabular-nums}
    .inline-controls{justify-self:end;display:flex;gap:8px;align-items:center;position:relative}
    .ic-btn{width:48px;height:36px;border-radius:12px;border:1px solid var(--stroke);
      background:radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.16), rgba(255,255,255,0) 58%), var(--glass-1);
      display:grid;place-items:center;cursor:pointer;box-shadow:inset 0 0 0 1px rgba(255,255,255,.05), 0 8px 20px rgba(0,0,0,.28), var(--btnGlow); color:#fff}
    .ic-btn:active{transform:translateY(1px)}
    .ic-btn .ico{font-size:18px;line-height:1}

    .menu{position:absolute;top:46px;right:0;min-width:280px;padding:10px;border:1px solid var(--stroke);border-radius:14px;background:rgba(12,18,36,.96);backdrop-filter:blur(10px);transform:scale(.96);opacity:0;pointer-events:none;transition:.16s ease;z-index:60}
    .menu.show{transform:scale(1);opacity:1;pointer-events:auto}
    .menu .item{display:flex;align-items:center;gap:10px;padding:10px;border:1px solid var(--stroke);border-radius:10px;background:var(--glass-2);margin-bottom:8px}
    .menu h4{margin:6px 0 8px;font-size:13px;color:#cfe0ff}
    .btn{padding:8px 12px;border-radius:10px;border:1px solid var(--stroke);cursor:pointer;background:var(--glass-2);color:#fff;box-shadow:var(--btnGlow)}

    #buffs{position:sticky;z-index:22;top:calc(var(--hudBottom) + 6px);display:flex;gap:8px;align-items:center;max-width:min(1080px,96vw);margin:6px auto 0;padding-left:6px;overflow:auto;scrollbar-width:none}
    #buffs::-webkit-scrollbar{display:none}
    .chip{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--stroke);border-radius:999px;background:var(--glass-1);font-size:12px;white-space:nowrap;color:#cfe0ff}
    #promptsDock{position:sticky;z-index:20;top:calc(var(--hudBottom) + 48px);max-width:min(1080px,96vw);margin:6px auto 0;padding:0 6px;display:flex;gap:8px;align-items:flex-start;overflow:auto;scrollbar-width:none}
    #promptsDock::-webkit-scrollbar{display:none}
    .prompt{padding:8px 10px;border:1px solid var(--stroke);border-radius:12px;background:rgba(14,22,40,.92);box-shadow:0 10px 26px rgba(0,0,0,.34);font-size:12px;line-height:1.45;color:#eaf2ff;white-space:nowrap}

    .stage{position:relative;margin:12px auto 0;max-width:min(1080px,96vw);border-radius:18px;padding:12px;box-sizing:border-box;background:var(--stageGlass);background-image:var(--panelPattern);background-blend-mode:overlay;}
    canvas#game{background:linear-gradient(180deg,#0d132a,#0b1226 55%, #091223);border:1px solid rgba(80,110,170,.45);border-radius:16px;display:block;width:100%;height:auto;margin:0 auto;box-shadow:inset 0 0 160px rgba(255,255,255,.03), 0 28px 90px rgba(0,0,0,.46)}
    .legend{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;font-size:12px;color:#cfe0ff;margin-top:6px}
    .legend .item{padding:4px 8px;border-radius:10px;background:rgba(255,255,255,.05);border:1px solid var(--stroke)}
    .legend .box{width:14px;height:14px;display:inline-block;border-radius:3px;margin-right:4px;vertical-align:middle}

    .hearts{filter: drop-shadow(0 0 10px var(--heartGlow));}
    .hearts.flame{filter: drop-shadow(0 0 12px var(--heartGlow));}

    /* Skulls revive animation (灰化→重組) */
    .hearts.revive .life-icon{ animation: skull-revive 800ms ease-out; }
    @keyframes skull-revive{
      0%{ filter: grayscale(1) blur(1.5px); opacity:.2; transform: translateY(6px) scale(.9); }
      60%{ filter: grayscale(1) blur(2.5px); opacity:.1; transform: translateY(10px) scale(.85); }
      100%{ filter:none; opacity:1; transform:none; }
    }


    @media (max-width:390px){ .pill{font-size:14px;padding:7px 14px} .ic-btn{width:44px;height:36px} }

    /* ======== 既有 Skins（科技/木紋/冰雪） ======== */
    body[data-skin="霓虹．魅影幻彩"]{ --ink:#f6fbff; --muted:#dbe6ff; --stroke:rgba(200,220,255,.38); --bg1:#0b0f2a; --bg2:#070a18; --hudGrad1:rgba(24,28,70,.58); --hudGrad2:rgba(16,22,58,.42); --glass-1:rgba(255,255,255,.12); --glass-2:rgba(255,255,255,.09); --stageGlass:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0)); --panelPattern:conic-gradient(from 0deg at 60% 40%, rgba(255,160,220,.08), rgba(160,220,255,.06), rgba(160,255,200,.06), rgba(255,220,160,.06), rgba(255,160,220,.08)); --btnGlow:0 0 20px rgba(160,220,255,.25);}    
    body[data-skin="科技．賽博格綠"]{ --ink:#e7ffe7; --muted:#bdfdcc; --stroke:rgba(120,255,170,.34); --bg1:#081812; --bg2:#03110a; --hudGrad1:rgba(10,40,26,.64); --hudGrad2:rgba(6,28,18,.46); --glass-1:rgba(160,255,200,.12); --glass-2:rgba(120,220,170,.08); --stageGlass:linear-gradient(180deg, rgba(120,255,180,.05), rgba(0,0,0,0)); --panelPattern:repeating-linear-gradient(180deg, rgba(140,255,190,.05) 0 1px, transparent 1px 3px); --btnGlow:0 0 16px rgba(120,255,170,.25);}    
    body[data-skin="宇宙．星辰絮語"]{ --ink:#eef0ff; --muted:#c9c9ff; --stroke:rgba(160,140,255,.34); --bg1:#0c0b24; --bg2:#09081a; --hudGrad1:rgba(30,24,70,.58); --hudGrad2:rgba(20,18,50,.44); --glass-1:rgba(200,180,255,.10); --glass-2:rgba(160,140,255,.08); --stageGlass:linear-gradient(180deg, rgba(160,140,255,.05), rgba(0,0,0,0)); --panelPattern:radial-gradient(120px 80px at 20% 10%, rgba(110,80,255,.08), transparent 60%), radial-gradient(160px 120px at 80% 20%, rgba(180,100,255,.08), transparent 60%); --btnGlow:0 0 22px rgba(150,120,255,.25);}    
    body[data-skin="木紋．黑檀曜金"]{ --ink:#f6edd8; --muted:#d9caa8; --stroke:rgba(255,220,140,.28); --bg1:#0e0b09; --bg2:#060403; --hudGrad1:rgba(28,18,10,.72); --hudGrad2:rgba(18,12,8,.56); --glass-1:rgba(255,220,140,.10); --glass-2:rgba(255,220,140,.07); --stageGlass:linear-gradient(180deg, rgba(255,220,140,.04), rgba(0,0,0,0)); --panelPattern:repeating-linear-gradient(12deg, rgba(40,28,18,.35) 0 18px, rgba(0,0,0,0) 18px 34px), repeating-linear-gradient(192deg, rgba(60,44,28,.20) 0 12px, rgba(0,0,0,0) 12px 28px); --btnGlow:0 0 20px rgba(255,210,120,.24);}    
    body[data-skin="木紋．白橡北歐"]{ --ink:#fff8ec; --muted:#e6d8c2; --stroke:rgba(255,215,170,.26); --bg1:#3a2d19; --bg2:#1c150b; --hudGrad1:rgba(78,60,30,.66); --hudGrad2:rgba(48,36,18,.50); --glass-1:rgba(255,220,170,.10); --glass-2:rgba(255,220,170,.08); --stageGlass:linear-gradient(180deg, rgba(255,230,190,.05), rgba(0,0,0,0)); --panelPattern:repeating-linear-gradient(8deg, rgba(210,170,120,.14) 0 14px, rgba(0,0,0,0) 14px 26px), repeating-linear-gradient(188deg, rgba(240,210,160,.05) 0 2px, rgba(0,0,0,0) 2px 8px); --btnGlow:0 0 16px rgba(255,220,170,.22);}    
    body[data-skin="冰雪．極光絲綢"]{ --ink:#f6fbff; --muted:#d7e9ff; --stroke:rgba(190,220,255,.38); --bg1:#0b1626; --bg2:#060b14; --hudGrad1:rgba(18,28,60,.56); --hudGrad2:rgba(10,20,44,.42); --glass-1:rgba(220,245,255,.12); --glass-2:rgba(210,235,255,.09); --stageGlass:linear-gradient(180deg, rgba(230,245,255,.04), transparent); --panelPattern:conic-gradient(from 0deg at 60% 40%, rgba(180,220,255,.06), rgba(160,210,255,.05), rgba(180,230,255,.06)); --btnGlow:0 0 20px rgba(180,220,255,.26);}    

    
    /* ======== 騎士・白銀劍光 ======== */
    body[data-skin="騎士．白銀劍光"]{
      --ink:#eef4ff; --muted:#cfd9ec;
      --stroke:rgba(190,205,235,.34);
      --bg1:#0D0D0F; --bg2:#0A0A0C;
      --hudGrad1:rgba(22,26,36,.66); --hudGrad2:rgba(14,18,26,.52);
      --glass-1:rgba(255,255,255,.10); --glass-2:rgba(255,255,255,.07);
      --stageGlass:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0));
      --panelPattern:
        repeating-linear-gradient(90deg, rgba(220,230,245,.06) 0 2px, rgba(0,0,0,0) 2px 8px),
        radial-gradient(160px 100px at 72% 14%, rgba(176,196,222,.06), transparent 60%);
      --btnGlow:0 0 20px rgba(200,220,255,.18);
      --heartGlow:rgba(210,230,255,.85);
    }
    /* 生命圖示（頭盔/帽/星）尺寸 */
    .hearts .life-icon{ display:inline-block; width:18px; height:18px; margin:0 2px; vertical-align:-3px; }
    .hearts .life-icon svg{ width:18px; height:18px; }

    /* ======== 烈焰・星火風暴（唯一保留的烈焰皮膚） ======== */
    body[data-skin="烈焰．星火風暴"]{
      --ink:#fff3ec; --muted:#ffd0b8; --stroke:rgba(255,160,120,.30);
      --bg1:#150807; --bg2:#080404;
      --hudGrad1:rgba(40,16,12,.68); --hudGrad2:rgba(22,10,8,.52);
      --glass-1:rgba(255,150,100,.12); --glass-2:rgba(255,130,90,.08);
      --stageGlass:linear-gradient(180deg, rgba(255,140,90,.04), rgba(0,0,0,0));
      --panelPattern:radial-gradient(120px 90px at 30% 20%, rgba(255,120,90,.06), transparent 60%);
      --btnGlow:0 0 22px rgba(255,150,100,.28);
      --heartGlow:rgba(255,120,60,.9);
    }
    /* 星火風暴：UI燃邊與按鈕微閃爍 */
    @keyframes fireFlicker{ 0%{filter:brightness(1);} 50%{filter:brightness(1.08);} 100%{filter:brightness(1);} }
    @keyframes emberBorder{ 0%{ box-shadow:0 0 0 rgba(0,0,0,0), 0 0 28px rgba(255,130,80,.25);} 50%{ box-shadow:0 0 0 rgba(0,0,0,0), 0 0 38px rgba(255,160,110,.34);} 100%{ box-shadow:0 0 0 rgba(0,0,0,0), 0 0 28px rgba(255,130,80,.25);} }
    body[data-skin="烈焰．星火風暴"] .ic-btn,
    body[data-skin="烈焰．星火風暴"] .btn{
      background:
        conic-gradient(from 120deg at 80% 10%, rgba(255,220,180,.12), rgba(255,160,100,.12) 40%, rgba(255,120,80,.08) 60%, rgba(255,220,180,.12)),
        radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.18), rgba(255,255,255,0) 58%),
        var(--glass-1);
      border-color: rgba(255,150,110,.45);
      animation: fireFlicker 1.2s ease-in-out infinite alternate;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), 0 8px 22px rgba(0,0,0,.28), 0 0 32px rgba(255,140,90,.25);
    }
    body[data-skin="烈焰．星火風暴"] .hud{
      animation: emberBorder 2.6s ease-in-out infinite;
      border-color: rgba(255,150,110,.35);
    }
  
    /* ======== 魔法・金耀日蝕 ======== */
    body[data-skin="魔法．金耀日蝕"]{
      --ink:#FFF6E6; --muted:#EED9B6;
      --stroke:rgba(255,210,120,.30);
      --bg1:#0E0C08; --bg2:#0A0906;
      --hudGrad1:rgba(34,26,12,.72); --hudGrad2:rgba(22,16,8,.58);
      --glass-1:rgba(255,228,168,.10); --glass-2:rgba(184,133,46,.08);
      --stageGlass:linear-gradient(180deg, rgba(255,228,168,.045), rgba(0,0,0,0));
      --panelPattern: radial-gradient(160px 100px at 70% 18%, rgba(255,210,120,.06), transparent 60%),
                      radial-gradient(220px 160px at 18% 6%, rgba(184,133,46,.05), transparent 60%);
      --btnGlow:0 0 22px rgba(255,210,120,.22);
      --heartGlow:rgba(255,210,120,.88);
    }
    @keyframes goldBreath{0%{filter:brightness(1)}50%{filter:brightness(1.08)}100%{filter:brightness(1)}}
    body[data-skin="魔法．金耀日蝕"] .ic-btn,
    body[data-skin="魔法．金耀日蝕"] .btn{
      background:
        linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,0) 42%),
        repeating-linear-gradient(90deg, rgba(255,255,255,.06) 0 2px, rgba(0,0,0,0) 2px 6px),
        radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.16), rgba(255,255,255,0) 58%),
        var(--glass-1);
      border-color: rgba(255,210,120,.50);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), 0 8px 22px rgba(0,0,0,.28), 0 0 32px rgba(255,210,120,.18);
      animation: goldBreath 3.5s ease-in-out infinite;
    }
    body[data-skin="魔法．金耀日蝕"] .ic-btn:active,
    body[data-skin="魔法．金耀日蝕"] .btn:active{
      transform: translateY(1px);
      box-shadow: inset 0 1px 0 rgba(0,0,0,.35), 0 6px 18px rgba(0,0,0,.24);
      filter: brightness(1.08);
    }

  
    /* ======== 兔兔・奶油雲朵 ======== */
    body[data-skin="兔兔．奶油雲朵"]{
      --ink:#FFF9FB; --muted:#F7DDE6;
      --stroke:rgba(255,200,180,.28);
      --bg1:#1a1218; --bg2:#0b0a10;
      --hudGrad1:rgba(255,240,246,.18); --hudGrad2:rgba(255,255,255,.10);
      --glass-1:rgba(255,255,255,.18); --glass-2:rgba(255,255,255,.12);
      --stageGlass:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(255,190,220,.18);
      --heartGlow:rgba(255,182,193,.85);
    }
    body[data-skin="兔兔．奶油雲朵"] .hud{ border-radius:20px; box-shadow:0 10px 34px rgba(255,190,220,.18), 0 2px 0 rgba(255,255,255,.04) inset; }
    body[data-skin="兔兔．奶油雲朵"] .hearts .life-icon, body[data-skin="兔兔．奶油雲朵"] .hearts .life-icon svg{width:24px;height:24px}
    body[data-skin="兔兔．奶油雲朵"] .hearts.compact .life-icon, body[data-skin="兔兔．奶油雲朵"] .hearts.compact .life-icon svg{width:21px;height:21px}
    @media (max-width:360px){ body[data-skin="兔兔．奶油雲朵"] .hearts .life-icon, body[data-skin="兔兔．奶油雲朵"] .hearts .life-icon svg{width:22px;height:22px} }
    body[data-skin="兔兔．奶油雲朵"] .ic-btn,
    body[data-skin="兔兔．奶油雲朵"] .btn{
      background:
        linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,0) 46%),
        radial-gradient(90% 120% at 30% 18%, rgba(255,244,234,.36), rgba(255,244,234,0) 60%),
        var(--glass-1);
      border-color: rgba(255,210,230,.45);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), 0 8px 22px rgba(0,0,0,.22), 0 0 24px rgba(255,200,220,.20);
      transition: filter .2s ease;
    }
    body[data-skin="兔兔．奶油雲朵"] .ic-btn:active,
    body[data-skin="兔兔．奶油雲朵"] .btn:active{ filter: brightness(1.06); transform: translateY(1px); }

  
    /* ======== 魔王．終焉寂滅（Apocalypse Silence） ======== */
    body[data-skin="魔王．終焉寂滅"]{
      --ink:#C0C0C0; --muted:#9aa3ad; --stroke:#363636;
      --hudGrad1:rgba(14,14,14,.82); --hudGrad2:rgba(10,10,10,.66);
      --glass-1:rgba(192,192,192,.08); --glass-2:rgba(120,120,120,.06);
      --stageGlass:linear-gradient(180deg, rgba(14,14,14,.85), rgba(10,10,10,.65));
      --panelPattern:
        repeating-linear-gradient(125deg, rgba(255,255,255,0.04) 0 2px, rgba(0,0,0,0) 2px 10px),
        repeating-linear-gradient(305deg, rgba(255,140,0,0.035) 0 3px, rgba(0,0,0,0) 3px 14px);
      --heartGlow:rgba(255,120,80,.25);
    }


/* 魔王．終焉寂滅：骷髏生命圖示加大 */
body[data-skin="魔王．終焉寂滅"] .hearts .life-icon,
body[data-skin="魔王．終焉寂滅"] .hearts .life-icon svg{
  width:22px; height:22px;
}

/* Oak background refinement */
body[data-skin="木紋．白橡北歐"]{
  --panelPattern:
    /* base oak tone */
    linear-gradient(180deg, rgba(240,221,190,.18), rgba(210,190,160,.14)),
    /* straight grain */
    repeating-linear-gradient(12deg, rgba(120,85,40,.28) 0 6px, rgba(0,0,0,0) 6px 18px),
    /* ray fleck subtle highlights */
    repeating-linear-gradient(90deg, rgba(255,240,210,.08) 0 2px, rgba(0,0,0,0) 2px 12px);
  --stageGlass: linear-gradient(180deg, rgba(255,245,230,.10), rgba(255,245,230,.00));
}

/* Per-skin larger life icons for wood & ice skins */
body[data-skin="木紋．黑檀曜金"] .hearts .life-icon,
body[data-skin="木紋．白橡北歐"] .hearts .life-icon,
body[data-skin="冰雪．極光絲綢"] .hearts .life-icon{ width:24px; height:24px; }
body[data-skin="木紋．黑檀曜金"] .hearts .life-icon svg,
body[data-skin="木紋．白橡北歐"] .hearts .life-icon svg,
body[data-skin="冰雪．極光絲綢"] .hearts .life-icon svg{ width:24px; height:24px; }
</style>
</head>
<body data-skin="經典．冷藍玻璃">
  <div class="wrap" id="app">
    <header>
      <h1>Rock打磚塊 — <span id="skinTitle">經典．冷藍玻璃</span></h1>
      <span class="small" id="skinDesc">LED：最新版（三側一致深藍，右側鏡像，2s 呼吸）；按鍵配置 0 變更。</span>
    </header>

    
    <section class="hud" aria-label="遊戲 HUD">
      <div class="stats">
        <div class="pill">分數 <b id="score">0</b></div>
        <div class="pill">關卡 <b id="level">1</b>/20</div>
        <div class="inline-controls">
          <button class="ic-btn" id="sndBtn" aria-haspopup="true" aria-expanded="false" aria-controls="soundMenu" title="聲音"><span class="ico">🔊</span></button>
          <div class="menu" id="soundMenu">
            <div class="item"><span>🎵</span><label><input type="checkbox" id="bgmOn"> BGM 開關</label></div>
            <div class="item"><span>🎚</span><label style="width:100%">BGM 音量 <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.7" style="width:60%" aria-label="BGM 音量"></label></div>
            <div class="item"><span>🔈</span><label><input type="checkbox" id="sfxOn" checked> 音效開關</label></div>
          </div>
          <button class="ic-btn" id="optBtn" aria-haspopup="true" aria-expanded="false" aria-controls="optMenu" title="選項">⋯</button>
          <div class="menu" id="optMenu">
            <h4>遊戲</h4>
            <div class="item"><span>🎮</span>難度 <select id="difficulty" aria-label="難度"><option>簡單</option><option selected>一般</option><option>困難</option></select></div>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap"><button class="btn" id="resetBtn">重新開始</button><button class="btn" id="saveBtn">存檔</button><button class="btn" id="loadBtn">讀檔</button></div>
            <h4>其他</h4>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap"><button class="btn" id="fsBtn">全螢幕</button><button class="btn" id="tutorBtn">教學</button><button class="btn" id="effectsBtn">效果說明</button><button class="btn" id="galleryBtn">畫廊</button><button class="btn" id="rankBtn">排行榜</button></div>
            <div class="item"><span>🎨</span>Skin <select aria-label="Skin" id="skinSel"><option>經典．冷藍玻璃</option></select></div>
          </div>
        </div>
        <div class="pill wide">生命 <b id="lives">3</b> <span class="hearts" id="hearts" aria-hidden="true">❤️❤️❤️</span></div>
      </div>
    </section>
    <div class="hud-sentinel" style="height:0"></div>

    <div id="buffs" aria-live="polite"></div>
    <div id="promptsDock" aria-live="polite" aria-label="提示卡"></div>

    <div class="stage">
      <canvas id="game" width="1100" height="700" aria-label="遊戲畫面"></canvas>
      <div class="legend">
        <span class="item"><span class="box" style="background:#ffd166"></span>一般磚</span>
        <span class="item"><span class="box" style="background:#888"></span>不可破壞磚</span>
        <span class="item"><span class="box" style="background:#bb7aff"></span>強反彈磚</span>
        <span class="item"><span class="box" style="background:#6ec6ff"></span>移動磚</span>
      </div>
    </div>
  </div>

  <script>
  "use strict";
  /* ---------------- HUD 互動（原樣） ---------------- */
  (function(){
    const hud = document.querySelector('.hud');
    const sentinel = document.querySelector('.hud-sentinel');
    const sndBtn = document.getElementById('sndBtn');
    const optBtn = document.getElementById('optBtn');
    const soundMenu = document.getElementById('soundMenu');
    const optMenu = document.getElementById('optMenu');
    let scheduled=false;
    function schedule(){ if(scheduled) return; scheduled=true; requestAnimationFrame(()=>{ scheduled=false; placeHUD(); }); }
    function placeHUD(){ const rect = (sentinel||hud).getBoundingClientRect(); const top = Math.max(0, Math.ceil(rect.top)) + 6; document.documentElement.style.setProperty('--hudBottom', top + 'px'); }
    function toggle(menu, btn){ const show = !menu.classList.contains('show'); [soundMenu,optMenu].forEach(m=>m.classList.remove('show')); document.querySelectorAll('[aria-expanded="true"]').forEach(b=>b.setAttribute('aria-expanded','false')); if(show){ menu.classList.add('show'); btn.setAttribute('aria-expanded','true'); } schedule(); }
    sndBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(soundMenu, sndBtn); }, {passive:true});
    optBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(optMenu, optBtn); }, {passive:true});
    document.addEventListener('click', (e)=>{ if(!e.target.closest('.menu') && !e.target.closest('#optBtn') && !e.target.closest('#sndBtn')){ [soundMenu,optMenu].forEach(m=>m.classList.remove('show')); schedule(); } }, {passive:true});
    ['resize','orientationchange'].forEach(ev=>window.addEventListener(ev, schedule, {passive:true}));
    if(document.fonts && document.fonts.ready){ document.fonts.ready.then(schedule); }
    schedule();
  })();

  /* ---------------- Canvas Renderer（含：六芒星、咒文圈、旋渦 embers） ---------------- */
  (function(){
    const cv  = document.getElementById('game');
    const box = document.querySelector('.stage');
    const ctx = cv.getContext('2d');

    let W=0,H=0,dpr=1, rafId=0;
    let skin = { base:[92,136,255], hi:[255,255,255], period:2000, effects:{}, bg:null };

    // 既有狀態（木紋/星點/冰雪/冰裂）
    let woodPattern=null, woodKind=null; let oakOverlayPat=null;
    let stars=null, starOpts={}, starSizeKey='';
    let snows=null, snowOpts={}, snowKey='';
    let shards=null, shardOpts={}, shardKey='';

    // 星火與熱擾動
    
    // 終焉寂滅：廢墟＋殘光＋震動＋Hit白閃
    let ruins=null, ruinOpts={}, ruinsKey='';
    let nukeFlashUntil=0, nukeNextAt=0, shakeUntil=0;
    let ledHitFlashUntil=0;
let embers=null, emberOpts={}, emberKey='';
    // 切割線（血紅）與暗灰擴散（終焉寂滅專用）
    let slicers = [];      // {t0, x, y, ang, w}
    let nextSliceAt = 0;
    let burstNextAt = 0;
    let slicerOpts = {};
    let diffusionStart = performance.now();


    const rgba = (rgb,a)=>`rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a.toFixed(3)})`;
    function hslToRgb(h,s,l){ s/=100; l/=100; const k=n=> (n+ h/30)%12; const a=s*Math.min(l,1-l); const f=n=> l - a*Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1))); return [Math.round(255*f(0)),Math.round(255*f(8)),Math.round(255*f(4))]; }
    function mix(a,b,w){ return [ Math.round(a[0]*(1-w)+b[0]*w), Math.round(a[1]*(1-w)+b[1]*w), Math.round(a[2]*(1-w)+b[2]*w) ]; }
    const easeOutQuad = x=>1-(1-x)*(1-x);

    function resize(){
      const contentW = box.clientWidth; const w = Math.min(1100, contentW);
      const h = Math.round(w * (700/1100));
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      cv.style.width = '100%'; cv.style.height = Math.round(h) + 'px';
      cv.width  = Math.round(w * dpr); cv.height = Math.round(h * dpr);
      W=cv.width;H=cv.height;
      if(woodKind==='oak'){ buildWoodPattern('oak'); }
      ensureStarsIfNeeded(); ensureSnowIfNeeded(); ensureShardsIfNeeded(); ensureEmbersIfNeeded(); ensureCloudsIfNeeded(); ensureRuinsIfNeeded(); ensureSlicerIfNeeded(); if(skin.effects && skin.effects.diffuse){ diffusionStart = performance.now(); }
    }

    /* ========= 木紋 ========= */
    function buildWoodPattern(kind){
      const oc = document.createElement('canvas'); const S = 320; oc.width=S; oc.height=S; const c = oc.getContext('2d');
      
      // --- unified white oak (no patchwork): draw a full-canvas grain and use 'no-repeat' ---
      if(kind==='oak'){
        const Sx = Math.max(512, W|0), Sy = Math.max(512, H|0);
        const oc2 = document.createElement('canvas'); oc2.width = Sx; oc2.height = Sy;
        const cx = oc2.getContext('2d');
        // base tone gradient for elegant furniture-like oak
        const g = cx.createLinearGradient(0,0,0,Sy);
        g.addColorStop(0.00,'#efe6d6');
        g.addColorStop(0.50,'#dfceb4');
        g.addColorStop(1.00,'#cfb997');
        cx.fillStyle = g; cx.fillRect(0,0,Sx,Sy);

        // long-grain bands across the whole canvas (slight angle, soft contrast)
        cx.save(); cx.translate(Sx/2,Sy/2); cx.rotate(8*Math.PI/180); cx.translate(-Sx/2,-Sy/2);
        for(let x=-Sx; x<Sx*2; x+=18){
          cx.fillStyle='rgba(120,85,40,0.06)'; cx.fillRect(x, 0, 5, Sy);
          cx.fillStyle='rgba(255,240,210,0.030)'; cx.fillRect(x+7, 0, 2, Sy);
        }
        cx.restore();

        // gentle growth-ring curvature to avoid straight plank feeling
        cx.save();
        cx.globalAlpha = 0.06;
        cx.strokeStyle = 'rgba(100,75,40,0.25)';
        const Rmax = Math.max(Sx,Sy);
        for(let r = Rmax*0.55; r <= Rmax*1.35; r += 90){
          cx.beginPath();
          cx.ellipse(Sx*0.2, Sy*0.85, r, r*0.36, -12*Math.PI/180, 0, Math.PI*2);
          cx.stroke();
        }
        cx.restore();

        // sparse ray-flecks (white oak medullary rays) — very subtle
        cx.fillStyle='rgba(255,230,200,0.04)';
        const flecks = Math.round((Sx*Sy)/40000);
        for(let i=0;i<flecks;i++){
          const ex = Math.random()*Sx, ey = Math.random()*Sy, ew=1+Math.random()*3, eh=10+Math.random()*24;
          cx.save(); cx.translate(ex,ey); cx.rotate((Math.random()*10-5)*Math.PI/180);
          cx.fillRect(-ew/2,-eh/2,ew,eh); cx.restore();
        }

        // create a no-repeat pattern so the fill is one-piece on this canvas size
        woodPattern = ctx.createPattern(oc2, 'no-repeat');
        woodKind = 'oak';
        return;
      }
const presets = { walnut:{ ang:25*Math.PI/180, step:16, line:8, dark:'#3b2517', light:'rgba(156,106,62,0.12)', rings:'#6e4a2e' }, ebony:{ ang:12*Math.PI/180, step:18, line:9, dark:'#120d0a', light:'rgba(80,65,50,0.10)',  rings:'#3c2b1e' }, cherry:{ ang:160*Math.PI/180,step:14, line:7, dark:'#5a2c33', light:'rgba(162,90,102,0.12)',rings:'#a8616f' }, oak:{ ang:8*Math.PI/180,  step:18, line:7, dark:'#6c5432', light:'rgba(182,138,84,0.12)', rings:'#a07a45' } };
      const p = presets[kind] || presets.walnut; const S2=S; c.clearRect(0,0,S2,S2);
      c.save(); c.translate(S2/2,S2/2); c.rotate(p.ang); c.translate(-S2/2,-S2/2);
      c.fillStyle=p.light; for(let x=-S2; x<=S2*2; x+=p.step){ c.fillRect(x,0,p.line,S2); }
      c.globalAlpha=0.25; c.fillStyle=p.dark; for(let x=-S2; x<=S2*2; x+=p.step*3){ c.fillRect(x,0,Math.max(1,p.line-4),S2); } c.restore();
      c.globalAlpha=0.06; c.strokeStyle=p.rings; c.lineWidth=2; const cx=S2*0.32, cy=S2*0.42;
      for(let r=28;r<S2*0.9;r+=22){ c.beginPath(); c.ellipse(cx,cy,r, r*(0.82+0.06*Math.sin(r)), 0, 0, Math.PI*2); c.stroke(); }
      c.globalAlpha=0.04; c.fillStyle='#000'; for(let i=0;i<80;i++){ const sx=Math.random()*S2, sy=Math.random()*S2, w=2+Math.random()*4, h=1+Math.random()*2; c.beginPath(); c.ellipse(sx,sy,w,h,Math.random()*Math.PI,0,Math.PI*2); c.fill(); }
      woodPattern = ctx.createPattern(oc,'repeat'); woodKind = kind;
    }

    
        
    /* ========= 奶油雲層（集中雲核版：強化核心、限制擴散、橢圓裁切） ========= */
    let clouds=null, cloudOpts={}, cloudKey='';
    
    function ensureCloudsIfNeeded(){
      if(!(skin.effects && skin.effects.clouds)){ clouds=null; cloudOpts={}; return; }
      const o = typeof skin.effects.clouds==='object' ? skin.effects.clouds : {};
      const count = Math.max(4, o.count || 7);
      // v4: cumulus clustered (nuclei + lobes), flat base shading
      const key = [W,H,count,o.speed||0.003,o.alpha||0.18,o.sizePx||300,o.lifeMs||32000,o.fadeInMs||6000,o.fadeOutMs||8000,'cluster-v4'].join('x');
      if(clouds && cloudKey===key) return;
      cloudKey = key; cloudOpts = o;
      const rng = Math.random;
      const baseScale = W/1100;
      const sizePx = ((o.sizePx || 300) * 0.55) * Math.max(0.7, Math.min(1.5, baseScale));

      function makePalette(){
        const r = rng();
        let h1, h2, s1 = 86 + rng()*10, s2 = 84 + rng()*12, l1 = 92 + rng()*4, l2 = 89 + rng()*5;
        if(r < 0.45){        // 蜜桃 → 草莓粉
          h1 = 24 + rng()*8; h2 = 340 + rng()*12;
        }else if(r < 0.75){  // 香草 → 蜜桃
          h1 = 36 + rng()*6; h2 = 14 + rng()*10;
        }else{               // 奶油白 → 玫瑰粉
          h1 = 10 + rng()*8; h2 = 350 + rng()*10;
        }
        return { A: hslToRgb(h1, Math.min(100, s1), Math.min(100, l1)),
                 B: hslToRgb(h2, Math.min(100, s2), Math.min(100, l2)) };
      }

      function clampEllipse(x,y,rx,ry){
        const nx = x/rx, ny = y/ry;
        const k = Math.hypot(nx,ny);
        if(k<=1) return {x,y};
        const s = 1/k; return { x: x*s, y: y*s };
      }

      clouds = new Array(count).fill(0).map(()=>{
        const bw = sizePx * (0.95 + rng()*0.35);
        const bh = bw * (0.52 + rng()*0.36);
        const life = (o.lifeMs || 32000) * (0.85 + rng()*0.40);
        const fadeIn  = o.fadeInMs  || 6000;
        const fadeOut = o.fadeOutMs || 8000;

        // 核心種子（2–4 個）— 2D 高斯，集中雲心
        const seedN = 2 + Math.floor(rng()*3);
        const seeds = [];
        for(let i=0;i<seedN;i++){
          // 確保分佈集中於雲中心（避免空心）
          let sx = (rng()-0.5) * bw * 0.35;
          let sy = (rng()-0.5) * bh * 0.28 - bh*0.08; // 稍微偏上
          const cl = clampEllipse(sx, sy, bw*0.45, bh*0.40);
          sx = cl.x; sy = cl.y;
          seeds.push({sx, sy, r:(0.20 + rng()*0.14)});
        }

        // 雲瓣：由種子擴展（每個種子 3–6 個瓣）＋中心大瓣保證不空心
        const lobes = [];
        for(const sd of seeds){
          const ln = 3 + Math.floor(rng()*4);
          for(let i=0;i<ln;i++){
            let lx = sd.sx + (rng()-0.5)*bw*0.22;
            let ly = sd.sy + (rng()-0.5)*bh*0.20;
            const cl = clampEllipse(lx, ly, bw*0.52, bh*0.50);
            lx = cl.x; ly = cl.y;
            const rMul = (sd.r * (0.85 + rng()*0.45));
            const b = 0.68 + rng()*0.32;
            lobes.push({ xoff: lx/bw, yoff: ly/bh, rMul, b });
          }
        }
        // 中心雲核（最大瓣）
        lobes.push({ xoff: 0, yoff: -0.06, rMul: 0.26 + rng()*0.10, b: 0.95 });

        // 底裙少量小瓣，集中度更高
        const skirtN = 2 + Math.floor(rng()*3);
        for(let i=0;i<skirtN;i++){
          const t = (i/(skirtN-1)-0.5);
          const lx = t*(0.6 + rng()*0.2) * bw * 0.6;
          const ly = (0.06 + rng()*0.10) * bh;
          const cl = clampEllipse(lx, ly, bw*0.55, bh*0.55);
          lobes.push({ xoff: cl.x/bw, yoff: cl.y/bh, rMul: 0.12 + rng()*0.08, b: 0.60 + rng()*0.18 });
        }

        const palette = makePalette();
        const tilt = (rng()-0.5) * 0.22;             // 輕微傾角
        const speed = (o.speed||0.003)*(0.65 + rng()*0.70);
        const alpha = (o.alpha||0.18)*(0.85 + rng()*0.35);
        const edgeSoft = 0.72 + rng()*0.22;          // 邊緣柔化
        const breathAmp = 0.00 + rng()*0.04;         // 微呼吸

        // 少量飄絮（偏下風向，避免四散）
        const wisps = Array.from({length: (rng()<0.45? Math.floor(rng()*3) : 0)}, ()=>({
          x:(rng()-0.2)*0.6, y:0.00 + rng()*0.22, r:0.06 + rng()*0.08, a:0.30 + rng()*0.25
        }));

        return {
          x0: rng()*W,
          y: (H*0.22) + rng()*H*0.42,
          bw, bh, lobes,
          paletteA: palette.A, paletteB: palette.B,
          tilt, phase: rng()*life, speed, a: alpha,
          lifeMs: life, fadeInMs: fadeIn, fadeOutMs: fadeOut,
          edgeSoft, breathAmp, wisps,
          baseFlat: 0.30 + rng()*0.12   // 底部扁平比例（0.3–0.42）
        };
      });
    }

    
    function drawClouds(t){
      if(!clouds) return;
      ctx.save();
      ctx.globalCompositeOperation='source-over';

      for(const c of clouds){
        // ----- 位置與時間參數 -----
        const dx = (t*c.speed + c.phase*0.35) % (W + c.bw*2);
        const x = -c.bw + dx;
        const y = c.y + Math.sin(t*0.00018 + c.phase*0.013)*6;
        const cx = x + c.bw*0.5, cy = y + c.bh*0.5;

        // 生命淡入/淡出
        const L = c.lifeMs, fi = c.fadeInMs, fo = c.fadeOutMs;
        const tt = (t + c.phase) % L;
        let lifeA = 1.0;
        if(tt < fi){ lifeA = tt/fi; }
        else if(tt > L - fo){ lifeA = (L-tt)/fo; }
        lifeA = Math.max(0, Math.min(1, lifeA));

        // 顏色/透明度
        const colA = c.paletteA || [255,244,234];
        const colB = c.paletteB || [255,217,230];
        const a0 = Math.min(0.50, c.a*lifeA);

                // ----- 棉團雲瓣（集中排列） -----
        const cosT = Math.cos(c.tilt||0), sinT = Math.sin(c.tilt||0);
        const baseY = cy + c.bh*(c.baseFlat!=null? c.baseFlat : 0.34); // 扁平基準線
        // 依相對 y 排序，讓上層瓣蓋過下層（塑造層次）
        const lobes = c.lobes.slice().sort((a,b)=> (a.yoff - b.yoff));

        // 先畫出上半部（clip：避免底部圓滑過頭）
        ctx.save();
        ctx.beginPath();
        // 曲線上緣裁切（避免直線長方形感）
        ctx.moveTo(0, 0);
        ctx.lineTo(0, baseY);
        // 以一條淺拱曲線作為雲底邊緣
        ctx.quadraticCurveTo(W*0.5, baseY - c.bh*0.22, W, baseY);
        ctx.lineTo(W, 0);
        ctx.closePath();
        ctx.clip();

        let li = 0;
        for(const l of lobes){
          // 旋轉後位置
          const dx0 = c.bw * (l.xoff||0);
          const dy0 = c.bh * (l.yoff||0);
          const rx = cosT*dx0 - sinT*dy0;
          const ry = sinT*dx0 + cosT*dy0;
          const lx = cx + rx, ly = cy + ry;

          // 半徑＋微呼吸
          const rBase = Math.max(2, (c.bw * (l.rMul||0.16)) * 0.92);
          const rPulse = 1 + (c.breathAmp||0)*Math.sin(t*0.0015 + c.phase*0.008 + li*0.7);
          const rr = Math.max(2, rBase * rPulse);

          const lb = (l && typeof l.b==='number') ? l.b : 1.0;
          // 漸層中心稍微上移，製造向上受光
          const ly2 = ly - rr*0.18;
          const gg = ctx.createRadialGradient(lx,ly2, rr*0.08, lx,ly2, rr * (0.78 - 0.18*(c.edgeSoft||0.0)));
          gg.addColorStop(0, `rgba(${colA[0]},${colA[1]},${colA[2]},${(a0*0.95*lb).toFixed(3)})`);
          gg.addColorStop(1, `rgba(${colB[0]},${colB[1]},${colB[2]},0)`);
          ctx.fillStyle=gg;
          ctx.beginPath(); ctx.arc(lx,ly, rr, 0, Math.PI*2); ctx.fill();
          li++;
        }
        ctx.restore();

        
        // 下風向的少量絮絲（不破壞集中度）
        if(c.wisps && c.wisps.length){
          for(const w of c.wisps){
            const dx0 = c.bw * w.x, dy0 = c.bh * w.y;
            const rx = cosT*dx0 - sinT*dy0;
            const ry = sinT*dx0 + cosT*dy0;
            const lx = cx + rx, ly = cy + ry;
            const r = Math.max(2, c.bw * w.r);
            const ga = (a0 * lifeA) * (0.45 * (w.a||0.5));
            const gw = ctx.createRadialGradient(lx,ly, r*0.06, lx,ly, r*0.95);
            gw.addColorStop(0, `rgba(${colA[0]},${colA[1]},${colA[2]},${ga.toFixed(3)})`);
            gw.addColorStop(1, `rgba(${colB[0]},${colB[1]},${colB[2]},0)`);
            ctx.fillStyle=gw;
            ctx.beginPath(); ctx.arc(lx,ly, r, 0, Math.PI*2); ctx.fill();
          }
        }
      }

      ctx.restore();
    }

/* ========= 星點 ========= */
    function buildStars(){
      const baseCount = (starOpts && typeof starOpts.count==='number') ? starOpts.count : 140; const scale = (W*H)/(1100*700); const N = Math.max( Math.min(60, baseCount), Math.floor(baseCount*scale) );
      stars = new Array(N).fill(0).map(()=>({ x:Math.random()*W, y:Math.random()*H, r:0.9+Math.random()*0.9, a:0.05+Math.random()*0.12, ph:Math.random()*Math.PI*2, sp:0.6+Math.random()*1.2, px:0.3+Math.random()*0.7 }));
      starSizeKey = W+'x'+H;
    }
    function ensureStarsIfNeeded(){ if(!(skin.effects && skin.effects.stars)){ stars=null; return; } if(!stars || starSizeKey !== (W+'x'+H)) buildStars(); }
    function drawStarField(t){ if(!stars) return; ctx.save(); ctx.globalCompositeOperation='screen'; for(const s of stars){ const twi=0.5+0.5*Math.sin(t*0.001*s.sp + s.ph); const baseA=(s.a*(0.55+0.6*twi)); const bMul = (starOpts && starOpts.brightness!=null)? starOpts.brightness : 1.0; const a = baseA * bMul; const dx=(t*0.008*s.px)%(W+20); const x=(s.x+dx), y=s.y, r=s.r*dpr*1.2; const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,`rgba(255,255,255,${(a*1.35).toFixed(3)})`); g.addColorStop(1,'rgba(180,160,255,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); } ctx.restore(); }

    /* ========= 冰雪 ========= */
    function ensureSnowIfNeeded(){ if(!(skin.effects && skin.effects.snow)){ snows=null; snowOpts={}; return; } const o=typeof skin.effects.snow==='object'? skin.effects.snow : {}; const density=Math.max(40, o.count || Math.round((W*H)/(420*420)*120)); const key=[W,H,density,o.gust||0,o.twinkle?1:0,o.sizeMin||1,o.sizeMax||3].join('x'); if(snows && snowKey===key) return; snowKey=key; snows=new Array(density).fill(0).map(()=>{ const size=(o.sizeMin||1)+Math.random()*((o.sizeMax||3)-(o.sizeMin||1)); return {x:Math.random()*W,y:Math.random()*H,size, baseX:Math.random()*W, speed:(o.speed||0.25)+Math.random()*((o.speedMax||0.9)-(o.speed||0.25)), sway:(o.sway||0.8)*(0.5+Math.random()), phase:Math.random()*Math.PI*2, twinkle:!!o.twinkle && Math.random()<0.25}; }); snowOpts=o; }
    function drawSnow(t){ if(!snows) return; const tt=t*0.001, gust=snowOpts.gust||0; const aBase=Math.min(.22, .10 + .12*(Math.sin(tt*0.6+1.7)*.5+.5)); const glow=Math.min(.14, .06 + .08*(Math.sin(tt*0.8+0.4)*.5+.5)); for(const f of snows){ f.phase += 0.01 + gust*0.015; f.y += f.speed * (1 + 0.6*Math.sin(tt*0.9)); f.x = f.baseX + Math.sin(f.phase)*(f.sway*4 + gust*24); if(f.y>H+10){ f.y=-10; f.baseX=Math.random()*W; } if(f.x<-10){ f.baseX=W+10; } const a=aBase*(f.twinkle?(0.7+0.3*Math.sin(tt*6+f.phase)):1); ctx.save(); ctx.globalAlpha=a; ctx.beginPath(); ctx.arc(f.x,f.y,f.size*dpr,0,Math.PI*2); ctx.fillStyle='white'; ctx.fill(); if(glow>0){ const r=(f.size*3+2)*dpr; const g=ctx.createRadialGradient(f.x,f.y,0,f.x,f.y,r); g.addColorStop(0,'rgba(255,255,255,'+glow+')'); g.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(f.x,f.y,r,0,Math.PI*2); ctx.fill(); } ctx.restore(); } }

    /* ========= 冰裂 ========= */
    function ensureShardsIfNeeded(){ if(!(skin.effects && skin.effects.shards)){ shards=null; shardOpts={}; return; } const o=typeof skin.effects.shards==='object'? skin.effects.shards : {}; const count=Math.max(6, o.count || Math.round((W+H)/200)); const key=[W,H,count,o.alpha||0.12,o.speed||0.06,o.lenMin||40,o.lenMax||180].join('x'); if(shards && shardKey===key) return; shardKey=key; shards=new Array(count).fill(0).map(()=>{ const len=(o.lenMin||40)+Math.random()*((o.lenMax||180)-(o.lenMin||40)); const angle=(o.angleDeg!==undefined? o.angleDeg : -28)*Math.PI/180; const x=Math.random()*W, y=Math.random()*H; return {x,y,len,angle,width:(o.width||1.2)*dpr,alpha:(o.alpha||0.12),speed:(o.speed||0.06)}; }); shardOpts=o; }
    function drawShards(t){ if(!shards) return; const drift=(shardOpts.drift||0.20); ctx.save(); ctx.globalAlpha=Math.min(.22,(shardOpts.alpha||0.12)); ctx.strokeStyle='rgba(220,245,255,1)'; ctx.lineWidth=Math.max(0.6,(shardOpts.width||1.2)*dpr); for(const s of shards){ s.x += Math.cos(s.angle)*s.speed*60; s.y += Math.sin(s.angle)*s.speed*60 + drift; if(s.x<-50 || s.x>W+50 || s.y<-50 || s.y>H+50){ s.x=Math.random()*W; s.y=-20; } const x2=s.x+Math.cos(s.angle)*s.len, y2=s.y+Math.sin(s.angle)*s.len; ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(x2,y2); ctx.stroke(); } ctx.restore(); }

    /* ========= 星火（embers） with Vortex Mode ========= */
    function ensureEmbersIfNeeded(){
      if(!(skin.effects && skin.effects.embers)){ embers=null; emberOpts={}; return; }
      const o=typeof skin.effects.embers==='object'? skin.effects.embers : {};
      const N = Math.round((W*H)/(1100*700) * (o.count || 320));
      const key=[W,H,N,o.sizeMin||1.0,o.sizeMax||2.6,o.mode||'rise',o.omega||0.0018,(o.tail||6), (o.center?o.center.join(','):'0.5,0.5'), o.twinkle?1:0, o.noise||0.12].join('|');
      if(embers && emberKey===key) return;
      emberKey=key;
      embers = new Array(N).fill(0).map(()=>{
        const s=(o.sizeMin||1.0)+Math.random()*((o.sizeMax||2.6)-(o.sizeMin||1.0));
        const p={
          x:Math.random()*W, y:Math.random()*H,
          vx:(Math.random()-.5)*0.1, vy:(Math.random()-.5)*0.1,
          size:s, hue: 25+Math.random()*20, tw: (!!o.twinkle && Math.random()<0.4),
          t:Math.random()*Math.PI*2, hist:[]
        };
        return p;
      });
      emberOpts=o;
    }

    let lastT=0;
    function drawEmbers(t){
      if(!embers) return;
      const dt = Math.max(10, Math.min(34, lastT? (t - lastT) : 16)); // 估算幀時間，夾在 [10,34]ms
      const mode = emberOpts.mode || 'rise';
      ctx.save();
      ctx.globalCompositeOperation='screen';
      const cx = W * ((emberOpts.center && emberOpts.center[0] != null)? emberOpts.center[0] : 0.5);
      const cy = H * ((emberOpts.center && emberOpts.center[1] != null)? emberOpts.center[1] : 0.50);
      const omega = emberOpts.omega != null ? emberOpts.omega : 0.0018; // rad/ms
      const tailLen = Math.max(3, emberOpts.tail || 6);
      const noise = emberOpts.noise != null ? emberOpts.noise : 0.12;

      for(const p of embers){
        // --- 更新位置（vortex or rise） ---
        if(mode==='vortex'){
          // 指向中心的向量
          const dx = p.x - cx, dy = p.y - cy;
          const r = Math.hypot(dx, dy) + 0.0001;
          // 切向單位向量（逆時針）
          const tx = -dy / r, ty = dx / r;
          // 中等速度：vt 隨半徑略增
          const vt = omega * dt * (0.45 + 0.55*Math.min(1, r/Math.max(120,Math.min(W,H)*0.28)));
          // 微弱向心/離心雜訊，避免粒子聚集
          const radialJit = (Math.random()-0.5) * noise;
          p.vx += tx*vt + radialJit * (dx/r);
          p.vy += ty*vt + radialJit * (dy/r);
          // 輕微黏滯阻尼，穩定旋轉
          p.vx *= 0.985; p.vy *= 0.985;
        }else{
          // 舊式：向上飄＋小旋擺
          p.t += 0.02 + (emberOpts.swirl||0.18)*0.02;
          p.x += p.vx + Math.sin(p.t)*(emberOpts.swirl||0.18)*1.2;
          p.y += p.vy - Math.cos(p.t)*(emberOpts.swirl||0.18)*0.4 - (emberOpts.up||0.35);
        }

        // 移動
        p.x += p.vx; p.y += p.vy;

        // 邊界再生：確保全畫面都有粒子
        if(p.x<-12 || p.x>W+12 || p.y<-12 || p.y>H+12){
          p.x = Math.random()*W; p.y = Math.random()*H;
          p.vx = (Math.random()-.5)*0.2; p.vy = (Math.random()-.5)*0.2;
          p.hist.length = 0;
        }

        // --- 畫尾巴（歷史路徑） ---
        p.hist.push({x:p.x, y:p.y});
        if(p.hist.length>tailLen) p.hist.shift();

        // head glow
        const twk = p.tw ? (0.85 + 0.15*Math.sin(t*0.012 + p.t*3)) : 1.0;
        const headR = p.size*dpr*(1.6 * twk);
        const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,headR*3.0);
        const colorHue = p.hue;
        g.addColorStop(0.0, `hsla(${colorHue}, 100%, 65%, 0.90)`);
        g.addColorStop(1.0, `hsla(${colorHue+10}, 100%, 50%, 0)`);
        ctx.fillStyle=g;
        ctx.beginPath(); ctx.arc(p.x,p.y,headR,0,Math.PI*2); ctx.fill();

        // tail segments
        ctx.lineCap='round';
        for(let i=1;i<p.hist.length;i++){
          const a = i/(p.hist.length-1);
          const p0 = p.hist[i-1], p1 = p.hist[i];
          const w = Math.max(1, (p.size*1.2*dpr) * (1-a));
          ctx.strokeStyle = `hsla(${colorHue+6}, 100%, ${55 - a*25}%, ${0.32*(1-a)})`;
          ctx.lineWidth = w;
          ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
        }
      }
      ctx.restore();
      lastT = t;
    }

    /* ========= 背景框架與 LED ========= */
    function drawPrism(t){ const p=skin.effects && skin.effects.prism; if(!p) return; const beams=p.beams||8, speed=p.speed||0.0005, alpha=(p.alpha!=null?p.alpha:0.10), spread=p.spread||0.85, hueShift=p.hueShift||0; const cx=W*0.5, cy=H*0.45, R=Math.hypot(W,H); ctx.save(); ctx.globalCompositeOperation='screen'; for(let i=0;i<beams;i++){ const ang=t*speed + i*(Math.PI*2/beams); ctx.save(); ctx.translate(cx,cy); ctx.rotate(ang); const w=R*0.12; const grad=ctx.createLinearGradient(0,0,R,0); const h0=(i*360/beams + (t*0.02) + hueShift)%360, h1=(h0+60)%360; const c0=hslToRgb(h0,85,62), c1=hslToRgb(h1,80,58); grad.addColorStop(0.00,'rgba(255,255,255,0)'); grad.addColorStop(0.10,rgba(c0,0.20)); grad.addColorStop(0.55,rgba(c1,0.12)); grad.addColorStop(1.00,'rgba(255,255,255,0)'); ctx.fillStyle=grad; ctx.globalAlpha=alpha; ctx.beginPath(); ctx.moveTo(-w,0); ctx.lineTo(R*spread,-w*0.40); ctx.lineTo(R,0); ctx.lineTo(R*spread,w*0.40); ctx.lineTo(w,0); ctx.closePath(); ctx.fill(); ctx.restore(); } ctx.restore(); }
    function drawPulse(t){ const p=skin.effects && skin.effects.pulse; if(!p) return; const time = t * (p.speedFactor!=null? p.speedFactor : 1.0); const rings = p.rings || 5; const thick = Math.max(1.5,(p.thickness||6)*dpr*0.85); const col = p.color || skin.base; const col2 = mix(col, [120,240,255], 0.35); const strength = (p.strength!=null? p.strength:0.20); const cx=W/2, cy=H*0.48, maxR=Math.min(W,H)*0.56; const micro = Math.max(1, p.microRipples||2); const dash  = p.dash!==false; const baseDelay = skin.period / rings; const ringDelay = (p.ringDelayMs!=null) ? p.ringDelayMs : baseDelay * (p.intervalMul || 1); ctx.save(); ctx.globalCompositeOperation='screen'; for(let i=0;i<rings;i++){ const raw = ((time - i*ringDelay) % skin.period + skin.period) % skin.period; const ph = raw / skin.period; const jitter = Math.sin((time*0.0009 + i)*3.7)*0.012; const eased = easeOutQuad(Math.min(1, Math.max(0, ph + jitter))); const r = eased * maxR; const fade = Math.pow(1-ph, 2.15); ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.lineWidth = thick*(0.72 + 0.52*(1-ph)); ctx.shadowColor = rgba(col, Math.min(0.30,strength*0.50)*fade); ctx.shadowBlur = 18; ctx.strokeStyle = rgba(col, Math.min(0.78, strength*0.92) * fade); ctx.stroke(); ctx.restore(); ctx.save(); ctx.beginPath(); ctx.arc(cx,cy, r*0.996, 0, Math.PI*2); ctx.lineWidth = Math.max(1, thick*0.42); ctx.strokeStyle = rgba(col2, Math.min(0.48, strength*0.40) * fade); ctx.stroke(); ctx.restore(); const band = Math.max(2, thick*1.2); const rg = ctx.createRadialGradient(cx,cy, Math.max(0,r-band), cx,cy, r+band); rg.addColorStop(0.45, 'rgba(0,0,0,0)'); rg.addColorStop(0.50, rgba(col, Math.min(0.36, strength*0.30)*fade)); rg.addColorStop(0.55, 'rgba(0,0,0,0)'); ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(cx,cy,r+band,0,Math.PI*2); ctx.fill(); for(let m=1;m<=micro;m++){ const rr = r + m*(band*0.65); const g2 = ctx.createRadialGradient(cx,cy, rr-1.5, cx,cy, rr+1.5); g2.addColorStop(0,'rgba(0,0,0,0)'); g2.addColorStop(0.49, rgba(col2, Math.min(0.33, strength*0.24)*(fade*(0.85-0.25*m)))); g2.addColorStop(0.51, 'rgba(0,0,0,0)'); ctx.fillStyle=g2; ctx.beginPath(); ctx.arc(cx,cy,rr+2,0,Math.PI*2); ctx.fill(); } if(dash){ ctx.save(); ctx.setLineDash([8,14]); ctx.lineDashOffset = - (time*0.06) * (i+1); ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.lineWidth = Math.max(1, thick*0.34); ctx.strokeStyle = rgba(col2, Math.min(0.30, strength*0.22) * fade); ctx.stroke(); ctx.setLineDash([]); ctx.restore(); } } ctx.restore(); }

    /* ========= 魔法幾何：六芒星 ========= */
    function drawHexagram(t){
      const hex = skin.effects && skin.effects.hexagram; if(!hex) return;
      const cx = W*0.5, cy = H*0.48;
      const R = Math.min(W,H) * (hex.radiusMul != null ? hex.radiusMul : 0.44);
      const rotT = (t % (hex.rotationPeriodMs||24000)) / (hex.rotationPeriodMs||24000);
      const ang = rotT * Math.PI*2; // 24s 一圈（順時針）
      // 明暗曲線：9s 漸亮 3s 回落 → 12s 週期
      const up = hex.fadeUpMs != null ? hex.fadeUpMs : 9000;
      const down = hex.fadeDownMs != null ? hex.fadeDownMs : 3000;
      const cyc = (up+down);
      const tt = (t % cyc);
      const br = tt < up ? (0.35 + 0.65 * (0.5 - 0.5*Math.cos(Math.PI*tt/up)))
                         : (1.0 - 0.5 * (1 - Math.cos(Math.PI*(tt-up)/down)));
      const baseCol = hex.color || '#FFD27A';
      const strokePx = Math.max(1.5, (hex.strokePx||2.8)*dpr);
      ctx.save();
      ctx.translate(cx,cy); ctx.rotate(ang);
      ctx.globalCompositeOperation = 'screen';
      ctx.lineWidth = strokePx;
      ctx.strokeStyle = baseCol;
      ctx.globalAlpha = Math.min(1, (hex.alpha!=null?hex.alpha:0.9) * br);

      // 兩個等邊三角形組成六芒星
      const drawTri = (start)=>{
        ctx.beginPath();
        for(let i=0;i<3;i++){
          const a = start + i*(2*Math.PI/3);
          const x = Math.cos(a)*R, y = Math.sin(a)*R;
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath(); ctx.stroke();
      };
      drawTri(-Math.PI/2);
      drawTri(-Math.PI/2 + Math.PI/3);

      // 內側暗金暈光
      const glow = ctx.createRadialGradient(0,0, R*0.55, 0,0, R*1.02);
      glow.addColorStop(0, 'rgba(255,210,122,0.20)');
      glow.addColorStop(1, 'rgba(255,210,122,0.0)');
      ctx.fillStyle = glow; ctx.globalAlpha = 0.8*br; ctx.beginPath(); ctx.arc(0,0,R*1.05,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    /* ========= 魔法咒文圈（取代月相環）：24s 逆時針、6s 呼吸 ========= */
    function drawScriptRing(t){
      const sr = skin.effects && skin.effects.scriptRing; if(!sr) return;
      const cx = W*0.5, cy = H*0.48;
      const R = Math.min(W,H) * (sr.radiusMul != null ? sr.radiusMul : 0.58); // 外於六芒星
      const rotT = (t % (sr.rotationPeriodMs||24000)) / (sr.rotationPeriodMs||24000);
      const ang = - rotT * Math.PI*2; // 逆時針
      const breath = (0.6 + 0.4 * (0.5 + 0.5 * Math.sin((t % (sr.breathMs||6000)) / (sr.breathMs||6000) * Math.PI*2)));
      const alpha = Math.min(1, (sr.alpha!=null? sr.alpha:0.72) * breath);
      const stroke = Math.max(1.0, (sr.strokePx||1.6)*dpr);
      const col = sr.color || '#FFD27A';
      const glyphs = (sr.glyphs || '✶✷✸✹✺✻✼✽✾✿☀︎☼☽☾✧✦⟡◇◆◈').split('');
      const N = sr.count || 84;
      const tickN = sr.ticks || 42;
      const fontPx = Math.max(8, (sr.fontPx||12)*dpr);

      ctx.save(); ctx.translate(cx,cy); ctx.rotate(ang); ctx.globalCompositeOperation='screen';

      // 基礎外圈
      ctx.globalAlpha = alpha * 0.55;
      ctx.strokeStyle = sr.strokeColor || col;
      ctx.lineWidth = stroke;
      ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.stroke();

      // Glyphs
      ctx.font = fontPx + 'px ui-sans-serif, "Noto Sans TC", system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      for(let i=0;i<N;i++){
        const a = (i/N)*Math.PI*2;
        ctx.save();
        ctx.rotate(a); ctx.translate(0,-R);
        ctx.rotate(Math.PI/2); // 文字沿切線
        ctx.globalAlpha = alpha * (0.75 + 0.25*Math.sin(t*0.003 + i));
        ctx.fillStyle = col;
        ctx.fillText(glyphs[i % glyphs.length], 0, 0);
        ctx.restore();
      }

      // 細刻度（不影響六芒星，可視化節奏）
      ctx.globalAlpha = alpha * 0.45;
      ctx.strokeStyle = col; ctx.lineWidth = Math.max(0.8, (sr.tickPx||1.0)*dpr);
      for(let i=0;i<tickN;i++){
        const a=(i/tickN)*Math.PI*2;
        const r1=R-3*dpr, r2=R+3*dpr;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*r1, Math.sin(a)*r1);
        ctx.lineTo(Math.cos(a)*r2, Math.sin(a)*r2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawSparks(t){
      const sp = skin.effects && skin.effects.sparks; if(!sp) return;
      // 極少量小金色火花（偶發）
      const cx=W*0.5, cy=H*0.48, R=Math.min(W,H)*0.48;
      ctx.save(); ctx.globalCompositeOperation='screen';
      const n = sp.count || 12;
      for(let i=0;i<n;i++){
        const a = (t*0.0003 + i*0.618) * Math.PI*2;
        const r = R*(0.75 + 0.25*(0.5+0.5*Math.sin(t*0.0007+i)));
        const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
        const rr = (sp.size || 1.6)*dpr;
        const g = ctx.createRadialGradient(x,y,0,x,y,rr*6);
        g.addColorStop(0, 'rgba(255,210,122,0.80)'); g.addColorStop(1, 'rgba(255,210,122,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,rr,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }


    
    
    function ensureSlicerIfNeeded(){
      const sfx = skin.effects && skin.effects.slicer;
      if(!sfx){ slicers = []; slicerOpts = {}; nextSliceAt = 0; burstNextAt = 0; return; }
      slicerOpts = sfx;
      if(nextSliceAt === 0 || !burstNextAt){
        const now = performance.now();
        nextSliceAt = now + (sfx.intervalMs || 3000);
        burstNextAt = now + (sfx.burstEveryMs || 30000);
      }
    }
    function scheduleSlice(at){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const ang = (Math.random()*Math.PI*2);
      const mul = (document.body && document.body.dataset && document.body.dataset.skin === '魔王．終焉寂滅') ? (1/3) : 1;
      const w = Math.max(1, Math.round(8*dpr * mul));
slicers.push({ t0: at, x, y, ang, w });
    }
    function maybeSlicers(t){
      const sfx = skin.effects && skin.effects.slicer; if(!sfx) return;
      const now = performance.now();
      if(now >= nextSliceAt){
        scheduleSlice(now);
        nextSliceAt = now + (sfx.intervalMs || 3000);
      }
      if(now >= burstNextAt){
        const step = sfx.burstIntervalMs || 200;
        for(let i=0;i<10;i++){ scheduleSlice(now + i*step); }
        burstNextAt = now + (sfx.burstEveryMs || 30000);
      }
      // draw & prune
      const lifeMs = sfx.lifeMs || 500;
      const color = sfx.color || 'rgba(190,0,30,0.38)';
      const colorEdge = sfx.edge || 'rgba(255,120,140,0.55)';
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      const maxLen = Math.hypot(W, H);
      const keep = [];
      for(const s of slicers){
        const p = (now - s.t0) / lifeMs;
        if(p < 0){ keep.push(s); continue; }
        if(p > 1.0) continue;
        const ease = p<0.5 ? (p/0.5) : (1 - (p-0.5)/0.5);
        const alpha = Math.max(0, ease);
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.ang);
        // core line
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(-maxLen, -s.w*0.5, maxLen*2, s.w);
        // bright edge
        const g = ctx.createLinearGradient(-maxLen, 0, maxLen, 0);
        g.addColorStop(0.48, 'rgba(255,255,255,0)');
        g.addColorStop(0.50, colorEdge);
        g.addColorStop(0.52, 'rgba(255,255,255,0)');
        ctx.fillStyle = g;
        ctx.fillRect(-maxLen, -s.w*0.7, maxLen*2, s.w*1.4);
        ctx.restore();
        keep.push(s);
      }
      ctx.restore();
      slicers = keep;
    }
    function drawDiffuse(t){
      const dfx = skin.effects && skin.effects.diffuse; if(!dfx) return;
      const now = performance.now();
      const cycle = (dfx.cycleMs || 40000);
      const expandMs = (dfx.expandMs || 30000);
      const retractMs = (dfx.retractMs || 10000);
      const elapsed = (now - diffusionStart) % cycle;
      let prog;
      if(elapsed <= expandMs){ prog = elapsed / expandMs; }
      else { prog = 1 - (elapsed - expandMs) / retractMs; }
      prog = Math.max(0, Math.min(1, prog));
      const cx = W*0.5, cy = H*0.5;
      const maxR = Math.hypot(W, H);
      const r = Math.max(0, prog) * maxR;
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
      const base = dfx.color || 'rgba(40,40,40,0.65)';
      g.addColorStop(0, base);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
function ensureRuinsIfNeeded(){
      const rfx = skin.effects && skin.effects.ruins;
      if(!rfx){ ruins=null; ruinOpts={}; return; }
      const layers = Math.max(1, (rfx.layers||3));
      const key = [W,H,layers].join('x');
      if(ruins && ruinsKey===key) return;
      ruinsKey = key; ruinOpts = rfx;
      const rng = Math.random;
      ruins = new Array(layers).fill(0).map((_,i)=>{
        const yBase = H*0.55 + i*(H*0.08);
        const count = 6 - i + Math.floor(rng()*2);
        const alpha = 0.12 + i*0.06;
        const objs = new Array(count).fill(0).map(()=>{
          const w = 80 + rng()*180;
          const h = 40 + rng()*120;
          const x = -40 + rng()*(W+80);
          const y = yBase + rng()*30;
          const tilt = (rng()-0.5)*0.2;
          const rebar = rng()<0.5;
          return {x,y,w,h,tilt,rebar,alpha};
        });
        return {alpha, objs};
      });
    }
    function drawRuins(t){
      if(!ruins) return;
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      for(const layer of ruins){
        ctx.globalAlpha = Math.max(0, Math.min(1, (1-(ruinOpts.haze||0))*layer.alpha));
        for(const o of layer.objs){
          ctx.save();
          ctx.translate(o.x, o.y);
          ctx.rotate(o.tilt);
          const g = ctx.createLinearGradient(0,0,o.w,0);
          g.addColorStop(0,'rgba(50,50,50,0.5)');
          g.addColorStop(1,'rgba(20,20,20,0.2)');
          ctx.fillStyle = g;
          ctx.fillRect(0,0,o.w,o.h);
          if(o.rebar){
            ctx.strokeStyle='rgba(160,160,160,0.25)';
            ctx.lineWidth = 1*dpr;
            for(let i=0;i<3;i++){
              const rx = 6 + i*(8+Math.random()*12);
              ctx.beginPath(); ctx.moveTo(rx,-6); ctx.lineTo(rx,o.h+8); ctx.stroke();
            }
          }
          ctx.restore();
        }
      }
      ctx.restore();
    }
    function maybeNuke(t){
      const nfx = skin.effects && skin.effects.nuke;
      if(!nfx) return;
      const now = performance.now();
      if(now > nukeNextAt && Math.random() < 0.015){
        nukeFlashUntil = now + (nfx.flashMs||220);
        shakeUntil = now + 300;
        nukeNextAt = now + (nfx.intervalMs||13000) * (0.7 + Math.random()*0.6);
      }
      if(nukeFlashUntil > now){
        const x = W*(0.2 + Math.random()*0.6);
        const y = H*(0.45 + Math.random()*0.15);
        const r = Math.max(W,H)*0.8;
        const g = ctx.createRadialGradient(x,y,0,x,y,r);
        g.addColorStop(0,'rgba(255,255,255,0.55)');
        g.addColorStop(0.35,'rgba(255,160,80,0.25)');
        g.addColorStop(1,'rgba(255,255,255,0)');
        ctx.save();
        ctx.globalCompositeOperation='screen';
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }
    window.__skinNotifyHit = function(ms){ ledHitFlashUntil = performance.now() + (ms||180); };
function drawFrame(t){
      const phase=(t%skin.period)/skin.period; const breathe = 0.65 + 0.35 * (0.5 + 0.5 * Math.sin(phase * Math.PI * 2));
      const edge=Math.max(2,Math.round(1.5*dpr)), bevel=Math.max(3,Math.round(4*dpr)); const aura=Math.max(10,Math.round(12*dpr)); const edgThick = edge + bevel;

      // 背景（可被 skin.bg 覆蓋）
      const bg=ctx.createLinearGradient(0,0,0,H);
      if(Array.isArray(skin.bg) && skin.bg.length>=3){ bg.addColorStop(0,skin.bg[0]); bg.addColorStop(0.55,skin.bg[1]); bg.addColorStop(1,skin.bg[2]); }
      else { bg.addColorStop(0,'#0d132a'); bg.addColorStop(0.55,'#0b1226'); bg.addColorStop(1,'#091223'); }
      ctx.fillStyle=bg; ctx.fillRect(0,0,W,H);
      // --- White Oak end-grain background (full-canvas) ---
      if(woodPattern && woodKind==='oak'){
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0; // dominate background so users clearly see wood texture
        ctx.fillStyle = woodPattern;
        ctx.fillRect(0,0,W,H);
        // subtle sheen for elegance, if defined
        const sheen = skin.effects && skin.effects.woodSheen && (skin.effects.woodSheen.alpha||0.06);
        if(sheen){
          const gSheen = ctx.createLinearGradient(0,0,W,H);
          gSheen.addColorStop(0.0, 'rgba(255,255,255,0.05)');
          gSheen.addColorStop(0.5, 'rgba(255,255,255,0.00)');
          gSheen.addColorStop(1.0, 'rgba(0,0,0,0.03)');
          ctx.globalAlpha = sheen;
          ctx.fillStyle = gSheen;
          ctx.fillRect(0,0,W,H);
        }
        
        // unify oak long-grain overlay for furniture-like continuity
        if(!oakOverlayPat){
          const oc=document.createElement('canvas'); oc.width=256; oc.height=256; const c=oc.getContext('2d');
          // base gentle longitudinal grain
          c.fillStyle='rgba(210,190,160,0.06)'; c.fillRect(0,0,256,256);
          c.save(); c.translate(128,128); c.rotate(12*Math.PI/180); c.translate(-128,-128);
          for(let x=-256; x<512; x+=18){
            c.fillStyle='rgba(120,85,40,0.08)'; c.fillRect(x,0,4,256);
            c.fillStyle='rgba(255,240,210,0.035)'; c.fillRect(x+6,0,2,256);
          }
          c.restore();
          // sparse ray flecks (very subtle)
          c.fillStyle='rgba(255,230,200,0.04)';
          for(let i=0;i<22;i++){
            const ex=Math.random()*256, ey=Math.random()*256, ew=1+Math.random()*3, eh=8+Math.random()*22;
            c.save(); c.translate(ex,ey); c.rotate((Math.random()*10-5)*Math.PI/180);
            c.fillRect(-ew/2,-eh/2,ew,eh); c.restore();
          }
          oakOverlayPat = ctx.createPattern(oc,'repeat');
        }
        ctx.globalCompositeOperation='soft-light';
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = oakOverlayPat;
        ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation='source-over';
ctx.restore();
      }
      // 背景震動（終焉寂滅）
      if(shakeUntil>performance.now()){
        const amp = 2*dpr; ctx.save(); ctx.translate((Math.random()-0.5)*amp, (Math.random()-0.5)*amp);
      }
      drawRuins(t);
      drawDiffuse(t);
      maybeSlicers(t);
      maybeNuke(t);

      // 柔和暗角（只在本 skin 開啟）
      (function bgVignette(){
        const vg = skin.effects && skin.effects.bgVignette; if(!vg) return;
        const g = ctx.createRadialGradient(W*0.5, H*0.5, Math.min(W,H)*0.10, W*0.5, H*0.5, Math.max(W,H)*0.70);
        g.addColorStop(0, 'rgba(0,0,0,0)');
        g.addColorStop(1, 'rgba(200,210,230,0.16)');
        ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      })();

      // 背景特效層
      ensureCloudsIfNeeded();
      drawClouds(t);
      if(skin.effects && skin.effects.stars) drawStarField(t);
      drawPrism(t);
      drawPulse(t);
      if(skin.effects && skin.effects.snow){ ensureSnowIfNeeded(); drawSnow(t); }
      if(skin.effects && skin.effects.shards){ ensureShardsIfNeeded(); drawShards(t); }
      if(skin.effects && skin.effects.embers){ drawEmbers(t); }

      // 魔法圖形
      drawHexagram(t);
      drawScriptRing(t); // 新增：外圈咒文，24s CCW、6s 呼吸
      drawSparks(t);
      // 兔兔・奶油雲朵專屬 LED 燈條（6px 粉白→蜜桃，3.2s 呼吸＋珠點）
      
(function drawLedStrip(){
  let ls = skin.effects && skin.effects.ledStrip; if(!ls){ if(window.__currentSkinKey==='w4'){ ls={ period:2400, hi:[255,236,210], lo:[230,210,180], segment:28, vignette:true }; } else { return; } }
  const period = (ls.period||3200);
  const phase = ((t % period) / period);
  const breathe = 0.65 + 0.35 * (0.5 + 0.5 * Math.sin(phase * Math.PI * 2));
  const thick = Math.max(2, Math.round(6*dpr));
  const seg = Math.max(10, (ls.segment||28) * dpr);
  let hi = ls.hi || [255,182,193];
  let lo = ls.lo || [255,244,234];
  if(ls.hitFlash && ledHitFlashUntil>performance.now()){ hi=[255,255,255]; lo=[255,255,255]; }
  ctx.save();
  ctx.globalCompositeOperation='screen';
  for(let x=0, i=0; x<W; x+=seg, i++){
    const g = ctx.createLinearGradient(0,0,0,thick);
    const isPink = (i % 2 === 0);
    const base = isPink ? hi : lo;
    const tip  = isPink ? lo : hi;
    g.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${0.42*breathe})`);
    g.addColorStop(1, `rgba(${tip[0]},${tip[1]},${tip[2]},0)`);
    ctx.fillStyle=g; ctx.fillRect(x,0,Math.min(seg,W-x),thick);
  }
  for(let y=0, i=0; y<H; y+=seg, i++){
    const g = ctx.createLinearGradient(0,0,thick,0);
    const isPink = (i % 2 === 0);
    const base = isPink ? hi : lo;
    const tip  = isPink ? lo : hi;
    g.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${0.42*breathe})`);
    g.addColorStop(1, `rgba(${tip[0]},${tip[1]},${tip[2]},0)`);
    ctx.fillStyle=g; ctx.fillRect(0,y,thick,Math.min(seg,H-y));
  }
  for(let y=0, i=0; y<H; y+=seg, i++){
    const g = ctx.createLinearGradient(W,0,W-thick,0);
    const isPink = (i % 2 === 0);
    const base = isPink ? hi : lo;
    const tip  = isPink ? lo : hi;
    g.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${0.42*breathe})`);
    g.addColorStop(1, `rgba(${tip[0]},${tip[1]},${tip[2]},0)`);
    ctx.fillStyle=g; ctx.fillRect(W-thick,y,thick,Math.min(seg,H-y));
  }
  ctx.fillStyle=`rgba(${lo[0]},${lo[1]},${lo[2]},${Math.min(0.85,0.50+0.38*breathe)})`;
  ctx.fillRect(0,0,W,1*dpr);
  const pearlStep = Math.max(14, 16) * dpr;
  const pearlA = 0.28 * breathe;
  for(let x=0, i=0; x<W; x+=pearlStep, i++){
    const base = (i%2===0) ? hi : lo;
    const r=1.2*dpr;
    const cx = x+pearlStep*0.5, cy = 0.5*thick;
    const gg=ctx.createRadialGradient(cx, cy, 0, cx, cy, r*4);
    gg.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${pearlA})`);
    gg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle=gg; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  }
  for(let y=0, i=0; y<H; y+=pearlStep, i++){
    const base = (i%2===0) ? hi : lo;
    const r=1.2*dpr;
    let cx = 0.5*thick, cy = y+pearlStep*0.5;
    let gg=ctx.createRadialGradient(cx, cy, 0, cx, cy, r*4);
    gg.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${pearlA})`);
    gg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle=gg; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
    cx = W-0.5*thick; cy = y+pearlStep*0.5;
    gg=ctx.createRadialGradient(cx, cy, 0, cx, cy, r*4);
    gg.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${pearlA})`);
    gg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle=gg; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
})();

if(shakeUntil>performance.now()) { ctx.restore(); }
      // LED 邊（上/左/右）
      let hiRGB=skin.hi, baseRGB=skin.base; if(skin.effects && skin.effects.rainbow){ hiRGB=hslToRgb((phase*360),85,65); baseRGB=hslToRgb((phase*360+200)%360,80,60); }
      const coreA=0.78 + 0.20*breathe, hiA=0.62*breathe;
      const gTop=ctx.createLinearGradient(0,0,0,edgThick); gTop.addColorStop(0,   rgba(hiRGB,  hiA)); gTop.addColorStop(0.55,rgba(baseRGB,coreA)); gTop.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=gTop; ctx.fillRect(0,0,W,edgThick);
      const spec=Math.max(1, Math.round(1*dpr)); ctx.fillStyle=rgba(hiRGB, Math.min(0.88, 0.55+0.40*breathe)); ctx.fillRect(0,0,W,spec);
      const gLeft=ctx.createLinearGradient(0,0,edgThick,0); gLeft.addColorStop(0,rgba(hiRGB,hiA)); gLeft.addColorStop(0.55,rgba(baseRGB,coreA)); gLeft.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=gLeft; ctx.fillRect(0,0,edgThick,H);
      const gRight=ctx.createLinearGradient(W,0,W-edgThick,0); gRight.addColorStop(0,rgba(hiRGB,hiA)); gRight.addColorStop(0.55,rgba(baseRGB,coreA)); gRight.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=gRight; ctx.fillRect(W-edgThick,0,edgThick,H);

      rafId=requestAnimationFrame(drawFrame);
    }

    function start(){ cancelAnimationFrame(rafId); rafId=requestAnimationFrame(drawFrame); }
     window.__dbg_getFps = function(){ return __dbg_fps; }; window.__stopCanvas=function(){ try{ cancelAnimationFrame(rafId);}catch(_){}};window.addEventListener('resize', ()=>{ resize(); start(); }, {passive:true});
    if(document.fonts && document.fonts.ready){ document.fonts.ready.then(()=>{ resize(); start(); }); } else { resize(); start(); }

    window.__applySkinCanvas = function(params){
      const next = Object.assign({ base:[92,136,255], hi:[255,255,255], period:2000, effects:{}, bg:null }, params||{});
      skin = next;
      if(skin.effects && typeof skin.effects.wood==='string'){ if(woodKind!==skin.effects.wood){ buildWoodPattern(skin.effects.wood); } }
      else { woodPattern=null; woodKind=null; }
      if(skin.effects && skin.effects.stars){ starOpts = (typeof skin.effects.stars==='object')? skin.effects.stars : {}; ensureStarsIfNeeded(); } else { stars=null; starOpts={}; }
      ensureEmbersIfNeeded(); // 其餘 ensure 在 draw / resize 中執行
      ensureCloudsIfNeeded(); // FIX: 切換 Skin 時重建奶油雲層，避免初始為 null 看不到雲朵
      ensureRuinsIfNeeded(); ensureSlicerIfNeeded(); if(skin.effects && skin.effects.diffuse){ diffusionStart = performance.now(); }
    };
  })();

  /* ---------------- Skin 管理（火系僅保留星火旋渦） ---------------- */
  (function(){
    const skinSel = document.getElementById('skinSel');
    const skinTitle = document.getElementById('skinTitle');
    const skinDesc = document.getElementById('skinDesc');
    const heartsEl = document.getElementById('hearts');
    const livesEl = document.getElementById('lives');

    function updateHeartsIcons(mode){
      const prev = parseInt(heartsEl.dataset.prevLives || (livesEl.textContent||'0'), 10) || 0;
      const lives = parseInt(livesEl.textContent||'0', 10) || 0;
      heartsEl.classList.toggle('compact', lives>=5);
      heartsEl.dataset.prevLives = String(lives);
      if(mode !== 'flame') heartsEl.classList.remove('flame');

      // Map modes to SVG icons for concise, consistent rendering
      const ICON = {
        star:   STAR_SVG,
        hat:    HAT_SVG,
        helmet: HELMET_SVG,
        ebony:  EBONY_SVG,
        oak:    OAK_SVG,
        ice:    ICE_SVG,
        rabbit: RABBIT_SVG,
        skull:  SKULL_SVG
      };

      // Special cases
      if(mode === 'flame'){
        heartsEl.classList.add('flame');
        heartsEl.innerHTML = '🔥'.repeat(Math.max(0, lives));
        return;
      }

      if(ICON[mode]){
        heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>ICON[mode]).join('');
        // Skull revive animation (when life increases)
        if(mode==='skull' && lives>prev){
          heartsEl.classList.add('revive');
          setTimeout(()=>heartsEl.classList.remove('revive'), 900);
        }
      }else{
        // Default to classic heart emoji
        heartsEl.textContent = '❤️'.repeat(Math.max(0,lives));
      }
    }
    
    
    const HELMET_SVG = '<span class="life-icon helmet" aria-hidden="true"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="knGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#F2F4F8"/><stop offset="1" stop-color="#B0C4DE"/></linearGradient></defs><path d="M6 10.2c0-3.8 3.1-6.9 6.9-6.9s6.9 3.1 6.9 6.9v6.3c0 .9-.5 1.7-1.3 2.1l-3.3 1.9c-1 .6-2.2 .6-3.2 0l-3.3-1.9c-.8-.4-1.3-1.2-1.3-2.1v-6.3z" fill="url(#knGrad)" stroke="#cfd8e6" stroke-width="1"/><path d="M7 10.6h10" stroke="#e7eef8" stroke-width="1" opacity=".9"/><rect x="8" y="11" width="8" height="2.2" rx="1.1" fill="#0D0D0F" opacity=".88"/><path d="M12 13.2v3.1" stroke="#0D0D0F" stroke-width="1.1" opacity=".88"/><path d="M8.4 9.8c.8-2.0 2.6-3.4 3.6-3.7 1 .3 2.8 1.7 3.6 3.7" stroke="#b9c9e2" stroke-width="1.1" stroke-linecap="round" opacity=".9"/><circle cx="9.5" cy="10.6" r=".35" fill="#e6eef8" stroke="#aebdd2" stroke-width=".2"/><circle cx="12" cy="10.6" r=".35" fill="#e6eef8" stroke="#aebdd2" stroke-width=".2"/><circle cx="14.5" cy="10.6" r=".35" fill="#e6eef8" stroke="#aebdd2" stroke-width=".2"/><path d="M6.8 12.2v3.8a1.8 1.8 0 0 0 1 1.6l1.8 1.0" stroke="#cbd6e6" stroke-width=".9" opacity=".8"/><path d="M17.2 12.2v3.8a1.8 1.8 0 0 1-1 1.6l-1.8 1.0" stroke="#cbd6e6" stroke-width=".9" opacity=".8"/></svg></span>';

    const HAT_SVG = '<span class="life-icon hat" aria-hidden="true"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="hatGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#0E0C08"/><stop offset="1" stop-color="#2B2011"/></linearGradient><linearGradient id="pinGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#FFD27A"/><stop offset="1" stop-color="#B8852E"/></linearGradient></defs><path d="M4 16.8c0-1.2 6.2-3.4 8.0-3.4s8.0 2.2 8.0 3.4-6.2 2.6-8.0 2.6S4 18.0 4 16.8z" fill="#0E0C08" opacity=".65"/><path d="M12 4.2c-1.4 1.6-2.4 4.4-2.6 6.4-.1 .6-.6 1.0-1.2 1.1-1.6 .2-3.7 1.0-4.0 1.9 3.2-.5 6.6-.8 7.8-.8s4.6 .3 7.8 .8c-.4-.9-2.4-1.7-4.0-1.9-.6-.1-1.1-.5-1.2-1.1-.2-2.0-1.2-4.8-2.6-6.4z" fill="url(#hatGrad)" stroke="#B8852E" stroke-width=".8"/><path d="M13.6 7.8l2.1-1.0" stroke="url(#pinGrad)" stroke-width="1.2" stroke-linecap="round"/><circle cx="16.0" cy="6.9" r=".75" fill="url(#pinGrad)"/></svg></span>';

    const RABBIT_SVG = '<span class="life-icon rabbit" aria-hidden="true" style="filter:drop-shadow(0 0 6px var(--heartGlow))"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="earGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#FFD9E6"/><stop offset="1" stop-color="#FFC0D6"/></linearGradient></defs><path d="M7.2 5.6c0-2.2 1.6-4.4 3.0-4.4s3.0 2.2 3.0 4.4c0 1.1-.2 2.0-.7 2.7-.5.7-1.1 1.0-2.3 1.0s-1.8-.3-2.3-1.0c-.5-.7-.7-1.6-.7-2.7z" fill="#FFF4EA" stroke="#EADBD0" stroke-width=".8"/><path d="M10.8 5.6c0-2.2 1.6-4.4 3.0-4.4s3.0 2.2 3.0 4.4c0 1.1-.2 2.0-.7 2.7-.5.7-1.1 1.0-2.3 1.0s-1.8-.3-2.3-1.0c-.5-.7-.7-1.6-.7-2.7z" fill="#FFF4EA" stroke="#EADBD0" stroke-width=".8"/><path d="M9.0 3.8c.7-.2 1.2.3 1.3 1.2l.1 1.8c0 .3-.2.6-.6.7-.3.1-.6-.1-.7-.4l-.5-1.7c-.2-.8 0-1.4.4-1.6z" fill="url(#earGrad)"/><path d="M14.0 3.8c-.7-.2-1.2.3-1.3 1.2l-.1 1.8c0 .3.2.6.6.7.3.1.6-.1.7-.4l.5-1.7c.2-.8 0-1.4-.4-1.6z" fill="url(#earGrad)"/><ellipse cx="12" cy="13.2" rx="6.2" ry="5.6" fill="#FFF4EA" stroke="#EADBD0" stroke-width=".8"/><circle cx="10.3" cy="12.5" r="1.0" fill="#333"/><circle cx="13.7" cy="12.5" r="1.0" fill="#333"/><path d="M12 13.6l-.9.6c.4.5 1.4.5 1.8 0z" fill="#FF9DB8"/><path d="M11.1 15.4c.6.3 1.8.3 2.4 0" stroke="#FF9DB8" stroke-width=".8" stroke-linecap="round"/></svg></span>';

        const SKULL_SVG = '<span class="life-icon skull" aria-hidden="true"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="skullGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#e0e0e0"/><stop offset="1" stop-color="#9aa0a6"/></linearGradient></defs><g fill="url(#skullGrad)" stroke="#2f2f2f" stroke-width=".8" stroke-linejoin="round"><path d="M12 3.2c-4.4 0-7.6 3-7.6 7 0 2.7 1.4 4.8 3.6 6v2.2c0 .7.6 1.2 1.3 1.2h.7c.4 0 .7-.3.7-.7v-1.1c0-.4.3-.7.7-.7h1.2c.4 0 .7.3.7.7v1.1c0 .4.3.7.7.7h.7c.7 0 1.3-.5 1.3-1.2v-2.2c2.2-1.2 3.6-3.3 3.6-6 0-4-3.2-7-7.6-7z"/><circle cx="9.3" cy="10.4" r="2.1" fill="#0e0e0e"/><circle cx="14.7" cy="10.4" r="2.1" fill="#0e0e0e"/><path d="M11.2 12.8l1.6-1.1-.7-1 .9-.6" fill="none" stroke="#64696f" stroke-width=".9"/><rect x="8.4" y="16.6" width="7.2" height="2.8" rx="1.2"/><g fill="#0e0e0e"><rect x="9.2" y="17" width="1.1" height="1.8" rx=".2"/><rect x="11.1" y="17" width="1.1" height="1.8" rx=".2"/><rect x="13" y="17" width="1.1" height="1.8" rx=".2"/><rect x="14.9" y="17" width="1.1" height="1.8" rx=".2"/></g></g></svg></span>';
const EBONY_SVG = '<span class=\"life-icon wood-ebony\" aria-hidden=\"true\"><svg viewBox=\"0 0 24 24\" width=\"24\" height=\"24\" role=\"img\" aria-label=\"ebony trunk\"><defs><linearGradient id=\"eb_side\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\"><stop offset=\"0\" stop-color=\"#2b1e16\"/><stop offset=\"1\" stop-color=\"#120c08\"/></linearGradient><radialGradient id=\"eb_top\" cx=\"50%\" cy=\"45%\" r=\"60%\"><stop offset=\"0\" stop-color=\"#261a12\"/><stop offset=\"1\" stop-color=\"#110b07\"/></radialGradient><linearGradient id=\"eb_edge\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\"><stop offset=\"0\" stop-color=\"#caa464\"/><stop offset=\"1\" stop-color=\"#8f6a2f\"/></linearGradient></defs><g transform=\"rotate(-18 12 12) translate(0,1)\"><ellipse cx=\"12\" cy=\"9.2\" rx=\"7.6\" ry=\"4.2\" fill=\"url(#eb_top)\" stroke=\"url(#eb_edge)\" stroke-width=\"1\"/><rect x=\"4.4\" y=\"9.2\" width=\"15.2\" height=\"9.0\" fill=\"url(#eb_side)\"/><ellipse cx=\"12\" cy=\"18.2\" rx=\"7.6\" ry=\"4.2\" fill=\"url(#eb_side)\" /><g opacity=\".9\"><ellipse cx=\"12\" cy=\"9.2\" rx=\"6.1\" ry=\"3.4\" fill=\"none\" stroke=\"rgba(202,164,100,55)\" stroke-width=\".8\"/><ellipse cx=\"12\" cy=\"9.2\" rx=\"4.4\" ry=\"2.5\" fill=\"none\" stroke=\"rgba(202,164,100,35)\" stroke-width=\".7\"/><ellipse cx=\"12\" cy=\"9.2\" rx=\"2.5\" ry=\"1.4\" fill=\"none\" stroke=\"rgba(202,164,100,35)\" stroke-width=\".6\"/></g><ellipse cx=\"12\" cy=\"9.2\" rx=\"7.6\" ry=\"4.2\" fill=\"none\" stroke=\"rgba(255,255,255,08)\" stroke-width=\"1\"/></g><ellipse cx=\"12\" cy=\"19.9\" rx=\"8.0\" ry=\"2.8\" fill=\"rgba(0,0,0,25)\"/></svg></span>';
const OAK_SVG = '<span class="life-icon wood-oak" aria-hidden="true"><svg viewBox="0 0 24 24" width="24" height="24" role="img" aria-label="oak trunk"><defs><linearGradient id="ok_side" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#d9b786"/><stop offset="1" stop-color="#b08853"/></linearGradient><radialGradient id="ok_top" cx="50%" cy="45%" r="60%"><stop offset="0" stop-color="#e9cfaa"/><stop offset="1" stop-color="#c5a074"/></radialGradient><linearGradient id="ok_edge" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#9c7a4b"/><stop offset="1" stop-color="#6d4f2a"/></linearGradient></defs><g transform="rotate(-18 12 12) translate(0,1)"><ellipse cx="12" cy="9.2" rx="7.6" ry="4.2" fill="url(#ok_top)" stroke="url(#ok_edge)" stroke-width="1"/><rect x="4.4" y="9.2" width="15.2" height="6.6" fill="url(#ok_side)"/><ellipse cx="12" cy="15.8" rx="7.6" ry="4.2" fill="url(#ok_side)" /><g opacity=".9"><ellipse cx="12" cy="9.2" rx="6.1" ry="3.4" fill="none" stroke="rgba(120,85,40,.55)" stroke-width=".8"/><ellipse cx="12" cy="9.2" rx="4.4" ry="2.5" fill="none" stroke="rgba(120,85,40,.38)" stroke-width=".7"/><ellipse cx="12" cy="9.2" rx="2.5" ry="1.4" fill="none" stroke="rgba(120,85,40,.32)" stroke-width=".6"/></g><ellipse cx="12" cy="9.2" rx="7.6" ry="4.2" fill="none" stroke="rgba(255,255,255,.10)" stroke-width="1"/></g><ellipse cx="12" cy="17.5" rx="8.0" ry="2.8" fill="rgba(0,0,0,.18)"/></svg></span>';
const ICE_SVG = '<span class="life-icon ice-cube" aria-hidden="true"><svg viewBox="0 0 24 24" width="24" height="24" role="img" aria-label="ice cube"><defs><linearGradient id="iceg" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#d7eeff"/><stop offset="1" stop-color="#9ed1ff"/></linearGradient></defs><rect x="5.5" y="5.5" width="13" height="13" rx="2.5" ry="2.5" fill="url(#iceg)" stroke="#b6d9ff" stroke-width="1"/><path d="M8.2 9.1l7.0-1.3-1.1 7.0-7.1 1.3z" fill="rgba(255,255,255,.35)"/><path d="M8 8.5h8.5v7.0H8z" fill="none" stroke="rgba(255,255,255,.35)" stroke-width="0.6"/></svg></span>';

    

const STAR_SVG = '<span class="life-icon star" aria-hidden="true"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="starGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#FFE49A"/><stop offset="1" stop-color="#B8852E"/></linearGradient><radialGradient id="starGlow" cx="50%" cy="50%" r="50%"><stop offset="0" stop-color="rgba(255,210,120,0.85)"/><stop offset="1" stop-color="rgba(255,210,120,0)"/></radialGradient></defs><circle cx="12" cy="12" r="7.2" fill="url(#starGlow)" opacity=".55"/><path d="M12 3.6l2.35 4.76 5.26 .77-3.8 3.70 .90 5.24-4.71-2.47-4.71 2.47 .90-5.24-3.8-3.70 5.26-.77L12 3.6z" fill="url(#starGrad)" stroke="#F3C96A" stroke-width=".8"/></svg></span>';

    const SKINS = {
      classic:{ label:'經典風格', selectLabel:'經典．冷藍玻璃', cssSkin:'經典風格', canvas:{ base:[92,136,255], hi:[255,255,255], period:2000, effects:{}, bg:null }, desc:'LED：三側一致深藍，右側鏡像，2s 呼吸。' },
      s2:{ label:'霓虹．魅影幻彩', selectLabel:'霓虹．魅影幻彩', cssSkin:'科技感風格2', canvas:{ base:[160,220,255], hi:[255,255,255], period:2200, effects:{ rainbow:true, prism:{ beams:6, speed:0.0005, alpha:0.10, spread:0.85, hueShift:40 } }, bg:['#0b0f2a','#0a0e26','#070a18'] }, desc:'全息 HUD：彩虹高光邊＋Holo Prism 光束（低對比）、2.2s 呼吸。' },
      s3:{ label:'科技．賽博格綠', selectLabel:'科技．賽博格綠', cssSkin:'科技感風格3', canvas:{ base:[80,255,160], hi:[255,255,255], period:2400, effects:{ scanline:true, pulse:{ rings:6, thickness:6, strength:0.16, color:[80,255,160], speedFactor:0.45, intervalMul:1.6, microRipples:2, dash:true } }, bg:['#07150f','#06130e','#041009'] }, desc:'賽博格綠脈衝：速度放緩（×0.45）、每圈間隔加長（×1.6），顏色更淡；2.4s 呼吸。' },
      s5:{ label:'宇宙．星辰絮語', selectLabel:'宇宙．星辰絮語', cssSkin:'科技感風格5', canvas:{ base:[150,120,255], hi:[255,255,255], period:2800, effects:{ stars:{ countScale:1.1, twinkle:0.85, drift:0.009, sizeMin:1.6, sizeMax:3.2, glow:2.0, brightness:1.2 } }, bg:['#0b0a20','#0a0820','#08071a'] }, desc:'藍紫星際霓虹：更大更亮的星點與光暈、緩慢漂移，2.8s 呼吸。' },
      w2:{ label:'木紋・黑檀曜金', selectLabel:'木紋・黑檀曜金', cssSkin:'木紋．黑檀曜金', canvas:{ base:[240,190,110], hi:[255,245,210], period:2400, effects:{ wood:'ebony', woodBoost:true, woodSheen:{alpha:0.08} }, bg:['#0b0806','#090705','#070504'] }, desc:'黑檀深棕：加強木孔/髮絲紋，油潤柔光高光；2.4s。' },
      w4:{ label:'木紋・白橡北歐', selectLabel:'木紋・白橡北歐', cssSkin:'木紋．白橡北歐', canvas:{ base:[255,220,170], hi:[255,250,230], period:1900, effects:{ wood:'oak', woodBoost:true, woodSheen:{alpha:0.06} }, bg:['#322515','#261c10','#1b140b'] }, desc:'白橡淺木：直紋＋ray fleck（低對比）、優雅油光；1.9s。' },
      i1:{ label:'冰雪・極光絲綢', selectLabel:'冰雪・極光絲綢', cssSkin:'冰雪．極光絲綢', canvas:{ base:[170,210,255], hi:[255,255,255], period:2200, effects:{ snow:{countScale:120, twinkle:true, sway:1.0, speed:0.28, speedMax:0.72, gust:0.12, sizeMin:1.0, sizeMax:2.5}, shards:{count:10, speed:0.05, width:1.2, alpha:0.10, lenMin:60, lenMax:160, drift:0.15}, frost:{alpha:0.10}, prism:{ beams:6, speed:0.0004, alpha:0.06, spread:0.82, hueShift:18 } }, bg:['#0b1626','#0a1a2f','#081628'] }, desc:'極光絲緞：冰藍呼吸＋輕雪＋低對比極光束；2.2s。' },
      k1:{ label:'騎士．白銀劍光', selectLabel:'騎士．白銀劍光', cssSkin:'騎士．白銀劍光',
          canvas:{ base:[176,196,222], hi:[235,238,245], period:2300,
                   effects:{
                     pulse:{ rings:5, thickness:5, strength:0.22, color:[235,238,245], speedFactor:1.0, intervalMul:1.0, microRipples:2, dash:true, ringDelayMs:0 },
                     shards:{ count:9, alpha:0.12, speed:0.06, width:1.2, lenMin:70, lenMax:180, drift:0.12, angleDeg:-18 }
                   },
                   bg:['#0D0D0F','#0B0B0D','#0A0A0C'] },
          desc:'高貴正義：冷白漸層＋銀光流動；Pulse 白光規律閃動，Shards 劍光稀疏。生命圖示＝騎士頭盔。2.3s。' },
      /* === 唯一保留且改為旋渦粒子的火系 === */
      f3:{ label:'烈焰・星火風暴', selectLabel:'烈焰・星火風暴', cssSkin:'烈焰．星火風暴',
          canvas:{ base:[255,150,110], hi:[255,250,240], period:2100,
                   effects:{
                     /* 移除 flames/heat/prism，僅保留旋渦 embers */
                     embers:{ mode:'vortex', count:360, sizeMin:1.0, sizeMax:2.4, tail:7, twinkle:true, omega:0.0020, center:[0.5,0.50], noise:0.12 }
                   },
                   bg:['#150807','#0d0504','#080404'] },
          desc:'星火旋渦：全畫面帶尾巴的火焰粒子繞中央龍捲以中速旋轉；生命改為🔥，UI燃邊微閃。2.1s。' },

      
      b1:{ label:'兔兔・奶油雲朵', selectLabel:'兔兔・奶油雲朵', cssSkin:'兔兔．奶油雲朵',
          canvas:{ base:[255,244,234], hi:[255,217,230], period:3200,
                   effects:{
                     clouds:{ count:7, sizePx:300, speed:0.003, alpha:0.20, lifeMs:30000, fadeInMs:6000, fadeOutMs:8000 },
                     stars:{ count:38, brightness:0.85 }, /* 柔光白星點 < 50 顆（降亮度） */
                     ledStrip:{ period:3200, hi:[255,182,193], lo:[255,244,234], segment:28 },
                     bgVignette:true
                   },
                   bg:['#0B1430','#0D1E4A','#1B4C8E'] },
          desc:'粉嫩清新：A1/A2/A3 已套用——奶油雲層更霧散、星點更柔、LED 改粉白→蜜桃 3.2s 呼吸；HUD 20px 霧面玻璃；生命圖示＝大尺寸兔兔頭。' },

      m1:{ label:'魔法．金耀日蝕', selectLabel:'魔法．金耀日蝕', cssSkin:'魔法．金耀日蝕',
          canvas:{ base:[255,228,168], hi:[255,210,122], period:3500,
                   effects:{
                     hexagram:{ strokePx:2.8, color:'#FFD27A', rotationPeriodMs:24000, fadeUpMs:9000, fadeDownMs:3000, radiusMul:0.44 },
                     /* 移除 moonRing；改為 scriptRing（外圈金色咒文），24s 逆時針，6s 呼吸 */
                     scriptRing:{ strokePx:1.6, strokeColor:'#FFD27A', color:'#FFD27A', breathMs:6000, rotationPeriodMs:24000, radiusMul:0.58, alpha:0.72, fontPx:12, count:84, ticks:42 },
                     sparks:{ count:10, size:1.4 }
                   },
                   bg:['#0E0C08','#0B0A07','#0A0906'] },
          desc:'日蝕聖環：六芒星 24s 匀速旋轉；外圈金色咒文圈 24s 逆時針、6s 呼吸；LED 金絲亮點（3.5s）。生命圖示＝金耀星徽。' },
    
      d1:{ label:'魔王．終焉寂滅', selectLabel:'魔王．終焉寂滅', cssSkin:'魔王．終焉寂滅',
          canvas:{ base:[14,14,14], hi:[255,69,0], period:3000,
                   effects:{
                     ruins:{ layers:3, haze:0.22 },
                     nuke:{ intervalMs:13000, flashMs:220 },
                     slicer:{ intervalMs:3000, burstEveryMs:30000, burstIntervalMs:200, lifeMs:500, color:'rgba(190,0,30,0.35)', edge:'rgba(255,120,140,0.55)' },
                     diffuse:{ cycleMs:40000, expandMs:30000, retractMs:10000 },
                     ledStrip:{ hi:[255,69,0], lo:[96,96,96], period:3200, segment:26, hitFlash:true }
                   },
                   bg:['#0E0E0E','#1A1A1A','#0E0E0E'] },
          desc:'廢墟鐵影＋殘光：遠景廢墟陰影、偶爾核爆殘光觸發0.3s震動；LED 灰→橘，擊中瞬白閃；生命圖示＝裂痕骷髏。' },
};

    (function populate(){
      const exists = Array.from(skinSel.options).map(o=>o.textContent.trim());
      if(!exists.includes(SKINS.classic.selectLabel)){
        const opt=document.createElement('option'); opt.textContent=SKINS.classic.selectLabel; skinSel.appendChild(opt);
      }
      ['s2','s3','s5','w2','w4','i1','b1','f3','k1','m1','d1'].forEach(k=>{ const opt=document.createElement('option'); opt.textContent=SKINS[k].selectLabel; skinSel.appendChild(opt); });
    })();

    function applyClassic(){ document.body.dataset.skin = SKINS.classic.cssSkin; window.__applySkinCanvas(SKINS.classic.canvas); skinTitle.textContent=SKINS.classic.label; skinDesc.textContent=SKINS.classic.desc; updateHeartsIcons('heart'); }
    function applySkinKey(key){
      const s=SKINS[key];
      document.body.dataset.skin=s.cssSkin||'經典風格';
      window.__applySkinCanvas(s.canvas); window.__currentSkinKey=key;
      skinTitle.textContent=s.label; skinDesc.textContent=s.desc;
      // 切換生命圖示
      if(key==='w2'){ updateHeartsIcons('ebony'); }
      else if(key==='w4'){ updateHeartsIcons('oak'); }
      else if(key==='i1'){ updateHeartsIcons('ice'); }
      else if(key==='f3'){ updateHeartsIcons('flame'); } else if(key==='k1'){ updateHeartsIcons('helmet'); } else if(key==='m1'){ updateHeartsIcons('star'); } else if(key==='b1'){ updateHeartsIcons('rabbit'); } else if(key==='d1'){ updateHeartsIcons('skull'); } else { updateHeartsIcons('heart'); }
    }

    skinSel.addEventListener('change',()=>{
      const val = skinSel.value.trim();
      if(val===SKINS.classic.selectLabel) return applyClassic();
      if(val===SKINS.s2.selectLabel) return applySkinKey('s2');
      if(val===SKINS.s3.selectLabel) return applySkinKey('s3');
      if(val===SKINS.s5.selectLabel) return applySkinKey('s5');
      if(val===SKINS.w2.selectLabel) return applySkinKey('w2');
      if(val===SKINS.w4.selectLabel) return applySkinKey('w4');
      if(val===SKINS.i1.selectLabel) return applySkinKey('i1');
      if(val===SKINS.k1.selectLabel) return applySkinKey('k1');
      if(val===SKINS.f3.selectLabel) return applySkinKey('f3');
      if(val===SKINS.m1.selectLabel) return applySkinKey('m1');
      if(val===SKINS.d1.selectLabel) return applySkinKey('d1');
      if(val===SKINS.b1.selectLabel) return applySkinKey('b1');
    }, {passive:true});

    // 初始載入
    applyClassic();
  })();
  </script>

  <div id="devHud" style="position:fixed;right:8px;top:8px;z-index:9999;font:12px/1.4 ui-monospace,monospace;background:rgba(0,0,0,.65);color:#0f0;padding:6px 8px;border:1px solid rgba(0,255,0,.25);border-radius:6px;display:none"></div>
  <script>
    (function(){
      "use strict";
      var params = new URLSearchParams(location.search);
      var DEBUG = /^(1|true)$/i.test(params.get("debug")||"");
      window.__debug = DEBUG;
      var hud = document.getElementById("devHud");
      if(DEBUG && hud){ hud.style.display="block"; }
      window.__lastError = null;
      window.addEventListener("error", function(e){
        window.__lastError = (e && e.message ? e.message : "error") + (e && e.filename ? (" @" + e.filename + ":" + e.lineno) : "");
      });
      window.addEventListener("unhandledrejection", function(e){
        try { window.__lastError = "Promise: " + (e.reason && (e.reason.stack||e.reason.message||e.reason)); } catch(_){}
      });
      window.__updateHud = function(stats){
        if(!DEBUG || !hud) return;
        var fpsTxt = (stats && stats.fps!=null) ? stats.fps.toFixed(1) : "?";
        hud.textContent = "FPS: " + fpsTxt + " | lastError: " + (window.__lastError || "-");
      };
      // 60s autoplay (renderer stress test)
      window.__autoplay = function(durationMs){
        durationMs = durationMs || 60000;
        return new Promise(function(resolve){
          var samples = [];
          var it = setInterval(function(){
            try{ samples.push(window.__dbg_getFps ? window.__dbg_getFps() : 0); }catch(_){ samples.push(0); }
          }, 1000);
          setTimeout(function(){
            clearInterval(it);
            var avg = samples.length ? samples.reduce(function(a,b){return a+b;},0)/samples.length : 0;
            resolve({ durationMs: durationMs, fpsAvg: avg, samples: samples.length, lastError: window.__lastError || null });
          }, durationMs);
        });
      };
    })();
  </script>
</body>

</html>