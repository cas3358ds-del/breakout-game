<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rockæ‰“ç£šå¡Š Breakoutï¼ˆæœ€çµ‚å¢å¼·ç‰ˆï¼‰</title>
  <script type="text/javascript" src="https://gc.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=DBoWnEos32TbdwXyFBHCXIYDdjYfcR1BpIlcNlWGioDDbcNV5A_bTOTI6tXcifAWoOzaMMoNqgvw4XtlltXXB2CPRksoMZFbbtBlQx5XzCIT8rj62BwDq1pJQ5YhFn_gLjg8SjDpOmM7OBFhdVa_FDrS0aSwzoxG2vdAkNz6KubfpExOhpsMQX93dyRvRLvyN5auIlry3tbsYABpnH5fxLQd-tpTY0qYRmVrhnYm5m_Q7j7cS_zOQm8HDXmF7CmS" charset="UTF-8"></script><style>
    /* å…¨é¢æ›ç”¨å…¨æ–° UI é¢¨æ ¼ï¼ˆå–è‡ª index_skin.htmlï¼‰ */
    :root{
      --ink:#eaf2ff; --muted:#b8c7ea;
      --glass-1:rgba(255,255,255,.08); --glass-2:rgba(255,255,255,.06);
      --stroke:rgba(140,180,255,.28);
      --bg1:#13224a; --bg2:#081022;
      --hudGrad1:rgba(20,25,44,.62); --hudGrad2:rgba(12,20,42,.44);
      --stageGlass:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
      --panelPattern:none;
      --btnGlow:0 0 0 rgba(0,0,0,0);
      --hudBottom:96px;
      --heartGlow: rgba(0,0,0,0);
      /* ä¿ç•™åŸæœ¬ç£šå¡Šèˆ‡é“å…·é¡è‰² */
      --brick1:#ff6b6b; --brick2:#ffd166; --brick3:#06d6a0; --brick4:#4cc9f0;
      --expl:#ff8c00; --power:#7aa2ff; --debuff:#ff6aa3;
      --glass-stroke:rgba(255,255,255,.12);
    }
    html,body{
      height:100%; margin:0; color:var(--ink);
      background: radial-gradient(140% 140% at 50% -12%, var(--bg1) 0%, #0e1a3a 50%, #0b1633 75%, var(--bg2) 100%);
      font-family: ui-sans-serif, -apple-system, system-ui, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:0 12px 24px}
    header{
      padding:calc(8px + env(safe-area-inset-top)) 0 10px;
      display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:space-between
    }
    h1{font-size:clamp(16px,2.6vw,22px);margin:0 8px 0 0;letter-spacing:.4px;opacity:.95}
    .small{font-size:12px;color:var(--muted)}

    /* HUD èˆ‡ UI */
    .hud{
      position:sticky;top:0;z-index:30;
      display:grid;gap:8px;align-items:center;
      grid-template-columns:1fr;max-width:min(1080px,96vw);margin:8px auto 0;
      border:1px solid var(--stroke);
      border-radius:18px;padding:10px;
      background:linear-gradient(180deg,var(--hudGrad1),var(--hudGrad2));
      backdrop-filter: blur(8px);
      box-shadow:0 6px 28px rgba(0,0,0,.28)
    }
    .stats{display:grid;grid-template-columns:auto auto 1fr;grid-auto-rows:minmax(36px,auto);gap:8px 10px;align-items:center}
    .stats .wide{grid-column:1 / -1}
    .pill{
      padding:8px 18px;border:1px solid var(--stroke);
      background:var(--glass-2);border-radius:999px;
      min-height:36px;display:flex;align-items:center;gap:10px;
      color:#d7e3ff;font-weight:650;font-size:15px
    }
    .pill b{color:#fff;font-variant-numeric:tabular-nums}
    .inline-controls{justify-self:end;display:flex;gap:8px;align-items:center;position:relative}
    .ic-btn{
      width:48px;height:36px;border-radius:12px;border:1px solid var(--stroke);
      background:radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.16), rgba(255,255,255,0) 58%), var(--glass-1);
      display:grid;place-items:center;cursor:pointer;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.05), 0 8px 20px rgba(0,0,0,.28), var(--btnGlow);
      color:#fff
    }
    .ic-btn:active{transform:translateY(1px)}
    .ic-btn .ico{font-size:18px;line-height:1}
    .menu{
      position:absolute;top:46px;right:0;min-width:280px;padding:10px;
      border:1px solid var(--stroke);border-radius:14px;
      background:rgba(12,18,36,.96);backdrop-filter:blur(10px);
      transform:scale(.96);opacity:0;pointer-events:none;transition:.16s ease;z-index:60
    }
    .menu.show{transform:scale(1);opacity:1;pointer-events:auto}
    .menu .item{display:flex;align-items:center;gap:10px;padding:10px;border:1px solid var(--stroke);border-radius:10px;background:var(--glass-2);margin-bottom:8px}
    .menu h4{margin:6px 0 8px;font-size:13px;color:#cfe0ff}
    .btn{
      padding:8px 12px;border-radius:10px;border:1px solid var(--stroke);cursor:pointer;
      background:var(--glass-2);color:#fff;box-shadow:var(--btnGlow)
    }
    select,input[type="range"]{background:var(--glass-2);color:#fff;border:1px solid var(--stroke);border-radius:8px;padding:6px 10px}
    /* Buffs & Prompts */
    #buffs{
      position:sticky;z-index:22;
      top:calc(var(--hudBottom) + 6px);
      display:flex;gap:8px;align-items:center;
      max-width:min(1080px,96vw);margin:6px auto 0;padding-left:6px;
      overflow:auto;scrollbar-width:none
    }
    #buffs::-webkit-scrollbar{display:none}
    #buffs .badge{
      display:inline-flex;align-items:center;gap:8px;
      padding:6px 10px;border:1px solid var(--stroke);border-radius:999px;
      background:var(--glass-1);font-size:12px;white-space:nowrap;color:#cfe0ff
    }
    #promptsDock{
      position:sticky;z-index:20;top:calc(var(--hudBottom) + 48px);
      max-width:min(1080px,96vw);margin:6px auto 0;padding:0 6px;
      display:flex;gap:8px;align-items:flex-start;overflow:auto;scrollbar-width:none
    }
    #promptsDock::-webkit-scrollbar{display:none}
    .prompt{
      padding:8px 10px;border:1px solid var(--stroke);border-radius:12px;
      background:rgba(14,22,40,.92);box-shadow:0 10px 26px rgba(0,0,0,.34);
      font-size:12px;line-height:1.45;color:#eaf2ff;white-space:nowrap
    }
    /* Stage */
    .stage{position:relative;margin:12px auto 0;max-width:min(1080px,96vw);border-radius:18px;padding:12px;box-sizing:border-box;background:var(--stageGlass);background-image:var(--panelPattern);background-blend-mode:overlay;}
    canvas#game{background:linear-gradient(180deg,#0d132a,#0b1226 55%, #091223);border:1px solid rgba(80,110,170,.45);border-radius:16px;display:block;width:100%;height:auto;margin:0 auto;box-shadow:inset 0 0 160px rgba(255,255,255,.03), 0 28px 90px rgba(0,0,0,.46);touch-action:none;}
    .legend{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;font-size:12px;color:#cfe0ff;margin-top:6px}
    .legend .item{padding:4px 8px;border-radius:10px;background:rgba(255,255,255,.05);border:1px solid var(--stroke);display:flex;align-items:center;gap:4px}
    .legend .box{width:14px;height:14px;border-radius:3px;display:inline-block;vertical-align:middle}
    /* Hearts */
    .hearts{filter:drop-shadow(0 0 10px var(--heartGlow));display:inline-block}
    .hearts.compact .life-icon{width:14px;height:14px}
    /* Gallery and overlay (retain original styles) */
    .overlay{position:fixed;inset:0;z-index:40;pointer-events:none}
    .gallery{position:absolute;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;z-index:4;pointer-events:auto}
    .gallery .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.75);opacity:0;transition:opacity .6s;}
    .gallery img{max-width:min(94vw,1040px);max-height:min(88vh,680px);border-radius:16px;box-shadow:0 30px 120px rgba(0,0,0,.6);opacity:0;transform:translateY(12px) scale(.98);transition:opacity .6s, transform .6s;}
    .gallery .hint{position:absolute;bottom:24px;color:#fff;font-size:16px;opacity:0;text-shadow:0 2px 10px rgba(0,0,0,.6);}
    .gallery.show .backdrop{opacity:1;}
    .gallery.show img{opacity:1;transform:translateY(0) scale(1);} 
    .gallery.show .hint{opacity:.9;}
    /* Win and Game Over overlays */
    .win{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:6;pointer-events:auto}
    .win.show{display:flex;}
    .gameover{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:8;pointer-events:auto}
    .gameover.show{display:flex;}
    .gameover .backdrop{position:absolute;inset:0;background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .gameover .center{position:relative;z-index:2;text-align:center;background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75));padding:18px 22px;border:1px solid var(--glass-stroke);border-radius:16px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .win .backdrop{position:absolute;inset:0;background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .thumb-ring{position:absolute;inset:16px;pointer-events:none;display:grid;grid-template-columns:repeat(10,1fr);gap:6px;opacity:.95}
    .thumb-ring img{width:100%;height:100%;object-fit:cover;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,.5);}
    .win .center{position:relative;z-index:2;text-align:center;background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75));padding:18px 22px;border:1px solid var(--glass-stroke);border-radius:16px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .win h2{margin:4px 0 6px;font-size:28px;letter-spacing:2px}
    .win .small{opacity:.8;font-size:12px;margin-top:6px}
    .win .again{margin-top:10px}
    /* Note box */
    .center-note{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:auto;z-index:3}
    .note-box{background:linear-gradient(180deg, rgba(8,12,28,.9), rgba(8,12,28,.85));border:1px solid var(--glass-stroke);padding:16px 18px;border-radius:14px;text-align:center;max-width:min(90vw,860px);box-shadow:0 12px 60px rgba(0,0,0,.5);font-size:14px;position:relative}
    .note-box h2{margin:0 0 8px 0;font-size:18px}
    .note-box p{margin:6px 0;line-height:1.6}
    kbd{background:#0e1836;border:1px solid #2a356a;border-radius:6px;padding:2px 6px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:90%}
    .note-close{
      position:absolute;top:8px;right:8px;width:28px;height:28px;border-radius:999px;
      display:grid;place-items:center;cursor:pointer;user-select:none;
      border:1px solid var(--glass-stroke);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), rgba(255,255,255,.02));
      box-shadow: 0 6px 16px rgba(0,0,0,.25);
      color:#d7dcff;font-weight:800;line-height:1;
    }
    .note-close:hover{filter:brightness(1.1);}
    .note-close:active{transform:translateY(1px);}
    @media (max-width:390px){
      .pill{font-size:14px;padding:7px 14px}
      .ic-btn{width:44px;height:36px}
    }

  </style>
<style>
/* --- Imported Skins from index_skin.html --- */
body[data-skin="éœ“è™¹ï¼é­…å½±å¹»å½©"]{ --ink:#f6fbff; --muted:#dbe6ff; --stroke:rgba(200,220,255,.38); --bg1:#0b0f2a; --bg2:#070a18; --hudGrad1:rgba(24,28,70,.58); --hudGrad2:rgba(16,22,58,.42); --glass-1:rgba(255,255,255,.12); --glass-2:rgba(255,255,255,.09); --stageGlass:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0)); --panelPattern:conic-gradient(from 0deg at 60% 40%, rgba(255,160,220,.08), rgba(160,220,255,.06), rgba(160,255,200,.06), rgba(255,220,160,.06), rgba(255,160,220,.08)); --btnGlow:0 0 20px rgba(160,220,255,.25);}

body[data-skin="ç§‘æŠ€ï¼è³½åšæ ¼ç¶ "]{ --ink:#e7ffe7; --muted:#bdfdcc; --stroke:rgba(120,255,170,.34); --bg1:#081812; --bg2:#03110a; --hudGrad1:rgba(10,40,26,.64); --hudGrad2:rgba(6,28,18,.46); --glass-1:rgba(160,255,200,.12); --glass-2:rgba(120,220,170,.08); --stageGlass:linear-gradient(180deg, rgba(120,255,180,.05), rgba(0,0,0,0)); --panelPattern:repeating-linear-gradient(180deg, rgba(140,255,190,.05) 0 1px, transparent 1px 3px); --btnGlow:0 0 16px rgba(120,255,170,.25);}

body[data-skin="å®‡å®™ï¼æ˜Ÿè¾°çµ®èª"]{ --ink:#eef0ff; --muted:#c9c9ff; --stroke:rgba(160,140,255,.34); --bg1:#0c0b24; --bg2:#09081a; --hudGrad1:rgba(30,24,70,.58); --hudGrad2:rgba(20,18,50,.44); --glass-1:rgba(200,180,255,.10); --glass-2:rgba(160,140,255,.08); --stageGlass:linear-gradient(180deg, rgba(160,140,255,.05), rgba(0,0,0,0)); --panelPattern:radial-gradient(120px 80px at 20% 10%, rgba(110,80,255,.08), transparent 60%), radial-gradient(160px 120px at 80% 20%, rgba(180,100,255,.08), transparent 60%); --btnGlow:0 0 22px rgba(150,120,255,.25);}

body[data-skin="æœ¨ç´‹ï¼é»‘æª€æ›œé‡‘"]{ --ink:#f6edd8; --muted:#d9caa8; --stroke:rgba(255,220,140,.28); --bg1:#0e0b09; --bg2:#060403; --hudGrad1:rgba(28,18,10,.72); --hudGrad2:rgba(18,12,8,.56); --glass-1:rgba(255,220,140,.10); --glass-2:rgba(255,220,140,.07); --stageGlass:linear-gradient(180deg, rgba(255,220,140,.04), rgba(0,0,0,0)); --panelPattern:repeating-linear-gradient(12deg, rgba(40,28,18,.35) 0 18px, rgba(0,0,0,0) 18px 34px), repeating-linear-gradient(192deg, rgba(60,44,28,.20) 0 12px, rgba(0,0,0,0) 12px 28px); --btnGlow:0 0 20px rgba(255,210,120,.24);}

body[data-skin="æœ¨ç´‹ï¼ç™½æ©¡åŒ—æ­"]{ --ink:#fff8ec; --muted:#e6d8c2; --stroke:rgba(255,215,170,.26); --bg1:#3a2d19; --bg2:#1c150b; --hudGrad1:rgba(78,60,30,.66); --hudGrad2:rgba(48,36,18,.50); --glass-1:rgba(255,220,170,.10); --glass-2:rgba(255,220,170,.08); --stageGlass:linear-gradient(180deg, rgba(255,230,190,.05), rgba(0,0,0,0)); --panelPattern:repeating-linear-gradient(8deg, rgba(210,170,120,.14) 0 14px, rgba(0,0,0,0) 14px 26px), repeating-linear-gradient(188deg, rgba(240,210,160,.05) 0 2px, rgba(0,0,0,0) 2px 8px); --btnGlow:0 0 16px rgba(255,220,170,.22);}

body[data-skin="å†°é›ªï¼æ¥µå…‰çµ²ç¶¢"]{ --ink:#f6fbff; --muted:#d7e9ff; --stroke:rgba(190,220,255,.38); --bg1:#0b1626; --bg2:#060b14; --hudGrad1:rgba(18,28,60,.56); --hudGrad2:rgba(10,20,44,.42); --glass-1:rgba(220,245,255,.12); --glass-2:rgba(210,235,255,.09); --stageGlass:linear-gradient(180deg, rgba(230,245,255,.04), transparent); --panelPattern:conic-gradient(from 0deg at 60% 40%, rgba(180,220,255,.06), rgba(160,210,255,.05), rgba(180,230,255,.06)); --btnGlow:0 0 20px rgba(180,220,255,.26);}

body[data-skin="é¨å£«ï¼ç™½éŠ€åŠå…‰"]{
      --ink:#eef4ff; --muted:#cfd9ec;
      --stroke:rgba(190,205,235,.34);
      --bg1:#0D0D0F; --bg2:#0A0A0C;
      --hudGrad1:rgba(22,26,36,.66); --hudGrad2:rgba(14,18,26,.52);
      --glass-1:rgba(255,255,255,.10); --glass-2:rgba(255,255,255,.07);
      --stageGlass:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0));
      --panelPattern:
        repeating-linear-gradient(90deg, rgba(220,230,245,.06) 0 2px, rgba(0,0,0,0) 2px 8px),
        radial-gradient(160px 100px at 72% 14%, rgba(176,196,222,.06), transparent 60%);
      --btnGlow:0 0 20px rgba(200,220,255,.18);
      --heartGlow:rgba(210,230,255,.85);
    }

body[data-skin="çƒˆç„°ï¼æ˜Ÿç«é¢¨æš´"]{
      --ink:#fff3ec; --muted:#ffd0b8; --stroke:rgba(255,160,120,.30);
      --bg1:#150807; --bg2:#080404;
      --hudGrad1:rgba(40,16,12,.68); --hudGrad2:rgba(22,10,8,.52);
      --glass-1:rgba(255,150,100,.12); --glass-2:rgba(255,130,90,.08);
      --stageGlass:linear-gradient(180deg, rgba(255,140,90,.04), rgba(0,0,0,0));
      --panelPattern:radial-gradient(120px 90px at 30% 20%, rgba(255,120,90,.06), transparent 60%);
      --btnGlow:0 0 22px rgba(255,150,100,.28);
      --heartGlow:rgba(255,120,60,.9);
    }

body[data-skin="é­”æ³•ï¼é‡‘è€€æ—¥è•"]{
      --ink:#FFF6E6; --muted:#EED9B6;
      --stroke:rgba(255,210,120,.30);
      --bg1:#0E0C08; --bg2:#0A0906;
      --hudGrad1:rgba(34,26,12,.72); --hudGrad2:rgba(22,16,8,.58);
      --glass-1:rgba(255,228,168,.10); --glass-2:rgba(184,133,46,.08);
      --stageGlass:linear-gradient(180deg, rgba(255,228,168,.045), rgba(0,0,0,0));
      --panelPattern: radial-gradient(160px 100px at 70% 18%, rgba(255,210,120,.06), transparent 60%),
                      radial-gradient(220px 160px at 18% 6%, rgba(184,133,46,.05), transparent 60%);
      --btnGlow:0 0 22px rgba(255,210,120,.22);
      --heartGlow:rgba(255,210,120,.88);
    }

body[data-skin="å…”å…”ï¼å¥¶æ²¹é›²æœµ"]{
      --ink:#FFF9FB; --muted:#F7DDE6;
      --stroke:rgba(255,200,180,.28);
      --bg1:#1a1218; --bg2:#0b0a10;
      --hudGrad1:rgba(255,240,246,.18); --hudGrad2:rgba(255,255,255,.10);
      --glass-1:rgba(255,255,255,.18); --glass-2:rgba(255,255,255,.12);
      --stageGlass:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(255,190,220,.18);
      --heartGlow:rgba(255,182,193,.85);
    }

body[data-skin="é­”ç‹ï¼çµ‚ç„‰å¯‚æ»…"]{
      --ink:#C0C0C0; --muted:#9aa3ad; --stroke:#363636;
      --hudGrad1:rgba(14,14,14,.82); --hudGrad2:rgba(10,10,10,.66);
      --glass-1:rgba(192,192,192,.08); --glass-2:rgba(120,120,120,.06);
      --stageGlass:linear-gradient(180deg, rgba(14,14,14,.85), rgba(10,10,10,.65));
      --panelPattern:
        repeating-linear-gradient(125deg, rgba(255,255,255,0.04) 0 2px, rgba(0,0,0,0) 2px 10px),
        repeating-linear-gradient(305deg, rgba(255,140,0,0.035) 0 3px, rgba(0,0,0,0) 3px 14px);
      --heartGlow:rgba(255,120,80,.25);
    }

body[data-skin="æœ¨ç´‹ï¼ç™½æ©¡åŒ—æ­"]{
  /* Elegant rift/quarter white-oak look with subtle straight grain, no patchwork feel */
  --panelPattern:
    /* warm champagne white oak tone */
    linear-gradient(180deg, rgba(245,232,209,.16), rgba(227,210,182,.12)),
    /* long straight grain (rift-like), very low-contrast to avoid 'æ‹¼æ¥æ„Ÿ' */
    repeating-linear-gradient(10deg, rgba(120,90,50,.22) 0 5px, rgba(0,0,0,0) 5px 16px),
    /* ultra-subtle ray flecks (quarter-sawn hint) */
    repeating-linear-gradient(90deg, rgba(255,242,220,.06) 0 1px, rgba(0,0,0,0) 1px 10px);
  /* glass overlay slightly warmer */
  --stageGlass: linear-gradient(180deg, rgba(255,245,230,.10), rgba(255,245,230,.00));
  /* LED button glow tuned to warm neutral */
  --btnGlow: 0 0 16px rgba(255, 225, 180, .22);
  --heartGlow: rgba(255, 220, 170, .18);
}
/* Hearts extra */
.hearts{filter: drop-shadow(0 0 10px var(--heartGlow));}
    .hearts.flame{filter: drop-shadow(0 0 12px var(--heartGlow));}

    /* Skulls revive animation (ç°åŒ–â†’é‡çµ„) */
    .hearts.revive .life-icon{ animation: skull-revive 800ms ease-out; }
    @keyframes skull-revive{
      0%{ filter: grayscale(1) blur(1.5px); opacity:.2; transform: translateY(6px) scale(.9); }
      60%{ filter: grayscale(1) blur(2.5px); opacity:.1; transform: translateY(10px) scale(.85); }
      100%{ filter:none; opacity:1; transform:none; }
    }


    
</style>

</head>
<body>
  <!-- æ–°å¢ UI åŒ…è£ -->
  <div class="wrap" id="app">
    <header>
      <h1>Rockæ‰“ç£šå¡Š â€” <span id="skinTitle">ç¶“å…¸é¢¨æ ¼</span></h1>
      <span class="small" id="skinDesc">LEDï¼šä¸‰å´ä¸€è‡´æ·±è—ï¼Œå³å´é¡åƒï¼Œ2s å‘¼å¸ã€‚</span>
    </header>
    <!-- é ‚éƒ¨ HUD -->
    <section class="hud" aria-label="éŠæˆ² HUD">
      <div class="stats">
        <div class="pill">åˆ†æ•¸ <b id="score">0</b></div>
        <div class="pill">é—œå¡ <b id="level">1</b>/<span id="totalLevels">20</span></div>
        <div class="inline-controls">
          <button class="ic-btn" id="sndBtn" aria-haspopup="true" aria-expanded="false" aria-controls="soundMenu" title="è²éŸ³"><span class="ico">ğŸ”Š</span></button>
          <div class="menu" id="soundMenu">
            <div class="item"><span>ğŸµ</span><label><input type="checkbox" id="bgmOn"> BGM é–‹é—œ</label></div>
            <div class="item"><span>ğŸš</span><label style="width:100%">BGM éŸ³é‡ <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.7" style="width:60%" aria-label="BGM éŸ³é‡"></label></div>
            <div class="item"><span>ğŸ”ˆ</span><label><input type="checkbox" id="sfxOn" checked> éŸ³æ•ˆé–‹é—œ</label></div>
            <!-- éš±è—çš„èˆŠç‰ˆæŒ‰éˆ•ï¼Œç”¨æ–¼è…³æœ¬ç¶­æŒé‚è¼¯ -->
            <button id="soundBtn" style="display:none;"></button>
            <button id="bgmBtn" style="display:none;"></button>
          </div>
          <button class="ic-btn" id="optBtn" aria-haspopup="true" aria-expanded="false" aria-controls="optMenu" title="é¸é …">â‹¯</button>
          <div class="menu" id="optMenu">
            <h4>éŠæˆ²</h4>
              <div class="item"><span>ğŸ®</span>é›£åº¦ <select id="difficultySel" aria-label="é›£åº¦">
              <option value="easy">ç°¡å–®</option>
              <option value="normal" selected>ä¸€èˆ¬</option>
              <option value="hard">å›°é›£</option>
            </select></div>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn" id="pauseBtn" style="display:none;">æš«åœ/ç¹¼çºŒ</button>
              <button class="btn" id="resetBtn">é‡æ–°é–‹å§‹</button>
              <button class="btn" id="saveBtn">å­˜æª”</button>
              <button class="btn" id="loadBtn">è®€æª”</button>
              <button class="btn" id="clearSaveBtn">æ¸…é™¤å­˜æª”</button>
            </div>
            <h4>å…¶ä»–</h4>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn" id="fsBtn">å…¨è¢å¹•</button>
              <button class="btn" id="tutorBtn">æ•™å­¸</button>
              <button class="btn" id="effectsBtn">æ•ˆæœèªªæ˜</button>
              <button class="btn" id="galleryBtn">ç•«å»Š</button>
              <button class="btn" id="rankBtn">æ’è¡Œæ¦œ</button>
            </div>
            <div class="item"><span>ğŸ¨</span>Skin <select aria-label="Skin" id="skinSel">
              <option>ç¶“å…¸ï¼å†·è—ç»ç’ƒ</option>
            </select></div>
          </div>
        </div>
        <div class="pill wide">ç”Ÿå‘½ <b id="lives">3</b> <span class="hearts" id="hearts">â¤ï¸â¤ï¸â¤ï¸</span></div>
      </div>
    </section>
    <div class="hud-sentinel" style="height:0"></div>
    <!-- Buffs / æç¤º -->
    <div id="buffs" class="badges"></div>
    <div id="promptsDock"></div>
    <!-- éŠæˆ²å€åŸŸ -->
    <div class="stage">
      <canvas id="game" width="1100" height="700"></canvas>
      <div class="legend">
        <span class="item"><span class="box" style="background:var(--expl)"></span>çˆ†ç‚¸ç£š</span>
        <span class="item"><span class="box" style="background:var(--brick2)"></span>ä¸€èˆ¬ç£š</span>
        <span class="item"><span class="box" style="background:#888"></span>ä¸å¯ç ´å£ç£š</span>
        <span class="item"><span class="box" style="background:#bb7aff"></span>å¼·åå½ˆç£š</span>
        <span class="item"><span class="box" style="background:#6ec6ff"></span>ç§»å‹•ç£š</span>
        <span class="item"><span class="box" style="background:#ff4d6d"></span>Bossç£š</span>
        <span class="item"><span class="box" style="background:var(--power)"></span>å¢ç›Šé“å…·</span>
        <span class="item"><span class="box" style="background:var(--debuff)"></span>æ¸›ç›Šé“å…·</span>
      </div>
    </div>

    <!-- è¦†è“‹å±¤/ç•«å»Š/å‹åˆ©/çµæŸ/æç¤º -->
    <div class="overlay">
      <div class="gallery" id="gallery">
        <div class="backdrop"></div>
        <img id="galleryImg" src="" alt="é—œå¡å¤§åœ–" />
        <div class="hint">é»ä¸€ä¸‹é€²å…¥ä¸‹ä¸€é—œ â–¶</div>
      </div>

      <div class="win" id="win">
        <div class="backdrop"></div>
        <div class="thumb-ring" id="ring"></div>
        <div class="center">
          <h2>æ­å–œéé—œï¼</h2>
          <div style="font-size:28px;margin:6px 0;">ç¸½åˆ†æ•¸ï¼š<span id="finalScore">0</span></div>
          <div id="statsWin" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:360px"></div>
          <div class="small">ä½œè€…ï¼š ChatGPTã€€ï¼ã€€æŒ‡å°è€…ï¼š Rock</div>
          <div class="again"><button class="btn" id="againBtn">å†ç©ä¸€æ¬¡</button></div>
        </div>
      </div>

      <div class="gameover" id="gameover">
        <div class="backdrop"></div>
        <div class="center">
          <h2>éŠæˆ²çµæŸ</h2>
          <div style="font-size:28px;margin:6px 0;">æœ€çµ‚åˆ†æ•¸ï¼š<span id="finalScore2">0</span></div>
          <div id="statsOver" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:320px"></div>
          <div class="again"><button class="btn" id="retryBtn">å†æ¬¡éŠæˆ²</button></div>
        </div>
      </div>
      
      <div class="center-note" id="centerNote">
        <div class="note-box" id="noteBox"><button class="note-close" id="noteClose" aria-label="é—œé–‰">Ã—</button>
          <h2 id="noteTitle">æŒ‰ <kbd>Space</kbd> æˆ–é»ç•«é¢é–‹å§‹</h2>
          <p id="noteText">
            æ“ä½œï¼š<kbd>â†</kbd>/<kbd>â†’</kbd> æˆ– <kbd>A</kbd>/<kbd>D</kbd>ï¼›æ‰‹æŒ‡æ‹–æ›³ç•«é¢ä¹Ÿå¯ç§»å‹•å¹³å°ã€‚<br>
            å·²æ•´åˆï¼šèƒŒæ™¯é€æ­¥æ­ç¤º + æ¸…é—œç•«å»Šã€å¢ç›Š/æ¸›ç›Šï¼ˆå«é›»æ¼¿çƒ/å‡çµçƒ/ç¥è–çƒ/é³³å‡°å¯©åˆ¤/9å‘½æ€ªè²“ï¼‰ã€çˆ†ç‚¸ç£šã€éŸ³æ•ˆã€é›£åº¦ã€å­˜è®€æª”ã€BGMã€æ•™å­¸/æ•ˆæœèªªæ˜ã€Bossèˆ‡é€²éšç£šã€‚
          </p>
        </div>
      </div>
    </div>
  </div>

<script>

  // === è¨­å®š ===
  const GAME_CONFIG = {
    totalLevels: 20,
    difficulty: {
      easy:   { paddleBaseW: 220, baseSpeed: 4, rowsBase: 6, dropRate: 0.72 },
      normal: { paddleBaseW: 180, baseSpeed: 4.5, rowsBase: 7, dropRate: 0.52 },
      hard:   { paddleBaseW: 140, baseSpeed: 6, rowsBase: 8, dropRate: 0.32 },
    },
    bricks: { explosiveChance: 0.18, brickHeight: 30, padding: 9, topOffset: 60, cols: 12 },
    powers: {
      // æ—¢æœ‰
      WIDE:{label:'å¹³å°è®Šå¯¬',type:'buff',durationMs:30000,paddleWidthAdd:50,badge:'â†”ï¸'},
      LONG:{label:'å¹³å°è®Šé•·(å¯ç–Š)',type:'buff',durationMs:30000,longPerStackAdd:40,stacksMax:2,badge:'ğŸ“'},
      STICKY:{label:'é»æ€§å¹³å°(ä¸Šå½ˆå¯æš«é»)',type:'buff',durationMs:5000,sticky:true,badge:'ğŸ§²'},
      MULTI:{label:'å¤šçƒ',type:'buff',multiDuplicate:true,maxBalls:4,badge:'âœ¨'},
      SLOW:{label:'å…¨å±€æ…¢é€Ÿ',type:'buff',durationMs:15000,speedMul:0.6,badge:'ğŸ¢'},
      PIERCE:{label:'ç©¿é€çƒ',type:'buff',durationMs:12000,piercing:true,badge:'ğŸ¯'},
      SHIELD:{label:'è­·ç›¾(æ‰çƒæ“‹ä¸€æ¬¡)',type:'buff',oneShotShield:true,badge:'ğŸ›¡'},
      RAMPAGE:{label:'æš´èµ°çƒ(çŸ­æš«å¼·ç©¿)',type:'buff',durationMs:5000,forcePiercing:true,rampageMs:5000,badge:'ğŸ”¥'},
      FAST:{label:'å¿«é€Ÿçƒ',type:'debuff',durationMs:5000,globalSpeedMul:1.5,screenShakeOnApply:6,badge:'âš¡'},
      WAVY:{label:'è®Šé€Ÿçƒ',type:'debuff',durationMs:5000,wavy:{amp:0.6,base:1.2,periodMs:200},badge:'ã€°ï¸'},
      // æ–°å¢
      PLASMA:{label:'é›»æ¼¿çƒ(æ“Šä¸­æ”¾å‡ºé›»æ¼¿åœˆæ¸…åˆ—)',type:'buff',durationMs:10000,plasma:{drift:1.2,radius:38,lifeMs:3000},badge:'âš¡ï¸'},
      FREEZE:{label:'å‡çµçƒ(å»¶é²åœé “ä¸€ä¸‹)',type:'buff',durationMs:10000,freeze:{delayMs:300,stopMs:2000},badge:'â„ï¸'},
      HOLY:{label:'ç¥è–çƒ(åå­—æ¸…ç·š)',type:'buff',durationMs:5000,holy:{},badge:'âœï¸'},
      PHOENIX:{label:'é³³å‡°å¯©åˆ¤(æ¶ˆåŠå ´/ä¸ç§’æ®ºBoss)',type:'rare',rareFactor:0.08,instant:true,badge:'ğŸª½'},
      NINE:{label:'9å‘½æ€ªè²“(ç”Ÿå‘½è®Š9)',type:'rare',rareFactor:0.08,instant:true,badge:'ğŸ±'}
      ,TRACK:{label:'è¿½è¹¤çƒ(è‡ªå‹•ä¿®æ­£è»Œè·¡)',type:'buff',durationMs:10000,track:{},badge:'ğŸ§­'}
      ,MISSILE:{label:'é£›å½ˆçƒ(æ“‹æ¿åå½ˆæ™‚ç™¼å°„3æš)',type:'buff',durationMs:5000,missile:{speed:7,turn:0.08,lifeMs:4000},badge:'ğŸš€'}
      ,HELL:{label:'åœ°ç„çƒ(é»‘æ´åé„°è¿‘æ ¼)',type:'buff',durationMs:5000,hell:{speedMul:1.2,haloMs:2000},badge:'ğŸ•³ï¸'}
      ,MEGA:{label:'ç‰¹å¤§çƒ(åŠå¾‘Ã—3, é€Ÿåº¦Ã—0.8)',type:'buff',durationMs:5000,mega:{sizeMul:3,speedMul:0.8},badge:'ğŸŸ¢'}
      ,CHAIN:{label:'é–éˆçƒ(å‘½ä¸­ç£šé–10ç§’)',type:'debuff',durationMs:5000,chain:{lockMs:10000},badge:'â›“ï¸'}
      ,NARROW:{label:'å¹³å°ç¸®å°(å¯¬åº¦æ¸›åŠ)',type:'debuff',durationMs:5000,narrow:true,badge:'ğŸ“‰'}
      ,HOLE:{label:'å¹³å°ç©ºæ´(ä¸­é–“1/3ç„¡æ•ˆ)',type:'debuff',durationMs:5000,hole:true,badge:'ğŸ•³'}
      ,FLIP:{label:'å¤©åœ°ç¿»è½‰(æ”¹ç‚ºå·¦å´æ“‹æ¿)',type:'special',durationMs:15000,specialWeight:0.1,badge:'ğŸ”„'}
      ,GODSPEED:{label:'ç¥é€Ÿæµè½‰(ä¸è½åœ°/å¿½ç•¥æ•ˆæœ/æ»¿é€Ÿ)',type:'special',durationMs:10000,specialWeight:0.1,badge:'â˜„ï¸'}
      ,LASER:{label:'è‡ªå‹•é›·å°„(æ¯2ç§’å…©ç«¯ç™¼å°„)',type:'special',durationMs:10000,specialWeight:0.1,laser:{intervalMs:2000},badge:'ğŸ”«'}

    },
    powerCapsule:{width:24,height:16,fallVy:2.2},
    caps:{paddleMaxW:300,ballSpeedMax:19.5}
  };

  // === å•Ÿå‹•é©—è­‰ï¼švalidateConfig() ===
  function validateConfig() {
    try {
      const p = GAME_CONFIG.powers || {};
      const required = {
        MEGA: ['mega','mega.sizeMul','mega.speedMul'],
      };
      for (const [k, fields] of Object.entries(required)) {
        if (!p[k]) continue;
        for (const f of fields) {
          const seg = f.split('.');
          let cur = p[k];
          for (const s of seg) {
            // replace optional chaining with safe property access
            cur = cur ? cur[s] : undefined;
          }
          if (cur == null) {
            // å®‰å…¨é è¨­
            if (k==='MEGA') {
              p.MEGA.mega = p.MEGA.mega || {};
              if (p.MEGA.mega.sizeMul == null) p.MEGA.mega.sizeMul = 3;
              if (p.MEGA.mega.speedMul == null) p.MEGA.mega.speedMul = 0.8;
            };
            (window.__configWarnings = window.__configWarnings||[]).push(`[validateConfig] ${k} ç¼ºå°‘ ${f}ï¼Œå·²å¥—å®‰å…¨é è¨­`);
          }
        }
      }
    } catch (e) {
      // avoid optional chaining; fall back to stack or string
      window.__lastError = (e && e.stack) || String(e);
      console.error('[validateConfig] ä¾‹å¤–', e);
    }
  }


  // === å½±åƒè¼‰å…¥ï¼ˆæ”¯æ´ .png / .jpgï¼‰ ===
  const IMG_PAIRS = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.png`, cg:`images/cg${i}.png`}));
  // æº–å‚™ jpg å¾Œå‚™
  const IMG_PAIRS_FALLBACK = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.jpg`, cg:`images/cg${i}.jpg`}));

  function makeImg(src, fallback){
    const im = new Image(); im.decoding='async'; im.loading='eager'; im.src=src;
    if(fallback){
      im.onerror=()=>{ if(im.src!==fallback) im.src=fallback; };
    }
    return im;
  }
  const IMG_MAP = []; // 0..9: {bg:Image, cg:Image}
  for(let i=0;i<10;i++){
    IMG_MAP[i] = {
      bg: makeImg(IMG_PAIRS[i].bg, IMG_PAIRS_FALLBACK[i].bg),
      cg: makeImg(IMG_PAIRS[i].cg, IMG_PAIRS_FALLBACK[i].cg),
    };
  }

  
// === Skins & VFX Integration (imported) ===
const SKINS = {
      classic:{ label:'ç¶“å…¸é¢¨æ ¼', selectLabel:'ç¶“å…¸ï¼å†·è—ç»ç’ƒ', cssSkin:'ç¶“å…¸é¢¨æ ¼', canvas:{ base:[92,136,255], hi:[255,255,255], period:2000, effects:{}, bg:null }, desc:'LEDï¼šä¸‰å´ä¸€è‡´æ·±è—ï¼Œå³å´é¡åƒï¼Œ2s å‘¼å¸ã€‚' },
      s2:{ label:'éœ“è™¹ï¼é­…å½±å¹»å½©', selectLabel:'éœ“è™¹ï¼é­…å½±å¹»å½©', cssSkin:'éœ“è™¹ï¼é­…å½±å¹»å½©', canvas:{ base:[160,220,255], hi:[255,255,255], period:2200, effects:{ rainbow:true, prism:{ beams:6, speed:0.0005, alpha:0.10, spread:0.85, hueShift:40 } }, bg:['#0b0f2a','#0a0e26','#070a18'] }, desc:'å…¨æ¯ HUDï¼šå½©è™¹é«˜å…‰é‚Šï¼‹Holo Prism å…‰æŸï¼ˆä½å°æ¯”ï¼‰ã€2.2s å‘¼å¸ã€‚' },
      s3:{ label:'ç§‘æŠ€ï¼è³½åšæ ¼ç¶ ', selectLabel:'ç§‘æŠ€ï¼è³½åšæ ¼ç¶ ', cssSkin:'ç§‘æŠ€ï¼è³½åšæ ¼ç¶ ', canvas:{ base:[80,255,160], hi:[255,255,255], period:2400, effects:{ scanline:true, pulse:{ rings:6, thickness:6, strength:0.16, color:[80,255,160], speedFactor:0.45, intervalMul:1.6, microRipples:2, dash:true } }, bg:['#07150f','#06130e','#041009'] }, desc:'è³½åšæ ¼ç¶ è„ˆè¡ï¼šé€Ÿåº¦æ”¾ç·©ï¼ˆÃ—0.45ï¼‰ã€æ¯åœˆé–“éš”åŠ é•·ï¼ˆÃ—1.6ï¼‰ï¼Œé¡è‰²æ›´æ·¡ï¼›2.4s å‘¼å¸ã€‚' },
      s5:{ label:'å®‡å®™ï¼æ˜Ÿè¾°çµ®èª', selectLabel:'å®‡å®™ï¼æ˜Ÿè¾°çµ®èª', cssSkin:'å®‡å®™ï¼æ˜Ÿè¾°çµ®èª', canvas:{ base:[150,120,255], hi:[255,255,255], period:2800, effects:{ stars:{ countScale:1.1, twinkle:0.85, drift:0.009, sizeMin:1.6, sizeMax:3.2, glow:2.0, brightness:1.2 } }, bg:['#0b0a20','#0a0820','#08071a'] }, desc:'è—ç´«æ˜Ÿéš›éœ“è™¹ï¼šæ›´å¤§æ›´äº®çš„æ˜Ÿé»èˆ‡å…‰æšˆã€ç·©æ…¢æ¼‚ç§»ï¼Œ2.8s å‘¼å¸ã€‚' },
      w2:{ label:'æœ¨ç´‹ï¼é»‘æª€æ›œé‡‘', selectLabel:'æœ¨ç´‹ï¼é»‘æª€æ›œé‡‘', cssSkin:'æœ¨ç´‹ï¼é»‘æª€æ›œé‡‘', canvas:{ base:[240,190,110], hi:[255,245,210], period:2400, effects:{ wood:'ebony', woodBoost:true, woodSheen:{alpha:0.08} }, bg:['#0b0806','#090705','#070504'] }, desc:'é»‘æª€æ·±æ£•ï¼šåŠ å¼·æœ¨å­”/é«®çµ²ç´‹ï¼Œæ²¹æ½¤æŸ”å…‰é«˜å…‰ï¼›2.4sã€‚' },
      w4:{ label:'æœ¨ç´‹ï¼ç™½æ©¡åŒ—æ­', selectLabel:'æœ¨ç´‹ï¼ç™½æ©¡åŒ—æ­', cssSkin:'æœ¨ç´‹ï¼ç™½æ©¡åŒ—æ­', canvas:{ base:[255,220,170], hi:[255,250,230], period:1900, effects:{ wood:'oak', woodBoost:true, woodSheen:{alpha:0.06} }, bg:['#322515','#261c10','#1b140b'] }, desc:'ç™½æ©¡æ·ºæœ¨ï¼šç›´ç´‹ï¼‹ray fleckï¼ˆä½å°æ¯”ï¼‰ã€å„ªé›…æ²¹å…‰ï¼›1.9sã€‚' },
      i1:{ label:'å†°é›ªï¼æ¥µå…‰çµ²ç¶¢', selectLabel:'å†°é›ªï¼æ¥µå…‰çµ²ç¶¢', cssSkin:'å†°é›ªï¼æ¥µå…‰çµ²ç¶¢', canvas:{ base:[170,210,255], hi:[255,255,255], period:2200, effects:{ snow:{countScale:120, twinkle:true, sway:1.0, speed:0.28, speedMax:0.72, gust:0.12, sizeMin:1.0, sizeMax:2.5}, shards:{count:10, speed:0.05, width:1.2, alpha:0.10, lenMin:60, lenMax:160, drift:0.15}, frost:{alpha:0.10}, prism:{ beams:6, speed:0.0004, alpha:0.06, spread:0.82, hueShift:18 } }, bg:['#0b1626','#0a1a2f','#081628'] }, desc:'æ¥µå…‰çµ²ç·ï¼šå†°è—å‘¼å¸ï¼‹è¼•é›ªï¼‹ä½å°æ¯”æ¥µå…‰æŸï¼›2.2sã€‚' },
      k1:{ label:'é¨å£«ï¼ç™½éŠ€åŠå…‰', selectLabel:'é¨å£«ï¼ç™½éŠ€åŠå…‰', cssSkin:'é¨å£«ï¼ç™½éŠ€åŠå…‰',
          canvas:{ base:[176,196,222], hi:[235,238,245], period:2300,
                   effects:{
                     pulse:{ rings:5, thickness:5, strength:0.22, color:[235,238,245], speedFactor:1.0, intervalMul:1.0, microRipples:2, dash:true, ringDelayMs:0 },
                     shards:{ count:9, alpha:0.12, speed:0.06, width:1.2, lenMin:70, lenMax:180, drift:0.12, angleDeg:-18 }
                   },
                   bg:['#0D0D0F','#0B0B0D','#0A0A0C'] },
          desc:'é«˜è²´æ­£ç¾©ï¼šå†·ç™½æ¼¸å±¤ï¼‹éŠ€å…‰æµå‹•ï¼›Pulse ç™½å…‰è¦å¾‹é–ƒå‹•ï¼ŒShards åŠå…‰ç¨€ç–ã€‚ç”Ÿå‘½åœ–ç¤ºï¼é¨å£«é ­ç›”ã€‚2.3sã€‚' },
      /* === å”¯ä¸€ä¿ç•™ä¸”æ”¹ç‚ºæ—‹æ¸¦ç²’å­çš„ç«ç³» === */
      f3:{ label:'çƒˆç„°ï¼æ˜Ÿç«é¢¨æš´', selectLabel:'çƒˆç„°ï¼æ˜Ÿç«é¢¨æš´', cssSkin:'çƒˆç„°ï¼æ˜Ÿç«é¢¨æš´',
          canvas:{ base:[255,150,110], hi:[255,250,240], period:2100,
                   effects:{
                     /* ç§»é™¤ flames/heat/prismï¼Œåƒ…ä¿ç•™æ—‹æ¸¦ embers */
                     embers:{ mode:'vortex', count:360, sizeMin:1.0, sizeMax:2.4, tail:7, twinkle:true, omega:0.0020, center:[0.5,0.50], noise:0.12 }
                   },
                   bg:['#150807','#0d0504','#080404'] },
          desc:'æ˜Ÿç«æ—‹æ¸¦ï¼šå…¨ç•«é¢å¸¶å°¾å·´çš„ç«ç„°ç²’å­ç¹ä¸­å¤®é¾æ²ä»¥ä¸­é€Ÿæ—‹è½‰ï¼›ç”Ÿå‘½æ”¹ç‚ºğŸ”¥ï¼ŒUIç‡ƒé‚Šå¾®é–ƒã€‚2.1sã€‚' },

      
      b1:{ label:'å…”å…”ï¼å¥¶æ²¹é›²æœµ', selectLabel:'å…”å…”ï¼å¥¶æ²¹é›²æœµ', cssSkin:'å…”å…”ï¼å¥¶æ²¹é›²æœµ',
          canvas:{ base:[255,244,234], hi:[255,217,230], period:3200,
                   effects:{
                     clouds:{ count:7, sizePx:300, speed:0.003, alpha:0.20, lifeMs:30000, fadeInMs:6000, fadeOutMs:8000 },
                     stars:{ count:38, brightness:0.85 }, /* æŸ”å…‰ç™½æ˜Ÿé» < 50 é¡†ï¼ˆé™äº®åº¦ï¼‰ */
                     ledStrip:{ period:3200, hi:[255,182,193], lo:[255,244,234], segment:28 },
                     bgVignette:true
                   },
                   bg:['#0B1430','#0D1E4A','#1B4C8E'] },
          desc:'ç²‰å«©æ¸…æ–°ï¼šA1/A2/A3 å·²å¥—ç”¨â€”â€”å¥¶æ²¹é›²å±¤æ›´éœ§æ•£ã€æ˜Ÿé»æ›´æŸ”ã€LED æ”¹ç²‰ç™½â†’èœœæ¡ƒ 3.2s å‘¼å¸ï¼›HUD 20px éœ§é¢ç»ç’ƒï¼›ç”Ÿå‘½åœ–ç¤ºï¼å¤§å°ºå¯¸å…”å…”é ­ã€‚' },

      m1:{ label:'é­”æ³•ï¼é‡‘è€€æ—¥è•', selectLabel:'é­”æ³•ï¼é‡‘è€€æ—¥è•', cssSkin:'é­”æ³•ï¼é‡‘è€€æ—¥è•',
          canvas:{ base:[255,228,168], hi:[255,210,122], period:3500,
                   effects:{
                     hexagram:{ strokePx:2.8, color:'#FFD27A', rotationPeriodMs:24000, fadeUpMs:9000, fadeDownMs:3000, radiusMul:0.44 },
                     /* ç§»é™¤ moonRingï¼›æ”¹ç‚º scriptRingï¼ˆå¤–åœˆé‡‘è‰²å’’æ–‡ï¼‰ï¼Œ24s é€†æ™‚é‡ï¼Œ6s å‘¼å¸ */
                     scriptRing:{ strokePx:1.6, strokeColor:'#FFD27A', color:'#FFD27A', breathMs:6000, rotationPeriodMs:24000, radiusMul:0.58, alpha:0.72, fontPx:12, count:84, ticks:42 },
                     sparks:{ count:10, size:1.4 }
                   },
                   bg:['#0E0C08','#0B0A07','#0A0906'] },
          desc:'æ—¥è•è–ç’°ï¼šå…­èŠ’æ˜Ÿ 24s åŒ€é€Ÿæ—‹è½‰ï¼›å¤–åœˆé‡‘è‰²å’’æ–‡åœˆ 24s é€†æ™‚é‡ã€6s å‘¼å¸ï¼›LED é‡‘çµ²äº®é»ï¼ˆ3.5sï¼‰ã€‚ç”Ÿå‘½åœ–ç¤ºï¼é‡‘è€€æ˜Ÿå¾½ã€‚' },
    
      d1:{ label:'é­”ç‹ï¼çµ‚ç„‰å¯‚æ»…', selectLabel:'é­”ç‹ï¼çµ‚ç„‰å¯‚æ»…', cssSkin:'é­”ç‹ï¼çµ‚ç„‰å¯‚æ»…',
          canvas:{ base:[14,14,14], hi:[255,69,0], period:3000,
                   effects:{
                     ruins:{ layers:3, haze:0.22 },
                     nuke:{ intervalMs:13000, flashMs:220 },
                     slicer:{ widthMul:0.333,  intervalMs:3000, burstEveryMs:30000, burstIntervalMs:200, lifeMs:500, color:'rgba(190,0,30,0.35)', edge:'rgba(255,120,140,0.55)' },
                     diffuse:{ cycleMs:40000, expandMs:30000, retractMs:10000 },
                     ledStrip:{ hi:[255,69,0], lo:[96,96,96], period:3200, segment:26, hitFlash:true }
                   },
                   bg:['#0E0E0E','#1A1A1A','#0E0E0E'] },
  desc:'å»¢å¢Ÿéµå½±ï¼‹æ®˜å…‰ï¼šé æ™¯å»¢å¢Ÿé™°å½±ã€å¶çˆ¾æ ¸çˆ†æ®˜å…‰è§¸ç™¼0.3séœ‡å‹•ï¼›LED ç°â†’æ©˜ï¼Œæ“Šä¸­ç¬ç™½é–ƒï¼›ç”Ÿå‘½åœ–ç¤ºï¼è£‚ç—•éª·é«ã€‚' },
};

// (Removed development-only global error handler and script-run test)

/* ---------------- Canvas Rendererï¼ˆå«ï¼šå…­èŠ’æ˜Ÿã€å’’æ–‡åœˆã€æ—‹æ¸¦ embersï¼‰ ---------------- */
  (function(){
    const cv  = document.getElementById('game');
    const box = document.querySelector('.stage');
    const ctx = cv.getContext('2d');
    // Expose canvas and context globally for game logic modules
    // Some downstream game functions refer to global variables `canvas` and `ctx`. Assign them here
    window.canvas = cv;
    window.ctx = ctx;

    let W=0,H=0,dpr=1, rafId=0;
    let skin = { base:[92,136,255], hi:[255,255,255], period:2000, effects:{}, bg:null };

    // æ—¢æœ‰ç‹€æ…‹ï¼ˆæœ¨ç´‹/æ˜Ÿé»/å†°é›ª/å†°è£‚ï¼‰
    let woodPattern=null, woodKind=null; let oakOverlayPat=null;
    let stars=null, starOpts={}, starSizeKey='';
    let snows=null, snowOpts={}, snowKey='';
    let shards=null, shardOpts={}, shardKey='';

    // æ˜Ÿç«èˆ‡ç†±æ“¾å‹•
    
    // çµ‚ç„‰å¯‚æ»…ï¼šå»¢å¢Ÿï¼‹æ®˜å…‰ï¼‹éœ‡å‹•ï¼‹Hitç™½é–ƒ
    let ruins=null, ruinOpts={}, ruinsKey='';
    let nukeFlashUntil=0, nukeNextAt=0, shakeUntil=0;
    let ledHitFlashUntil=0;
let embers=null, emberOpts={}, emberKey='';
    // åˆ‡å‰²ç·šï¼ˆè¡€ç´…ï¼‰èˆ‡æš—ç°æ“´æ•£ï¼ˆçµ‚ç„‰å¯‚æ»…å°ˆç”¨ï¼‰
    let slicers = [];      // {t0, x, y, ang, w}
    let nextSliceAt = 0;
    let burstNextAt = 0;
    let slicerOpts = {};
    let diffusionStart = performance.now();


    const rgba = (rgb,a)=>`rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a.toFixed(3)})`;
    function hslToRgb(h,s,l){ s/=100; l/=100; const k=n=> (n+ h/30)%12; const a=s*Math.min(l,1-l); const f=n=> l - a*Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1))); return [Math.round(255*f(0)),Math.round(255*f(8)),Math.round(255*f(4))]; }
    function mix(a,b,w){ return [ Math.round(a[0]*(1-w)+b[0]*w), Math.round(a[1]*(1-w)+b[1]*w), Math.round(a[2]*(1-w)+b[2]*w) ]; }
    const easeOutQuad = x=>1-(1-x)*(1-x);

    function resize(){
      const contentW = box.clientWidth; const w = Math.min(1100, contentW);
      const h = Math.round(w * (700/1100));
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      cv.style.width = '100%'; cv.style.height = Math.round(h) + 'px';
      cv.width  = Math.round(w * dpr); cv.height = Math.round(h * dpr);
      W=cv.width;H=cv.height;
      if(woodKind==='oak'){ buildWoodPattern('oak'); }
      ensureStarsIfNeeded(); ensureSnowIfNeeded(); ensureShardsIfNeeded(); ensureEmbersIfNeeded(); ensureCloudsIfNeeded(); ensureRuinsIfNeeded(); ensureSlicerIfNeeded(); if(skin.effects && skin.effects.diffuse){ diffusionStart = performance.now(); }
    }

    /* ========= æœ¨ç´‹ ========= */
    function buildWoodPattern(kind){
      const oc = document.createElement('canvas'); const S = 320; oc.width=S; oc.height=S; const c = oc.getContext('2d');
      
      // --- unified white oak (no patchwork): draw a full-canvas grain and use 'no-repeat' ---
      if(kind==='oak'){
        const Sx = Math.max(512, W|0), Sy = Math.max(512, H|0);
        const oc2 = document.createElement('canvas'); oc2.width = Sx; oc2.height = Sy;
        const cx = oc2.getContext('2d');
        // base tone gradient for elegant furniture-like oak
        const g = cx.createLinearGradient(0,0,0,Sy);
        g.addColorStop(0.00,'#efe6d6');
        g.addColorStop(0.50,'#dfceb4');
        g.addColorStop(1.00,'#cfb997');
        cx.fillStyle = g; cx.fillRect(0,0,Sx,Sy);

        // long-grain bands across the whole canvas (slight angle, soft contrast)
        cx.save(); cx.translate(Sx/2,Sy/2); cx.rotate(8*Math.PI/180); cx.translate(-Sx/2,-Sy/2);
        for(let x=-Sx; x<Sx*2; x+=18){
          cx.fillStyle='rgba(120,85,40,0.06)'; cx.fillRect(x, 0, 5, Sy);
          cx.fillStyle='rgba(255,240,210,0.030)'; cx.fillRect(x+7, 0, 2, Sy);
        }
        cx.restore();

        // gentle growth-ring curvature to avoid straight plank feeling
        cx.save();
        cx.globalAlpha = 0.06;
        cx.strokeStyle = 'rgba(100,75,40,0.25)';
        const Rmax = Math.max(Sx,Sy);
        for(let r = Rmax*0.55; r <= Rmax*1.35; r += 90){
          cx.beginPath();
          cx.ellipse(Sx*0.2, Sy*0.85, r, r*0.36, -12*Math.PI/180, 0, Math.PI*2);
          cx.stroke();
        }
        cx.restore();

        // sparse ray-flecks (white oak medullary rays) â€” very subtle
        cx.fillStyle='rgba(255,230,200,0.04)';
        const flecks = Math.round((Sx*Sy)/40000);
        for(let i=0;i<flecks;i++){
          const ex = Math.random()*Sx, ey = Math.random()*Sy, ew=1+Math.random()*3, eh=10+Math.random()*24;
          cx.save(); cx.translate(ex,ey); cx.rotate((Math.random()*10-5)*Math.PI/180);
          cx.fillRect(-ew/2,-eh/2,ew,eh); cx.restore();
        }

        // create a no-repeat pattern so the fill is one-piece on this canvas size
        woodPattern = ctx.createPattern(oc2, 'no-repeat');
        woodKind = 'oak';
        return;
      }
const presets = { walnut:{ ang:25*Math.PI/180, step:16, line:8, dark:'#3b2517', light:'rgba(156,106,62,0.12)', rings:'#6e4a2e' }, ebony:{ ang:12*Math.PI/180, step:18, line:9, dark:'#120d0a', light:'rgba(80,65,50,0.10)',  rings:'#3c2b1e' }, cherry:{ ang:160*Math.PI/180,step:14, line:7, dark:'#5a2c33', light:'rgba(162,90,102,0.12)',rings:'#a8616f' }, oak:{ ang:8*Math.PI/180,  step:18, line:7, dark:'#6c5432', light:'rgba(182,138,84,0.12)', rings:'#a07a45' } };
      const p = presets[kind] || presets.walnut; const S2=S; c.clearRect(0,0,S2,S2);
      c.save(); c.translate(S2/2,S2/2); c.rotate(p.ang); c.translate(-S2/2,-S2/2);
      c.fillStyle=p.light; for(let x=-S2; x<=S2*2; x+=p.step){ c.fillRect(x,0,p.line,S2); }
      c.globalAlpha=0.25; c.fillStyle=p.dark; for(let x=-S2; x<=S2*2; x+=p.step*3){ c.fillRect(x,0,Math.max(1,p.line-4),S2); } c.restore();
      c.globalAlpha=0.06; c.strokeStyle=p.rings; c.lineWidth=2; const cx=S2*0.32, cy=S2*0.42;
      for(let r=28;r<S2*0.9;r+=22){ c.beginPath(); c.ellipse(cx,cy,r, r*(0.82+0.06*Math.sin(r)), 0, 0, Math.PI*2); c.stroke(); }
      c.globalAlpha=0.04; c.fillStyle='#000'; for(let i=0;i<80;i++){ const sx=Math.random()*S2, sy=Math.random()*S2, w=2+Math.random()*4, h=1+Math.random()*2; c.beginPath(); c.ellipse(sx,sy,w,h,Math.random()*Math.PI,0,Math.PI*2); c.fill(); }
      woodPattern = ctx.createPattern(oc,'repeat'); woodKind = kind;
    }

    
        
    /* ========= å¥¶æ²¹é›²å±¤ï¼ˆé›†ä¸­é›²æ ¸ç‰ˆï¼šå¼·åŒ–æ ¸å¿ƒã€é™åˆ¶æ“´æ•£ã€æ©¢åœ“è£åˆ‡ï¼‰ ========= */
    let clouds=null, cloudOpts={}, cloudKey='';
    
    function ensureCloudsIfNeeded(){
      if(!(skin.effects && skin.effects.clouds)){ clouds=null; cloudOpts={}; return; }
      const o = typeof skin.effects.clouds==='object' ? skin.effects.clouds : {};
      const count = Math.max(4, o.count || 7);
      // v4: cumulus clustered (nuclei + lobes), flat base shading
      const key = [W,H,count,o.speed||0.003,o.alpha||0.18,o.sizePx||300,o.lifeMs||32000,o.fadeInMs||6000,o.fadeOutMs||8000,'cluster-v4'].join('x');
      if(clouds && cloudKey===key) return;
      cloudKey = key; cloudOpts = o;
      const rng = Math.random;
      const baseScale = W/1100;
      const sizePx = ((o.sizePx || 300) * 0.55) * Math.max(0.7, Math.min(1.5, baseScale));

      function makePalette(){
        const r = rng();
        let h1, h2, s1 = 86 + rng()*10, s2 = 84 + rng()*12, l1 = 92 + rng()*4, l2 = 89 + rng()*5;
        if(r < 0.45){        // èœœæ¡ƒ â†’ è‰è“ç²‰
          h1 = 24 + rng()*8; h2 = 340 + rng()*12;
        }else if(r < 0.75){  // é¦™è‰ â†’ èœœæ¡ƒ
          h1 = 36 + rng()*6; h2 = 14 + rng()*10;
        }else{               // å¥¶æ²¹ç™½ â†’ ç«ç‘°ç²‰
          h1 = 10 + rng()*8; h2 = 350 + rng()*10;
        }
        return { A: hslToRgb(h1, Math.min(100, s1), Math.min(100, l1)),
                 B: hslToRgb(h2, Math.min(100, s2), Math.min(100, l2)) };
      }

      function clampEllipse(x,y,rx,ry){
        const nx = x/rx, ny = y/ry;
        const k = Math.hypot(nx,ny);
        if(k<=1) return {x,y};
        const s = 1/k; return { x: x*s, y: y*s };
      }

      clouds = new Array(count).fill(0).map(()=>{
        const bw = sizePx * (0.95 + rng()*0.35);
        const bh = bw * (0.52 + rng()*0.36);
        const life = (o.lifeMs || 32000) * (0.85 + rng()*0.40);
        const fadeIn  = o.fadeInMs  || 6000;
        const fadeOut = o.fadeOutMs || 8000;

        // æ ¸å¿ƒç¨®å­ï¼ˆ2â€“4 å€‹ï¼‰â€” 2D é«˜æ–¯ï¼Œé›†ä¸­é›²å¿ƒ
        const seedN = 2 + Math.floor(rng()*3);
        const seeds = [];
        for(let i=0;i<seedN;i++){
          // ç¢ºä¿åˆ†ä½ˆé›†ä¸­æ–¼é›²ä¸­å¿ƒï¼ˆé¿å…ç©ºå¿ƒï¼‰
          let sx = (rng()-0.5) * bw * 0.35;
          let sy = (rng()-0.5) * bh * 0.28 - bh*0.08; // ç¨å¾®åä¸Š
          const cl = clampEllipse(sx, sy, bw*0.45, bh*0.40);
          sx = cl.x; sy = cl.y;
          seeds.push({sx, sy, r:(0.20 + rng()*0.14)});
        }

        // é›²ç“£ï¼šç”±ç¨®å­æ“´å±•ï¼ˆæ¯å€‹ç¨®å­ 3â€“6 å€‹ç“£ï¼‰ï¼‹ä¸­å¿ƒå¤§ç“£ä¿è­‰ä¸ç©ºå¿ƒ
        const lobes = [];
        for(const sd of seeds){
          const ln = 3 + Math.floor(rng()*4);
          for(let i=0;i<ln;i++){
            let lx = sd.sx + (rng()-0.5)*bw*0.22;
            let ly = sd.sy + (rng()-0.5)*bh*0.20;
            const cl = clampEllipse(lx, ly, bw*0.52, bh*0.50);
            lx = cl.x; ly = cl.y;
            const rMul = (sd.r * (0.85 + rng()*0.45));
            const b = 0.68 + rng()*0.32;
            lobes.push({ xoff: lx/bw, yoff: ly/bh, rMul, b });
          }
        }
        // ä¸­å¿ƒé›²æ ¸ï¼ˆæœ€å¤§ç“£ï¼‰
        lobes.push({ xoff: 0, yoff: -0.06, rMul: 0.26 + rng()*0.10, b: 0.95 });

        // åº•è£™å°‘é‡å°ç“£ï¼Œé›†ä¸­åº¦æ›´é«˜
        const skirtN = 2 + Math.floor(rng()*3);
        for(let i=0;i<skirtN;i++){
          const t = (i/(skirtN-1)-0.5);
          const lx = t*(0.6 + rng()*0.2) * bw * 0.6;
          const ly = (0.06 + rng()*0.10) * bh;
          const cl = clampEllipse(lx, ly, bw*0.55, bh*0.55);
          lobes.push({ xoff: cl.x/bw, yoff: cl.y/bh, rMul: 0.12 + rng()*0.08, b: 0.60 + rng()*0.18 });
        }

        const palette = makePalette();
        const tilt = (rng()-0.5) * 0.22;             // è¼•å¾®å‚¾è§’
        const speed = (o.speed||0.003)*(0.65 + rng()*0.70);
        const alpha = (o.alpha||0.18)*(0.85 + rng()*0.35);
        const edgeSoft = 0.72 + rng()*0.22;          // é‚Šç·£æŸ”åŒ–
        const breathAmp = 0.00 + rng()*0.04;         // å¾®å‘¼å¸

        // å°‘é‡é£„çµ®ï¼ˆåä¸‹é¢¨å‘ï¼Œé¿å…å››æ•£ï¼‰
        const wisps = Array.from({length: (rng()<0.45? Math.floor(rng()*3) : 0)}, ()=>({
          x:(rng()-0.2)*0.6, y:0.00 + rng()*0.22, r:0.06 + rng()*0.08, a:0.30 + rng()*0.25
        }));

        return {
          x0: rng()*W,
          y: (H*0.22) + rng()*H*0.42,
          bw, bh, lobes,
          paletteA: palette.A, paletteB: palette.B,
          tilt, phase: rng()*life, speed, a: alpha,
          lifeMs: life, fadeInMs: fadeIn, fadeOutMs: fadeOut,
          edgeSoft, breathAmp, wisps,
          baseFlat: 0.30 + rng()*0.12   // åº•éƒ¨æ‰å¹³æ¯”ä¾‹ï¼ˆ0.3â€“0.42ï¼‰
        };
      });
    }

    
    function drawClouds(t){
      if(!clouds) return;
      ctx.save();
      ctx.globalCompositeOperation='source-over';

      for(const c of clouds){
        // ----- ä½ç½®èˆ‡æ™‚é–“åƒæ•¸ -----
        const dx = (t*c.speed + c.phase*0.35) % (W + c.bw*2);
        const x = -c.bw + dx;
        const y = c.y + Math.sin(t*0.00018 + c.phase*0.013)*6;
        const cx = x + c.bw*0.5, cy = y + c.bh*0.5;

        // ç”Ÿå‘½æ·¡å…¥/æ·¡å‡º
        const L = c.lifeMs, fi = c.fadeInMs, fo = c.fadeOutMs;
        const tt = (t + c.phase) % L;
        let lifeA = 1.0;
        if(tt < fi){ lifeA = tt/fi; }
        else if(tt > L - fo){ lifeA = (L-tt)/fo; }
        lifeA = Math.max(0, Math.min(1, lifeA));

        // é¡è‰²/é€æ˜åº¦
        const colA = c.paletteA || [255,244,234];
        const colB = c.paletteB || [255,217,230];
        const a0 = Math.min(0.50, c.a*lifeA);

                // ----- æ£‰åœ˜é›²ç“£ï¼ˆé›†ä¸­æ’åˆ—ï¼‰ -----
        const cosT = Math.cos(c.tilt||0), sinT = Math.sin(c.tilt||0);
        const baseY = cy + c.bh*(c.baseFlat!=null? c.baseFlat : 0.34); // æ‰å¹³åŸºæº–ç·š
        // ä¾ç›¸å° y æ’åºï¼Œè®“ä¸Šå±¤ç“£è“‹éä¸‹å±¤ï¼ˆå¡‘é€ å±¤æ¬¡ï¼‰
        const lobes = c.lobes.slice().sort((a,b)=> (a.yoff - b.yoff));

        // å…ˆç•«å‡ºä¸ŠåŠéƒ¨ï¼ˆclipï¼šé¿å…åº•éƒ¨åœ“æ»‘éé ­ï¼‰
        ctx.save();
        ctx.beginPath();
        // æ›²ç·šä¸Šç·£è£åˆ‡ï¼ˆé¿å…ç›´ç·šé•·æ–¹å½¢æ„Ÿï¼‰
        ctx.moveTo(0, 0);
        ctx.lineTo(0, baseY);
        // ä»¥ä¸€æ¢æ·ºæ‹±æ›²ç·šä½œç‚ºé›²åº•é‚Šç·£
        ctx.quadraticCurveTo(W*0.5, baseY - c.bh*0.22, W, baseY);
        ctx.lineTo(W, 0);
        ctx.closePath();
        ctx.clip();

        let li = 0;
        for(const l of lobes){
          // æ—‹è½‰å¾Œä½ç½®
          const dx0 = c.bw * (l.xoff||0);
          const dy0 = c.bh * (l.yoff||0);
          const rx = cosT*dx0 - sinT*dy0;
          const ry = sinT*dx0 + cosT*dy0;
          const lx = cx + rx, ly = cy + ry;

          // åŠå¾‘ï¼‹å¾®å‘¼å¸
          const rBase = Math.max(2, (c.bw * (l.rMul||0.16)) * 0.92);
          const rPulse = 1 + (c.breathAmp||0)*Math.sin(t*0.0015 + c.phase*0.008 + li*0.7);
          const rr = Math.max(2, rBase * rPulse);

          const lb = (l && typeof l.b==='number') ? l.b : 1.0;
          // æ¼¸å±¤ä¸­å¿ƒç¨å¾®ä¸Šç§»ï¼Œè£½é€ å‘ä¸Šå—å…‰
          const ly2 = ly - rr*0.18;
          const gg = ctx.createRadialGradient(lx,ly2, rr*0.08, lx,ly2, rr * (0.78 - 0.18*(c.edgeSoft||0.0)));
          gg.addColorStop(0, `rgba(${colA[0]},${colA[1]},${colA[2]},${(a0*0.95*lb).toFixed(3)})`);
          gg.addColorStop(1, `rgba(${colB[0]},${colB[1]},${colB[2]},0)`);
          ctx.fillStyle=gg;
          ctx.beginPath(); ctx.arc(lx,ly, rr, 0, Math.PI*2); ctx.fill();
          li++;
        }
        ctx.restore();

        
        // ä¸‹é¢¨å‘çš„å°‘é‡çµ®çµ²ï¼ˆä¸ç ´å£é›†ä¸­åº¦ï¼‰
        if(c.wisps && c.wisps.length){
          for(const w of c.wisps){
            const dx0 = c.bw * w.x, dy0 = c.bh * w.y;
            const rx = cosT*dx0 - sinT*dy0;
            const ry = sinT*dx0 + cosT*dy0;
            const lx = cx + rx, ly = cy + ry;
            const r = Math.max(2, c.bw * w.r);
            const ga = (a0 * lifeA) * (0.45 * (w.a||0.5));
            const gw = ctx.createRadialGradient(lx,ly, r*0.06, lx,ly, r*0.95);
            gw.addColorStop(0, `rgba(${colA[0]},${colA[1]},${colA[2]},${ga.toFixed(3)})`);
            gw.addColorStop(1, `rgba(${colB[0]},${colB[1]},${colB[2]},0)`);
            ctx.fillStyle=gw;
            ctx.beginPath(); ctx.arc(lx,ly, r, 0, Math.PI*2); ctx.fill();
          }
        }
      }

      ctx.restore();
    }

/* ========= æ˜Ÿé» ========= */
    function buildStars(){
      const baseCount = (starOpts && typeof starOpts.count==='number') ? starOpts.count : 140; const scale = (W*H)/(1100*700); const N = Math.max( Math.min(60, baseCount), Math.floor(baseCount*scale) );
      stars = new Array(N).fill(0).map(()=>({ x:Math.random()*W, y:Math.random()*H, r:0.9+Math.random()*0.9, a:0.05+Math.random()*0.12, ph:Math.random()*Math.PI*2, sp:0.6+Math.random()*1.2, px:0.3+Math.random()*0.7 }));
      starSizeKey = W+'x'+H;
    }
    function ensureStarsIfNeeded(){ if(!(skin.effects && skin.effects.stars)){ stars=null; return; } if(!stars || starSizeKey !== (W+'x'+H)) buildStars(); }
    function drawStarField(t){ if(!stars) return; ctx.save(); ctx.globalCompositeOperation='screen'; for(const s of stars){ const twi=0.5+0.5*Math.sin(t*0.001*s.sp + s.ph); const baseA=(s.a*(0.55+0.6*twi)); const bMul = (starOpts && starOpts.brightness!=null)? starOpts.brightness : 1.0; const a = baseA * bMul; const dx=(t*0.008*s.px)%(W+20); const x=(s.x+dx), y=s.y, r=s.r*dpr*1.2; const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,`rgba(255,255,255,${(a*1.35).toFixed(3)})`); g.addColorStop(1,'rgba(180,160,255,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); } ctx.restore(); }

    /* ========= å†°é›ª ========= */
    function ensureSnowIfNeeded(){ if(!(skin.effects && skin.effects.snow)){ snows=null; snowOpts={}; return; } const o=typeof skin.effects.snow==='object'? skin.effects.snow : {}; const density=Math.max(40, o.count || Math.round((W*H)/(420*420)*120)); const key=[W,H,density,o.gust||0,o.twinkle?1:0,o.sizeMin||1,o.sizeMax||3].join('x'); if(snows && snowKey===key) return; snowKey=key; snows=new Array(density).fill(0).map(()=>{ const size=(o.sizeMin||1)+Math.random()*((o.sizeMax||3)-(o.sizeMin||1)); return {x:Math.random()*W,y:Math.random()*H,size, baseX:Math.random()*W, speed:(o.speed||0.25)+Math.random()*((o.speedMax||0.9)-(o.speed||0.25)), sway:(o.sway||0.8)*(0.5+Math.random()), phase:Math.random()*Math.PI*2, twinkle:!!o.twinkle && Math.random()<0.25}; }); snowOpts=o; }
    function drawSnow(t){ if(!snows) return; const tt=t*0.001, gust=snowOpts.gust||0; const aBase=Math.min(.22, .10 + .12*(Math.sin(tt*0.6+1.7)*.5+.5)); const glow=Math.min(.14, .06 + .08*(Math.sin(tt*0.8+0.4)*.5+.5)); for(const f of snows){ f.phase += 0.01 + gust*0.015; f.y += f.speed * (1 + 0.6*Math.sin(tt*0.9)); f.x = f.baseX + Math.sin(f.phase)*(f.sway*4 + gust*24); if(f.y>H+10){ f.y=-10; f.baseX=Math.random()*W; } if(f.x<-10){ f.baseX=W+10; } const a=aBase*(f.twinkle?(0.7+0.3*Math.sin(tt*6+f.phase)):1); ctx.save(); ctx.globalAlpha=a; ctx.beginPath(); ctx.arc(f.x,f.y,f.size*dpr,0,Math.PI*2); ctx.fillStyle='white'; ctx.fill(); if(glow>0){ const r=(f.size*3+2)*dpr; const g=ctx.createRadialGradient(f.x,f.y,0,f.x,f.y,r); g.addColorStop(0,'rgba(255,255,255,'+glow+')'); g.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(f.x,f.y,r,0,Math.PI*2); ctx.fill(); } ctx.restore(); } }

    /* ========= å†°è£‚ ========= */
    function ensureShardsIfNeeded(){ if(!(skin.effects && skin.effects.shards)){ shards=null; shardOpts={}; return; } const o=typeof skin.effects.shards==='object'? skin.effects.shards : {}; const count=Math.max(6, o.count || Math.round((W+H)/200)); const key=[W,H,count,o.alpha||0.12,o.speed||0.06,o.lenMin||40,o.lenMax||180].join('x'); if(shards && shardKey===key) return; shardKey=key; shards=new Array(count).fill(0).map(()=>{ const len=(o.lenMin||40)+Math.random()*((o.lenMax||180)-(o.lenMin||40)); const angle=(o.angleDeg!==undefined? o.angleDeg : -28)*Math.PI/180; const x=Math.random()*W, y=Math.random()*H; return {x,y,len,angle,width:(o.width||1.2)*dpr,alpha:(o.alpha||0.12),speed:(o.speed||0.06)}; }); shardOpts=o; }
    function drawShards(t){ if(!shards) return; const drift=(shardOpts.drift||0.20); ctx.save(); ctx.globalAlpha=Math.min(.22,(shardOpts.alpha||0.12)); ctx.strokeStyle='rgba(220,245,255,1)'; ctx.lineWidth=Math.max(0.6,(shardOpts.width||1.2)*dpr); for(const s of shards){ s.x += Math.cos(s.angle)*s.speed*60; s.y += Math.sin(s.angle)*s.speed*60 + drift; if(s.x<-50 || s.x>W+50 || s.y<-50 || s.y>H+50){ s.x=Math.random()*W; s.y=-20; } const x2=s.x+Math.cos(s.angle)*s.len, y2=s.y+Math.sin(s.angle)*s.len; ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(x2,y2); ctx.stroke(); } ctx.restore(); }

    /* ========= æ˜Ÿç«ï¼ˆembersï¼‰ with Vortex Mode ========= */
    function ensureEmbersIfNeeded(){
      if(!(skin.effects && skin.effects.embers)){ embers=null; emberOpts={}; return; }
      const o=typeof skin.effects.embers==='object'? skin.effects.embers : {};
      const N = Math.round((W*H)/(1100*700) * (o.count || 320));
      const key=[W,H,N,o.sizeMin||1.0,o.sizeMax||2.6,o.mode||'rise',o.omega||0.0018,(o.tail||6), (o.center?o.center.join(','):'0.5,0.5'), o.twinkle?1:0, o.noise||0.12].join('|');
      if(embers && emberKey===key) return;
      emberKey=key;
      embers = new Array(N).fill(0).map(()=>{
        const s=(o.sizeMin||1.0)+Math.random()*((o.sizeMax||2.6)-(o.sizeMin||1.0));
        const p={
          x:Math.random()*W, y:Math.random()*H,
          vx:(Math.random()-.5)*0.1, vy:(Math.random()-.5)*0.1,
          size:s, hue: 25+Math.random()*20, tw: (!!o.twinkle && Math.random()<0.4),
          t:Math.random()*Math.PI*2, hist:[]
        };
        return p;
      });
      emberOpts=o;
    }

    let lastT=0;
    function drawEmbers(t){
      if(!embers) return;
      const dt = Math.max(10, Math.min(34, lastT? (t - lastT) : 16)); // ä¼°ç®—å¹€æ™‚é–“ï¼Œå¤¾åœ¨ [10,34]ms
      const mode = emberOpts.mode || 'rise';
      ctx.save();
      ctx.globalCompositeOperation='screen';
      const cx = W * ((emberOpts.center && emberOpts.center[0] != null)? emberOpts.center[0] : 0.5);
      const cy = H * ((emberOpts.center && emberOpts.center[1] != null)? emberOpts.center[1] : 0.50);
      const omega = emberOpts.omega != null ? emberOpts.omega : 0.0018; // rad/ms
      const tailLen = Math.max(3, emberOpts.tail || 6);
      const noise = emberOpts.noise != null ? emberOpts.noise : 0.12;

      for(const p of embers){
        // --- æ›´æ–°ä½ç½®ï¼ˆvortex or riseï¼‰ ---
        if(mode==='vortex'){
          // æŒ‡å‘ä¸­å¿ƒçš„å‘é‡
          const dx = p.x - cx, dy = p.y - cy;
          const r = Math.hypot(dx, dy) + 0.0001;
          // åˆ‡å‘å–®ä½å‘é‡ï¼ˆé€†æ™‚é‡ï¼‰
          const tx = -dy / r, ty = dx / r;
          // ä¸­ç­‰é€Ÿåº¦ï¼švt éš¨åŠå¾‘ç•¥å¢
          const vt = omega * dt * (0.45 + 0.55*Math.min(1, r/Math.max(120,Math.min(W,H)*0.28)));
          // å¾®å¼±å‘å¿ƒ/é›¢å¿ƒé›œè¨Šï¼Œé¿å…ç²’å­èšé›†
          const radialJit = (Math.random()-0.5) * noise;
          p.vx += tx*vt + radialJit * (dx/r);
          p.vy += ty*vt + radialJit * (dy/r);
          // è¼•å¾®é»æ»¯é˜»å°¼ï¼Œç©©å®šæ—‹è½‰
          p.vx *= 0.985; p.vy *= 0.985;
        }else{
          // èˆŠå¼ï¼šå‘ä¸Šé£„ï¼‹å°æ—‹æ“º
          p.t += 0.02 + (emberOpts.swirl||0.18)*0.02;
          p.x += p.vx + Math.sin(p.t)*(emberOpts.swirl||0.18)*1.2;
          p.y += p.vy - Math.cos(p.t)*(emberOpts.swirl||0.18)*0.4 - (emberOpts.up||0.35);
        }

        // ç§»å‹•
        p.x += p.vx; p.y += p.vy;

        // é‚Šç•Œå†ç”Ÿï¼šç¢ºä¿å…¨ç•«é¢éƒ½æœ‰ç²’å­
        if(p.x<-12 || p.x>W+12 || p.y<-12 || p.y>H+12){
          p.x = Math.random()*W; p.y = Math.random()*H;
          p.vx = (Math.random()-.5)*0.2; p.vy = (Math.random()-.5)*0.2;
          p.hist.length = 0;
        }

        // --- ç•«å°¾å·´ï¼ˆæ­·å²è·¯å¾‘ï¼‰ ---
        p.hist.push({x:p.x, y:p.y});
        if(p.hist.length>tailLen) p.hist.shift();

        // head glow
        const twk = p.tw ? (0.85 + 0.15*Math.sin(t*0.012 + p.t*3)) : 1.0;
        const headR = p.size*dpr*(1.6 * twk);
        const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,headR*3.0);
        const colorHue = p.hue;
        g.addColorStop(0.0, `hsla(${colorHue}, 100%, 65%, 0.90)`);
        g.addColorStop(1.0, `hsla(${colorHue+10}, 100%, 50%, 0)`);
        ctx.fillStyle=g;
        ctx.beginPath(); ctx.arc(p.x,p.y,headR,0,Math.PI*2); ctx.fill();

        // tail segments
        ctx.lineCap='round';
        for(let i=1;i<p.hist.length;i++){
          const a = i/(p.hist.length-1);
          const p0 = p.hist[i-1], p1 = p.hist[i];
          const w = Math.max(1, (p.size*1.2*dpr) * (1-a));
          ctx.strokeStyle = `hsla(${colorHue+6}, 100%, ${55 - a*25}%, ${0.32*(1-a)})`;
          ctx.lineWidth = w;
          ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
        }
      }
      ctx.restore();
      lastT = t;
    }

    /* ========= èƒŒæ™¯æ¡†æ¶èˆ‡ LED ========= */
    function drawPrism(t){ const p=skin.effects && skin.effects.prism; if(!p) return; const beams=p.beams||8, speed=p.speed||0.0005, alpha=(p.alpha!=null?p.alpha:0.10), spread=p.spread||0.85, hueShift=p.hueShift||0; const cx=W*0.5, cy=H*0.45, R=Math.hypot(W,H); ctx.save(); ctx.globalCompositeOperation='screen'; for(let i=0;i<beams;i++){ const ang=t*speed + i*(Math.PI*2/beams); ctx.save(); ctx.translate(cx,cy); ctx.rotate(ang); const w=R*0.12; const grad=ctx.createLinearGradient(0,0,R,0); const h0=(i*360/beams + (t*0.02) + hueShift)%360, h1=(h0+60)%360; const c0=hslToRgb(h0,85,62), c1=hslToRgb(h1,80,58); grad.addColorStop(0.00,'rgba(255,255,255,0)'); grad.addColorStop(0.10,rgba(c0,0.20)); grad.addColorStop(0.55,rgba(c1,0.12)); grad.addColorStop(1.00,'rgba(255,255,255,0)'); ctx.fillStyle=grad; ctx.globalAlpha=alpha; ctx.beginPath(); ctx.moveTo(-w,0); ctx.lineTo(R*spread,-w*0.40); ctx.lineTo(R,0); ctx.lineTo(R*spread,w*0.40); ctx.lineTo(w,0); ctx.closePath(); ctx.fill(); ctx.restore(); } ctx.restore(); }
    function drawPulse(t){ const p=skin.effects && skin.effects.pulse; if(!p) return; const time = t * (p.speedFactor!=null? p.speedFactor : 1.0); const rings = p.rings || 5; const thick = Math.max(1.5,(p.thickness||6)*dpr*0.85); const col = p.color || skin.base; const col2 = mix(col, [120,240,255], 0.35); const strength = (p.strength!=null? p.strength:0.20); const cx=W/2, cy=H*0.48, maxR=Math.min(W,H)*0.56; const micro = Math.max(1, p.microRipples||2); const dash  = p.dash!==false; const baseDelay = skin.period / rings; const ringDelay = (p.ringDelayMs!=null) ? p.ringDelayMs : baseDelay * (p.intervalMul || 1); ctx.save(); ctx.globalCompositeOperation='screen'; for(let i=0;i<rings;i++){ const raw = ((time - i*ringDelay) % skin.period + skin.period) % skin.period; const ph = raw / skin.period; const jitter = Math.sin((time*0.0009 + i)*3.7)*0.012; const eased = easeOutQuad(Math.min(1, Math.max(0, ph + jitter))); const r = eased * maxR; const fade = Math.pow(1-ph, 2.15); ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.lineWidth = thick*(0.72 + 0.52*(1-ph)); ctx.shadowColor = rgba(col, Math.min(0.30,strength*0.50)*fade); ctx.shadowBlur = 18; ctx.strokeStyle = rgba(col, Math.min(0.78, strength*0.92) * fade); ctx.stroke(); ctx.restore(); ctx.save(); ctx.beginPath(); ctx.arc(cx,cy, r*0.996, 0, Math.PI*2); ctx.lineWidth = Math.max(1, thick*0.42); ctx.strokeStyle = rgba(col2, Math.min(0.48, strength*0.40) * fade); ctx.stroke(); ctx.restore(); const band = Math.max(2, thick*1.2); const rg = ctx.createRadialGradient(cx,cy, Math.max(0,r-band), cx,cy, r+band); rg.addColorStop(0.45, 'rgba(0,0,0,0)'); rg.addColorStop(0.50, rgba(col, Math.min(0.36, strength*0.30)*fade)); rg.addColorStop(0.55, 'rgba(0,0,0,0)'); ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(cx,cy,r+band,0,Math.PI*2); ctx.fill(); for(let m=1;m<=micro;m++){ const rr = r + m*(band*0.65); const g2 = ctx.createRadialGradient(cx,cy, rr-1.5, cx,cy, rr+1.5); g2.addColorStop(0,'rgba(0,0,0,0)'); g2.addColorStop(0.49, rgba(col2, Math.min(0.33, strength*0.24)*(fade*(0.85-0.25*m)))); g2.addColorStop(0.51, 'rgba(0,0,0,0)'); ctx.fillStyle=g2; ctx.beginPath(); ctx.arc(cx,cy,rr+2,0,Math.PI*2); ctx.fill(); } if(dash){ ctx.save(); ctx.setLineDash([8,14]); ctx.lineDashOffset = - (time*0.06) * (i+1); ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.lineWidth = Math.max(1, thick*0.34); ctx.strokeStyle = rgba(col2, Math.min(0.30, strength*0.22) * fade); ctx.stroke(); ctx.setLineDash([]); ctx.restore(); } } ctx.restore(); }

    /* ========= é­”æ³•å¹¾ä½•ï¼šå…­èŠ’æ˜Ÿ ========= */
    function drawHexagram(t){
      const hex = skin.effects && skin.effects.hexagram; if(!hex) return;
      const cx = W*0.5, cy = H*0.48;
      const R = Math.min(W,H) * (hex.radiusMul != null ? hex.radiusMul : 0.44);
      const rotT = (t % (hex.rotationPeriodMs||24000)) / (hex.rotationPeriodMs||24000);
      const ang = rotT * Math.PI*2; // 24s ä¸€åœˆï¼ˆé †æ™‚é‡ï¼‰
      // æ˜æš—æ›²ç·šï¼š9s æ¼¸äº® 3s å›è½ â†’ 12s é€±æœŸ
      const up = hex.fadeUpMs != null ? hex.fadeUpMs : 9000;
      const down = hex.fadeDownMs != null ? hex.fadeDownMs : 3000;
      const cyc = (up+down);
      const tt = (t % cyc);
      const br = tt < up ? (0.35 + 0.65 * (0.5 - 0.5*Math.cos(Math.PI*tt/up)))
                         : (1.0 - 0.5 * (1 - Math.cos(Math.PI*(tt-up)/down)));
      const baseCol = hex.color || '#FFD27A';
      const strokePx = Math.max(1.5, (hex.strokePx||2.8)*dpr);
      ctx.save();
      ctx.translate(cx,cy); ctx.rotate(ang);
      ctx.globalCompositeOperation = 'screen';
      ctx.lineWidth = strokePx;
      ctx.strokeStyle = baseCol;
      ctx.globalAlpha = Math.min(1, (hex.alpha!=null?hex.alpha:0.9) * br);

      // å…©å€‹ç­‰é‚Šä¸‰è§’å½¢çµ„æˆå…­èŠ’æ˜Ÿ
      const drawTri = (start)=>{
        ctx.beginPath();
        for(let i=0;i<3;i++){
          const a = start + i*(2*Math.PI/3);
          const x = Math.cos(a)*R, y = Math.sin(a)*R;
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath(); ctx.stroke();
      };
      drawTri(-Math.PI/2);
      drawTri(-Math.PI/2 + Math.PI/3);

      // å…§å´æš—é‡‘æšˆå…‰
      const glow = ctx.createRadialGradient(0,0, R*0.55, 0,0, R*1.02);
      glow.addColorStop(0, 'rgba(255,210,122,0.20)');
      glow.addColorStop(1, 'rgba(255,210,122,0.0)');
      ctx.fillStyle = glow; ctx.globalAlpha = 0.8*br; ctx.beginPath(); ctx.arc(0,0,R*1.05,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    /* ========= é­”æ³•å’’æ–‡åœˆï¼ˆå–ä»£æœˆç›¸ç’°ï¼‰ï¼š24s é€†æ™‚é‡ã€6s å‘¼å¸ ========= */
    function drawScriptRing(t){
      const sr = skin.effects && skin.effects.scriptRing; if(!sr) return;
      const cx = W*0.5, cy = H*0.48;
      const R = Math.min(W,H) * (sr.radiusMul != null ? sr.radiusMul : 0.58); // å¤–æ–¼å…­èŠ’æ˜Ÿ
      const rotT = (t % (sr.rotationPeriodMs||24000)) / (sr.rotationPeriodMs||24000);
      const ang = - rotT * Math.PI*2; // é€†æ™‚é‡
      const breath = (0.6 + 0.4 * (0.5 + 0.5 * Math.sin((t % (sr.breathMs||6000)) / (sr.breathMs||6000) * Math.PI*2)));
      const alpha = Math.min(1, (sr.alpha!=null? sr.alpha:0.72) * breath);
      const stroke = Math.max(1.0, (sr.strokePx||1.6)*dpr);
      const col = sr.color || '#FFD27A';
      const glyphs = (sr.glyphs || 'âœ¶âœ·âœ¸âœ¹âœºâœ»âœ¼âœ½âœ¾âœ¿â˜€ï¸â˜¼â˜½â˜¾âœ§âœ¦âŸ¡â—‡â—†â—ˆ').split('');
      const N = sr.count || 84;
      const tickN = sr.ticks || 42;
      const fontPx = Math.max(8, (sr.fontPx||12)*dpr);

      ctx.save(); ctx.translate(cx,cy); ctx.rotate(ang); ctx.globalCompositeOperation='screen';

      // åŸºç¤å¤–åœˆ
      ctx.globalAlpha = alpha * 0.55;
      ctx.strokeStyle = sr.strokeColor || col;
      ctx.lineWidth = stroke;
      ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.stroke();

      // Glyphs
      ctx.font = fontPx + 'px ui-sans-serif, "Noto Sans TC", system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      for(let i=0;i<N;i++){
        const a = (i/N)*Math.PI*2;
        ctx.save();
        ctx.rotate(a); ctx.translate(0,-R);
        ctx.rotate(Math.PI/2); // æ–‡å­—æ²¿åˆ‡ç·š
        ctx.globalAlpha = alpha * (0.75 + 0.25*Math.sin(t*0.003 + i));
        ctx.fillStyle = col;
        ctx.fillText(glyphs[i % glyphs.length], 0, 0);
        ctx.restore();
      }

      // ç´°åˆ»åº¦ï¼ˆä¸å½±éŸ¿å…­èŠ’æ˜Ÿï¼Œå¯è¦–åŒ–ç¯€å¥ï¼‰
      ctx.globalAlpha = alpha * 0.45;
      ctx.strokeStyle = col; ctx.lineWidth = Math.max(0.8, (sr.tickPx||1.0)*dpr);
      for(let i=0;i<tickN;i++){
        const a=(i/tickN)*Math.PI*2;
        const r1=R-3*dpr, r2=R+3*dpr;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*r1, Math.sin(a)*r1);
        ctx.lineTo(Math.cos(a)*r2, Math.sin(a)*r2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawSparks(t){
      const sp = skin.effects && skin.effects.sparks; if(!sp) return;
      // æ¥µå°‘é‡å°é‡‘è‰²ç«èŠ±ï¼ˆå¶ç™¼ï¼‰
      const cx=W*0.5, cy=H*0.48, R=Math.min(W,H)*0.48;
      ctx.save(); ctx.globalCompositeOperation='screen';
      const n = sp.count || 12;
      for(let i=0;i<n;i++){
        const a = (t*0.0003 + i*0.618) * Math.PI*2;
        const r = R*(0.75 + 0.25*(0.5+0.5*Math.sin(t*0.0007+i)));
        const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
        const rr = (sp.size || 1.6)*dpr;
        const g = ctx.createRadialGradient(x,y,0,x,y,rr*6);
        g.addColorStop(0, 'rgba(255,210,122,0.80)'); g.addColorStop(1, 'rgba(255,210,122,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,rr,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }


    
    
    function ensureSlicerIfNeeded(){
      const sfx = skin.effects && skin.effects.slicer;
      if(!sfx){ slicers = []; slicerOpts = {}; nextSliceAt = 0; burstNextAt = 0; return; }
      slicerOpts = sfx;
      if(nextSliceAt === 0 || !burstNextAt){
        const now = performance.now();
        nextSliceAt = now + (sfx.intervalMs || 3000);
        burstNextAt = now + (sfx.burstEveryMs || 30000);
      }
    }
    function scheduleSlice(at){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const ang = (Math.random()*Math.PI*2);
      const sfx = (skin.effects && skin.effects.slicer) || {};
      const baseW = Math.max(6, Math.round(8*dpr));
      const mul = (sfx.widthMul != null ? sfx.widthMul : 1);
      const w = Math.max(1, Math.round(baseW * mul));
      slicers.push({ t0: at, x, y, ang, w });
    }
    function maybeSlicers(t){
      const sfx = skin.effects && skin.effects.slicer; if(!sfx) return;
      const now = performance.now();
      if(now >= nextSliceAt){
        scheduleSlice(now);
        nextSliceAt = now + (sfx.intervalMs || 3000);
      }
      if(now >= burstNextAt){
        const step = sfx.burstIntervalMs || 200;
        for(let i=0;i<10;i++){ scheduleSlice(now + i*step); }
        burstNextAt = now + (sfx.burstEveryMs || 30000);
      }
      // draw & prune
      const lifeMs = sfx.lifeMs || 500;
      const color = sfx.color || 'rgba(190,0,30,0.38)';
      const colorEdge = sfx.edge || 'rgba(255,120,140,0.55)';
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      const maxLen = Math.hypot(W, H);
      const keep = [];
      for(const s of slicers){
        const p = (now - s.t0) / lifeMs;
        if(p < 0){ keep.push(s); continue; }
        if(p > 1.0) continue;
        const ease = p<0.5 ? (p/0.5) : (1 - (p-0.5)/0.5);
        const alpha = Math.max(0, ease);
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.ang);
        // core line
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(-maxLen, -s.w*0.5, maxLen*2, s.w);
        // bright edge
        const g = ctx.createLinearGradient(-maxLen, 0, maxLen, 0);
        g.addColorStop(0.48, 'rgba(255,255,255,0)');
        g.addColorStop(0.50, colorEdge);
        g.addColorStop(0.52, 'rgba(255,255,255,0)');
        ctx.fillStyle = g;
        ctx.fillRect(-maxLen, -s.w*0.7, maxLen*2, s.w*1.4);
        ctx.restore();
        keep.push(s);
      }
      ctx.restore();
      slicers = keep;
    }
    function drawDiffuse(t){
      const dfx = skin.effects && skin.effects.diffuse; if(!dfx) return;
      const now = performance.now();
      const cycle = (dfx.cycleMs || 40000);
      const expandMs = (dfx.expandMs || 30000);
      const retractMs = (dfx.retractMs || 10000);
      const elapsed = (now - diffusionStart) % cycle;
      let prog;
      if(elapsed <= expandMs){ prog = elapsed / expandMs; }
      else { prog = 1 - (elapsed - expandMs) / retractMs; }
      prog = Math.max(0, Math.min(1, prog));
      const cx = W*0.5, cy = H*0.5;
      const maxR = Math.hypot(W, H);
      const r = Math.max(0, prog) * maxR;
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
      const base = dfx.color || 'rgba(40,40,40,0.65)';
      g.addColorStop(0, base);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
function ensureRuinsIfNeeded(){
      const rfx = skin.effects && skin.effects.ruins;
      if(!rfx){ ruins=null; ruinOpts={}; return; }
      const layers = Math.max(1, (rfx.layers||3));
      const key = [W,H,layers].join('x');
      if(ruins && ruinsKey===key) return;
      ruinsKey = key; ruinOpts = rfx;
      const rng = Math.random;
      ruins = new Array(layers).fill(0).map((_,i)=>{
        const yBase = H*0.55 + i*(H*0.08);
        const count = 6 - i + Math.floor(rng()*2);
        const alpha = 0.12 + i*0.06;
        const objs = new Array(count).fill(0).map(()=>{
          const w = 80 + rng()*180;
          const h = 40 + rng()*120;
          const x = -40 + rng()*(W+80);
          const y = yBase + rng()*30;
          const tilt = (rng()-0.5)*0.2;
          const rebar = rng()<0.5;
          return {x,y,w,h,tilt,rebar,alpha};
        });
        return {alpha, objs};
      });
    }
    function drawRuins(t){
      if(!ruins) return;
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      for(const layer of ruins){
        ctx.globalAlpha = Math.max(0, Math.min(1, (1-(ruinOpts.haze||0))*layer.alpha));
        for(const o of layer.objs){
          ctx.save();
          ctx.translate(o.x, o.y);
          ctx.rotate(o.tilt);
          const g = ctx.createLinearGradient(0,0,o.w,0);
          g.addColorStop(0,'rgba(50,50,50,0.5)');
          g.addColorStop(1,'rgba(20,20,20,0.2)');
          ctx.fillStyle = g;
          ctx.fillRect(0,0,o.w,o.h);
          if(o.rebar){
            ctx.strokeStyle='rgba(160,160,160,0.25)';
            ctx.lineWidth = 1*dpr;
            for(let i=0;i<3;i++){
              const rx = 6 + i*(8+Math.random()*12);
              ctx.beginPath(); ctx.moveTo(rx,-6); ctx.lineTo(rx,o.h+8); ctx.stroke();
            }
          }
          ctx.restore();
        }
      }
      ctx.restore();
    }
    function maybeNuke(t){
      const nfx = skin.effects && skin.effects.nuke;
      if(!nfx) return;
      const now = performance.now();
      if(now > nukeNextAt && Math.random() < 0.015){
        nukeFlashUntil = now + (nfx.flashMs||220);
        shakeUntil = now + 300;
        nukeNextAt = now + (nfx.intervalMs||13000) * (0.7 + Math.random()*0.6);
      }
      if(nukeFlashUntil > now){
        const x = W*(0.2 + Math.random()*0.6);
        const y = H*(0.45 + Math.random()*0.15);
        const r = Math.max(W,H)*0.8;
        const g = ctx.createRadialGradient(x,y,0,x,y,r);
        g.addColorStop(0,'rgba(255,255,255,0.55)');
        g.addColorStop(0.35,'rgba(255,160,80,0.25)');
        g.addColorStop(1,'rgba(255,255,255,0)');
        ctx.save();
        ctx.globalCompositeOperation='screen';
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }
    window.__skinNotifyHit = function(ms){ ledHitFlashUntil = performance.now() + (ms||180); };
function drawFrame(t){
      const phase=(t%skin.period)/skin.period; const breathe = 0.65 + 0.35 * (0.5 + 0.5 * Math.sin(phase * Math.PI * 2));
      const edge=Math.max(2,Math.round(1.5*dpr)), bevel=Math.max(3,Math.round(4*dpr)); const aura=Math.max(10,Math.round(12*dpr)); const edgThick = edge + bevel;

      // èƒŒæ™¯ï¼ˆå¯è¢« skin.bg è¦†è“‹ï¼‰
      const bg=ctx.createLinearGradient(0,0,0,H);
      if(Array.isArray(skin.bg) && skin.bg.length>=3){ bg.addColorStop(0,skin.bg[0]); bg.addColorStop(0.55,skin.bg[1]); bg.addColorStop(1,skin.bg[2]); }
      else { bg.addColorStop(0,'#0d132a'); bg.addColorStop(0.55,'#0b1226'); bg.addColorStop(1,'#091223'); }
      ctx.fillStyle=bg; ctx.fillRect(0,0,W,H);
      // --- White Oak end-grain background (full-canvas) ---
      if(woodPattern && woodKind==='oak'){
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0; // dominate background so users clearly see wood texture
        ctx.fillStyle = woodPattern;
        ctx.fillRect(0,0,W,H);
        // subtle sheen for elegance, if defined
        const sheen = skin.effects && skin.effects.woodSheen && (skin.effects.woodSheen.alpha||0.06);
        if(sheen){
          const gSheen = ctx.createLinearGradient(0,0,W,H);
          gSheen.addColorStop(0.0, 'rgba(255,255,255,0.05)');
          gSheen.addColorStop(0.5, 'rgba(255,255,255,0.00)');
          gSheen.addColorStop(1.0, 'rgba(0,0,0,0.03)');
          ctx.globalAlpha = sheen;
          ctx.fillStyle = gSheen;
          ctx.fillRect(0,0,W,H);
        }
        
        // unify oak long-grain overlay for furniture-like continuity
        if(!oakOverlayPat){
          const oc=document.createElement('canvas'); oc.width=256; oc.height=256; const c=oc.getContext('2d');
          // base gentle longitudinal grain
          c.fillStyle='rgba(210,190,160,0.06)'; c.fillRect(0,0,256,256);
          c.save(); c.translate(128,128); c.rotate(12*Math.PI/180); c.translate(-128,-128);
          for(let x=-256; x<512; x+=18){
            c.fillStyle='rgba(120,85,40,0.08)'; c.fillRect(x,0,4,256);
            c.fillStyle='rgba(255,240,210,0.035)'; c.fillRect(x+6,0,2,256);
          }
          c.restore();
          // sparse ray flecks (very subtle)
          c.fillStyle='rgba(255,230,200,0.04)';
          for(let i=0;i<22;i++){
            const ex=Math.random()*256, ey=Math.random()*256, ew=1+Math.random()*3, eh=8+Math.random()*22;
            c.save(); c.translate(ex,ey); c.rotate((Math.random()*10-5)*Math.PI/180);
            c.fillRect(-ew/2,-eh/2,ew,eh); c.restore();
          }
          oakOverlayPat = ctx.createPattern(oc,'repeat');
        }
        ctx.globalCompositeOperation='soft-light';
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = oakOverlayPat;
        ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation='source-over';
ctx.restore();
      }
      // èƒŒæ™¯éœ‡å‹•ï¼ˆçµ‚ç„‰å¯‚æ»…ï¼‰
      if(shakeUntil>performance.now()){
        const amp = 2*dpr; ctx.save(); ctx.translate((Math.random()-0.5)*amp, (Math.random()-0.5)*amp);
      }
      drawRuins(t);
      drawDiffuse(t);
      maybeSlicers(t);
      maybeNuke(t);

      // æŸ”å’Œæš—è§’ï¼ˆåªåœ¨æœ¬ skin é–‹å•Ÿï¼‰
      (function bgVignette(){
        const vg = skin.effects && skin.effects.bgVignette; if(!vg) return;
        const g = ctx.createRadialGradient(W*0.5, H*0.5, Math.min(W,H)*0.10, W*0.5, H*0.5, Math.max(W,H)*0.70);
        g.addColorStop(0, 'rgba(0,0,0,0)');
        g.addColorStop(1, 'rgba(200,210,230,0.16)');
        ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      })();

      // èƒŒæ™¯ç‰¹æ•ˆå±¤
      ensureCloudsIfNeeded();
      drawClouds(t);
      if(skin.effects && skin.effects.stars) drawStarField(t);
      drawPrism(t);
      drawPulse(t);
      if(skin.effects && skin.effects.snow){ ensureSnowIfNeeded(); drawSnow(t); }
      if(skin.effects && skin.effects.shards){ ensureShardsIfNeeded(); drawShards(t); }
      if(skin.effects && skin.effects.embers){ drawEmbers(t); }

      // é­”æ³•åœ–å½¢
      drawHexagram(t);
      drawScriptRing(t); // æ–°å¢ï¼šå¤–åœˆå’’æ–‡ï¼Œ24s CCWã€6s å‘¼å¸
      drawSparks(t);
      // å…”å…”ï¼å¥¶æ²¹é›²æœµå°ˆå±¬ LED ç‡ˆæ¢ï¼ˆ6px ç²‰ç™½â†’èœœæ¡ƒï¼Œ3.2s å‘¼å¸ï¼‹ç é»ï¼‰
      
(function drawLedStrip(){
  let ls = skin.effects && skin.effects.ledStrip; if(!ls){ if(window.__currentSkinKey==='w4'){ ls={ period:2400, hi:[255,236,210], lo:[230,210,180], segment:28, vignette:true }; } else { return; } }
  const period = (ls.period||3200);
  const phase = ((t % period) / period);
  const breathe = 0.65 + 0.35 * (0.5 + 0.5 * Math.sin(phase * Math.PI * 2));
  const thick = Math.max(2, Math.round(6*dpr));
  const seg = Math.max(10, (ls.segment||28) * dpr);
  let hi = ls.hi || [255,182,193];
  let lo = ls.lo || [255,244,234];
  if(ls.hitFlash && ledHitFlashUntil>performance.now()){ hi=[255,255,255]; lo=[255,255,255]; }
  ctx.save();
  ctx.globalCompositeOperation='screen';
  for(let x=0, i=0; x<W; x+=seg, i++){
    const g = ctx.createLinearGradient(0,0,0,thick);
    const isPink = (i % 2 === 0);
    const base = isPink ? hi : lo;
    const tip  = isPink ? lo : hi;
    g.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${0.42*breathe})`);
    g.addColorStop(1, `rgba(${tip[0]},${tip[1]},${tip[2]},0)`);
    ctx.fillStyle=g; ctx.fillRect(x,0,Math.min(seg,W-x),thick);
  }
  for(let y=0, i=0; y<H; y+=seg, i++){
    const g = ctx.createLinearGradient(0,0,thick,0);
    const isPink = (i % 2 === 0);
    const base = isPink ? hi : lo;
    const tip  = isPink ? lo : hi;
    g.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${0.42*breathe})`);
    g.addColorStop(1, `rgba(${tip[0]},${tip[1]},${tip[2]},0)`);
    ctx.fillStyle=g; ctx.fillRect(0,y,thick,Math.min(seg,H-y));
  }
  for(let y=0, i=0; y<H; y+=seg, i++){
    const g = ctx.createLinearGradient(W,0,W-thick,0);
    const isPink = (i % 2 === 0);
    const base = isPink ? hi : lo;
    const tip  = isPink ? lo : hi;
    g.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${0.42*breathe})`);
    g.addColorStop(1, `rgba(${tip[0]},${tip[1]},${tip[2]},0)`);
    ctx.fillStyle=g; ctx.fillRect(W-thick,y,thick,Math.min(seg,H-y));
  }
  ctx.fillStyle=`rgba(${lo[0]},${lo[1]},${lo[2]},${Math.min(0.85,0.50+0.38*breathe)})`;
  ctx.fillRect(0,0,W,1*dpr);
  const pearlStep = Math.max(14, 16) * dpr;
  const pearlA = 0.28 * breathe;
  for(let x=0, i=0; x<W; x+=pearlStep, i++){
    const base = (i%2===0) ? hi : lo;
    const r=1.2*dpr;
    const cx = x+pearlStep*0.5, cy = 0.5*thick;
    const gg=ctx.createRadialGradient(cx, cy, 0, cx, cy, r*4);
    gg.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${pearlA})`);
    gg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle=gg; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  }
  for(let y=0, i=0; y<H; y+=pearlStep, i++){
    const base = (i%2===0) ? hi : lo;
    const r=1.2*dpr;
    let cx = 0.5*thick, cy = y+pearlStep*0.5;
    let gg=ctx.createRadialGradient(cx, cy, 0, cx, cy, r*4);
    gg.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${pearlA})`);
    gg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle=gg; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
    cx = W-0.5*thick; cy = y+pearlStep*0.5;
    gg=ctx.createRadialGradient(cx, cy, 0, cx, cy, r*4);
    gg.addColorStop(0, `rgba(${base[0]},${base[1]},${base[2]},${pearlA})`);
    gg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle=gg; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
})();

if(shakeUntil>performance.now()) { ctx.restore(); }
      // LED é‚Šï¼ˆä¸Š/å·¦/å³ï¼‰
      let hiRGB=skin.hi, baseRGB=skin.base; if(skin.effects && skin.effects.rainbow){ hiRGB=hslToRgb((phase*360),85,65); baseRGB=hslToRgb((phase*360+200)%360,80,60); }
      const coreA=0.78 + 0.20*breathe, hiA=0.62*breathe;
      const gTop=ctx.createLinearGradient(0,0,0,edgThick); gTop.addColorStop(0,   rgba(hiRGB,  hiA)); gTop.addColorStop(0.55,rgba(baseRGB,coreA)); gTop.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=gTop; ctx.fillRect(0,0,W,edgThick);
      const spec=Math.max(1, Math.round(1*dpr)); ctx.fillStyle=rgba(hiRGB, Math.min(0.88, 0.55+0.40*breathe)); ctx.fillRect(0,0,W,spec);
      const gLeft=ctx.createLinearGradient(0,0,edgThick,0); gLeft.addColorStop(0,rgba(hiRGB,hiA)); gLeft.addColorStop(0.55,rgba(baseRGB,coreA)); gLeft.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=gLeft; ctx.fillRect(0,0,edgThick,H);
      const gRight=ctx.createLinearGradient(W,0,W-edgThick,0); gRight.addColorStop(0,rgba(hiRGB,hiA)); gRight.addColorStop(0.55,rgba(baseRGB,coreA)); gRight.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=gRight; ctx.fillRect(W-edgThick,0,edgThick,H);

      rafId=requestAnimationFrame(drawFrame);
    }

    function start(){ cancelAnimationFrame(rafId); rafId=requestAnimationFrame(drawFrame); }
    window.addEventListener('resize', ()=>{ resize();  }, {passive:true});
    if(document.fonts && document.fonts.ready){ document.fonts.ready.then(()=>{ resize();  }); } else { resize();  }

    window.__applySkinCanvas = function(params){
      const next = Object.assign({ base:[92,136,255], hi:[255,255,255], period:2000, effects:{}, bg:null }, params||{});
      skin = next;
      if(skin.effects && typeof skin.effects.wood==='string'){ if(woodKind!==skin.effects.wood){ buildWoodPattern(skin.effects.wood); } }
      else { woodPattern=null; woodKind=null; }
      if(skin.effects && skin.effects.stars){ starOpts = (typeof skin.effects.stars==='object')? skin.effects.stars : {}; ensureStarsIfNeeded(); } else { stars=null; starOpts={}; }
      ensureEmbersIfNeeded(); // å…¶é¤˜ ensure åœ¨ draw / resize ä¸­åŸ·è¡Œ
      ensureCloudsIfNeeded(); // FIX: åˆ‡æ› Skin æ™‚é‡å»ºå¥¶æ²¹é›²å±¤ï¼Œé¿å…åˆå§‹ç‚º null çœ‹ä¸åˆ°é›²æœµ
      ensureRuinsIfNeeded(); ensureSlicerIfNeeded(); if(skin.effects && skin.effects.diffuse){ diffusionStart = performance.now(); }
        // Assign global hooks for skin rendering and resizing after definitions become available
        window.__drawSkinFrame = drawFrame;
        window.__skinResize = resize;
    };
  })();

  /* ---------------- Skin ç®¡ç†ï¼ˆç«ç³»åƒ…ä¿ç•™æ˜Ÿç«æ—‹æ¸¦ï¼‰ ---------------- */
  (function(){
    const skinSel = document.getElementById('skinSel');
    const skinTitle = document.getElementById('skinTitle');
    const skinDesc = document.getElementById('skinDesc');
    const heartsEl = document.getElementById('hearts');
    const livesEl = document.getElementById('lives');

    
// (Removed early assignment; assignments moved to end of first IIFE)

const HELMET_SVG = '<span class="life-icon helmet" aria-hidden="true"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="knGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#F2F4F8"/><stop offset="1" stop-color="#B0C4DE"/></linearGradient></defs><path d="M6 10.2c0-3.8 3.1-6.9 6.9-6.9s6.9 3.1 6.9 6.9v6.3c0 .9-.5 1.7-1.3 2.1l-3.3 1.9c-1 .6-2.2 .6-3.2 0l-3.3-1.9c-.8-.4-1.3-1.2-1.3-2.1v-6.3z" fill="url(#knGrad)" stroke="#cfd8e6" stroke-width="1"/><path d="M7 10.6h10" stroke="#e7eef8" stroke-width="1" opacity=".9"/><rect x="8" y="11" width="8" height="2.2" rx="1.1" fill="#0D0D0F" opacity=".88"/><path d="M12 13.2v3.1" stroke="#0D0D0F" stroke-width="1.1" opacity=".88"/><path d="M8.4 9.8c.8-2.0 2.6-3.4 3.6-3.7 1 .3 2.8 1.7 3.6 3.7" stroke="#b9c9e2" stroke-width="1.1" stroke-linecap="round" opacity=".9"/><circle cx="9.5" cy="10.6" r=".35" fill="#e6eef8" stroke="#aebdd2" stroke-width=".2"/><circle cx="12" cy="10.6" r=".35" fill="#e6eef8" stroke="#aebdd2" stroke-width=".2"/><circle cx="14.5" cy="10.6" r=".35" fill="#e6eef8" stroke="#aebdd2" stroke-width=".2"/><path d="M6.8 12.2v3.8a1.8 1.8 0 0 0 1 1.6l1.8 1.0" stroke="#cbd6e6" stroke-width=".9" opacity=".8"/><path d="M17.2 12.2v3.8a1.8 1.8 0 0 1-1 1.6l-1.8 1.0" stroke="#cbd6e6" stroke-width=".9" opacity=".8"/></svg></span>';
const HAT_SVG = '<span class="life-icon hat" aria-hidden="true"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="hatGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#0E0C08"/><stop offset="1" stop-color="#2B2011"/></linearGradient><linearGradient id="pinGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#FFD27A"/><stop offset="1" stop-color="#B8852E"/></linearGradient></defs><path d="M4 16.8c0-1.2 6.2-3.4 8.0-3.4s8.0 2.2 8.0 3.4-6.2 2.6-8.0 2.6S4 18.0 4 16.8z" fill="#0E0C08" opacity=".65"/><path d="M12 4.2c-1.4 1.6-2.4 4.4-2.6 6.4-.1 .6-.6 1.0-1.2 1.1-1.6 .2-3.7 1.0-4.0 1.9 3.2-.5 6.6-.8 7.8-.8s4.6 .3 7.8 .8c-.4-.9-2.4-1.7-4.0-1.9-.6-.1-1.1-.5-1.2-1.1-.2-2.0-1.2-4.8-2.6-6.4z" fill="url(#hatGrad)" stroke="#B8852E" stroke-width=".8"/><path d="M13.6 7.8l2.1-1.0" stroke="url(#pinGrad)" stroke-width="1.2" stroke-linecap="round"/><circle cx="16.0" cy="6.9" r=".75" fill="url(#pinGrad)"/></svg></span>';
const RABBIT_SVG = '<span class="life-icon rabbit" aria-hidden="true" style="filter:drop-shadow(0 0 6px var(--heartGlow))"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="earGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#FFD9E6"/><stop offset="1" stop-color="#FFC0D6"/></linearGradient></defs><path d="M7.2 5.6c0-2.2 1.6-4.4 3.0-4.4s3.0 2.2 3.0 4.4c0 1.1-.2 2.0-.7 2.7-.5.7-1.1 1.0-2.3 1.0s-1.8-.3-2.3-1.0c-.5-.7-.7-1.6-.7-2.7z" fill="#FFF4EA" stroke="#EADBD0" stroke-width=".8"/><path d="M10.8 5.6c0-2.2 1.6-4.4 3.0-4.4s3.0 2.2 3.0 4.4c0 1.1-.2 2.0-.7 2.7-.5.7-1.1 1.0-2.3 1.0s-1.8-.3-2.3-1.0c-.5-.7-.7-1.6-.7-2.7z" fill="#FFF4EA" stroke="#EADBD0" stroke-width=".8"/><path d="M9.0 3.8c.7-.2 1.2.3 1.3 1.2l.1 1.8c0 .3-.2.6-.6.7-.3.1-.6-.1-.7-.4l-.5-1.7c-.2-.8 0-1.4.4-1.6z" fill="url(#earGrad)"/><path d="M14.0 3.8c-.7-.2-1.2.3-1.3 1.2l-.1 1.8c0 .3.2.6.6.7.3.1.6-.1.7-.4l.5-1.7c.2-.8 0-1.4-.4-1.6z" fill="url(#earGrad)"/><ellipse cx="12" cy="13.2" rx="6.2" ry="5.6" fill="#FFF4EA" stroke="#EADBD0" stroke-width=".8"/><circle cx="10.3" cy="12.5" r="1.0" fill="#333"/><circle cx="13.7" cy="12.5" r="1.0" fill="#333"/><path d="M12 13.6l-.9.6c.4.5 1.4.5 1.8 0z" fill="#FF9DB8"/><path d="M11.1 15.4c.6.3 1.8.3 2.4 0" stroke="#FF9DB8" stroke-width=".8" stroke-linecap="round"/></svg></span>';
const SKULL_SVG = '<span class="life-icon skull" aria-hidden="true"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="skullGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#e0e0e0"/><stop offset="1" stop-color="#9aa0a6"/></linearGradient></defs><g fill="url(#skullGrad)" stroke="#2f2f2f" stroke-width=".8" stroke-linejoin="round"><path d="M12 3.2c-4.4 0-7.6 3-7.6 7 0 2.7 1.4 4.8 3.6 6v2.2c0 .7.6 1.2 1.3 1.2h.7c.4 0 .7-.3.7-.7v-1.1c0-.4.3-.7.7-.7h1.2c.4 0 .7.3.7.7v1.1c0 .4.3.7.7.7h.7c.7 0 1.3-.5 1.3-1.2v-2.2c2.2-1.2 3.6-3.3 3.6-6 0-4-3.2-7-7.6-7z"/><circle cx="9.3" cy="10.4" r="2.1" fill="#0e0e0e"/><circle cx="14.7" cy="10.4" r="2.1" fill="#0e0e0e"/><path d="M11.2 12.8l1.6-1.1-.7-1 .9-.6" fill="none" stroke="#64696f" stroke-width=".9"/><rect x="8.4" y="16.6" width="7.2" height="2.8" rx="1.2"/><g fill="#0e0e0e"><rect x="9.2" y="17" width="1.1" height="1.8" rx=".2"/><rect x="11.1" y="17" width="1.1" height="1.8" rx=".2"/><rect x="13" y="17" width="1.1" height="1.8" rx=".2"/><rect x="14.9" y="17" width="1.1" height="1.8" rx=".2"/></g></g></svg></span>';
const EBONY_SVG = '<span class=\"life-icon wood-ebony\" aria-hidden=\"true\"><svg viewBox=\"0 0 24 24\" width=\"24\" height=\"24\" role=\"img\" aria-label=\"ebony trunk\"><defs><linearGradient id=\"eb_side\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\"><stop offset=\"0\" stop-color=\"#2b1e16\"/><stop offset=\"1\" stop-color=\"#120c08\"/></linearGradient><radialGradient id=\"eb_top\" cx=\"50%\" cy=\"45%\" r=\"60%\"><stop offset=\"0\" stop-color=\"#261a12\"/><stop offset=\"1\" stop-color=\"#110b07\"/></radialGradient><linearGradient id=\"eb_edge\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\"><stop offset=\"0\" stop-color=\"#caa464\"/><stop offset=\"1\" stop-color=\"#8f6a2f\"/></linearGradient></defs><g transform=\"rotate(-18 12 12) translate(0,1)\"><ellipse cx=\"12\" cy=\"9.2\" rx=\"7.6\" ry=\"4.2\" fill=\"url(#eb_top)\" stroke=\"url(#eb_edge)\" stroke-width=\"1\"/><rect x=\"4.4\" y=\"9.2\" width=\"15.2\" height=\"9.0\" fill=\"url(#eb_side)\"/><ellipse cx=\"12\" cy=\"18.2\" rx=\"7.6\" ry=\"4.2\" fill=\"url(#eb_side)\" /><g opacity=\".9\"><ellipse cx=\"12\" cy=\"9.2\" rx=\"6.1\" ry=\"3.4\" fill=\"none\" stroke=\"rgba(202,164,100,55)\" stroke-width=\".8\"/><ellipse cx=\"12\" cy=\"9.2\" rx=\"4.4\" ry=\"2.5\" fill=\"none\" stroke=\"rgba(202,164,100,35)\" stroke-width=\".7\"/><ellipse cx=\"12\" cy=\"9.2\" rx=\"2.5\" ry=\"1.4\" fill=\"none\" stroke=\"rgba(202,164,100,35)\" stroke-width=\".6\"/></g><ellipse cx=\"12\" cy=\"9.2\" rx=\"7.6\" ry=\"4.2\" fill=\"none\" stroke=\"rgba(255,255,255,08)\" stroke-width=\"1\"/></g><ellipse cx=\"12\" cy=\"19.9\" rx=\"8.0\" ry=\"2.8\" fill=\"rgba(0,0,0,25)\"/></svg></span>';
const OAK_SVG = '<span class="life-icon wood-oak" aria-hidden="true"><svg viewBox="0 0 24 24" width="24" height="24" role="img" aria-label="oak trunk"><defs><linearGradient id="ok_side" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#d9b786"/><stop offset="1" stop-color="#b08853"/></linearGradient><radialGradient id="ok_top" cx="50%" cy="45%" r="60%"><stop offset="0" stop-color="#e9cfaa"/><stop offset="1" stop-color="#c5a074"/></radialGradient><linearGradient id="ok_edge" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#9c7a4b"/><stop offset="1" stop-color="#6d4f2a"/></linearGradient></defs><g transform="rotate(-18 12 12) translate(0,1)"><ellipse cx="12" cy="9.2" rx="7.6" ry="4.2" fill="url(#ok_top)" stroke="url(#ok_edge)" stroke-width="1"/><rect x="4.4" y="9.2" width="15.2" height="6.6" fill="url(#ok_side)"/><ellipse cx="12" cy="15.8" rx="7.6" ry="4.2" fill="url(#ok_side)" /><g opacity=".9"><ellipse cx="12" cy="9.2" rx="6.1" ry="3.4" fill="none" stroke="rgba(120,85,40,.55)" stroke-width=".8"/><ellipse cx="12" cy="9.2" rx="4.4" ry="2.5" fill="none" stroke="rgba(120,85,40,.38)" stroke-width=".7"/><ellipse cx="12" cy="9.2" rx="2.5" ry="1.4" fill="none" stroke="rgba(120,85,40,.32)" stroke-width=".6"/></g><ellipse cx="12" cy="9.2" rx="7.6" ry="4.2" fill="none" stroke="rgba(255,255,255,.10)" stroke-width="1"/></g><ellipse cx="12" cy="17.5" rx="8.0" ry="2.8" fill="rgba(0,0,0,.18)"/></svg></span>';
const ICE_SVG = '<span class="life-icon ice-cube" aria-hidden="true"><svg viewBox="0 0 24 24" width="24" height="24" role="img" aria-label="ice cube"><defs><linearGradient id="iceg" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#d7eeff"/><stop offset="1" stop-color="#9ed1ff"/></linearGradient></defs><rect x="5.5" y="5.5" width="13" height="13" rx="2.5" ry="2.5" fill="url(#iceg)" stroke="#b6d9ff" stroke-width="1"/><path d="M8.2 9.1l7.0-1.3-1.1 7.0-7.1 1.3z" fill="rgba(255,255,255,.35)"/><path d="M8 8.5h8.5v7.0H8z" fill="none" stroke="rgba(255,255,255,.35)" stroke-width="0.6"/></svg></span>';
const STAR_SVG = '<span class="life-icon star" aria-hidden="true"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" role="img"><defs><linearGradient id="starGrad" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="#FFE49A"/><stop offset="1" stop-color="#B8852E"/></linearGradient><radialGradient id="starGlow" cx="50%" cy="50%" r="50%"><stop offset="0" stop-color="rgba(255,210,120,0.85)"/><stop offset="1" stop-color="rgba(255,210,120,0)"/></radialGradient></defs><circle cx="12" cy="12" r="7.2" fill="url(#starGlow)" opacity=".55"/><path d="M12 3.6l2.35 4.76 5.26 .77-3.8 3.70 .90 5.24-4.71-2.47-4.71 2.47 .90-5.24-3.8-3.70 5.26-.77L12 3.6z" fill="url(#starGrad)" stroke="#F3C96A" stroke-width=".8"/></svg></span>';
function updateHeartsIcons(mode){ const prev = parseInt(heartsEl.dataset.prevLives||'0',10); const lives = parseInt(livesEl.textContent,10) || 0; heartsEl.classList.toggle('compact', lives>=5); heartsEl.dataset.prevLives = String(lives);
      if(mode !== 'flame') heartsEl.classList.remove('flame');
      switch(mode){
        case 'star':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>STAR_SVG).join('');
          break;
        case 'hat':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>HAT_SVG).join('');
          break;
        case 'flame':
          heartsEl.classList.add('flame');
          heartsEl.innerHTML = 'ğŸ”¥'.repeat(Math.max(0,lives));
          break;
        case 'helmet':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>HELMET_SVG).join('');
          break;
        case 'ebony':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>EBONY_SVG).join('');
          break;
        case 'oak':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>OAK_SVG).join('');
          break;
        case 'ice':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>ICE_SVG).join('');
          break;
        case 'helmet':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>HELMET_SVG).join('');
          break;
        case 'rabbit':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>RABBIT_SVG).join('');
          break;
        case 'helmet':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>HELMET_SVG).join('');
          break;
        case 'ebony':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>EBONY_SVG).join('');
          break;
        case 'oak':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>OAK_SVG).join('');
          break;
        case 'ice':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>ICE_SVG).join('');
          break;
        case 'helmet':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>HELMET_SVG).join('');
          break;
                case 'ebony':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>EBONY_SVG).join('');
          break;
        case 'oak':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>OAK_SVG).join('');
          break;
        case 'ice':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>ICE_SVG).join('');
          break;
case 'skull':
          heartsEl.innerHTML = new Array(Math.max(0,lives)).fill(0).map(()=>SKULL_SVG).join('');
          if(lives>prev){ heartsEl.classList.add('revive'); setTimeout(()=>heartsEl.classList.remove('revive'), 900); }
          break;
        default:
          heartsEl.textContent = 'â¤ï¸'.repeat(Math.max(0,lives));
      }
    }
function applyClassic(){ document.body.dataset.skin = SKINS.classic.cssSkin; window.__applySkinCanvas(SKINS.classic.canvas); skinTitle.textContent=SKINS.classic.label; skinDesc.textContent=SKINS.classic.desc; updateHeartsIcons('heart'); }
function applySkinKey(key){
      const s=SKINS[key];
      document.body.dataset.skin=s.cssSkin||'ç¶“å…¸é¢¨æ ¼';
      window.__applySkinCanvas(s.canvas); window.__currentSkinKey=key;
      skinTitle.textContent=s.label; skinDesc.textContent=s.desc;
      // åˆ‡æ›ç”Ÿå‘½åœ–ç¤º
      if(key==='w2'){ updateHeartsIcons('ebony'); }
      else if(key==='w4'){ updateHeartsIcons('oak'); }
      else if(key==='i1'){ updateHeartsIcons('ice'); }
      else if(key==='f3'){ updateHeartsIcons('flame'); } else if(key==='k1'){ updateHeartsIcons('helmet'); } else if(key==='m1'){ updateHeartsIcons('star'); } else if(key==='b1'){ updateHeartsIcons('rabbit'); } else if(key==='d1'){ updateHeartsIcons('skull'); } else { updateHeartsIcons('heart'); }
    }
function populate(){
      const exists = Array.from(skinSel.options).map(o=>o.textContent.trim());
      if(!exists.includes(SKINS.classic.selectLabel)){
        const opt=document.createElement('option'); opt.textContent=SKINS.classic.selectLabel; skinSel.appendChild(opt);
      }
      ['s2','s3','s5','w2','w4','i1','b1','f3','k1','m1','d1'].forEach(k=>{ const opt=document.createElement('option'); opt.textContent=SKINS[k].selectLabel; skinSel.appendChild(opt); });
    }

// Hook: populate skin dropdown and default skin on boot
document.addEventListener('DOMContentLoaded', ()=>{
  try{
    populate();
    window.__skinResize && window.__skinResize();
    // default to classic
    applyClassic();
  }catch(e){ window.__lastError = e; if(location.search.includes('debug=1')) console.error('[Skin init]', e); }
}, { once: true });

// Override drawBGDecor to render per-skin canvas frame each frame
const __orig_drawBGDecor = typeof drawBGDecor==='function'? drawBGDecor : null;
function drawBGDecor(){
  // call skin renderer frame
  if(window.__drawSkinFrame){
    window.__drawSkinFrame(performance.now());
  }else{
    // fallback: original
    if(__orig_drawBGDecor) __orig_drawBGDecor();
  }
}
  // Bind retry button click if the element exists
  {
    const rb = document.getElementById('retryBtn');
    if (rb) rb.addEventListener('click', ()=>{
      gameover.classList.remove('show');
      gameOver = false;
      resetGame();
      startGameWithCountdown();
    });
  }
  const bgmBtn=document.getElementById('bgmBtn'), bgmVol=document.getElementById('bgmVol');
  const gameover=document.getElementById('gameover'), finalScore2=document.getElementById('finalScore2');
  const retryBtn=document.getElementById('retryBtn');
  const centerNote=document.getElementById('centerNote'),
        noteTitle=document.getElementById('noteTitle'),
        noteText=document.getElementById('noteText');

  /*
   * æ–° UI éŸ³æ•ˆèˆ‡ BGM æ§åˆ¶
   *
   * ç‚ºäº†æ²¿ç”¨æ—¢æœ‰çš„è²éŸ³é‚è¼¯ï¼Œæˆ‘å€‘ç”¨è¤‡é¸æ¡†æ§åˆ¶éš±è—çš„èˆŠæŒ‰éˆ• soundBtn / bgmBtnã€‚
   * ç”±æ–¼ soundsOn èˆ‡ bgmOn åœ¨ç¨å¾Œæ‰å®£å‘Šï¼ˆä½¿ç”¨ letï¼‰ï¼Œé€™æ®µåˆå§‹åŒ–é‚è¼¯æœƒåœ¨
   * ç‹€æ…‹å®£å‘Šä¹‹å¾Œé‡æ–°æ’å…¥ã€‚é€™è£¡åƒ…é ç•™èªªæ˜æ–‡å­—ï¼Œå¯¦éš›é‚è¼¯è¦‹å¾Œæ–¹çš„æ’å…¥å€å¡Šã€‚
   */


  // é—œé–‰è¦–çª—æŒ‰éˆ•ï¼ˆé—œé–‰å¾Œç«‹å³å€’æ•¸ã€ç¹¼çºŒéŠæˆ²ï¼‰
  const noteClose = document.getElementById('noteClose');
  function closeNoteAndResume(){
    hideCenter();
    if(running){ startCountdown(); } else { startGameWithCountdown(); }
  }
  noteClose.addEventListener('click', (e)=>{ e.stopPropagation(); closeNoteAndResume(); });
  // ç©å®¶é»æ“Šæç¤ºè¦–çª—ä»»æ„è™•ä¹Ÿå¯é–‹å§‹ï¼ç¹¼çºŒéŠæˆ²
  if(centerNote){ centerNote.addEventListener('click', closeNoteAndResume); }


  // === DPR ç¸®æ”¾ ===
  function resizeCanvasDPR(){ const dpr=Math.min(window.devicePixelRatio||1,2); const cssW=canvas.clientWidth; const cssH=Math.round(cssW*(700/1100)); canvas.style.height=cssH+'px'; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); scaleX=canvas.width/1100; scaleY=canvas.height/700; }
  let scaleX=1, scaleY=1; window.addEventListener('resize', resizeCanvasDPR, {passive:true}); resizeCanvasDPR();

  // === ç‹€æ…‹ ===
  let running=false, paused=true, level=1, score=0, lives=3, soundsOn=false;
  let gameOver=false;
  let stats={catches:0,buffs:0,debuffs:0,eliteKills:0,bossKills:0,lifeStart:0,fastestDeath:Infinity,longestLife:0,livesUsed:0};
  let ledStyle = (localStorage.getItem('led_style')||'classic');
  function renderStatsHtml(){
    const fd = (stats.fastestDeath===Infinity)? '-' : stats.fastestDeath.toFixed(2);
    const ld = (stats.longestLife===0)? '-' : stats.longestLife.toFixed(2);
    return `<div class="grid">
      <div>æ¶ˆè€—ç”Ÿå‘½ï¼š<strong>${stats.livesUsed}</strong></div>
      <div>æ¥çƒæ¬¡æ•¸ï¼š<strong>${stats.catches}</strong></div>
      <div>å¢ç›Šæ¬¡æ•¸ï¼š<strong>${stats.buffs}</strong></div>
      <div>æ¸›ç›Šæ¬¡æ•¸ï¼š<strong>${stats.debuffs}</strong></div>
      <div>æ®ºèè‹±æ•¸ï¼š<strong>${stats.eliteKills}</strong></div>
      <div>æ®ºBossæ•¸ï¼š<strong>${stats.bossKills}</strong></div>
      <div>æœ€å¿«æ­»äº¡ï¼š<strong>${fd}</strong> s</div>
      <div>æœ€ä¹…å­˜æ´»ï¼š<strong>${ld}</strong> s</div>
    </div>`;
  }

  let bgTime=0; let screenShake=0;
  let countdownTimer=null, countdownShow=0, resumePending=false;
  // å½±åƒé¸æ“‡ï¼š1~10 éš¨æ©Ÿ bg/cgï¼Œ11~20 ç”¨å°æ‡‰æœªç”¨è€…
  let imageChoice = new Array(10).fill(-1); // 0=bg,1=cg; -1: æœªæ±º
  // BGM
  let audioCtx=null, bgmGain=null, bgmOn=false, bgmStarted=false;
  let bgmNodes=[]; // ä¾¿æ–¼åœæ’­

  // === åˆå§‹åŒ–æ–° UI çš„è²éŸ³/BGM æ§åˆ¶ ===
  // é€£çµè¤‡é¸æ¡†è‡³åŸæœ‰çš„ soundBtn/bgmBtn æŒ‰éˆ•ï¼Œä¸¦åŒæ­¥æœ¬åœ°å„²å­˜å€¼
  if (sfxOnEl) {
    const stored = localStorage.getItem('sfx_on');
    // è‹¥æœ¬åœ°æœ‰è¨­å®šå‰‡ä½¿ç”¨ï¼Œå¦å‰‡æ²¿ç”¨é è¨­çš„ soundsOn
    soundsOn = ((stored !== null && stored !== undefined) ? stored : (soundsOn ? '1' : '0')) === '1';
    sfxOnEl.checked = soundsOn;
    // åˆ‡æ›è¤‡é¸æ¡†å³å‘¼å«èˆŠé‚è¼¯çš„æŒ‰éˆ• clickï¼Œä¸¦ä¾æ“šæ›´æ–°å¾Œçš„è®Šæ•¸åŒæ­¥è¤‡é¸æ¡†ç‹€æ…‹
    sfxOnEl.addEventListener('change', () => {
      soundBtn.click();
      sfxOnEl.checked = soundsOn;
    });
  }
  if (bgmOnEl) {
    const stored = localStorage.getItem('bgm_on');
    bgmOn = ((stored !== null && stored !== undefined) ? stored : (bgmOn ? '1' : '0')) === '1';
    bgmOnEl.checked = bgmOn;
    bgmOnEl.addEventListener('change', () => {
      bgmBtn.click();
      bgmOnEl.checked = bgmOn;
    });
  }
  // åˆå§‹åŒ– BGM éŸ³é‡æ»‘æ¡¿
  if (localStorage.getItem('bgm_vol')) {
    const vol = parseFloat(localStorage.getItem('bgm_vol'));
    if (!isNaN(vol)) {
      bgmVol.value = String(vol);
      if (bgmGain) bgmGain.gain.value = vol;
    }
  }

  // ç²’å­ / ç‰¹æ•ˆå®¹å™¨
  const particles=[]; // {x,y,vx,vy,life,size,color}
  const plasmas=[];   // {x,y,vx,vy,until,radius}
  const holyFlashes=[]; // {x,y,until}
  let phoenixAnim=null; // {x, tEnd}
  const fireBursts=[];  // ç«ç„°ç‰‡æ®µ {x,y,life}

  // æ–°å¢å®¹å™¨ï¼šé£›å½ˆã€é»‘æ´ç‰¹æ•ˆã€é›·å°„å…‰æŸ
  const missiles=[]; // {x,y,vx,vy,targetId,lifeUntil,trail:[]}
  const blackHoles=[]; // {x,y,until}
  const laserBeams=[]; // {x1,y1,x2,y2,until}
  const laserImpacts=[]; // {x,y,t0,tEnd}
  const lockBoxes=[]; // {x,y,w,h,until,kind}

  // === Boss æŠ•å°„ç‰© ===
  const hostileBeams=[]; // ç·šæ€§å…‰æŸå½ˆ {x,y,vx,vy,color,hit,onHit}
  const hostileArcs=[];  // å¼§å½¢åŠæ°£ {x,y,vx,vy,phase,amp,color,onHit}
  const hostileColumns=[]; // ç›´ä¸‹çŸ³åŒ–å…‰æŸ {x,w,tStart,tEnd,color,applied}
  const hazardClouds=[]; // çƒé›² {x,y,tEnd,spawned}

  function bossCenter(){ for(const b of bricks){ if(b.boss) return {b, x:b.x+b.w/2, y:b.y+b.h/2}; } return null; }

  function spawnLionBeamFrom(x,y){ const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2; const ang=Math.atan2(ty-y, tx-x); const speed=6.0; hostileBeams.push({x:x, y:y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); }}); }
  function spawnLionBeam(){
    const bc=bossCenter(); if(!bc) return;
    const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
    const ang=Math.atan2(ty-bc.y, tx-bc.x);
    const speed=6.0;
    hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); }});
  }
  function spawnKnightArc(){
    const bc=bossCenter(); if(!bc) return;
    const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
    const ang=Math.atan2(ty-bc.y, tx-bc.x);
    const speed=3.8;
    hostileArcs.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, phase:0, amp:32, color:'silver', onHit:()=>{ lives=Math.max(0, lives-1); updateHUD(); }});
  }
  function spawnCyclopsColumn(){
    const bc=bossCenter(); if(!bc) return;
    // é¢¨upï¼šåœ¨ boss ä¸Šæ–¹ç™¼å…‰ 2 ç§’
    cyclopsChargeUntil = performance.now() + 2000;
    setTimeout(()=>{
      hostileColumns.push({x:bc.x, w:150, tStart:performance.now(), tEnd:performance.now()+1000, color:'#eedc9a', applied:false});
    },2000);
  }
  function spawnDemonBeam(){
    const bc=bossCenter(); if(!bc) return;
    const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
    const ang=Math.atan2(ty-bc.y, tx-bc.x);
    const speed=7.2;
    hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'#ff3355', hit:false, onHit:()=>{ lives=Math.max(0, lives-1); updateHUD(); }});
  }
  function spawnDemonClouds(){
    const picks = Array.from({length:5}, ()=> 40 + Math.random()*(1100-80));
    const y = layout().top - 10;
    const tEnd = performance.now() + 1000;
    for(const x of picks){ hazardClouds.push({x,y,tEnd,spawned:false}); }
  }
  let nextBossAtkA=0, nextBossAtkB=0, cyclopsChargeUntil=0;

  function updateBossAbilities(){
    const bossLv = (level%5===0)? level : 0;
    if(!bossLv) return;
    const now=performance.now();
    if(bossLv===5){ if(now>=nextBossAtkA){ spawnLionBeam(); nextBossAtkA = now + 10000; } }
    else if(bossLv===10){ if(now>=nextBossAtkA){ spawnKnightArc(); nextBossAtkA = now + 15000; } }
    else if(bossLv===15){ if(now>=nextBossAtkA){ spawnCyclopsColumn(); nextBossAtkA = now + 20000; } }
    else if(bossLv===20){ if(now>=nextBossAtkA){ spawnDemonBeam(); nextBossAtkA = now + 10000; } if(now>=nextBossAtkB){ spawnDemonClouds(); nextBossAtkB = now + 30000; } }
  }

  function drawAndStepBossProjectiles(){
    const pr=paddleRect();
    // é‡‘/ç´…é›·å°„
    for(let i=hostileBeams.length-1;i>=0;i--){
      const b = hostileBeams[i];
      b.x += b.vx; b.y += b.vy;
      // render
      const x1 = (b.x - b.vx*2)*scaleX, y1=(b.y - b.vy*2)*scaleY;
      const x2 = b.x*scaleX, y2=b.y*scaleY;
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const col = b.color==='gold' ? 'rgba(255,220,120,' : (b.color+' ,');
      ctx.strokeStyle = (b.color==='gold') ? 'rgba(255,220,120,0.8)' : 'rgba(255,80,120,0.8)';
      ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
      // hit check
      if(!b.hit && x2>=pr.x*scaleX && x2<= (pr.x+pr.w)*scaleX && y2>=pr.y*scaleY && y2<= (pr.y+pr.h)*scaleY){
        b.hit = true;
        // safely call onHit callback if defined
        if (b.onHit) b.onHit(pr);
        spawnParticles(b.x, b.y, '#ffd', 12, 1.6, 2.2, 2.5);
      }
      // out of bounds
      if(b.x<0||b.x>1100||b.y<0||b.y>700){ hostileBeams.splice(i,1); }
    }
    // å¼§å½¢åŠæ°£
    for(let i=hostileArcs.length-1;i>=0;i--){
      const a = hostileArcs[i];
      a.phase += 0.15;
      a.x += a.vx + Math.sin(a.phase)*0.9;
      a.y += a.vy + Math.cos(a.phase)*0.4;
      // render
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='rgba(220,220,255,0.9)'; ctx.lineWidth=3;
      ctx.beginPath(); 
      ctx.arc(a.x*scaleX, a.y*scaleY, 22*((scaleX+scaleY)/2), Math.PI*0.2, Math.PI*1.2);
      ctx.stroke();
      // ç²’å­
      for(let k=0;k<3;k++){ particles.push({x:a.x, y:a.y, vx:(Math.random()-0.5)*0.8, vy:(Math.random()-0.5)*0.8, life:220, size:1.6, color:'rgba(220,220,255,0.7)'}); }
      ctx.restore();
      // hit
      if(a.x>=pr.x && a.x<=pr.x+pr.w && a.y>=pr.y && a.y<=pr.y+pr.h){
        // safely call onHit callback if defined
        if (a.onHit) a.onHit();
        hostileArcs.splice(i, 1);
      }
      if(a.x<0||a.x>1100||a.y>700||a.y<0){ hostileArcs.splice(i,1); }
    }
    // çŸ³åŒ–æŸ±
    for(let i=hostileColumns.length-1;i>=0;i--){
      const c = hostileColumns[i];
      const now=performance.now();
      if(now>c.tEnd){ hostileColumns.splice(i,1); continue; }
      const x = (c.x - c.w/2)*scaleX, y = (layout().top)*scaleY;
      const w = c.w*scaleX, h = (700 - layout().top)*scaleY;
      const alpha = 0.5 + 0.5*Math.sin(now/80);
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const grd = ctx.createLinearGradient(c.x*scaleX, layout().top*scaleY, c.x*scaleX, 700*scaleY);
      grd.addColorStop(0, 'rgba(245,228,150,0.85)'); grd.addColorStop(1, 'rgba(240,210,120,0.35)');
      ctx.fillStyle = grd; ctx.fillRect(x, y, w, h);
      ctx.restore();
      // å‘½ä¸­å¹³å°ï¼šåƒµç›´3ç§’
      const pr = paddleRect();
      if(!c.applied){
        const inter = !( pr.x+pr.w < (c.x - c.w/2) || pr.x > (c.x + c.w/2) );
        if(inter){ paddleStunUntil = Math.max(paddleStunUntil, performance.now()+3000); c.applied=true; }
      }
    }
    // çƒé›²
    for(let i=hazardClouds.length-1;i>=0;i--){
      const cl = hazardClouds[i];
      const now=performance.now();
      // draw cloud
      ctx.save();
      const x = cl.x*scaleX, y=cl.y*scaleY;
      ctx.globalAlpha = 0.9 * Math.max(0, (cl.tEnd - now)/1000);
      ctx.fillStyle='rgba(60,60,80,0.9)';
      ctx.beginPath(); ctx.arc(x-20,y,14,0,Math.PI*2); ctx.arc(x,y-6,18,0,Math.PI*2); ctx.arc(x+18,y,16,0,Math.PI*2); ctx.fill();
      ctx.restore();
      if(now>=cl.tEnd && !cl.spawned){
        // æ‰è½æ¸›ç›Šé“å…·
        const debuffs = ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type==='debuff');
        const type = debuffs[Math.floor(Math.random()*debuffs.length)] || 'FAST';
        powerups.push({x:cl.x-12, y:cl.y, w:GAME_CONFIG.powerCapsule.width, h:GAME_CONFIG.powerCapsule.height, vy:GAME_CONFIG.powerCapsule.fallVy, type, isDebuff:true, phase:Math.random()*Math.PI*2});
        cl.spawned=true;
      }
      if(now > cl.tEnd + 2000){ hazardClouds.splice(i,1); }
    }
  }

// å¤©åœ°ç¿»è½‰ç‹€æ…‹
let orientLeft=false; // true æ™‚æ”¹ç‚ºå·¦å´æ“‹æ¿æ¨¡å¼
// ä»¥ä¸‹ç‚ºç¿»è½‰ç›¸é—œæ§åˆ¶è®Šé‡
// flipPending: true è¡¨ç¤ºå·²ç²å¾—ç¿»è½‰é“å…·ä½†å°šæœªçœŸæ­£é–‹å§‹ç¿»è½‰
let flipPending = false;
// flipScheduledAt: ç¿»è½‰å°‡æ–¼ä½•æ™‚çœŸæ­£é–‹å§‹ï¼ˆæ¯«ç§’æ™‚é–“æˆ³ï¼‰
let flipScheduledAt = 0;
// ç¿»è½‰å‰æç¤ºçµæŸæ™‚é–“ï¼›åœ¨æ­¤æ™‚é–“ä¹‹å‰ç•«é¢ä¸­å¤®æœƒé¡¯ç¤ºç¿»è½‰æç¤ºç¬¦è™Ÿ
let flipStartIndicatorUntil = 0;
// ç¿»è½‰çµæŸå‰æç¤ºé–‹å§‹èˆ‡çµæŸæ™‚é–“ï¼Œæ–¼çµæŸå‰2ç§’é¡¯ç¤º
let flipEndIndicatorFrom = 0;
let flipEndIndicatorUntil = 0;
// æš«åœé–‹å§‹æ™‚é–“ï¼Œç”¨æ–¼åœ¨æ¢å¾©éŠæˆ²æ™‚è£œå„Ÿè¨ˆæ™‚å™¨
let pauseStart = null;
// æœ€è¿‘ä¸€æ¬¡ç²å¾—å¢ç›Šï¼ˆæˆ–ç¨€æœ‰/ç‰¹æ®Šå¢ç›Šï¼‰çš„æ™‚é–“ï¼Œç”¨æ–¼10ç§’æœªç²å¾—å¢ç›Šæ™‚è‡ªå‹•æ‰è½
let lastBuffObtainedAt = performance.now();

// å°‡çƒè‡ªå‹•æœå‘æ“‹æ¿ä¸­å¿ƒï¼Œä»¥å…ç¿»è½‰ç¬é–“æ¥ä¸åˆ°çƒ
function aimBallsToPaddle(){
  const pr = paddleRect();
  // æ“‹æ¿ä¸­å¿ƒåº§æ¨™
  const targetX = pr.x + pr.w/2;
  const targetY = pr.y + pr.h/2;
  for(const b of balls){
    // æ ¹æ“šç›®å‰çƒé€Ÿèª¿æ•´æ–°é€Ÿåº¦æ–¹å‘
    const speed = Math.max(4, Math.hypot(b.vx||0, b.vy||0));
    const ang = Math.atan2(targetY - b.y, targetX - b.x);
    b.vx = Math.cos(ang) * speed;
    b.vy = Math.sin(ang) * speed;
    // è§£é™¤é»ä½ç‹€æ…‹ä»¥ä¿è­‰èƒ½ç§»å‹•
    if(b.stuck){ b.stuck=false; }
  }
}

let paddleStunUntil=0;


  function spawnParticles(x,y,color,count=10,spread=1.6,speed=3,size=3){
    for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const v=speed*(.4+Math.random()); particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:400+Math.random()*300,size:size*(.6+Math.random()*0.8),color}); }
  }

  // === å·¥å…· ===
  function getDiff(){ return GAME_CONFIG.difficulty[difficultySel.value]; }
  function brickColor(i){ return [getVar('--brick1'),getVar('--brick2'),getVar('--brick3'),getVar('--brick4')][i%4]; }
  function getVar(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }
  function clampHP(h){ return Math.max(1, Math.min(4, (h|0))); }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo((x+r)*scaleX,y*scaleY); ctx.arcTo((x+w)*scaleX,y*scaleY,(x+w)*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo((x+w)*scaleX,(y+h)*scaleY,x*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo(x*scaleX,(y+h)*scaleY,x*scaleX,y*scaleY,r*scaleX); ctx.arcTo(x*scaleX,y*scaleY,(x+w)*scaleX,y*scaleY,r*scaleX); ctx.closePath(); }

  // === çµ±ä¸€é–å®šæ¡†ï¼ˆé¡¯ç¤º 1 ç§’ï¼‰ ===
  function pushLockBox(x,y,w,h,kind='target'){ lockBoxes.push({x,y,w,h,until:performance.now()+1000,kind}); }
  function drawLockBoxes(){
    const now=performance.now();
    for(let i=lockBoxes.length-1;i>=0;i--){
      const b=lockBoxes[i];
      if(now>b.until){ lockBoxes.splice(i,1); continue; }
      const t = 1 - Math.max(0, (b.until-now)/1000);
      const pulse = 0.7 + 0.3*Math.sin(now/100);
      let col = b.kind==='paddle' ? 'rgba(120,220,255,'+(0.6*pulse)+')' : 'rgba(255,220,140,'+(0.6*pulse)+')';
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle = col;
      ctx.lineWidth = 2 + 2*pulse;
      drawRoundedRect(b.x, b.y, b.w, b.h, 10);
      ctx.stroke();
      ctx.restore();
    }
  }


  
  function drawBossEmblem(b){
    const cx = (b.x + b.w/2)*scaleX, cy = (b.y + b.h/2)*scaleY;
    const t = performance.now()/600;
    // è£ç”²å±¤
    ctx.save();
    const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
    g.addColorStop(0,'#5f0d2a'); g.addColorStop(1,'#130812');
    ctx.fillStyle = g; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.fill();
    // å¤–æ¡†å‘¼å¸
    const glow = 0.5 + 0.5*Math.sin(t*2);
    ctx.strokeStyle = 'rgba(255,90,120,'+(0.6*glow)+')'; ctx.lineWidth = 3 + 2*glow;
    drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke();
    // Emblem
    ctx.translate(cx, cy);
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,230,230,0.9)';
    const idx = ['ç…','é¨','ç›®','é­”'].indexOf(b.face);
    if(idx===0){
      // ç…ï¼šé¬ƒæ¯›åœ“ç’° + ç‰™
      ctx.beginPath(); ctx.arc(0,0, Math.min(b.w,b.h)*0.22*scaleX, 0, Math.PI*2); ctx.stroke();
      for(let i=0;i<6;i++){ const a = i*Math.PI/3; ctx.beginPath(); ctx.moveTo(Math.cos(a)*18, Math.sin(a)*18); ctx.lineTo(Math.cos(a)*30, Math.sin(a)*30); ctx.stroke(); }
      ctx.beginPath(); ctx.moveTo(-14,8); ctx.lineTo(-6,14); ctx.moveTo(14,8); ctx.lineTo(6,14); ctx.stroke();
    }else if(idx===1){
      // é¨å£«ï¼šé ­ç›” + ç¾½é£¾
      ctx.beginPath(); ctx.arc(0,0,22,Math.PI*0.15, Math.PI*0.85); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-14,0); ctx.lineTo(14,0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-10,-10); ctx.lineTo(0,-22); ctx.lineTo(10,-10); ctx.stroke();
    }else if(idx===2){
      // ç¨çœ¼ï¼šå·¨çœ¼ + çœ¼ç¼
      ctx.beginPath(); ctx.ellipse(0,0,26,18,0,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,0); ctx.lineTo(26,0); ctx.stroke();
    }else{
      // é­”ç‹ï¼šäº”èŠ’æ˜Ÿ + è§’
      ctx.beginPath();
      for(let i=0;i<5;i++){ const a = -Math.PI/2 + i*2*Math.PI/5; const x = Math.cos(a)*22, y=Math.sin(a)*22;
        const a2 = -Math.PI/2 + ((i*2+2)%10)*Math.PI/5; const x2=Math.cos(a2)*9, y2=Math.sin(a2)*9;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); ctx.lineTo(x2,y2);
      } ctx.closePath(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,-18); ctx.lineTo(-10,-30); ctx.moveTo(26,-18); ctx.lineTo(10,-30); ctx.stroke();
    }
    ctx.restore();
  }

  // === Buff/De-buff é¡¯ç¤º ===
  function badgeIcon(k){
    // avoid optional chaining; return badge if defined
    const pwr = GAME_CONFIG.powers[k];
    return (pwr && pwr.badge) || 'â—';
  }
  function updateBuffBadges(){ activeBuffsEl.innerHTML=''; const now=performance.now();
    // LONG å †ç–Š
    const longAct=buffs.LONG.stacks.filter(t=>t>now); if(longAct.length){ const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon('LONG')} LONGÃ—${longAct.length} ${Math.max(0,Math.max(...longAct)-now|0)}ms`; activeBuffsEl.appendChild(s); }
    // å…¶å®ƒ
    for(const key of Object.keys(GAME_CONFIG.powers)){
      if (key === 'LONG') continue;
      const b = buffs[key];
      // skip if buff not defined or inactive
      if (!b || !b.active) continue;
      const left = (b.until && b.until > now) ? (((b.until - now) / 1000).toFixed(1) + 's') : '';
      const s = document.createElement('span');
      s.className = 'badge';
      s.textContent = `${badgeIcon(key)} ${key}${left ? ' ' + left : ''}`;
      activeBuffsEl.appendChild(s);
    }
  }

  // === Buff ç‹€æ…‹ ===
  const buffs={WIDE:{active:false,until:0},STICKY:{active:false,until:0},MULTI:{active:false,until:0},SLOW:{active:false,until:0},PIERCE:{active:false,until:0},SHIELD:{active:false,until:0},RAMPAGE:{active:false,until:0},FAST:{active:false,until:0},WAVY:{active:false,until:0,start:0},LONG:{active:false,until:0,stacks:[]},PLASMA:{active:false,until:0},FREEZE:{active:false,until:0},HOLY:{active:false,until:0},TRACK:{active:false,until:0},MISSILE:{active:false,until:0},HELL:{active:false,until:0},MEGA:{active:false,until:0,applied:false},CHAIN:{active:false,until:0},NARROW:{active:false,until:0},HOLE:{active:false,until:0},FLIP:{active:false,until:0},GODSPEED:{active:false,until:0},LASER:{active:false,until:0,lastShot:0}};

  // === æ“‹æ¿ & çƒ ===
  let diff=getDiff(); const paddle={w:diff.paddleBaseW,h:18,x:1100/2-diff.paddleBaseW/2,y:700-50,speed:12};
  let balls=[]; function makeBall(stuck=false,x=null){ return {x:(x!==null && x!==undefined)?x:(1100/2),y:700/2,r:10,vx:5,vy:-5,speedCap:GAME_CONFIG.caps.ballSpeedMax,piercing:false,stuck:stuck,offsetX:0,rampageUntil:0,trail:[],freeze:{state:'idle',t0:0,until:0,oldVX:0,oldVY:0,delay:0,stop:0}}; }

  // === è²éŸ³èˆ‡BGM ===

  // === BGM ä¸»é¡Œä¾é—œå¡æ®µè½ ===
  function bgmThemeForLevel(lv){
    if(lv<=5) return 'whimsy';       // è¼•å¿«å¥‡å¦™
    if(lv<=10) return 'knight';      // é¨å£«æˆ°é¬¥
    if(lv<=15) return 'colossus';    // å·¨äººå¨å£“
    return 'demon';                  // é­”ç‹æ±ºæˆ°
  }
  let currentBGMTheme = null;
  function startBGMTheme(theme){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || !bgmOn) return;
    stopBGM();
    bgmStarted=true;
    currentBGMTheme = theme;
    const now=audioCtx.currentTime;
    function tone(freq, type, start, dur, gain=0.045){
      const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value=0; o.connect(g); g.connect(bgmGain);
      o.start(now+start); g.gain.setTargetAtTime(gain, now+start, 0.015);
      g.gain.setTargetAtTime(0.0001, now+start+dur-0.03, 0.02);
      o.stop(now+start+dur+0.1); bgmNodes.push(o,g);
    }
    function scheduleLoop(){
      if(!bgmOn || !bgmStarted) return;
      const base=audioCtx.currentTime;
      bgmNodes=[];
      if(theme==='whimsy'){
        const tempo=96/60;
        const chords=[[261.63,329.63,392.00],[293.66,349.23,440.00],[329.63,392.00,493.88],[293.66,392.00,523.25]];
        for(let i=0;i<4;i++){ for(const f of chords[i]) tone(f,'triangle', i*2/tempo, 1.8/tempo, 0.035); }
        const mel=[659.25,698.46,783.99,880.00,783.99,698.46,659.25,587.33];
        mel.forEach((f,idx)=> tone(f,'sine', idx*0.4/tempo, 0.28/tempo, 0.045));
        setTimeout(scheduleLoop, 3200);
      }else if(theme==='knight'){
        const tempo=128/60;
        const riff=[196.00,246.94,293.66,246.94,196.00,220.00,246.94,220.00];
        riff.forEach((f,idx)=> tone(f,'sawtooth', idx*0.25/tempo, 0.22/tempo, 0.055));
        const stab=[392.00,392.00,349.23,440.00];
        stab.forEach((f,idx)=> tone(f,'square', 1.2 + idx*0.5/tempo, 0.3/tempo, 0.065));
        setTimeout(scheduleLoop, 3000);
      }else if(theme==='colossus'){
        const tempo=72/60;
        const bass=[98.00,87.31,82.41,73.42];
        bass.forEach((f,idx)=> tone(f,'sine', idx*1.5/tempo, 1.2/tempo, 0.06));
        const hit=[196.00,174.61,196.00];
        hit.forEach((f,idx)=> tone(f,'square', 0.9 + idx*0.7/tempo, 0.2/tempo, 0.05));
        setTimeout(scheduleLoop, 4200);
      }else{ // demon
        const tempo=140/60;
        const ost=[293.66,277.18,261.63,246.94,233.08,246.94,261.63,277.18];
        ost.forEach((f,idx)=> tone(f,'sawtooth', idx*0.22/tempo, 0.2/tempo, 0.04));
        const stab=[587.33,554.37,523.25,493.88];
        stab.forEach((f,idx)=> tone(f,'square', 1.3 + idx*0.4/tempo, 0.22/tempo, 0.05));
        setTimeout(scheduleLoop, 2800);
      }
    }
    scheduleLoop();
  }
  function applyBGMThemeForLevel(){
    const theme = bgmThemeForLevel(level);
    if(theme!==currentBGMTheme){ startBGMTheme(theme); }
  }

  function ensureAudio(){ if(!audioCtx){ const AC=(window.AudioContext||window.webkitAudioContext); if(AC){ audioCtx=new AC(); } } if(audioCtx && !bgmGain){ bgmGain=audioCtx.createGain(); bgmGain.gain.value=parseFloat(localStorage.getItem('bgm_vol')||'0.7'); bgmGain.connect(audioCtx.destination); } }
  function beep(freq=600,dur=0.05,vol=0.06){ if(!soundsOn||!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.stop(); }, Math.max(10, dur*1000)); }

  function startBGM(){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || bgmStarted) return;
    // safely resume AudioContext if supported
    if (audioCtx && typeof audioCtx.resume === 'function') audioCtx.resume();
    bgmStarted = true;
    applyBGMThemeForLevel();
  }
  function stopBGM(){
    bgmStarted = false;
    bgmNodes.forEach(n=>{
      try{
        if (n && typeof n.disconnect === 'function') n.disconnect();
      }catch{}
    });
    bgmNodes.length = 0;
  }

  // === ç£šå¡Šèˆ‡æ­ç¤º ===
  let bricks=[]; let brickW=0, brickH=GAME_CONFIG.bricks.brickHeight; let revealRects=[];
  function layout(){ return {rows:getDiff().rowsBase+Math.floor((level-1)%3), cols:GAME_CONFIG.bricks.cols, pad:GAME_CONFIG.bricks.padding, top:GAME_CONFIG.bricks.topOffset, h:GAME_CONFIG.bricks.brickHeight}; }

  // å–å¾—æœ¬é—œé¡¯ç¤ºå½±åƒï¼ˆ1~10éš¨æ©ŸBG/CGï¼›11~20ç”¨å¦ä¸€å¼µï¼‰
  function getLevelImage(levelNum){
    const idx=((levelNum-1)%10);
    if(levelNum<=10){
      if(imageChoice[idx]<0){ imageChoice[idx]= Math.random()<0.5 ? 0:1; }
      return imageChoice[idx]===0? IMG_MAP[idx].bg : IMG_MAP[idx].cg;
    }else{
      if(imageChoice[idx]<0){ imageChoice[idx]=0; } // ä¿åº•
      return imageChoice[idx]===0? IMG_MAP[idx].cg : IMG_MAP[idx].bg;
    }
  }

  // ç‰¹æ®Šç£šæ¨¡æ¿
  function addBrick(list, x,y,w,h, opts={}){
    list.push(Object.assign({x,y,w,h,hp:opts.unbreakable?Infinity:(opts.hp||1), colorIdx:0, explosive:false, unbreakable:false, strong:false, moving:false, vx:0, vy:0, boss:false, face:''}, opts));
  }

  
  function postAdjustAndDensify(L){
    // å°‡ä¸€èˆ¬ç£šè¡€é‡å¹³æ»‘ä¸Šé™ç‚º 4ï¼Œä¸¦è£œç£šè‡³ >= 2/3 é¢ç©
    const rows=L.rows, cols=L.cols, pad=L.pad;
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // ä½”ç”¨ç¶²æ ¼
    const occ = Array.from({length:rows}, ()=> Array(cols).fill(false));
    function markRect(x,y,w,h){
      const cellW = brickW, cellH = brickH;
      const c0 = Math.max(0, Math.min(cols-1, Math.round((x - L.pad) / (cellW + L.pad)) ));
      const r0 = Math.max(0, Math.min(rows-1, Math.round((y - L.top) / (cellH + L.pad)) ));
      const cellsX = Math.max(1, Math.round((w + L.pad) / (cellW + L.pad)));
      const cellsY = Math.max(1, Math.round((h + L.pad) / (cellH + L.pad)));
      for(let rr=0; rr<cellsY; rr++){
        for(let cc=0; cc<cellsX; cc++){
          const c = Math.min(cols-1, c0 + cc);
          const r = Math.min(rows-1, r0 + rr);
          occ[r][c] = true;
        }
      }
    }
    // å…ˆå¤¾è¡€é‡ + æ¨™è¨˜æ—¢æœ‰ä½”ç”¨
    for(const b of bricks){
      if(!b.unbreakable && !b.boss){
        b.hp = clampHP(b.hp||1);
      }
      markRect(b.x,b.y,b.w,b.h);
    }
    // è¨ˆç®—è¦†è“‹åº¦
    let filled = 0;
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(occ[r][c]) filled++;
    const target = Math.ceil(rows*cols * (2/3));
    if(filled >= target) return;

    // ç”±ä¸­å¿ƒå¾€å¤–è£œç£šï¼Œç¶­æŒç¾æ„Ÿ
    const midC = (cols-1)/2, midR = (rows-1)/2;
    const empties = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(!occ[r][c]){
          const score = (c-midC)**2 + (r-midR)**2;
          empties.push({r,c,score});
        }
      }
    }
    

    empties.sort((a,b)=> a.score - b.score);
    const baseHP = Math.min(1 + Math.floor((level-1)/5), 3);
    let idx=0;
    while(filled < target && idx<empties.length){
      const {r,c} = empties[idx++];
      if(occ[r][c]) continue;
      let hp = baseHP + ((level>=13 && r>rows/2)?1:0);
      hp = clampHP(hp);
      const moving = (Math.random()<0.08) && (r%2===0);
      const vx = moving ? ((Math.random()<0.5?-1:1)*0.6) : 0;
      addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp, colorIdx:(r%4), moving, vx});
      occ[r][c] = true  
      filled += 1;
    }
  }

  function initBricks(){
    const L=layout();
    const totalPad=(L.cols+1)*L.pad; brickW=Math.floor((1100-totalPad)/L.cols); brickH=L.h; bricks=[]; revealRects=[];
    // ä¾é—œå¡è¨­è¨ˆé—œå¡å¸ƒå±€
    generateLevel(level, L);
    postAdjustAndDensify(L);
    // æ”¾ç½®èè‹±ç£šï¼ˆç¬¬6é—œä»¥å¾Œï¼Œæœ€å¤š2å€‹ï¼‰
    if(level>=6){ let placed=0; const candidates=bricks.filter(b=>!b.unbreakable && !b.boss);
      const cx=1100/2, cy=(layout().top + (layout().rows* (brickH+layout().pad) - layout().pad))/2;
      candidates.sort((a,b)=> (Math.hypot((a.x+a.w/2)-cx,(a.y+a.h/2)-cy) - Math.hypot((b.x+b.w/2)-cx,(b.y+b.h/2)-cy)) );
      for(const b of candidates){ if(placed>=2) break; b.elite=true; b.hp=Math.min(5, Math.max(3, b.hp||3)); placed++; }
    }
    // é‡ç½® Boss è¨ˆæ™‚
    nextBossAtkA = nextBossAtkB = cyclopsChargeUntil = 0;
  }

  
  
  // === ä¿®æ­£ï¼šéé—œåˆ¤å®šæ”¹ç‚ºåªçœ‹ã€Œå¯ç ´å£ç£šã€æ˜¯å¦æ¸…ç©º ===
  function hasBreakables(){
    // åªè¦å ´ä¸Šé‚„æœ‰ä¸æ˜¯ä¸å¯ç ´å£çš„ç£šï¼ˆåŒ…å« Boss ä»å­˜æ´»ï¼‰ï¼Œå°±å°šæœªæ¸…é—œ
    return bricks.some(b => !b.unbreakable);
  }

  // === ä¿®æ­£ï¼šæ ¼é»å°é½Šåœ°æ­ç¤ºåº•åœ–ï¼Œé¿å…é»‘æ´èˆ‡æµ®é»èª¤å·® ===
  function revealBrickArea(brick){
    const L = layout();
    const cellW = brickW, cellH = brickH;
    // ä»¥æ ¼é»å®šä½ï¼ˆå››æ¨äº”å…¥ï¼‰
    const c0 = Math.max(0, Math.min(GAME_CONFIG.bricks.cols-1, Math.round((brick.x - L.pad) / (cellW + L.pad)) ));
    const r0 = Math.max(0, Math.min(L.rows-1, Math.round((brick.y - L.top) / (cellH + L.pad)) ));
    // è¦†è“‹çš„æ ¼æ•¸ï¼ˆBoss/å¤§ç£šå¯èƒ½>1ï¼‰
    const cellsX = Math.max(1, Math.round((brick.w + L.pad) / (cellW + L.pad)));
    const cellsY = Math.max(1, Math.round((brick.h + L.pad) / (cellH + L.pad)));
    for(let rr=0; rr<cellsY; rr++){
      for(let cc=0; cc<cellsX; cc++){
        const c = Math.min(GAME_CONFIG.bricks.cols-1, c0 + cc);
        const r = Math.min(L.rows-1, r0 + rr);
        const rx = L.pad + c*(cellW + L.pad);
        const ry = L.top + r*(cellH + L.pad);
        revealRects.push({x:rx, y:ry, w:cellW, h:cellH});
      }
    }
  }
function generateLevel(lv, L){
    const cols=L.cols, rows=L.rows, pad=L.pad, top=L.top;
    const baseHP = 1 + Math.floor((lv-1)/3);
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // é—œå¡å€æ®µ
    const late = lv>=7;
    const later = lv>=11;
    const endgame = lv>=15;

    // Bossæ¯5é—œ
    const isBoss = (lv%5===0);
    if(isBoss){
      // ä¸­å¤®å¤§Bossï¼ˆ2x2ç£šå°ºå¯¸ä¸€å¡Šï¼‰
      const bx = Math.floor(cols/2)-1;
      const by = Math.max(1, Math.floor(rows/2)-1);
      const w = brickW*2 + pad;
      const h = brickH*2 + pad;
      const hpList=[10,20,30,40];
      const bossIdx = Math.floor(lv/5)-1;
      const bossHP = hpList[Math.max(0,Math.min(3,bossIdx))];
      const faces=['ç…','é¨','ç›®','é­”'];
      addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:bossHP, colorIdx:0, boss:true, face:faces[bossIdx], strong:true});
      // å‘¨åœè­·è¡›ç£š
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(c>=bx-2 && c<=bx+3 && r>=by-2 && r<=by+3) continue; // ç•™ Boss å€åŸŸ
          const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
          addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
        }
      }
      // åŠ é»ä¸å¯ç ´å£é‚Šæ¡†
      for(let c=0;c<cols;c+=2) addBrick(bricks, xAt(c), yAt(0), brickW, brickH, {unbreakable:true});
      return;
    }

    // éBossé—œï¼šè¨­è¨ˆä¸åŒæ’åˆ—
    if(lv<=3){
      // åˆå­¸ï¼šæ»¿ç‰ˆ + å°‘é‡çˆ†ç‚¸
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance*0.7;
        addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
      }
    }else if(lv<=6){
      // V å½¢ï¼‹ä¸­é–“èµ°å»Š
      const mid=Math.floor(cols/2);
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(Math.abs(c-mid)===r%5 && r<rows-1){ // V
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+((r%2)?1:0), colorIdx:r%4});
          }else if(r===Math.floor(rows/2) && (c%3===0)){ // ä¸­ç·šçˆ†ç‚¸
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, explosive:true, colorIdx:r%4});
          }
        }
      }
    }else if(lv<=10){
      // åŠ å…¥ä¸å¯ç ´å£éš”æ¿èˆ‡å°‘é‡ç§»å‹•ç£š
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r%4===0 && c%3===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else{
            const moving = (r%3===0 && c%4===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, moving, vx: moving? ((Math.random()<0.5?-1:1)*0.6) : 0});
          }
        }
      }
    }else if(lv<=14){
      // äº¤éŒ¯æ£‹ç›¤ + å¼·åå½ˆå¸¶
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if((r+c)%2===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, strong:(r%4===1)});
          }else if(r%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, moving:true, vx: (Math.random()<0.5?-1:1)*0.8});
          }
        }
      }
    }else{
      // çµ‚ç›¤ï¼šéš§é“ã€ç§»å‹•éšŠå½¢ã€å¼·åå½ˆè­·ç‰†
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r===1 || r===rows-2){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%3===0 && (r%2===0)){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+2, strong:true});
          }else{
            const mv=(r%3===1 && c%2===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, moving:mv, vx: mv?((Math.random()<0.5?-1:1)*1.0):0});
          }
        }
      }
    }
  }


  function canDestroyBrick(b){ const now=performance.now(); if(b.unbreakable) return false; if(b.lockedUntil && now < b.lockedUntil) return false; return true; }
  function damageOrDestroy(i, amount=1){ const b=bricks[i]; if(!b) return; if(b.unbreakable) return; const now=performance.now(); if(b.lockedUntil && now < b.lockedUntil) return; b.hp = (b.hp||1) - amount; if(b.hp<=0){ if(b.elite){ stats.eliteKills++; } revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); score+=10; updateHUD(); } }
  function destroyBrick(i){ const b=bricks[i]; if(!b) return; if(!canDestroyBrick(b)) return; if(b.boss){ b.hp-=1; if(b.hp<=0){ revealBrickArea(b); bricks.splice(i,1); score+=50; stats.bossKills++; updateHUD(); } return; } if(b.elite){ stats.eliteKills++; } revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); score+=10; updateHUD(); }
  function destroyNeighbors(idx){ const b=bricks[idx]; if(!b) return; const L=layout(); const near=[]; for(let j=bricks.length-1;j>=0;j--){ if(j===idx) continue; const t=bricks[j]; const dx=Math.abs((t.x+t.w/2)-(b.x+b.w/2)); const dy=Math.abs((t.y+t.h/2)-(b.y+b.h/2)); const thx=brickW+L.pad+2, thy=brickH+L.pad+2; if(dx<=thx && dy<=thy){ // é„°è¿‘ä¸€æ ¼
        if(canDestroyBrick(t)){ if(t.boss){ t.hp-=1; if(t.hp<=0){ revealBrickArea(t); maybeDropFromBrick(t); bricks.splice(j,1); score+=50; } } else { revealBrickArea(t); maybeDropFromBrick(t); bricks.splice(j,1); score+=10; } }
      }
    }
    updateHUD();
  }

  function explodeAt(cx,cy){
    const radius=Math.max(brickW,brickH)*1.3;
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy);
      if(d<=radius){
        if(b.unbreakable){ continue; }
        // Bossï¼šåªæ‰£è¡€ï¼Œä¸ç§’æ®º
        if(b.boss){
          b.hp -= 1;
          if(b.hp<=0){ revealBrickArea(b); bricks.splice(i,1); score+=50; }
        }else{
          revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); score+=10;
        }
        spawnParticles(bx,by,'#ffdd99',14,1.7,2.6,3);
      }
    }
    spawnParticles(cx,cy,'#ffbb55',24,2.1,3.2,4); updateHUD(); beep(200,0.08,0.08);
  }

  // === æ‰è½é“å…· ===
  const powerups=[]; const ALL_TYPES=Object.keys(GAME_CONFIG.powers); const NORMAL_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='rare'); const RARE_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type==='rare');

  // === å¤©ç©ºéš¨æ©Ÿå¢ç›Šæ‰è½ï¼ˆç¬¬1é—œæ¯25ç§’ â†’ ç¬¬20é—œæ¯6ç§’ ç·šæ€§éæ¸›ï¼‰ ===
  let nextSkyDropAt = 0;
  function skyDropIntervalMs(lv){
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const s = 25*1000 * (1-t) + 6*1000 * t;
    return s;
  }
  function scheduleNextSkyDrop(){ nextSkyDropAt = performance.now() + skyDropIntervalMs(level); }
  function spawnBeneficialAtTop(){
    const x = 40 + Math.random()*(1100-80);
    const y = layout().top - 20;
    // æŠ½éæ¸›ç›Šé“å…·ï¼ˆå«ç¨€æœ‰ï¼Œä½†æ©Ÿç‡è¼ƒä½ï¼‰
    const goodTypes = ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='debuff');
    let type = goodTypes[Math.floor(Math.random()*goodTypes.length)];
    powerups.push({x, y, w:GAME_CONFIG.powerCapsule.width, h:GAME_CONFIG.powerCapsule.height, vy:GAME_CONFIG.powerCapsule.fallVy, type, isDebuff:false, phase:Math.random()*Math.PI*2});
  }

  

  function maybeDropFromBrick(b){
    if(!b || b.unbreakable) return;
    // Bossä¸æœƒæ‰è½ä¸€èˆ¬å¢ç›Šï¼ˆä¿æŒå¹³è¡¡ï¼‰
    if(b.boss) return;
    if(Math.random()<dropRateForLevel(level)) spawnPower(b.x + b.w/2 - 12, b.y + b.h/2);
  }

  function dropRateForLevel(lv){
    const diff = getDiff();
    const base = diff.dropRate || 0.5;
    const startBoostAt = 8; // ä¸­æœŸé–‹å§‹æå‡æ‰è½ç‡
    const incPerLv = 0.02;
    let inc = Math.max(0, (lv - startBoostAt) * incPerLv);
    let max = 0.9;
    const d = (typeof difficultySel!=='undefined') ? difficultySel.value : 'normal';
    if(d==='normal') max = 0.7;
    if(d==='hard') max = 0.5;
    return Math.min(max, base + inc);
  }

function spawnPower(x,y){
    // æ ¹æ“šè¨­å®šï¼Œå…ˆåˆ¤å®šæ˜¯å¦æ‰è½ç¨€æœ‰é“å…·
    // avoid optional chaining in unsupported environments
    const rareChance = ((GAME_CONFIG.powers.PHOENIX && GAME_CONFIG.powers.PHOENIX.rareFactor) || 0.1);
    if (RARE_TYPES.length && Math.random() < rareChance) {
      // éš¨æ©Ÿé¸å–ç¨€æœ‰é¡å‹
      const type = RARE_TYPES[Math.floor(Math.random() * RARE_TYPES.length)];
      const def  = GAME_CONFIG.powers[type] || {};
      const isDebuff  = def.type === 'debuff';
      const isSpecial = def.type === 'special' || def.type === 'rare';
      // æ ¹æ“šåˆ†é¡èª¿æ•´ä¸‹è½é€Ÿåº¦ï¼šç‰¹æ®Šå¢ç›Šç¨æ…¢ï¼Œæ¸›ç›Šç¨å¿«
      let vy = GAME_CONFIG.powerCapsule.fallVy;
      if (isSpecial) vy *= 0.7;
      else if (isDebuff) vy *= 1.3;
      powerups.push({ x, y, w: GAME_CONFIG.powerCapsule.width, h: GAME_CONFIG.powerCapsule.height, vy, type, isDebuff, isSpecial, phase: Math.random() * Math.PI * 2 });
      return;
    }
    // éç¨€æœ‰é¡å‹ï¼šä½¿ç”¨åŠ æ¬Šéš¨æ©ŸæŠ½å–ï¼›ç‰¹æ®Šå¢ç›Šï¼ˆspecialWeight<1ï¼‰æ©Ÿç‡è¼ƒä½
    let totalW = 0;
    for (const key of NORMAL_TYPES) {
      const def = GAME_CONFIG.powers[key] || {};
      totalW += (def.specialWeight || 1);
    }
    let rnd = Math.random() * totalW;
    let chosen = NORMAL_TYPES[0];
    for (const key of NORMAL_TYPES) {
      const def = GAME_CONFIG.powers[key] || {};
      const w = (def.specialWeight || 1);
      if (rnd < w) { chosen = key; break; }
      rnd -= w;
    }
    const def = GAME_CONFIG.powers[chosen] || {};
    const isDebuff  = def.type === 'debuff';
    const isSpecial = def.type === 'special';
    // ä¸‹è½é€Ÿåº¦æ ¹æ“šåˆ†é¡èª¿æ•´
    let vy = GAME_CONFIG.powerCapsule.fallVy;
    if (isSpecial) vy *= 0.7;
    else if (isDebuff) vy *= 1.3;
    powerups.push({ x, y, w: GAME_CONFIG.powerCapsule.width, h: GAME_CONFIG.powerCapsule.height, vy, type: chosen, isDebuff, isSpecial, phase: Math.random() * Math.PI * 2 });
  }

  function applyPower(type){
    const _defC=GAME_CONFIG.powers[type]; if(_defC){ if(_defC.type==='debuff') stats.debuffs++; else if(_defC.type) stats.buffs++; }
const def=GAME_CONFIG.powers[type]; if(!def) return; const now=performance.now();
    // éæ¸›ç›Šé“å…·ï¼šæ›´æ–°æœ€è¿‘ä¸€æ¬¡ç²å¾—å¢ç›Šçš„æ™‚é–“
    if(def.type !== 'debuff'){
      lastBuffObtainedAt = now;
    }
    // ç½•è¦‹ç¬ç™¼
    if(def.instant && def.type==='rare'){
      if(type==='PHOENIX'){ // é³³å‡°é£›é + ç«ç„° + éš¨æ©Ÿä¸€åŠæ¶ˆé™¤ï¼ˆBossåªæ‰£1ï¼‰
        phoenixAnim={x:canvas.width+220,tEnd:now+1200};
        const keep=[]; for(const b of bricks){
          if(Math.random()<0.5){
            if(b.unbreakable){ keep.push(b); continue; }
            if(b.boss){ b.hp -= 1; if(b.hp>0){ keep.push(b);} else { revealBrickArea(b); score+=50; } }
            else { revealBrickArea(b); maybeDropFromBrick(b); score+=10; }
            fireBursts.push({x:b.x+b.w/2,y:b.y+b.h/2,life:400+Math.random()*400});
          } else keep.push(b);
        }
        bricks=keep; screenShake=6; beep(180,0.12,0.1);
      } else if(type==='NINE'){ lives=9; updateHUD(); spawnParticles(550,350,'#ffd',40,2.2,3.5,4); beep(880,0.1,0.06); }
      return;
    }
    // å®šæ™‚é¡
    if(def.durationMs){ if(type!=='LONG'){ const b=buffs[type]||(buffs[type]={active:false,until:0}); b.active=true; b.until=now+def.durationMs; } }
    if(def.paddleWidthAdd){ buffs.WIDE.active=true; buffs.WIDE.until=now+def.durationMs; }
    if(def.longPerStackAdd){ const act=buffs.LONG.stacks.filter(t=>t>now); const max=(def.stacksMax!==undefined && def.stacksMax!==null)?def.stacksMax:2; if(act.length<max){ buffs.LONG.stacks.push(now+def.durationMs);} else { const earliest=Math.min(...act); const idx=buffs.LONG.stacks.indexOf(earliest); buffs.LONG.stacks[idx]=now+def.durationMs; } }
    if(def.sticky){ buffs.STICKY.active=true; buffs.STICKY.until=now+def.durationMs; }
    if(def.multiDuplicate){ if(balls.length<3){ const news=[]; for(const b of balls){ const b1={...b}; b1.trail=[]; news.push(b1);} balls=balls.concat(news); const cap=(def.maxBalls!==undefined && def.maxBalls!==null)?def.maxBalls:4; if(balls.length>cap) balls.length=cap; } }
    if(def.speedMul){ buffs.SLOW.active=true; buffs.SLOW.until=now+def.durationMs; }
    if(def.piercing){ buffs.PIERCE.active=true; buffs.PIERCE.until=now+def.durationMs; for(const b of balls) b.piercing=true; }
    if(def.oneShotShield){ buffs.SHIELD.active=true; }
    if(def.forcePiercing && def.rampageMs){ buffs.RAMPAGE.active=true; buffs.RAMPAGE.until=now+def.durationMs; for(const b of balls){ b.rampageUntil=now+def.rampageMs; b.piercing=true; } }
    if(def.globalSpeedMul){ buffs.FAST.active=true; buffs.FAST.until=now+def.durationMs; if(def.screenShakeOnApply) screenShake=def.screenShakeOnApply; }
    if(def.wavy){ buffs.WAVY.active=true; buffs.WAVY.until=now+def.durationMs; buffs.WAVY.start=now; }
    if(type==='PLASMA'){ buffs.PLASMA.active=true; buffs.PLASMA.until=now+def.durationMs; }
    if(type==='FREEZE'){ buffs.FREEZE.active=true; buffs.FREEZE.until=now+def.durationMs; }
    if(type==='HOLY'){ buffs.HOLY.active=true; buffs.HOLY.until=now+def.durationMs; }

    if(type==='TRACK'){ buffs.TRACK.active=true; buffs.TRACK.until=now+def.durationMs; }
    if(type==='MISSILE'){ buffs.MISSILE.active=true; buffs.MISSILE.until=now+def.durationMs; }
    if(type==='HELL'){ buffs.HELL.active=true; buffs.HELL.until=now+def.durationMs; }
    if(type==='MEGA'){ if(!buffs.MEGA.active){ for(const ball of balls){ ball.r*=GAME_CONFIG.powers.MEGA.mega.sizeMul; } buffs.MEGA.applied=true; } buffs.MEGA.active=true; buffs.MEGA.until=now+def.durationMs; }
    if(type==='CHAIN'){ buffs.CHAIN.active=true; buffs.CHAIN.until=now+def.durationMs; }
    if(type==='NARROW'){ buffs.NARROW.active=true; buffs.NARROW.until=now+def.durationMs; }
    if(type==='HOLE'){ buffs.HOLE.active=true; buffs.HOLE.until=now+def.durationMs; }
    if(type==='FLIP'){
        // è§¸ç™¼å¤©åœ°ç¿»è½‰ï¼šå»¶é²2ç§’å¾Œæ‰çœŸæ­£é–‹å§‹ç¿»è½‰
        // è¨­å®š Buff ç‚ºæ´»èºç‹€æ…‹ï¼ˆç›´åˆ°çœŸæ­£çµæŸï¼‰
        buffs.FLIP.active = true;
        // è¨­å®šç¿»è½‰é–‹å§‹èˆ‡çµæŸæ™‚é–“
        const startDelay = 2000;
        flipPending = true;
        flipScheduledAt = now + startDelay;
        flipStartIndicatorUntil = flipScheduledAt;
        // Buff çš„çµæŸæ™‚é–“åŒ…å«å»¶é²ï¼ŒçœŸæ­£ç¿»è½‰çµæŸå¾Œè§¸ç™¼å›å¾©
        buffs.FLIP.until = now + def.durationMs + startDelay;
        // çµæŸå‰2ç§’æé†’
        flipEndIndicatorFrom = buffs.FLIP.until - 2000;
        flipEndIndicatorUntil = buffs.FLIP.until;
        // æ›´æ–°æœ€å¾Œå¢ç›Šæ™‚é–“
        lastBuffObtainedAt = now;
        // æ›´æ–° Buff æ¨™èªŒ
        updateBuffBadges();
        return;
    }
    if(type==='GODSPEED'){ buffs.GODSPEED.active=true; buffs.GODSPEED.until=now+def.durationMs; }
    if(type==='LASER'){ buffs.LASER.active=true; buffs.LASER.until=now+def.durationMs; buffs.LASER.lastShot=0; }

    updateBuffBadges();
  }

  function drawPower(p){
    // æ ¹æ“šé“å…·åˆ†é¡æ±ºå®šé¡è‰²ï¼šå¢ç›Šç‚ºè—åº•ç™½å­—ã€ç‰¹æ®Šå¢ç›Šç‚ºé‡‘åº•é»‘å­—ã€æ¸›ç›Šç‚ºç´…åº•ç™½å­—
    const x = p.x * scaleX;
    const y = p.y * scaleY;
    const w = p.w * scaleX;
    const h = p.h * scaleY;
    const wobble = Math.sin(p.phase) * 1.5;
    p.phase += 0.04;
    let colStart, colEnd, textColor;
    if (p.isSpecial) {
      // é‡‘è‰²æ¼¸å±¤ï¼Œå­—é«”é»‘è‰²
      colStart = '#f6d365';
      colEnd   = '#fda085';
      textColor= '#402a00';
    } else if (p.isDebuff) {
      // ç´…è‰²æ¼¸å±¤ï¼Œå­—é«”ç™½è‰²
      colStart = '#f25c54';
      colEnd   = '#d33f49';
      textColor= '#ffffff';
    } else {
      // ä¸€èˆ¬å¢ç›Šï¼šè—è‰²æ¼¸å±¤ï¼Œå­—é«”ç™½è‰²
      colStart = '#4a8ef0';
      colEnd   = '#3a6cd6';
      textColor= '#ffffff';
    }
    ctx.save();
    ctx.translate(0, wobble);
    const grd = ctx.createLinearGradient(x, y, x, y + h);
    grd.addColorStop(0, colStart);
    grd.addColorStop(1, colEnd);
    ctx.fillStyle = grd;
    roundedRect(x, y, w, h, 8);
    ctx.fill();
    // å¤–æ¡†ï¼šç‰¹æ®Šå¢ç›Šå¸¶æœ‰é–ƒçˆé‡‘å…‰ï¼Œå…¶å®ƒå‰‡ç‚ºæ·¡è‰²
    if (p.isSpecial) {
      const t = performance.now();
      const a = 0.6 + 0.4 * Math.abs(Math.sin(t / 200));
      ctx.strokeStyle = `rgba(255,220,150,${a.toFixed(2)})`;
    } else {
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    }
    ctx.stroke();
    // ç¹ªè£½å­—æ¯
    ctx.fillStyle = textColor;
    ctx.font = `${Math.max(10, Math.round(12 * scaleY))}px ui-monospace, monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.type[0], x + w / 2, y + h / 2 + 0.5);
    ctx.restore();
  }

  function updateHUD(){
    // æ›´æ–°åˆ†æ•¸ã€é—œå¡ã€ç”Ÿå‘½èˆ‡æ„›å¿ƒé¡¯ç¤º
    scoreEl.textContent = Math.max(0 | score, 0);
    // é¡¯ç¤ºç›®å‰é—œå¡æ•¸ï¼ˆlevel å…ƒç´ ï¼‰å’Œç¸½é—œå¡æ•¸ï¼ˆtotalLevels å…ƒç´ ï¼‰
    levelEl.textContent = level;
    if (totalLevelsEl) totalLevelsEl.textContent = GAME_CONFIG.totalLevels;
    // æ›´æ–°ç”Ÿå‘½æ–‡å­—èˆ‡æ„›å¿ƒ
    livesEl.textContent = lives;
    if (typeof updateHeartsIcons==='function') {
      // choose heart mode based on current skin selection
      const key = window.__currentSkinKey || 'classic';
      const mode = (key==='w2')?'ebony': (key==='w4')?'oak': (key==='i1')?'ice': (key==='f3')?'flame': (key==='k1')?'helmet': (key==='s5')?'star': (key==='d1')?'rabbit': (key==='m1')?'skull':'heart';
      updateHeartsIcons(mode);
    } else {
      if (heartsEl) {
        heartsEl.innerHTML = '';
        for (let i=0;i<lives;i++){ const span=document.createElement('span'); span.textContent='â¤ï¸'; span.className='life-icon'; heartsEl.appendChild(span); }
        heartsEl.classList.toggle('compact', lives>5);
      }
    }
  }
  function showCenter(t, txt){
    noteTitle.textContent = t;
    noteText.innerHTML = txt || '';
    centerNote.style.display = 'flex';
  }
  function showGameOver(){
    paused = true; running = false; gameOver = true;
    hideCenter();
    const fs2 = document.getElementById('finalScore2'); if(fs2) fs2.textContent = String(Math.max(0|score,0));
    const so  = document.getElementById('statsOver'); if(so)  so.innerHTML = renderStatsHtml();
    if (gameover) gameover.classList.add('show');
  }
  function hideCenter(){ centerNote.style.display='none'; }

  function resetGame(load=false){ diff=getDiff(); level=load?level:1; score=load?score:0; lives=load?lives:3; updateHUD(); initBricks(); resetBalls(); paused=true; running=false;
    // Debug: update title with bricks count after initialization to verify bricks are generated correctly
    try{
      document.title = 'Bricks:' + (Array.isArray(bricks) ? bricks.length : 'N/A');
    }catch(ignored){}
    for(const k of Object.keys(buffs)){ if(k!=='LONG'){ buffs[k].active=false; buffs[k].until=0; } } buffs.LONG.stacks=[]; powerups.length=0; particles.length=0; plasmas.length=0; holyFlashes.length=0; phoenixAnim=null; fireBursts.length=0;
    updateBuffBadges(); computePaddleWidth(); paddle.x=1100/2-paddle.w/2; showCenter('æŒ‰ Space æˆ–é»ç•«é¢é–‹å§‹','ç”¨ â†/â†’ æˆ– A/D ç§»å‹•ï¼›æ‰‹æŒ‡æ‹–æ›³ç•«é¢ä¹Ÿå¯ã€‚'); countdownShow=0; scheduleNextSkyDrop(); }

  // === å­˜è®€æª”ï¼ˆå«éŸ³æ•ˆ/BGMèˆ‡å½±åƒé¸æ“‡ï¼‰ ===
  function saveProgress(){ try{
      const data={level,score,lives,difficulty:difficultySel.value, imageChoice, soundsOn, bgmOn, bgmVol: parseFloat(bgmVol.value)};
      localStorage.setItem('breakout_save_v_final_cfg', JSON.stringify(data)); alert('å·²å­˜æª”ï¼');
    }catch(e){ alert('å­˜æª”å¤±æ•—ï¼š'+e); } }
  function loadProgress(){ try{ const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4'); if(!raw){ alert('æ²’æœ‰å­˜æª”'); return; } const data=JSON.parse(raw);
      difficultySel.value=data.difficulty||'normal'; level=data.level||1; score=data.score||0; lives=data.lives||3; if(Array.isArray(data.imageChoice)) imageChoice=data.imageChoice;
      soundsOn=!!data.soundsOn; soundBtn.textContent=`éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`;
      if(typeof data.bgmOn==='boolean'){ bgmOn=data.bgmOn; } if(typeof data.bgmVol==='number'){ bgmVol.value=String(data.bgmVol); if(bgmGain) bgmGain.gain.value=data.bgmVol; localStorage.setItem('bgm_vol', data.bgmVol); }
      resetGame(true); updateHUD(); alert(`å·²è®€æª”ï¼šç­‰ç´š ${level}ï¼Œåˆ†æ•¸ ${score}ï¼Œç”Ÿå‘½ ${lives}`);}catch(e){ alert('è®€æª”å¤±æ•—ï¼š'+e); } }
  function clearSave(){ localStorage.removeItem('breakout_save_v_final_cfg'); alert('å·²æ¸…é™¤å­˜æª”'); }

  // === è¼¸å…¥ï¼ˆå«è§¸æ§ï¼‰ ===
  let keyL=false, keyR=false; let touchActive=false;
  window.addEventListener('keydown',(e)=>{ if(gameOver){ e.preventDefault(); return; }
    const left = (e.code==='ArrowLeft'||e.key==='a'||e.key==='A');
    const right = (e.code==='ArrowRight'||e.key==='d'||e.key==='D');
    if(left) keyL=true;
    if(right) keyR=true;
    // è‹¥éŠæˆ²æœªé€²è¡Œæˆ–å·²æš«åœï¼Œå…è¨±ä»¥éµç›¤ç«‹å³ç§»å‹•æ“‹æ¿
    if((!running || paused) && (left || right)){
      if(!orientLeft){
        if(left) paddle.x=Math.max(0, paddle.x-paddle.speed);
        if(right) paddle.x=Math.min(1100-paddle.w, paddle.x+paddle.speed);
      }else{
        if(left) paddle.y=Math.max(0, paddle.y-paddle.speed);
        if(right) paddle.y=Math.min(700-paddle.w, paddle.y+paddle.speed);
      }
    }
    if(e.code==='Space'){ // é–‹å§‹ / æš«åœ / å€’æ•¸
      if(!running){ startGameWithCountdown(); } else { togglePause(); }
      return;
    }
    if((e.code==='ArrowUp' || e.key==='Shift') && !paused && running){
      let released=false;
      for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy = -Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
    if(e.key==='r'||e.key==='R'){ resetGame(); }
    if(e.key==='f'||e.key==='F'){ toggleFullscreen(); }
  });
  window.addEventListener('keyup',(e)=>{ if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=false; if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=false; });
  canvas.addEventListener('mousemove',(e)=>{ const rect=canvas.getBoundingClientRect(); if(performance.now()<=paddleStunUntil) return; if(!orientLeft){ const x=(e.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(e.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } });
  canvas.addEventListener('click',()=>{ if(gameOver){ return; }
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  });
  canvas.addEventListener('touchstart',(e)=>{ if(gameOver){ e.preventDefault(); return; } touchActive=true; 
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  }, {passive:false});
  canvas.addEventListener('touchmove',(e)=>{ if(!touchActive) return; if(performance.now()<=paddleStunUntil) return; const t=e.touches[0]; const rect=canvas.getBoundingClientRect(); if(!orientLeft){ const x=(t.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(t.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } }, {passive:true});
  canvas.addEventListener('touchend',()=>{ touchActive=false; }, {passive:true});
  pauseBtn.addEventListener('click',()=>togglePause()); resetBtn.addEventListener('click',()=>resetGame()); fsBtn.addEventListener('click',()=>toggleFullscreen());
  soundBtn.addEventListener('click',()=>{
    soundsOn = !soundsOn;
    localStorage.setItem('sfx_on', soundsOn ? '1' : '0');
    soundBtn.textContent = `éŸ³æ•ˆï¼š${soundsOn ? 'é–‹' : 'é—œ'}`;
    ensureAudio();
    // resume audio context if possible
    if (audioCtx && typeof audioCtx.resume === 'function') audioCtx.resume();
    beep(880, 0.06, 0.05);
  });
  difficultySel.addEventListener('change',()=>{ resetGame(); });
  if(ledStyleSel){ ledStyleSel.value = ledStyle; ledStyleSel.addEventListener('change', ()=>{ ledStyle = ledStyleSel.value; localStorage.setItem('led_style', ledStyle); }); }
  saveBtn.addEventListener('click',saveProgress); loadBtn.addEventListener('click',loadProgress); clearSaveBtn.addEventListener('click',clearSave);
  tutorBtn.addEventListener('click', ()=> toggleHelp('tutor'));
  effectsBtn.addEventListener('click', ()=> toggleHelp('effects'));
  againBtn.addEventListener('click', ()=>{ win.classList.remove('show'); resetGame(); });

  // BGM UI
  bgmBtn.addEventListener('click', ()=>{
    bgmOn=!bgmOn; localStorage.setItem('bgm_on', bgmOn?'1':'0'); bgmBtn.textContent= bgmOn?'é–‹':'é—œ';
    if(bgmOn){ ensureAudio(); startBGM(); } else { stopBGM(); }
  });
  bgmVol.addEventListener('input', ()=>{
    ensureAudio(); const v=parseFloat(bgmVol.value||'0.5'); if(bgmGain) bgmGain.gain.value=v; localStorage.setItem('bgm_vol', v);
  });

  function togglePause(){
    if(!running){ startGameWithCountdown(); return; }
    paused=!paused;
    if(paused){
      // è¨˜éŒ„æš«åœé–‹å§‹æ™‚é–“
      pauseStart = performance.now();
      showCenter('å·²æš«åœ','æŒ‰ Space / é»ç•«é¢ç¹¼çºŒ');
    } else {
      // æ¢å¾©æ™‚è£œå„Ÿæš«åœçš„æ™‚é–“åˆ°æ‰€æœ‰å®šæ™‚å™¨
      const resumeNow = performance.now();
      const delta = pauseStart ? (resumeNow - pauseStart) : 0;
      pauseStart = null;
      // èª¿æ•´æ‰€æœ‰ Buff çš„ until
      for(const k of Object.keys(buffs)){
        const b = buffs[k];
        if(b && b.until && b.active){ b.until += delta; }
      }
      // èª¿æ•´ LONG å †ç–Šè¨ˆæ™‚
      if(buffs.LONG && Array.isArray(buffs.LONG.stacks)){
        for(let i=0;i<buffs.LONG.stacks.length;i++){
          buffs.LONG.stacks[i] += delta;
        }
      }
      // èª¿æ•´ç¿»è½‰ç›¸é—œè¨ˆæ™‚
      if(flipPending){
        flipScheduledAt += delta;
        flipStartIndicatorUntil += delta;
        flipEndIndicatorFrom += delta;
        flipEndIndicatorUntil += delta;
        if(buffs.FLIP){ buffs.FLIP.until += delta; }
      } else if(buffs.FLIP && buffs.FLIP.active){
        flipStartIndicatorUntil += delta;
        flipEndIndicatorFrom += delta;
        flipEndIndicatorUntil += delta;
        if(buffs.FLIP){ buffs.FLIP.until += delta; }
      }
      // èª¿æ•´å¤©ç©ºæ‰è½èˆ‡å¢ç›Šç²å¾—æ™‚é–“
      nextSkyDropAt += delta;
      lastBuffObtainedAt += delta;
      startCountdown();
    }
  }

  function startGameWithCountdown(){
    running=true; paused=true; hideCenter();
    ensureAudio();
    // resume AudioContext when starting game
    if (audioCtx && typeof audioCtx.resume === 'function') audioCtx.resume();
    // éŸ³æ•ˆèˆ‡BGMè¨­å®šè¼‰å…¥
    // å¾ localStorage è¼‰å…¥éŸ³æ•ˆèˆ‡ BGM è¨­å®š
    soundsOn = (localStorage.getItem('sfx_on')||'0') === '1';
    // åŒæ­¥èˆŠç‰ˆæŒ‰éˆ•èˆ‡æ–° UI è¤‡é¸æ¡†
    soundBtn.textContent = `éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`;
    if (sfxOnEl) sfxOnEl.checked = soundsOn;
    bgmOn = (localStorage.getItem('bgm_on')||'0') === '1';
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.7');
    bgmVol.value = String(v);
    ensureAudio(); if (bgmGain) bgmGain.gain.value = v;
    bgmBtn.textContent = bgmOn ? 'é–‹' : 'é—œ';
    if (bgmOnEl) bgmOnEl.checked = bgmOn;
    if (bgmOn) startBGM(); applyBGMThemeForLevel();
    startCountdown();
  }

  // === æ•™å­¸/æ•ˆæœèªªæ˜ ===
  let helpMode=null; // 'tutor' | 'effects' | null
  function toggleHelp(mode){
    if(helpMode===mode){ helpMode=null; hideCenter(); if(running){ startCountdown(); } else { startGameWithCountdown(); } return; }
    helpMode=mode;
    paused=true;
    if(mode==='tutor'){
      showCenter('æ•™å­¸ï¼ˆæŒ‰éˆ•å†æŒ‰ä¸€æ¬¡é—œé–‰ï¼‰', `
        <div class="cols">
          <div>
            <strong>æ“ä½œ</strong><br>
            é›»è…¦ï¼š<kbd>â†</kbd>/<kbd>â†’</kbd> æˆ– <kbd>A</kbd>/<kbd>D</kbd> ç§»å‹•ï¼›<kbd>Space</kbd> é–‹å§‹/æš«åœã€‚<br>
            é‡‹æ”¾é»ä½çš„çƒï¼š<kbd>â†‘</kbd> æˆ– <kbd>Shift</kbd>ã€‚<br>
            æ‰‹æ©Ÿï¼šæ‰‹æŒ‡æ‹–æ›³æ“‹æ¿ä½ç½®å³å¯ã€‚<br>
            å…¨è¢å¹•ï¼š<kbd>F</kbd>ã€‚
          </div>
          <div>
            <strong>ç›®æ¨™</strong><br>
            æ‰“ç ´æ‰€æœ‰å¯ç ´å£ç£šé€²å…¥ä¸‹ä¸€é—œã€‚æ¯ 5 é—œæœ‰ Bossï¼ˆåªæ‰£è¡€ä¸æœƒè¢«ç§’æ®ºï¼‰ã€‚<br>
            ç¬¬ 1~10 é—œèˆ‡ 11~20 é—œæœƒåˆ†åˆ¥é¡¯ç¤ºåŒçµ„ç…§ç‰‡çš„ä¸åŒå¼µï¼Œ20 é—œçµæŸæ’­æ”¾é€šé—œç•«é¢ã€‚
          </div>
          <div>
            <strong>å­˜è®€æª”</strong><br>
            å¯å„²å­˜é—œå¡/åˆ†æ•¸/ç”Ÿå‘½ã€é›£åº¦ã€ç…§ç‰‡é¸æ“‡ã€éŸ³æ•ˆ/BGM è¨­å®šã€‚
          </div>
        </div>`);
    }else{
      // æ•ˆæœèªªæ˜ï¼šæŒ‰é¡å‹åˆ†é¡è¼¸å‡º
      let html = '<div class="cols">';
      // å¢ç›Š
      html += '<div><strong>å¢ç›Š</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'buff'){
          html += `${badgeIcon(k)} <em>${k}</em>ï¼š${p.label}<br>`;
        }
      }
      html += '</div>';
      // ç‰¹æ®Šå¢ç›Šï¼ˆåŒ…æ‹¬ special èˆ‡ rareï¼‰
      html += '<div><strong>ç‰¹æ®Šå¢ç›Š</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'special' || p.type === 'rare'){
          html += `${badgeIcon(k)} <em>${k}</em>ï¼š${p.label}<br>`;
        }
      }
      html += '</div>';
      // æ¸›ç›Š
      html += '<div><strong>æ¸›ç›Š</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'debuff'){
          html += `${badgeIcon(k)} <em>${k}</em>ï¼š${p.label}<br>`;
        }
      }
      html += '</div>';
      // ç‰¹æ®Šç£š
      html += '<div><strong>ç‰¹æ®Šç£š</strong><br>';
      html += 'ä¸å¯ç ´å£ç£šï¼šåªåå½ˆä¸æœƒå£ï¼›<br>ç§»å‹•ç£šï¼šæ°´å¹³ç§»å‹•ï¼›<br>å¼·åå½ˆç£šï¼šåå½ˆæ™‚åŠ é€Ÿæ›´å¼·ï¼›<br>Bossç£šï¼šå¤§å°ºå¯¸ã€åªæ‰£è¡€ï¼Œçˆ†ç‚¸/ç¥è–/é³³å‡°ä¹Ÿä¸æœƒè¢«ç§’æ®ºã€‚';
      html += '</div>';
      html += '</div>';
      showCenter('æ•ˆæœèªªæ˜ï¼ˆæŒ‰éˆ•å†æŒ‰ä¸€æ¬¡é—œé–‰ï¼‰', html);
    }
    };

    /* ---------------- HUD äº’å‹•ï¼ˆç§»æ¤è‡ª index_skin.htmlï¼‰ ---------------- */
  (function(){
    const hud = document.querySelector('.hud');
    const sentinel = document.querySelector('.hud-sentinel');
    const sndBtn = document.getElementById('sndBtn');
    const optBtn = document.getElementById('optBtn');
    const soundMenu = document.getElementById('soundMenu');
    const optMenu = document.getElementById('optMenu');
    let scheduled = false;
    function schedule(){ if(scheduled) return; scheduled = true; requestAnimationFrame(() => { scheduled = false; placeHUD(); }); }
    function placeHUD(){
      const rect = (sentinel || hud).getBoundingClientRect();
      const top = Math.max(0, Math.ceil(rect.top)) + 6;
      document.documentElement.style.setProperty('--hudBottom', top + 'px');
    }
    function toggle(menu, btn){
      const show = !menu.classList.contains('show');
      [soundMenu, optMenu].forEach(m => m.classList.remove('show'));
      document.querySelectorAll('[aria-expanded="true"]').forEach(b => b.setAttribute('aria-expanded', 'false'));
      if(show){
        menu.classList.add('show');
        btn.setAttribute('aria-expanded', 'true');
      }
      schedule();
    }
    if(sndBtn) sndBtn.addEventListener('click', (e) => { e.stopPropagation(); toggle(soundMenu, sndBtn); }, {passive:true});
    if(optBtn) optBtn.addEventListener('click', (e) => { e.stopPropagation(); toggle(optMenu, optBtn); }, {passive:true});
    document.addEventListener('click', (e) => {
      if(!e.target.closest('.menu') && !e.target.closest('#optBtn') && !e.target.closest('#sndBtn')){
        [soundMenu, optMenu].forEach(m => m.classList.remove('show'));
        schedule();
      }
    }, {passive:true});
    ['resize','orientationchange'].forEach(ev => window.addEventListener(ev, schedule, {passive:true}));
    if(document.fonts && document.fonts.ready){ document.fonts.ready.then(schedule); }
    schedule();
  })();

  // === å…¨è¢å¹• ===
  async function toggleFullscreen(){
    const elem = document.documentElement;
    try{
      if(!document.fullscreenElement){
        await elem.requestFullscreen();
      }else{
        await document.exitFullscreen();
      }
    }catch(e){
      console.warn('Fullscreen failed:', e);
    }
  }

  // === æ“‹æ¿å¯¬åº¦ ===
  function computePaddleWidth(){ const now=performance.now(); buffs.LONG.stacks=buffs.LONG.stacks.filter(t=>t>now); const longStacks=Math.min(GAME_CONFIG.powers.LONG.stacksMax, buffs.LONG.stacks.length);
    const addLong=longStacks*(GAME_CONFIG.powers.LONG.longPerStackAdd||0); const addWide=(buffs.WIDE.active?(GAME_CONFIG.powers.WIDE.paddleWidthAdd||0):0); const base=getDiff().paddleBaseW;
    let newW=Math.min(GAME_CONFIG.caps.paddleMaxW, base+addWide+addLong);
    if (buffs.NARROW && buffs.NARROW.active) newW = Math.max(60, newW * 0.5);
    const center=paddle.x+paddle.w/2; paddle.w=newW; paddle.x=Math.max(0, Math.min(1100-paddle.w, center - paddle.w/2)); }

  // æ“‹æ¿åœ¨ä¸åŒæœå‘ä¸‹çš„å¯¦éš›çŸ©å½¢
  function paddleRect(){
    // æ©«å‘ï¼šx,y,w,hï¼›ç¸±å‘ï¼šä»¥ h ç‚ºåšåº¦ã€w ç‚ºé•·åº¦
    if(!orientLeft){
      return {x:paddle.x, y:paddle.y, w:paddle.w, h:paddle.h};
    }else{
      // å·¦å´ï¼šå›ºå®šé å·¦ 40px
      const thick = paddle.h;
      const len = paddle.w;
      const x = 40; // èˆ‡ç‰†è·
      return {x:x, y:Math.max(0, Math.min(700-len, paddle.y)), w:thick, h:len};
    }
  }


  function speedMultiplier(now){ let mul=1.0; if(buffs.SLOW.active){ mul*=(GAME_CONFIG.powers.SLOW.speedMul!=null ? GAME_CONFIG.powers.SLOW.speedMul : 1.0);} if(buffs.FAST.active){ mul*=(GAME_CONFIG.powers.FAST.globalSpeedMul!=null ? GAME_CONFIG.powers.FAST.globalSpeedMul : 1.0);} if(buffs.WAVY.active){ const w=GAME_CONFIG.powers.WAVY.wavy||{amp:0.6,base:1.2,periodMs:200}; const phase=(now-(buffs.WAVY.start||now))/(w.periodMs); mul*=(w.base+w.amp*Math.sin(phase)); } return mul; }

  // === èƒŒæ™¯è£é£¾ & LED ç‡ˆæ¢ ===
  function ledColor(){
    if(buffs.GODSPEED.active) return '#ffe066';
    if(buffs.HOLY.active) return '#ffe08a';
    if(buffs.HELL.active) return '#a08cff';
    if(buffs.PLASMA.active) return '#9fe8ff';
    if(buffs.FREEZE.active) return '#cfe9ff';
    if(buffs.RAMPAGE.active || buffs.PIERCE.active || buffs.TRACK.active) return '#7fd8ff';
    if(buffs.FAST.active) return '#ffb37a';
    if(buffs.WAVY.active) return '#ba8fff';
    return '#8fb3ff';
  }

  function drawBGDecor(){ const w=canvas.width,h=canvas.height; bgTime+=0.003; ctx.save(); ctx.globalAlpha=0.12; ctx.translate(Math.sin(bgTime)*8, Math.cos(bgTime*0.7)*6); const step=40;

    for(let x=0;x<w;x+=step){ ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(x,0,1,h);} for(let y=0;y<h;y+=step){ ctx.fillStyle='rgba(255,255,255,.025)'; ctx.fillRect(0,y,w,1);} ctx.restore();
    const grad=ctx.createRadialGradient(w/2,h*0.2,0,w/2,h*0.5,Math.max(w,h)); grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
    if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }

    // é³³å‡°ç«ç„°æ®˜ç•™
    for(let i=fireBursts.length-1;i>=0;i--){ const f=fireBursts[i]; f.life-=16; if(f.life<=0){ fireBursts.splice(i,1); continue; } const a=Math.min(1, f.life/600); const rx= (f.x*scaleX), ry=(f.y*scaleY); const r=60*((scaleX+scaleY)/2); const g=ctx.createRadialGradient(rx,ry,1,rx,ry,r); g.addColorStop(0,`rgba(255,180,0,${0.6*a})`); g.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(rx,ry,r,0,Math.PI*2); ctx.fill(); }


    // LED ç‡ˆæ¢æ¡†ï¼ˆå¤šé¢¨æ ¼ï¼Œè½çƒå€åŸŸç„¡ç‡ˆæ¢ï¼‰
    const c=ledColor();
    let spAvg=0; for(const b of balls){ spAvg += Math.hypot(b.vx,b.vy); } spAvg = balls.length? spAvg/balls.length : 8;
    const nowT = performance.now();
    const breathClassic = (Math.sin(nowT / (180 - Math.min(120, spAvg*6)))+1)/2; // åŸï¼šä¾çƒé€Ÿ
    const breath5 = (Math.sin(nowT / (5000 / (2*Math.PI)))+1)/2;  // 5s
    const breath3 = (Math.sin(nowT / (3000 / (2*Math.PI)))+1)/2;  // 3s
    const breath8 = (Math.sin(nowT / (8000 / (2*Math.PI)))+1)/2;  // 8s

    function pathThreeSides(){
      ctx.beginPath();
      if(!orientLeft){
        ctx.moveTo(6,6); ctx.lineTo(w-6,6);
        ctx.moveTo(6,6); ctx.lineTo(6,h-6);
        ctx.moveTo(w-6,6); ctx.lineTo(w-6,h-6);
      }else{
        ctx.moveTo(6,6); ctx.lineTo(w-6,6);
        ctx.moveTo(w-6,6); ctx.lineTo(w-6,h-6);
        ctx.moveTo(6,h-6); ctx.lineTo(w-6,h-6);
      }
    }

    ctx.save();
    switch(ledStyle){
      case 'tech': {
        ctx.globalAlpha = 0.55 + 0.35*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=8; ctx.shadowColor=c; ctx.shadowBlur=28 + 10*breath5;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'arc': {
        ctx.globalAlpha = 0.5 + 0.25*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=5; ctx.shadowColor=c; ctx.shadowBlur=16 + 6*breath5;
        pathThreeSides(); ctx.setLineDash([14,10]); ctx.lineDashOffset = -(nowT/20); ctx.stroke();
        ctx.setLineDash([]); ctx.globalAlpha = 0.3 + 0.2*breath8; ctx.lineWidth=2.5; ctx.shadowBlur=0;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'steel': {
        ctx.globalAlpha = 0.65 + 0.25*breath5;
        const g = ctx.createLinearGradient(0,0,w,0);
        g.addColorStop(0, 'rgba(220,230,255,0.85)');
        g.addColorStop(0.5, 'rgba(120,140,180,0.85)');
        g.addColorStop(1, 'rgba(200,210,240,0.85)');
        ctx.strokeStyle=g; ctx.lineWidth=7.5; ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=12;
        pathThreeSides(); ctx.stroke();
        ctx.shadowBlur=0; ctx.fillStyle=c;
        const ends = !orientLeft ? [[6,6],[w-6,6]] : [[w-6,6],[w-6,h-6]];
        for(const [ex,ey] of ends){ ctx.beginPath(); ctx.arc(ex,ey,6 + 2*breath5, 0, Math.PI*2); ctx.fill(); }
        break;
      }
      case 'vivid': {
        ctx.globalAlpha = 0.5 + 0.5*breath3;
        const grad = ctx.createLinearGradient(0,0,w,0);
        grad.addColorStop(0, 'rgba(255,255,255,0.85)');
        grad.addColorStop(1, c);
        ctx.strokeStyle=grad; ctx.lineWidth=4.5;
        for(const off of [-4,0,4]){ ctx.save(); ctx.translate(0,off); pathThreeSides(); ctx.stroke(); ctx.restore(); }
        break;
      }
      default: {
        ctx.globalAlpha = 0.6 + 0.3*breathClassic;
        ctx.strokeStyle=c; ctx.lineWidth=6; ctx.shadowColor=c; ctx.shadowBlur=20 + 10*breathClassic; pathThreeSides(); ctx.stroke();
        break;
      }
    }
    ctx.restore();}

  // åªåœ¨ç£šå¡Šå€åŸŸæ­ç¤ºåœ–ç‰‡åˆ‡ç‰‡ï¼ˆä¾æœ¬é—œå½±åƒï¼‰
  function drawRevealTiles(){ const img=getLevelImage(level); if(!img || !(img.naturalWidth>0 && img.naturalHeight>0)) return; const L=layout();
    const area={x:L.pad,y:L.top,w:1100-L.pad*2,h:L.rows*(brickH+L.pad)-L.pad}; const rImg=img.naturalWidth/img.naturalHeight; const rArea=area.w/area.h; let dw,dh;
    if(rImg>rArea){ dh=area.h; dw=dh*rImg; } else { dw=area.w; dh=dw/rImg; } const dx=area.x+(area.w-dw)/2; const dy=area.y+(area.h-dh)/2;
    for(const r of revealRects){
      let sx=(r.x-dx)/dw*img.naturalWidth;
      let sy=(r.y-dy)/dh*img.naturalHeight;
      let sw=r.w/dw*img.naturalWidth;
      let sh=r.h/dh*img.naturalHeight;
      const sx0=Math.max(0, Math.min(img.naturalWidth, sx));
      const sy0=Math.max(0, Math.min(img.naturalHeight, sy));
      const sw0=Math.max(0, Math.min(img.naturalWidth - sx0, sw));
      const sh0=Math.max(0, Math.min(img.naturalHeight - sy0, sh));
      if(sw0>0 && sh0>0){
        ctx.drawImage(img, sx0,sy0,sw0,sh0, r.x*scaleX, r.y*scaleY, r.w*scaleX, r.h*scaleY);
      }
    } }

  function drawPlasmas(){ const now=performance.now(); ctx.save(); for(let i=plasmas.length-1;i>=0;i--){ const P=plasmas[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.995; P.vy*=0.995; if(now>P.until){ plasmas.splice(i,1); continue; }
      const x=P.x*scaleX, y=P.y*scaleY, r=P.radius*((scaleX+scaleY)/2); const grd=ctx.createRadialGradient(x,y,2,x,y,r); grd.addColorStop(0,'rgba(150,230,255,0.9)'); grd.addColorStop(0.4,'rgba(120,200,255,0.35)'); grd.addColorStop(1,'rgba(120,200,255,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(180,240,255,0.5)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,r*0.7,0,Math.PI*2); ctx.stroke();
      // æ²¿é€”æ¸…é™¤ç£šå¡Šï¼ˆBoss/ä¸å¯ç ´å£è±å…ï¼‰
      for(let j=bricks.length-1;j>=0;j--){ const b=bricks[j]; const bx=b.x+b.w/2, by=b.y+b.h/2; if(Math.hypot(P.x-bx,P.y-by)<=P.radius){
          if(b.unbreakable) continue;
          if(b.boss){ b.hp-=1; if(b.hp<=0){ revealBrickArea(b); bricks.splice(j,1); score+=50; } }
          else { revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(j,1); score+=10; }
        }
      }
    } ctx.restore(); }

  function drawHoly(){ const now=performance.now(); for(let i=holyFlashes.length-1;i>=0;i--){ const H=holyFlashes[i]; if(now>H.until){ holyFlashes.splice(i,1); continue; } const a=Math.max(0, (H.until-now)/300); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle=`rgba(255,240,180,${0.6*a})`; ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(0, H.y*scaleY); ctx.lineTo(canvas.width, H.y*scaleY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(H.x*scaleX, 0); ctx.lineTo(H.x*scaleX, canvas.height); ctx.stroke(); ctx.restore(); } }

  function drawPhoenix(){ if(!phoenixAnim) return; const now=performance.now(); const t=phoenixAnim; const prog=1-Math.max(0,(t.tEnd-now)/1200); const logicW=1100; const xLogic=(1-prog)*(logicW+200)-200; const x=xLogic*scaleX;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    // èº«å½¢å…‰ç¾½
    const grad=ctx.createLinearGradient((x+120),220*scaleY,x,260*scaleY); grad.addColorStop(0,'rgba(255,180,0,0.9)'); grad.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=grad;
    ctx.beginPath(); ctx.moveTo((x+180), 220*scaleY); ctx.quadraticCurveTo((x+60), 180*scaleY, (x), 230*scaleY); ctx.quadraticCurveTo((x-40), 260*scaleY, (x+120), 260*scaleY); ctx.closePath(); ctx.fill();
    // ç¾½æ¯›ç²’å­
    for(let i=0;i<3;i++){ fireBursts.push({x:(x-40)+Math.random()*120,y:220+Math.random()*60,life:300+Math.random()*400}); }
    ctx.restore(); if(now>=t.tEnd) phoenixAnim=null; }

  function draw(){
    if(screenShake>0){ const s=screenShake*0.6; ctx.save(); ctx.translate((Math.random()-0.5)*s,(Math.random()-0.5)*s); screenShake*=0.9; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBGDecor();
    drawRevealTiles();

    // ç£šå¡Š
    for(const b of bricks){
      // ç§»å‹•ç£šæ›´æ–°
      if(b.moving){
        b.x += b.vx;
        if(b.x<8){ b.x=8; b.vx=Math.abs(b.vx); }
        if(b.x+b.w>1100-8){ b.x=1100-8-b.w; b.vx=-Math.abs(b.vx); }
      }
      // ç¹ªè£½
      let base = b.boss ? '#ff4d6d' : b.unbreakable ? '#888' : b.strong ? '#bb7aff' : b.moving ? '#6ec6ff' : b.explosive ? getVar('--expl') : brickColor(b.colorIdx);
      const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY); g.addColorStop(0,base); g.addColorStop(1,'#1a1f3a'); ctx.fillStyle=g; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill();
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.stroke(); ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); }
      // é–éˆè¦†è“‹
      if(b.lockedUntil && performance.now() < b.lockedUntil){ ctx.fillStyle='rgba(90,0,120,0.35)'; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill();
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.stroke(); ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); } }
      // èè‹±èšæ°£å…‰
      if(b.elite && b.eliteChargeUntil && performance.now()<b.eliteChargeUntil){ const a=0.5+0.5*Math.sin(performance.now()/80); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,220,255,'+(0.6*a)+')'; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.restore(); }
      // è¡€æ¢ / é¢å­”
      if(b.boss){
        drawBossEmblem(b);
        // è¡€æ¢
        ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*scaleX,6*scaleY);
        const ratio=Math.max(0, b.hp/40);
        const hpGrad=ctx.createLinearGradient((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.x+b.w-8)*scaleX,(b.y+b.h-8)*scaleY);
        hpGrad.addColorStop(0,'rgba(255,150,150,.95)'); hpGrad.addColorStop(1,'rgba(255,240,240,.95)');
        ctx.fillStyle=hpGrad; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*ratio*scaleX,6*scaleY);
      }else if(b.hp>1 && b.hp<99 && b.hp<Infinity){
        ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*scaleX,4*scaleY);
        ctx.fillStyle='rgba(255,255,255,.75)'; const ratio=Math.max(0,(b.hp-1))/3; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*ratio*scaleX,4*scaleY);
      }
    }

    drawPlasmas(); drawHoly(); drawPhoenix();

    // Cyclops wind-up glow
    if(cyclopsChargeUntil && performance.now()<cyclopsChargeUntil){ for(const b of bricks){ if(b.boss && b.face==='ç›®'){ const a = 0.5 + 0.5*Math.sin(performance.now()/80); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(255,235,150,'+(0.6*a)+')'; ctx.lineWidth=4; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke(); ctx.restore(); } } }


    // æ“‹æ¿
    const pr=paddleRect();
    const padGlow=buffs.STICKY.active?'rgba(120,230,220,.6)':((buffs.WIDE.active||buffs.LONG.stacks.length)?'rgba(120,170,255,.6)':'rgba(200,210,255,.4)'); ctx.shadowColor=padGlow; ctx.shadowBlur=20;
    ctx.fillStyle='#9aaeff';
    if(!orientLeft){
      // æ°´å¹³
      drawRoundedRect(pr.x,pr.y,pr.w,pr.h,8); ctx.fill();
      // ç©ºæ´
      if(buffs.HOLE.active){ const gapW=pr.w/3; ctx.clearRect((pr.x+pr.w/3)*scaleX, pr.y*scaleY, gapW*scaleX, pr.h*scaleY); }
    }else{
      // å·¦å´å‚ç›´
      drawRoundedRect(pr.x,pr.y,pr.w,pr.h,8); ctx.fill();
      if(buffs.HOLE.active){ const gapH=pr.h/3; ctx.clearRect(pr.x*scaleX, (pr.y+pr.h/3)*scaleY, pr.w*scaleX, gapH*scaleY); }
    }
    ctx.shadowBlur=0;
    if(buffs.SHIELD.active && !orientLeft){ const g=ctx.createLinearGradient(0,(700-10)*scaleY,0,700*scaleY); g.addColorStop(0,'rgba(120,220,255,0.35)'); g.addColorStop(1,'rgba(120,220,255,0.05)'); ctx.fillStyle=g; ctx.fillRect(0,(700-10)*scaleY,canvas.width,10*scaleY); }
    if(performance.now()<=paddleStunUntil){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(255,230,160,0.35)'; drawRoundedRect(pr.x,pr.y,pr.w,pr.h,8); ctx.fill(); ctx.restore(); }
    // é›·å°„ç ²å±•ç¤º
    if(buffs.LASER.active){ ctx.fillStyle='rgba(120,255,120,0.8)'; if(!orientLeft){ ctx.fillRect((pr.x-6)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); ctx.fillRect((pr.x+pr.w+2)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); } else { ctx.fillRect((pr.x-4)*scaleX, (pr.y-6)*scaleY, (pr.w+8)*scaleX, 4*scaleY); ctx.fillRect((pr.x-4)*scaleX, (pr.y+pr.h+2)*scaleY, (pr.w+8)*scaleX, 4*scaleY); } }

    // çƒèˆ‡æ‹–å°¾
    const nowT=performance.now();
    for(const b of balls){
      b.trail.push({x:b.x,y:b.y,t:nowT}); while(b.trail.length>12) b.trail.shift();
      for(let i=b.trail.length-1;i>=0;i--){ const p=b.trail[i]; const age=(nowT-p.t)/200; if(age>1) continue; const alpha=(1-age)*0.6;
        let color=( (b.rampageUntil&&nowT<b.rampageUntil)||b.piercing )?`rgba(120,220,255,${alpha})`:(buffs.FAST.active?`rgba(255,140,90,${alpha})`:`rgba(255,255,255,${alpha*0.6})`);
        if(buffs.PLASMA.active) color=`rgba(160,240,255,${alpha})`; if(buffs.FREEZE.active) color=`rgba(200,230,255,${alpha})`; if(buffs.HOLY.active) color=`rgba(255,240,180,${alpha})`;
        if(buffs.TRACK.active) color=`rgba(${Math.floor(128+127*Math.sin(nowT/80))},${Math.floor(128+127*Math.sin(nowT/95+2))},${Math.floor(128+127*Math.sin(nowT/110+4))},${alpha})`;
        if(buffs.GODSPEED.active) color=`rgba(255,224,102,${alpha})`;
        ctx.fillStyle=color; ctx.beginPath(); ctx.arc(p.x*scaleX,p.y*scaleY,(b.r*0.7)*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill();
      }
      const bx=b.x*scaleX, by=b.y*scaleY, br=b.r*((scaleX+scaleY)/2); const grad=ctx.createRadialGradient(bx-3,by-4,2,bx,by,br);
      let edge=(b.piercing||(b.rampageUntil&&nowT<b.rampageUntil))?'#9ff':(buffs.FAST.active?'#ff9a66':'#cbd4ff'); if(buffs.PLASMA.active) edge='#aff'; if(buffs.FREEZE.active) edge='#e8f8ff'; if(buffs.HOLY.active) edge='#fff0a0'; if(buffs.GODSPEED.active) edge='#ffe066';
      grad.addColorStop(0,'#fff'); grad.addColorStop(1, edge); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();
      if(buffs.WAVY.active){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; const r1=br+2+2*Math.sin((nowT/100)+b.x*0.02); ctx.beginPath(); ctx.arc(bx,by,r1,0,Math.PI*2); ctx.stroke(); }
      if(b.stuck && !orientLeft){ ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect((paddle.x+paddle.w/2-12)*scaleX,(paddle.y-6)*scaleY,24*scaleX,4*scaleY); }
    }

    // é»‘æ´ç‰¹æ•ˆ
    for(let i=blackHoles.length-1;i>=0;i--){ const h=blackHoles[i]; if(performance.now()>h.until){ blackHoles.splice(i,1); continue; } const age=(h.until-performance.now())/2000; const r=40*((scaleX+scaleY)/2)*(0.8+0.2*Math.sin(performance.now()/120)); const x=h.x*scaleX, y=h.y*scaleY; const g=ctx.createRadialGradient(x,y,2,x,y,r); g.addColorStop(0,`rgba(0,0,0,${0.6})`); g.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }

    
    // é›·å°„å…‰æŸï¼ˆå¼·åŒ–è³ªæ„Ÿï¼‰
    for(let i=laserBeams.length-1;i>=0;i--){
      const b=laserBeams[i];
      const nowP=performance.now();
      if(nowP>b.until){ laserBeams.splice(i,1); continue; }
      const x1=b.x1*scaleX, y1=b.y1*scaleY, x2=b.x2*scaleX, y2=b.y2*scaleY;
      const t = Math.max(0, Math.min(1, (b.until-nowP)/200));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      // Outer glow
      ctx.strokeStyle='rgba(120,255,180,'+(0.25*t)+')';
      ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Mid beam
      const grd = ctx.createLinearGradient(x1,y1,x2,y2);
      grd.addColorStop(0,'rgba(160,255,220,'+(0.7*t)+')');
      grd.addColorStop(1,'rgba(255,255,255,'+(0.9*t)+')');
      ctx.strokeStyle=grd; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Core
      ctx.strokeStyle='rgba(255,255,255,'+(1*t)+')'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    }
    // Boss æŠ•å°„ç‰©
    drawAndStepBossProjectiles();

    // é›·å°„å‘½ä¸­æ•£é–‹ç‰¹æ•ˆ
    for(let i=laserImpacts.length-1;i>=0;i--){
      const it=laserImpacts[i]; const nowI=performance.now();
      if(nowI>it.tEnd){ laserImpacts.splice(i,1); continue; }
      const prog = 1 - Math.max(0, (it.tEnd - nowI)/ (it.tEnd - it.t0));
      const x = it.x*scaleX, y = it.y*scaleY;
      // expanding ring
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='rgba(160,255,200,'+(0.8*(1-prog))+')';
      ctx.lineWidth = 2 + 6*prog;
      ctx.beginPath(); ctx.arc(x,y, 6 + 26*prog, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
      // sparks
      for(let s=0;s<6;s++){
        const ang = (s/6)*Math.PI*2;
        const len = 8 + prog*24;
        ctx.save(); ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle='rgba(180,255,220,'+(0.7*(1-prog))+')';
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(x,y);
        ctx.lineTo(x+Math.cos(ang)*len, y+Math.sin(ang)*len);
        ctx.stroke(); ctx.restore();
      }
    }
    // é£›å½ˆ
    for(const m of missiles){ for(const tr of (m.trail||[])){ const a=Math.max(0,1-(performance.now()-tr.t)/300); ctx.fillStyle=`rgba(255,180,90,${0.6*a})`; ctx.beginPath(); ctx.arc(tr.x*scaleX,tr.y*scaleY,2*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); } ctx.fillStyle='#ddd'; ctx.beginPath(); ctx.arc(m.x*scaleX,m.y*scaleY,4*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    // å¤©åœ°ç¿»è½‰æç¤ºåœ–ç¤ºï¼šç¿»è½‰é–‹å§‹å‰èˆ‡çµæŸå‰ 2 ç§’é¡¯ç¤ºå·¨å¤§ç¿»è½‰ç¬¦è™Ÿ
    {
      const tNow = performance.now();
      if(tNow < flipStartIndicatorUntil || (tNow >= flipEndIndicatorFrom && tNow < flipEndIndicatorUntil)){
        ctx.save();
        // åŠé€æ˜ï¼Œä¸é®æ“‹æ–¹å¡Š/çƒ/å¹³å°
        ctx.globalAlpha = 0.45;
        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        const fontSize = 160 * ((scaleX + scaleY) / 2);
        ctx.font = `${Math.round(fontSize)}px system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // ä½¿ç”¨é€†æ™‚é‡ç®­é ­ç¬¦è™Ÿ
        const symbol = 'âŸ²';
        ctx.fillText(symbol, canvas.width/2, canvas.height/2);
        ctx.restore();
      }
    }

    // æ‰è½é“å…·

    for(const p of powerups) drawPower(p);

    // é–å®šæ¡†
    drawLockBoxes();

    // ç²’å­
    for(let i=particles.length-1;i>=0;i--){ const P=particles[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.98; P.vy*=0.98; P.life-=16; if(P.life<=0){ particles.splice(i,1); continue; }
      const a=Math.max(0, Math.min(1, P.life/500)); ctx.fillStyle=P.color||`rgba(255,220,180,${a*0.6})`; ctx.beginPath(); ctx.arc(P.x*scaleX,P.y*scaleY,P.size*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    // å€’æ•¸æç¤º
    if(countdownShow>0){
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.font=`${Math.round(96*((scaleX+scaleY)/2))}px system-ui, sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(countdownShow), canvas.width/2, canvas.height/2);
      ctx.restore();
    }

    if(screenShake>0){ ctx.restore(); }
  }

  
  function speedForLevel(lv){
    // æ›´å¹³æ»‘çš„çƒé€Ÿæ›²ç·šï¼šå¾ baseSpeed ç·©æ…¢å¢é•·åˆ° +~3.2
    const base = getDiff().baseSpeed;
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const ease = t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2; // easeInOutQuad
    const extra = 0.6 + 2.6 * ease; // 0.6 -> 3.2
    return base + extra;
  }

  function resetBalls(center=true){ balls=[makeBall(false)]; const base=getDiff().baseSpeed; const speed=speedForLevel(level); const angle=(-60-Math.random()*60)*Math.PI/180;
    balls[0].x=center?1100/2:paddle.x+paddle.w/2; balls[0].y=700-70; balls[0].vx=Math.cos(angle)*speed; balls[0].vy=Math.sin(angle)*speed; balls[0].piercing=buffs.PIERCE.active; }

  function startCountdown(){
    paused=true; countdownShow=3; showCenter('', ''); centerNote.style.display='none'; // ç”¨ç•«é¢å€’æ•¸
    resumePending=true;
    const tick=()=>{
      if(countdownShow<=0){ resumePending=false; paused=false; stats.lifeStart=performance.now(); return; }
      beep(600 + (3-countdownShow)*100, 0.07, 0.05);
      setTimeout(()=>{ countdownShow--; if(countdownShow===0){ paused=false; } else { tick(); } }, 450);
    };
    tick();
  }


  function update(){
    const now=performance.now();

    // è‹¥å·²æ’¿å–ç¿»è½‰é“å…·ä½†å°šæœªé–‹å§‹ï¼Œç•¶é”åˆ°é å®šæ™‚é–“å‰‡é–‹å§‹ç¿»è½‰
    if(flipPending && now >= flipScheduledAt){
      flipPending = false;
      orientLeft = true;
      // å°‡æ“‹æ¿çš„ä½ç½®æ˜ å°„åˆ°å·¦å´å‚ç›´æ¨¡å¼ï¼šæ²¿è‘—æ©«å‘æ¯”ä¾‹å°æ‡‰åˆ°å‚ç›´é«˜åº¦
      const maxX = 1100 - paddle.w;
      const maxY = 700 - paddle.w;
      const ratio = (maxX > 0) ? (paddle.x / maxX) : 0;
      paddle.y = Math.max(0, Math.min(maxY, ratio * maxY));
      // é‡æ–°ç„æº–æ‰€æœ‰çƒåˆ°æ“‹æ¿ä¸­å¿ƒ
      aimBallsToPaddle();
    }
    // Buff éæœŸ
    for(const key of Object.keys(GAME_CONFIG.powers)){
      if(key==='LONG') continue; 
      const b = buffs[key];
      if (b && b.active && b.until && now > b.until){
        b.active=false;
        if(key==='PIERCE'){ for(const ball of balls) ball.piercing=false; }
        if(key==='STICKY'){ for(const ball of balls){ if(ball.stuck){ ball.stuck=false; ball.vy = -Math.abs(ball.vy||6); } } }
        if(key==='MEGA' && buffs.MEGA.applied){ for(const ball of balls){ ball.r/=GAME_CONFIG.powers.MEGA.mega.sizeMul; } buffs.MEGA.applied=false; }
        if(key==='FLIP'){
          // çµæŸç¿»è½‰ï¼šæ¢å¾©æ°´å¹³æ–¹å‘
          orientLeft=false;
          paddle.y=700-50;
          // å°‡çƒç„æº–å›æ“‹æ¿
          aimBallsToPaddle();
        }
      }
    }
    computePaddleWidth(); updateBuffBadges();

    
    // èè‹±ç£šæŠ€èƒ½ï¼šæ¯30ç§’ç™¼å°„ï¼Œç™¼å°„å‰èšæ°£2ç§’
    for(const b of bricks){ if(!b.elite) continue; if(b.eliteChargeUntil && now<b.eliteChargeUntil){ /* charging */ } else { if(!b.eliteNext) b.eliteNext = now+30000; if(now>=b.eliteNext){ b.eliteChargeUntil = now+2000; b.eliteNext = now+30000; setTimeout(()=>{ const idx = bricks.indexOf(b); if(idx!==-1){ spawnLionBeamFrom(b.x+b.w/2, b.y+b.h/2); } }, 2000); } } }
// éµç›¤ç§»å‹•ï¼šå¤©åœ°ç¿»è½‰æ™‚æ”¹ç‚ºä¸Šä¸‹ç§»å‹•ï¼ˆä»ä½¿ç”¨å·¦å³éµï¼‰
    if(!orientLeft){ if(performance.now()>paddleStunUntil){ if(keyL) paddle.x-=paddle.speed; if(keyR) paddle.x+=paddle.speed; } paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x)); }
    else{ if(performance.now()>paddleStunUntil){ if(keyL) paddle.y-=paddle.speed; if(keyR) paddle.y+=paddle.speed; } paddle.y=Math.max(0, Math.min(700-paddle.w, paddle.y)); }

    // é›·å°„ç™¼å°„
    if(buffs.LASER.active){
      const interval = GAME_CONFIG.powers.LASER.laser.intervalMs;
      if(!buffs.LASER.lastShot || now - buffs.LASER.lastShot >= interval){
        buffs.LASER.lastShot = now;
        const pr=paddleRect();
        const barrels = !orientLeft ? [{x:pr.x, y:pr.y+pr.h/2},{x:pr.x+pr.w, y:pr.y+pr.h/2}] : [{x:pr.x+pr.w/2, y:pr.y},{x:pr.x+pr.w/2, y:pr.y+pr.h}];
        for(const s of barrels){
          // é–å®šæœ€é çš„ç£šå¡Š
          let targetIdx=-1, best=-1; for(let i=0;i<bricks.length;i++){ const bk=bricks[i]; if(!canDestroyBrick(bk)) continue; const dx=(bk.x+bk.w/2)-s.x; const dy=(bk.y+bk.h/2)-s.y; const d=dx*dx+dy*dy; if(d>best){ best=d; targetIdx=i; } }
          if(targetIdx>=0){
            const t=bricks[targetIdx]; const tx=t.x+t.w/2, ty=t.y+t.h/2;
            laserBeams.push({x1:s.x,y1:s.y,x2:tx,y2:ty,until:now+200});
            laserImpacts.push({x:tx, y:ty, t0:now, tEnd:now+320});
            spawnParticles(tx,ty,'rgba(160,255,200,0.9)',10,1.8,2.2,2.6);
            destroyBrick(targetIdx);
          }
        }
      }
    }

    // å…¨å±€é€Ÿåº¦å€ç‡ï¼ˆGODSPEED æ™‚å¿½ç•¥å…¶å®ƒï¼‰
    function effectiveMul(){
      if(buffs.GODSPEED.active) return 1.0;
      let mul=1.0;
      if(buffs.SLOW.active){ mul*=(GAME_CONFIG.powers.SLOW.speedMul!=null ? GAME_CONFIG.powers.SLOW.speedMul : 1.0); }
      if(buffs.FAST.active){ mul*=(GAME_CONFIG.powers.FAST.globalSpeedMul!=null ? GAME_CONFIG.powers.FAST.globalSpeedMul : 1.0); }
      if(buffs.WAVY.active){ const w=GAME_CONFIG.powers.WAVY.wavy||{amp:0.6,base:1.2,periodMs:200}; const phase=(now-(buffs.WAVY.start||now))/(w.periodMs); mul*=(w.base+w.amp*Math.sin(phase)); }
      if(buffs.HELL.active){ mul*=(GAME_CONFIG.powers.HELL.hell.speedMul); }
      if(buffs.MEGA.active){ mul*=(GAME_CONFIG.powers.MEGA.mega.speedMul); }
      // å¤©åœ°ç¿»è½‰æœŸé–“ç¨å¾®æ”¾æ…¢çƒé€Ÿ
      if(buffs.FLIP.active){ mul *= 0.8; }
      return mul;
    }

    const mulGlobal=effectiveMul();

    // Boss èƒ½åŠ›æ’ç¨‹
    updateBossAbilities();
    for(const b of balls){
      if(b.rampageUntil && now>b.rampageUntil){ b.rampageUntil=0; if(!buffs.PIERCE.active) b.piercing=false; }

      // FREEZE ç‹€æ…‹
      if(b.freeze.state==='delay'){
        if(now - b.freeze.t0 >= b.freeze.delay){
          b.freeze.state = 'stopped';
          b.freeze.until = now + b.freeze.stop;
          b.vx = 0; b.vy = 0;
          spawnParticles(b.x,b.y,'rgba(230,247,255,0.9)',16,1.2,1.0,2.5);
        }
      }
      if(b.freeze.state==='stopped'){
        if(now < b.freeze.until){
          continue;
        }else{
          b.freeze.state = 'idle';
          let vx = b.freeze.oldVX, vy = b.freeze.oldVY;
          const tiny = Math.abs(vx)+Math.abs(vy) < 0.2;
          if(tiny){ vx = (Math.random()<0.5?-1:1) * 4; vy = -Math.max(4, speedForLevel(level)*0.8); }
          const sp = Math.max(4, Math.hypot(vx, vy));
          const ang = Math.atan2(vy, vx);
          b.vx = Math.cos(ang)*sp;
          b.vy = Math.sin(ang)*sp;
        }
      }

      if(b.stuck){ if(!orientLeft){ b.x=paddle.x+paddle.w/2+b.offsetX; b.y=paddle.y-b.r-0.1; } else { const pr=paddleRect(); b.x=pr.x+pr.w+b.r+0.1; b.y=pr.y+pr.h/2; } continue; }
      // ç§»å‹•
      let speedMul = mulGlobal;
      b.x+=b.vx*speedMul; b.y+=b.vy*speedMul;

      // GODSPEEDï¼šé€Ÿåº¦é–å®šåˆ°ä¸Šé™
      if(buffs.GODSPEED.active){
        const sp=Math.hypot(b.vx,b.vy); const cap=b.speedCap;
        if(sp<cap*0.98){ const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*cap; b.vy=Math.sin(ang)*cap; }
      }

      // ç‰†å£
      const r=b.r;
      if(!orientLeft){
        if(b.x-r<0){ b.x=r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
        if(b.y-r<0){ b.y=r; b.vy*=-1; beep(700,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
        if(b.y-r>700){
          // åº•éƒ¨ï¼šGODSPEED ä¸è½åœ° / SHIELD æ“‹ä¸€æ¬¡
          if(buffs.GODSPEED.active){ b.y=700-r; b.vy=-Math.abs(b.vy); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.y=700-r-1; b.vy=-Math.abs(b.vy); }
          else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; }
        }
      }else{
        // å·¦å´æ¨¡å¼ï¼šä¸Šä¸‹ç‚ºç‰†ï¼Œå·¦å´ç‚ºè½é»ï¼›GODSPEED ç„¡è½åœ°
        if(b.y-r<0){ b.y=r; b.vy*=-1; }
        if(b.y+r>700){ b.y=700-r; b.vy*=-1; }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; }
        if(b.x-r<0){
          if(buffs.GODSPEED.active){ b.x=r; b.vx=Math.abs(b.vx); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.x=r+1; b.vx=Math.abs(b.vx); }
          else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; }
        }
      }

      // æ“‹æ¿ç¢°æ’
      const pr=paddleRect();
      // æ“‹æ¿æœ‰ç©ºæ´ï¼šæ‹†æˆå…©æ®µ
      let hitPaddle=false;
      if(!orientLeft){
        const gap = buffs.HOLE.active ? pr.w/3 : 0;
        const l1=pr.x, r1=pr.x+pr.w*(gap?1/3:1);
        const l2=pr.x+pr.w*(gap?2/3:1), r2=pr.x+pr.w;
        const inSeg1 = (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l1 && b.x<=r1);
        const inSeg2 = gap? (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l2 && b.x<=r2):false;
        hitPaddle = inSeg1 || inSeg2;
      }else{
        const gap = buffs.HOLE.active ? pr.h/3 : 0;
        const t1=pr.y, b1=pr.y+pr.h*(gap?1/3:1);
        const t2=pr.y+pr.h*(gap?2/3:1), b2=pr.y+pr.h;
        const inSeg1 = (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t1 && b.y<=b1);
        const inSeg2 = gap? (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t2 && b.y<=b2):false;
        hitPaddle = inSeg1 || inSeg2;
      }
      if(hitPaddle){ stats.catches++;
        if(!orientLeft){
          const hitPos=(b.x-(pr.x+pr.w/2))/(pr.w/2); const sp=Math.min(Math.hypot(b.vx,b.vy)*1.02, b.speedCap); const angle=hitPos*(Math.PI/3);
          b.vx=Math.sin(angle)*sp; b.vy=-Math.cos(angle)*sp; b.y=pr.y-b.r-0.1;
        }else{
          const hitPos=(b.y-(pr.y+pr.h/2))/(pr.h/2); const sp=Math.min(Math.hypot(b.vx,b.vy)*1.02, b.speedCap); const angle=hitPos*(Math.PI/3);
          b.vx=Math.cos(angle)*sp; b.vy=Math.sin(angle)*sp; b.x=pr.x+pr.w+b.r+0.1;
        }
        beep(880,0.03); spawnParticles(b.x,b.y,'#caddff',8,1.3,1.5,2.5);
        if(buffs.STICKY.active){ b.stuck=true; b.offsetX= (!orientLeft) ? (b.x-(paddle.x+paddle.w/2)) : 0; }

        // MISSILEï¼šæ“‹æ¿å½ˆå‡ºæ™‚ç™¼å°„ä¸‰æš
        if(buffs.MISSILE.active){
          // å–æœ€è¿‘/ä¸­è·é›¢/æœ€é 
          const src={x:b.x,y:b.y};
          const candidates = bricks.map((bk,idx)=>({idx, d: (bk.x+bk.w/2-src.x)**2 + (bk.y+bk.h/2-src.y)**2 })).sort((a,b)=>a.d-b.d);
          const pickIdxs = [0, Math.floor(candidates.length/2), candidates.length-1].filter(i=>i>=0 && i<candidates.length);
          for(const i of pickIdxs){
            const targetObj = candidates[i];
            const targetId = (targetObj ? targetObj.idx : undefined);
            if(targetId==null) continue;
            const ang=Math.random()*Math.PI*2;
            missiles.push({x:src.x,y:src.y,vx:Math.cos(ang)*2,vy:Math.sin(ang)*2,targetId,lifeUntil:now+GAME_CONFIG.powers.MISSILE.missile.lifeMs,trail:[]});
            const ttt = bricks[targetId];
            if(ttt){ pushLockBox(ttt.x, ttt.y, ttt.w, ttt.h, 'target'); }
          }
        }

        // è¿½è¹¤çƒï¼šæ“‹æ¿å½ˆå‡ºå¾Œç„æº–ç›®æ¨™ç£šï¼ˆç¨ç«‹å„ªå…ˆï¼‰
        if(buffs.TRACK.active){
          function neighborCount(t){
            let cnt=0; const L=layout(); for(const o of bricks){ if(o===t) continue; const dx=Math.abs((o.x+o.w/2)-(t.x+t.w/2)); const dy=Math.abs((o.y+o.h/2)-(t.y+t.h/2)); const thx=brickW+L.pad+2, thy=brickH+L.pad+2; if(dx<=thx && dy<=thy) cnt++; } return cnt;
          }
          let best=null; for(const t of bricks){ if(t.unbreakable) continue; const iso=neighborCount(t); const d=Math.hypot((t.x+t.w/2)-b.x,(t.y+t.h/2)-b.y); const score=iso*1000 + d; if(best==null || score<best.score) best={t,score}; }
          const tx = best? (best.t.x+best.t.w/2) : (1100/2);
          const ty = best? (best.t.y+best.t.h/2) : (layout().top);
          const sp=Math.hypot(b.vx,b.vy); const ang=Math.atan2(ty-b.y, tx-b.x); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        
          if(best){ pushLockBox(best.t.x, best.t.y, best.t.w, best.t.h, 'target'); }
}
      }

      // ç¢°ç£š
      let hit=-1; for(let i=0;i<bricks.length;i++){ const bk=bricks[i]; if(b.x+r>bk.x && b.x-r<bk.x+bk.w && b.y+r>bk.y && b.y-r<bk.y+bk.h){ hit=i; break; } }
      if(hit>=0){
        const bk=bricks[hit]; const inRampage=b.rampageUntil && now<b.rampageUntil;
        // åå½ˆ
        const oL=(b.x+r)-bk.x, oR=(bk.x+bk.w)-(b.x-r), oT=(b.y+r)-bk.y, oB=(bk.y+bk.h)-(b.y-r); const m=Math.min(oL,oR,oT,oB);
        if(!inRampage && !b.piercing){
          if(m===oL){ b.x=bk.x-r; b.vx=-Math.abs(b.vx); } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=Math.abs(b.vx); } else if(m===oT){ b.y=bk.y-r; b.vy=-Math.abs(b.vy); } else { b.y=bk.y+bk.h+r; b.vy=Math.abs(b.vy); }
        }else{
          if(m===oL){ b.x=bk.x-r; b.vx=Math.abs(b.vx)||4; } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=-Math.abs(b.vx)||-4; } else if(m===oT){ b.y=bk.y-r; b.vy=Math.abs(b.vy)||4; } else { b.y=bk.y+bk.h+r; b.vy=-Math.abs(b.vy)||-4; }
          b.piercing=true;
        }

        // å¼·åå½ˆåŠ é€Ÿ
        if(bk.strong){ const sp=Math.min(Math.hypot(b.vx,b.vy)*1.08, b.speedCap); const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp; screenShake=Math.max(screenShake,3); }

        // ç‰¹æ•ˆè§¸ç™¼ï¼ˆGODSPEED æœŸé–“å¿½ç•¥ï¼‰
        if(!buffs.GODSPEED.active){
          if(buffs.PLASMA.active){ const cfg=GAME_CONFIG.powers.PLASMA.plasma; const ang=Math.random()*Math.PI*2; plasmas.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,vx:Math.cos(ang)*cfg.drift,vy:Math.sin(ang)*cfg.drift,until:now+cfg.lifeMs,radius:cfg.radius}); }
          if(buffs.FREEZE.active && (b.freeze.state==='idle' || !b.freeze.state)){ const f=GAME_CONFIG.powers.FREEZE.freeze; b.freeze.state = 'delay'; b.freeze.t0 = now; b.freeze.delay = f.delayMs; b.freeze.stop = f.stopMs; b.freeze.oldVX = b.vx; b.freeze.oldVY = b.vy; }
          if(buffs.HOLY.active){ holyFlashes.push({x:bk.x+bk.w/2, y:bk.y+bk.h/2, until:now+350}); for(let i=bricks.length-1;i>=0;i--){ const t=bricks[i]; const sameRow=Math.abs(t.y-bk.y)<1; const sameCol=Math.abs(t.x-bk.x)<1; if(sameRow||sameCol){ destroyBrick(i); } } screenShake=Math.max(screenShake,4); }
          if(buffs.CHAIN.active){ bk.lockedUntil = now + GAME_CONFIG.powers.CHAIN.chain.lockMs; }
          if(buffs.HELL.active){ blackHoles.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,until:now+GAME_CONFIG.powers.HELL.hell.haloMs}); destroyNeighbors(hit); destroyBrick(hit); }
        }

        // ç•¶å‰ç£šæ‰£è¡€ï¼ˆè‹¥å·²åœ¨ä¸Šé¢è¢«è™•ç†å‰‡ç•¥éï¼‰
        if(!buffs.HELL.active && !buffs.HOLY.active){
          // é–éˆä¸­ä¸å—å‚·å®³
          if(!(bk.lockedUntil && now<bk.lockedUntil)){
            bk.hp=(bk.hp||1)-1; score+=10; updateHUD();
            if(bk.hp<=0){
              const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
              revealBrickArea(bk);
              if(Math.random()<dropRateForLevel(level)) spawnPower(cx-12,cy);
              if(bk.explosive){ explodeAt(cx,cy); } else { bricks.splice(hit,1); }
            }
          }
        }

        // è¿½è¹¤çƒï¼šæ’ç£šå¾Œç„æº–æ“‹æ¿ä¸­å¿ƒ
        if(buffs.TRACK.active){
          const pr=paddleRect(); const tx = pr.x + (orientLeft? (pr.w + 60) : pr.w/2); const ty = pr.y + pr.h/2;
          const sp=Math.hypot(b.vx,b.vy); const ang=Math.atan2(ty-b.y, tx-b.x); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        
          pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
}

        beep(520+Math.random()*200,0.03,0.05);
      }

      // å®‰å…¨ä¿åº•é€Ÿåº¦
      const sp2 = Math.hypot(b.vx,b.vy);
      if(sp2 < 0.2 && !b.stuck && b.freeze.state==='idle'){
        b.vx = (Math.random()<0.5?-1:1) * 4;
        b.vy = -Math.max(4, speedForLevel(level)*0.8);
      }
    }

    // é£›å½ˆæ›´æ–°
    for(let i=missiles.length-1;i>=0;i--){
      const m=missiles[i];
      if(now>m.lifeUntil){ missiles.splice(i,1); continue; }
      // ç›®æ¨™ä½ç½®
      const t=bricks[m.targetId];
      if(!t){ missiles.splice(i,1); continue; }
      const tx=t.x+t.w/2, ty=t.y+t.h/2;
      const ang=Math.atan2(ty-m.y, tx-m.x);
      const sp=GAME_CONFIG.powers.MISSILE.missile.speed;
      // è½‰å‘
      const curAng=Math.atan2(m.vy, m.vx);
      let diff=ang-curAng; while(diff>Math.PI) diff-=2*Math.PI; while(diff<-Math.PI) diff+=2*Math.PI;
      const maxTurn=GAME_CONFIG.powers.MISSILE.missile.turn;
      const newAng = curAng + Math.max(-maxTurn, Math.min(maxTurn, diff));
      m.vx=Math.cos(newAng)*sp; m.vy=Math.sin(newAng)*sp;
      m.x+=m.vx; m.y+=m.vy;
      (m.trail||(m.trail=[])).push({x:m.x,y:m.y,t:now}); if(m.trail.length>20) m.trail.shift();
      // å‘½ä¸­åˆ¤å®š
      if(m.x>t.x && m.x<t.x+t.w && m.y>t.y && m.y<t.y+t.h){
        destroyBrick(m.targetId); missiles.splice(i,1); spawnParticles(m.x,m.y,'#ffbb66',12,1.8,2.2,3);
      }
    }

    // çƒå…¨æ²’äº†
    if(balls.length===0){ const nowL=performance.now(); if(stats.lifeStart){ const dur=(nowL-stats.lifeStart)/1000; if(dur<stats.fastestDeath) stats.fastestDeath=dur; if(dur>stats.longestLife) stats.longestLife=dur; } stats.livesUsed++;
      lives--; updateHUD();
      if(lives<=0){ running=false; paused=true; showGameOver(); return; }
      else { resetBalls(false); startCountdown(); return; }
    }

    // æ‰è½é“å…·ç§»å‹•/æ’¿å–
    for(let i=powerups.length-1;i>=0;i--){
      const p=powerups[i];
      // æ ¹æ“šå¤©åœ°ç¿»è½‰ç‹€æ…‹ç§»å‹•è† å›Šï¼šæ°´å¹³æ¨¡å¼å‘ä¸‹æ‰è½ï¼Œç¿»è½‰æ™‚å¾€å·¦ç§»å‹•
      if(!orientLeft){
        p.y += p.vy;
      }else{
        p.x -= p.vy;
      }
      const pr=paddleRect();
      const hit = (!orientLeft) ? (p.y+p.h>=pr.y && p.x+p.w>=pr.x && p.x<=pr.x+pr.w && p.y<=pr.y+pr.h) : (p.x+p.w>=pr.x && p.x<=pr.x+pr.w && p.y+p.h>=pr.y && p.y<=pr.y+pr.h);
      if(hit){ applyPower(p.type); powerups.splice(i,1); continue; }
      // ç§»å‡ºé‚Šç•Œå³æ¶ˆå¤±
      if(!orientLeft){
        if(p.y>710) powerups.splice(i,1);
      }else{
        if(p.x + p.w < 0) powerups.splice(i,1);
      }
    }

    // å¤©ç©ºå®šæ™‚æ‰è½
    if(performance.now() >= nextSkyDropAt){ spawnBeneficialAtTop(); scheduleNextSkyDrop(); }
    // è‹¥è¶…é 10 ç§’æ²’æœ‰ç²å¾—ä»»ä½•å¢ç›Šï¼Œå¾å¤©ç©ºéš¨æ©Ÿæ‰è½ä¸€å€‹å¢ç›Š
    if(!paused && running){
      if(now - lastBuffObtainedAt >= 10000){
        spawnBeneficialAtTop();
        lastBuffObtainedAt = now;
      }
    }

    // æ¸…é—œï¼ˆé€²å…¥ç•«å»Šæˆ–é€šé—œï¼‰
    if(!hasBreakables()){
      paused=true; running=false;
      if(level>=GAME_CONFIG.totalLevels){
        finalScore.textContent=String(score);
          const el=document.getElementById('statsWin'); if(el) el.innerHTML = renderStatsHtml();
        ring.innerHTML='';
        for(let i=1;i<=GAME_CONFIG.totalLevels;i++){
          const im=getLevelImage(i);
          const th=document.createElement('img'); th.src=im.src; ring.appendChild(th);
        }
        win.classList.add('show');
        ensureAudio(); if(audioCtx){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(659, audioCtx.currentTime); g.gain.value=0.04; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.frequency.value=880; }, 200); setTimeout(()=>{ o.stop(); }, 600); }
      }else{
        galleryImg.src=getLevelImage(level).src;
        gallery.style.display='flex'; requestAnimationFrame(()=>gallery.classList.add('show'));
        const proceed=()=>{ gallery.classList.remove('show'); setTimeout(()=>{ gallery.style.display='none'; gallery.removeEventListener('click',proceed); },200); level++; updateHUD(); initBricks(); resetBalls(); paused=true; running=false; applyBGMThemeForLevel(); showCenter(`é€²å…¥é—œå¡ ${level}`,'æŒ‰ Space æˆ–é»ç•«é¢é–‹å§‹'); };
        gallery.addEventListener('click',proceed,{once:true}); return;
      }
    }
  }


  function loop(){ if(!paused && running) update(); draw(); requestAnimationFrame(loop); }
  function boot(){
    resetGame(); updateHUD(); loop();
    // è‡ªå‹•è®€å–éŸ³æ•ˆ/BGMåå¥½
    soundsOn = (localStorage.getItem('sfx_on')||'0')==='1'; soundBtn.textContent=`éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`;
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.7'); bgmVol.value=String(v);
    bgmOn = (localStorage.getItem('bgm_on')||'0')==='1'; bgmBtn.textContent = bgmOn?'é–‹':'é—œ';
    // è‹¥æœ‰å­˜æª”çµ¦æç¤º
    const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4');
    if(raw){ setTimeout(()=>{ if(confirm('åµæ¸¬åˆ°å­˜æª”ï¼Œè¦è®€å–é€²åº¦å—ï¼Ÿ')) loadProgress(); }, 400); }

    // æœªè‡ªå‹•å•Ÿå‹•éŠæˆ²ï¼›ç©å®¶éœ€æŒ‰ Space æˆ–é»æ“Šç•«é¢é–‹å§‹
  }
  validateConfig();
  try{ boot(); }catch(e){
    // æ•æ‰éŒ¯èª¤ï¼šåœ¨éƒ¨åˆ†ç€è¦½å™¨ä¸Šå¯èƒ½ä¸æ”¯æ´å¯é¸éˆçµï¼Œæ”¹ç”¨å‚³çµ±åˆ¤æ–·
    window.__lastError = (e && e.stack) ? e.stack : String(e);
    console.error(e);
  }
  // Expose global error handler to help surface any uncaught errors after initialization. This updates the document
  // title with the line number where the error occurred and stores the error in window.__lastError for inspection.
  window.onerror = function(msg, url, line, col, err){
    try{
      document.title = 'ERR@' + line;
    }catch(ignored){}
    window.__lastError = err || msg;
    return false;
  };
})();
</script>
</body>
</html>
