<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æ‰“ç£šå¡Š Breakoutï¼ˆé€²éšé›»è…¦ç‰ˆ v4 Â· ç¾è¡“å¼·åŒ–ï¼‰</title>
  <style>
    :root {
      --bg:#0b1022; --bg2:#0a0f1e; --fg:#e9ecf1; --accent:#66b2ff;
      --brick1:#ff6b6b; --brick2:#ffd166; --brick3:#06d6a0; --brick4:#4cc9f0;
      --expl:#ff8c00; --power:#7aa2ff; --debuff:#ff6aa3;
      --glass: rgba(255,255,255,.06); --glass-stroke: rgba(255,255,255,.12);
      --btn:#1a2448; --btn-stroke:#2a3974; --pill:#121a36;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 800px at 50% -10%, #152040, #0a0f1e 60%); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;}
    .wrap{display:flex; gap:16px; align-items:center; justify-content:center; flex-direction:column; padding:20px}
    h1{margin:6px 0 0 0; font-weight:800; letter-spacing:.3px; text-shadow:0 2px 20px #0008}
    .hud{
      position:sticky; top:0; z-index:2;
      display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; font-weight:650;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--glass-stroke); border-radius:14px; padding:10px 12px;
      box-shadow: 0 6px 24px rgba(0,0,0,.25); backdrop-filter: blur(6px);
    }
    .pill{padding:8px 12px; background:var(--pill); border:1px solid var(--glass-stroke); border-radius:999px}
    .btn{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg);
      border:1px solid var(--btn-stroke); border-radius:10px; padding:8px 12px; cursor:pointer; user-select:none}
    .btn:active{transform:translateY(1px)}
    select{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg); border:1px solid var(--btn-stroke); border-radius:8px; padding:6px 10px}
    canvas{background:linear-gradient(180deg, #0d1126, #0b1022 55%, #091022);
      border:1px solid #1a2348; border-radius:14px; max-width:min(1120px, 96vw); width: min(1120px, 96vw); height: auto; display:block;
      box-shadow: 0 30px 80px rgba(0,0,0,.35), inset 0 0 120px rgba(255,255,255,.02);}
    .tip{opacity:.92}
    .overlay{position:relative}
    .center-note{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none}
    .note-box{background:linear-gradient(180deg, rgba(8,12,28,.9), rgba(8,12,28,.85));
      border:1px solid var(--glass-stroke); padding:18px 22px; border-radius:14px; text-align:center; max-width:min(90vw,820px);
      box-shadow: 0 12px 60px rgba(0,0,0,.5);}
    .note-box h2{margin:0 0 8px 0}
    .note-box p{margin:6px 0; line-height:1.6}
    kbd{background:#0e1836; border:1px solid #2a356a; border-radius:6px; padding:2px 6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:90%}
    .badges{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center}
    .badge{background:linear-gradient(180deg, rgba(18,32,68,.9), rgba(10,20,48,.9));
      border:1px solid var(--glass-stroke); padding:4px 10px; border-radius:999px; font-size:12px; display:flex; gap:6px; align-items:center}
    .legend{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center; font-size:13px}
    .legend .box{width:14px; height:14px; display:inline-block; border-radius:3px; margin-right:4px; vertical-align:middle}
    .legend .item{padding:4px 8px; border-radius:10px; background:rgba(255,255,255,.05); border:1px solid var(--glass-stroke)}
    .emoji{filter: drop-shadow(0 2px 2px rgba(0,0,0,.35));}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>æ‰“ç£šå¡Š Breakoutï¼ˆé€²éšé›»è…¦ç‰ˆ v4 Â· ç¾è¡“å¼·åŒ–ï¼‰</h1>
    <div class="hud">
      <div class="pill">åˆ†æ•¸ <span id="score">0</span></div>
      <div class="pill">é—œå¡ <span id="level">1</span></div>
      <div class="pill">ç”Ÿå‘½ <span id="lives">3</span></div>
      <label>é›£åº¦
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </label>
      <button class="btn" id="pauseBtn">é–‹å§‹ / æš«åœ (<kbd>Space</kbd>)</button>
      <button class="btn" id="resetBtn">é‡é–‹ (<kbd>R</kbd>)</button>
      <button class="btn" id="fsBtn">å…¨è¢å¹• (<kbd>F</kbd>)</button>
      <button class="btn" id="soundBtn">éŸ³æ•ˆï¼šé—œ</button>
      <button class="btn" id="saveBtn">å­˜æª”</button>
      <button class="btn" id="loadBtn">è®€æª”</button>
      <button class="btn" id="clearSaveBtn">æ¸…é™¤å­˜æª”</button>
    </div>

    <div class="legend">
      <span class="item"><span class="box" style="background:var(--expl)"></span>çˆ†ç‚¸ç£š</span>
      <span class="item"><span class="box" style="background:var(--brick2)"></span>ä¸€èˆ¬ç£š</span>
      <span class="item"><span class="box" style="background:var(--power)"></span>å¢ç›Šé“å…·</span>
      <span class="item"><span class="box" style="background:var(--debuff)"></span>æ¸›ç›Šé“å…·</span>
    </div>
    <div class="badges" id="activeBuffs"></div>

    <div class="overlay">
      <canvas id="game" width="1100" height="700"></canvas>
      <div class="center-note" id="centerNote">
        <div class="note-box">
          <h2 id="noteTitle">æŒ‰ <kbd>Space</kbd> æˆ–é»ç•«é¢é–‹å§‹</h2>
          <p id="noteText">
            æ¯å€‹é“å…·éƒ½æœ‰è¦–è¦ºç‰¹æ•ˆï¼ˆæŸ”å’Œã€ä¸åˆºçœ¼ï¼‰ï¼š<br>
            <b>RAMPAGE</b>ğŸ”¥æ®˜å½±ï¼‹è¼ªå»“æ»‘è¡Œã€<b>PIERCE</b>âœ¨è—è‰²æ‹–å°¾ã€<b>WIDE/LONG</b>â†”ï¸ å¹³å°å…‰æšˆã€<b>STICKY</b>ğŸ§² å¹³å°ç£åŠ›ç‡ˆã€<b>SLOW</b>ğŸ¢ è—è‰²è–„éœ§ã€
            <b>FAST</b>âš¡ ç´…æ©™æ‹–å°¾è„ˆè¡ã€<b>WAVY</b>ã€°ï¸ çƒé«”æ³¢ç´‹ã€<b>SHIELD</b>ğŸ›¡ åº•éƒ¨è­·ç›¾å…‰å¸¶ã€<b>EXPL</b>ğŸ’¥ çˆ†ç‚¸ç²’å­ã€‚<br>
            æ“ä½œï¼š<kbd>â†</kbd>/<kbd>â†’</kbd> æˆ– <kbd>A</kbd>/<kbd>D</kbd>ï¼›æ»‘é¼ å·¦å³ç§»å‹•ä¹Ÿå¯ã€‚Space æš«åœ/é–‹å§‹ï¼ŒR é‡é–‹ï¼ŒF å…¨è¢å¹•ã€‚
          </p>
        </div>
      </div>
    </div>

    <div class="tip">ä»‹é¢æ¡ç”¨ç»ç’ƒè³ªæ„Ÿ HUDã€æŸ”å’Œå…‰æšˆèˆ‡å¾®ç²’æ•ˆæœï¼›è‹¥æ•ˆèƒ½ä¸è¶³å¯å‘Šè¨´æˆ‘ï¼Œæˆ‘å‡ºã€Œä½é…ç‰ˆã€çµ¦ä½ ã€‚</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const livesEl = document.getElementById('lives');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const fsBtn = document.getElementById('fsBtn');
  const soundBtn = document.getElementById('soundBtn');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const clearSaveBtn = document.getElementById('clearSaveBtn');
  const centerNote = document.getElementById('centerNote');
  const noteTitle = document.getElementById('noteTitle');
  const noteText = document.getElementById('noteText');
  const difficultySel = document.getElementById('difficulty');
  const activeBuffsEl = document.getElementById('activeBuffs');

  // DPR scaling
  function resizeCanvasDPR() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const cssW = canvas.clientWidth;
    const cssH = Math.round(cssW * (700/1100));
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    scaleX = canvas.width / 1100;
    scaleY = canvas.height / 700;
  }
  let scaleX=1, scaleY=1;
  window.addEventListener('resize', resizeCanvasDPR);
  resizeCanvasDPR();

  // Game state
  let running = false;
  let paused = true;
  let level = 1;
  let score = 0;
  let lives = 3;
  let soundsOn = false;
  let mouseControl = true;

  // Particles
  const particles = []; // {x,y,vx,vy,life,color,size}
  function spawnParticles(x,y,color,count=10,spread=1.6,speed=3,size=3){
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const v = speed*(.4 + Math.random());
      particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:400+Math.random()*300,color,size:size*(.6+Math.random()*0.8)});
    }
  }

  // Background grid / vignette parameters
  let bgTime = 0;

  // Buffs/Debuffs
  const buffs = {
    WIDE:{active:false, until:0, dur:15000},
    STICKY:{active:false, until:0, dur:12000},
    MULTI:{active:false, until:0, dur:0},
    SLOW:{active:false, until:0, dur:8000},
    PIERCE:{active:false, until:0, dur:8000},
    SHIELD:{active:false, until:0, dur:0},
    RAMPAGE:{active:false, until:0, dur:3000},
    FAST:{active:false, until:0, dur:10000},
    WAVY:{active:false, until:0, dur:10000, start:0},
    LONG:{active:false, until:0, dur:15000, stacks:[]}
  };

  function badgeIcon(k){
    return {
      WIDE:'â†”ï¸', STICKY:'ğŸ§²', MULTI:'âœ¨', SLOW:'ğŸ¢', PIERCE:'ğŸ¯', SHIELD:'ğŸ›¡',
      RAMPAGE:'ğŸ”¥', FAST:'âš¡', WAVY:'ã€°ï¸', LONG:'ğŸ“'
    }[k] || 'â—';
  }

  function updateBuffBadges(){
    activeBuffsEl.innerHTML = '';
    const now = performance.now();
    const labels = {
      WIDE:'WIDE', STICKY:'STICKY', MULTI:'MULTI', SLOW:'SLOW', PIERCE:'PIERCE', SHIELD:'SHIELD',
      RAMPAGE:'RAMPAGE', FAST:'FAST', WAVY:'WAVY', LONG:'LONGÃ—'+buffs.LONG.stacks.filter(t=>t>now).length
    };
    for (const [k, b] of Object.entries(buffs)){
      if (k!=='LONG' && !b.active) continue;
      if (k==='LONG' && buffs.LONG.stacks.filter(t=>t>now).length===0) continue;
      const left = (k==='LONG')
        ? Math.max(0, Math.max(...buffs.LONG.stacks.filter(t=>t>now).map(t=>t-now), 0)/1000).toFixed(1)+'s'
        : (b.dur ? Math.max(0, ((b.until - now)/1000)).toFixed(1)+'s' : '');
      const span = document.createElement('span');
      span.className = 'badge';
      span.textContent = `${badgeIcon(k)} ${labels[k]}${left?' '+left:''}`;
      activeBuffsEl.appendChild(span);
    }
  }

  // Difficulty
  const diffs = {
    easy:   { paddleW: 180, baseSpeed: 5, rowsBase: 5, dropRate: 0.22 },
    normal: { paddleW: 150, baseSpeed: 6, rowsBase: 6, dropRate: 0.18 },
    hard:   { paddleW: 120, baseSpeed: 7, rowsBase: 7, dropRate: 0.14 },
  };
  let diff = diffs[difficultySel.value];

  // Paddle
  const paddle = { w: diff.paddleW, h: 18, x: 1100/2 - diff.paddleW/2, y: 700 - 50, speed: 12 };

  // Balls
  let balls = [];
  function makeBall(stuck=false, x=null){
    const b = { x: x??(1100/2), y: 700/2, r: 10, vx: 5, vy: -5, speedCap: 16, piercing:false, stuck:stuck, offsetX:0, rampageUntil:0, trail:[] };
    return b;
  }

  // Audio
  const audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
  function beep(freq=600, dur=0.05, vol=0.06){
    if (!soundsOn || !audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square'; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); }, Math.max(10, dur*1000));
  }

  // Bricks
  let bricks = [];
  let brickW = 0, brickH = 28;
  function layout(){
    return { rows: diffs[difficultySel.value].rowsBase + Math.floor((level-1)%3), cols: 12, pad: 9, top: 80, h: 28 };
  }
  function initBricks() {
    const L = layout();
    const totalPad = (L.cols+1) * L.pad;
    brickW = Math.floor((1100 - totalPad) / L.cols);
    brickH = L.h;
    bricks = [];
    for (let r=0;r<L.rows;r++){
      for (let c=0;c<L.cols;c++){
        const x = L.pad + c*(brickW + L.pad);
        const y = L.top + r*(brickH + L.pad);
        const hp = 1 + Math.floor((level-1)/3);
        const explosive = Math.random() < 0.10;
        bricks.push({x,y,w:brickW,h:brickH,hp:explosive ? 1 : hp,colorIdx:(r%4), explosive});
      }
    }
  }

  function explodeAt(cx, cy){
    const radius = Math.max(brickW, brickH) * 1.3;
    for (let i=bricks.length-1; i>=0; i--){
      const b = bricks[i];
      const bx = b.x + b.w/2, by = b.y + b.h/2;
      const d = Math.hypot(bx - cx, by - cy);
      if (d <= radius){
        bricks.splice(i,1);
        score += 10;
        spawnParticles(bx,by,'#ffdd99', 14, 1.7, 2.6, 3);
      }
    }
    spawnParticles(cx,cy,'#ffbb55', 24, 2.1, 3.2, 4);
    updateHUD();
    beep(200,0.08,0.08);
  }

  // Power-ups
  const powerups = []; // {x,y,w,h,vy,type,isDebuff,phase}
  const POWER_TYPES = ['WIDE','STICKY','MULTI','SLOW','PIERCE','SHIELD','RAMPAGE','LONG','FAST','WAVY'];
  function spawnPower(x,y){
    const type = POWER_TYPES[Math.floor(Math.random()*POWER_TYPES.length)];
    powerups.push({x:x, y:y, w:24, h:16, vy:2.2, type, isDebuff:(type==='FAST'||type==='WAVY'), phase:Math.random()*Math.PI*2});
  }

  function applyPower(type){
    const now = performance.now();
    switch(type){
      case 'WIDE':
        buffs.WIDE.active = true; buffs.WIDE.until = now + buffs.WIDE.dur;
        break;
      case 'STICKY':
        buffs.STICKY.active = true; buffs.STICKY.until = now + buffs.STICKY.dur;
        break;
      case 'MULTI':
        if (balls.length < 3){
          const newBalls = [];
          for (const b of balls){ const b1 = {...b}; b1.trail = []; newBalls.push(b1); }
          balls = balls.concat(newBalls);
        }
        break;
      case 'SLOW':
        buffs.SLOW.active = true; buffs.SLOW.until = now + buffs.SLOW.dur;
        break;
      case 'PIERCE':
        buffs.PIERCE.active = true; buffs.PIERCE.until = now + buffs.PIERCE.dur;
        for (const b of balls) b.piercing = true;
        break;
      case 'SHIELD':
        buffs.SHIELD.active = true;
        break;
      case 'RAMPAGE':
        buffs.RAMPAGE.active = true; buffs.RAMPAGE.until = now + buffs.RAMPAGE.dur;
        for (const b of balls){ b.rampageUntil = now + 3000; b.piercing = true; }
        break;
      case 'LONG':
        const actives = buffs.LONG.stacks.filter(t=>t>now);
        if (actives.length < 2){
          buffs.LONG.stacks.push(now + buffs.LONG.dur);
        } else {
          const idx = buffs.LONG.stacks.indexOf(Math.min(...actives));
          buffs.LONG.stacks[idx] = now + buffs.LONG.dur;
        }
        break;
      case 'FAST':
        buffs.FAST.active = true; buffs.FAST.until = now + buffs.FAST.dur;
        // small screenshake cue
        screenShake = 6;
        break;
      case 'WAVY':
        buffs.WAVY.active = true; buffs.WAVY.until = now + buffs.WAVY.dur; buffs.WAVY.start = now;
        break;
    }
    updateBuffBadges();
  }

  function drawPower(p){
    const color = p.isDebuff ? getVar('--debuff') : getVar('--power');
    const x = p.x*scaleX, y = p.y*scaleY, w = p.w*scaleX, h = p.h*scaleY;
    // pill with soft highlight and wobble
    const wobble = Math.sin(p.phase)*1.5;
    p.phase += 0.04;
    ctx.save();
    ctx.translate(0, wobble);
    const grd = ctx.createLinearGradient(x, y, x, y+h);
    grd.addColorStop(0, color);
    grd.addColorStop(1, p.isDebuff ? '#a33' : '#3a56a8');
    ctx.fillStyle = grd;
    roundedRect(x, y, w, h, 8);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,.25)';
    ctx.stroke();
    // label
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.max(10, Math.round(12*scaleY))}px ui-monospace, monospace`;
    ctx.textAlign = 'center'; ctx.textBaseline='middle';
    ctx.fillText(p.type[0], x + w/2, y + h/2 + 0.5);
    ctx.restore();
  }

  function resetBalls(center=true) {
    balls = [makeBall(false)];
    const base = diffs[difficultySel.value].baseSpeed;
    const speed = base + Math.min(level*0.5, 4);
    const angle = (-60 - Math.random()*60) * Math.PI/180;
    balls[0].x = center ? 1100/2 : paddle.x + paddle.w/2;
    balls[0].y = 700 - 70;
    balls[0].vx = Math.cos(angle)*speed;
    balls[0].vy = Math.sin(angle)*speed;
    balls[0].piercing = buffs.PIERCE.active;
  }

  function updateHUD(){ scoreEl.textContent = score; levelEl.textContent = level; livesEl.textContent = lives; }

  function showCenter(title, text){ noteTitle.textContent = title; noteText.innerHTML = text; centerNote.style.display = 'flex'; }
  function hideCenter(){ centerNote.style.display = 'none'; }

  function resetGame(load=false){
    diff = diffs[difficultySel.value];
    level = load ? level : 1; score = load ? score : 0; lives = load ? lives : 3;
    updateHUD();
    initBricks(); resetBalls();
    paused = true; running = false;
    for (const k of Object.keys(buffs)){ buffs[k].active=false; buffs[k].until=0; }
    buffs.LONG.stacks = [];
    powerups.length = 0;
    particles.length = 0;
    updateBuffBadges();
    computePaddleWidth();
    paddle.x = 1100/2 - paddle.w/2;
    showCenter('æŒ‰ Space æˆ–é»ç•«é¢é–‹å§‹', 'ç”¨ â†/â†’ æˆ– A/D ç§»å‹•ï¼›æ»‘é¼ å·¦å³ç§»å‹•ä¹Ÿå¯ã€‚');
  }

  // Save / Load
  function saveProgress(){
    try{
      const data = { level, score, lives, difficulty: difficultySel.value };
      localStorage.setItem('breakout_save_v4', JSON.stringify(data));
      alert('å·²å­˜æª”ï¼');
    }catch(e){ alert('å­˜æª”å¤±æ•—ï¼š' + e); }
  }
  function loadProgress(){
    try{
      const raw = localStorage.getItem('breakout_save_v4') || localStorage.getItem('breakout_save_v3') || localStorage.getItem('breakout_save_v2');
      if (!raw){ alert('æ²’æœ‰å­˜æª”'); return; }
      const data = JSON.parse(raw);
      difficultySel.value = data.difficulty || 'normal';
      level = data.level||1; score = data.score||0; lives = data.lives||3;
      resetGame(true);
      updateHUD();
      alert(`å·²è®€æª”ï¼šç­‰ç´š ${level}ï¼Œåˆ†æ•¸ ${score}ï¼Œç”Ÿå‘½ ${lives}`);
    }catch(e){ alert('è®€æª”å¤±æ•—ï¼š' + e); }
  }
  function clearSave(){ localStorage.removeItem('breakout_save_v4'); localStorage.removeItem('breakout_save_v3'); localStorage.removeItem('breakout_save_v2'); alert('å·²æ¸…é™¤å­˜æª”'); }

  // Input
  let keyL=false, keyR=false;
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keyL = true;
    if (e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') keyR = true;
    if (e.code === 'Space'){ togglePause(); }
    if (e.key === 'r' || e.key === 'R'){ resetGame(); }
    if (e.key === 'f' || e.key === 'F'){ toggleFullscreen(); }
    if (e.key === ' ' && buffs.STICKY.active){
      for (const b of balls){ if (b.stuck){ b.stuck=false; b.vy = -Math.abs(b.vy||6); } }
    }
  });
  window.addEventListener('keyup', (e)=>{
    if (e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keyL = false;
    if (e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') keyR = false;
  });

  // Mouse move
  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (1100 / rect.width);
    if (mouseControl) paddle.x = Math.max(0, Math.min(1100 - paddle.w, x - paddle.w/2));
  });
  canvas.addEventListener('click', ()=>{ if (!running || paused) { running = true; paused = false; hideCenter(); } });

  pauseBtn.addEventListener('click', ()=>togglePause());
  resetBtn.addEventListener('click', ()=>resetGame());
  fsBtn.addEventListener('click', ()=>toggleFullscreen());
  soundBtn.addEventListener('click', ()=>{
    soundsOn = !soundsOn;
    soundBtn.textContent = `éŸ³æ•ˆï¼š${soundsOn ? 'é–‹' : 'é—œ'}`;
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    beep(880,0.06,0.05);
  });
  difficultySel.addEventListener('change', ()=>{ resetGame(); });
  saveBtn.addEventListener('click', saveProgress);
  loadBtn.addEventListener('click', loadProgress);
  clearSaveBtn.addEventListener('click', clearSave);

  function togglePause(){
    if (!running){ running = true; paused = false; hideCenter(); return; }
    paused = !paused; if (paused) showCenter('å·²æš«åœ', 'æŒ‰ Space æˆ–é»ç•«é¢ç¹¼çºŒ'); else hideCenter();
  }

  async function toggleFullscreen(){
    const elem = document.documentElement;
    try{
      if (!document.fullscreenElement){
        await elem.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    }catch(e){ console.warn('Fullscreen failed:', e); }
  }

  // Helpers
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawRoundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo((x+r)*scaleX, y*scaleY);
    ctx.arcTo((x+w)*scaleX, y*scaleY, (x+w)*scaleX, (y+h)*scaleY, r*scaleX);
    ctx.arcTo((x+w)*scaleX, (y+h)*scaleY, x*scaleX, (y+h)*scaleY, r*scaleX);
    ctx.arcTo(x*scaleX, (y+h)*scaleY, x*scaleX, y*scaleY, r*scaleX);
    ctx.arcTo(x*scaleX, y*scaleY, (x+w)*scaleX, y*scaleY, r*scaleX);
    ctx.closePath();
  }
  function brickColor(idx){ return [getVar('--brick1'), getVar('--brick2'), getVar('--brick3'), getVar('--brick4')][idx%4]; }
  function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  function computePaddleWidth(){
    const now = performance.now();
    buffs.LONG.stacks = buffs.LONG.stacks.filter(t=>t>now);
    const longStacks = Math.min(2, buffs.LONG.stacks.length);
    const base = diffs[difficultySel.value].paddleW;
    const addWide = buffs.WIDE.active ? 50 : 0;
    const addLong = longStacks * 40;
    const newW = Math.min(300, base + addWide + addLong);
    const center = paddle.x + paddle.w/2;
    paddle.w = newW;
    paddle.x = Math.max(0, Math.min(1100 - paddle.w, center - paddle.w/2));
  }

  function speedMultiplier(now){
    let mul = 1.0;
    if (buffs.SLOW.active) mul *= 0.8;
    if (buffs.FAST.active) mul *= 3.0;
    if (buffs.WAVY.active){
      const phase = (now - (buffs.WAVY.start||now)) / 200;
      const osc = 1.2 + 0.6*Math.sin(phase);
      mul *= osc;
    }
    return mul;
  }

  // Screen shake (subtle)
  let screenShake = 0;

  function drawBackground(){
    // subtle animated grid + vignette
    const w = canvas.width, h = canvas.height;
    bgTime += 0.003;
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.translate(Math.sin(bgTime)*8, Math.cos(bgTime*0.7)*6);
    const step = 40;
    for (let x=0;x<w;x+=step){
      ctx.fillStyle = 'rgba(255,255,255,.03)';
      ctx.fillRect(x, 0, 1, h);
    }
    for (let y=0;y<h;y+=step){
      ctx.fillStyle = 'rgba(255,255,255,.025)';
      ctx.fillRect(0, y, w, 1);
    }
    ctx.restore();
    // vignette
    const grad = ctx.createRadialGradient(w/2,h*0.2,0,w/2,h*0.5,Math.max(w,h));
    grad.addColorStop(0,'rgba(0,0,0,0)');
    grad.addColorStop(1,'rgba(0,0,0,0.35)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);
    // slow overlay
    if (buffs.SLOW.active){
      ctx.fillStyle = 'rgba(80,140,255,0.08)';
      ctx.fillRect(0,0,w,h);
    }
  }

  function draw(){
    // shake
    if (screenShake > 0){
      const s = screenShake * 0.6;
      ctx.save();
      ctx.translate((Math.random()-0.5)*s, (Math.random()-0.5)*s);
      screenShake *= 0.9;
    }

    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();

    // paddle
    // glow color by buffs: sticky -> teal; wide/long -> accent glow
    const padGlow = buffs.STICKY.active ? 'rgba(120,230,220,.6)' : ( (buffs.WIDE.active || buffs.LONG.stacks.length) ? 'rgba(120,170,255,.6)' : 'rgba(200,210,255,.4)');
    ctx.shadowColor = padGlow; ctx.shadowBlur = 20;
    ctx.fillStyle = '#9aaeff';
    drawRoundedRect(paddle.x, paddle.y, paddle.w, paddle.h, 8); ctx.fill();
    ctx.shadowBlur = 0;

    // bottom shield aura
    if (buffs.SHIELD.active){
      const g = ctx.createLinearGradient(0,(700-10)*scaleY,0,700*scaleY);
      g.addColorStop(0,'rgba(120,220,255,0.35)'); g.addColorStop(1,'rgba(120,220,255,0.05)');
      ctx.fillStyle = g;
      ctx.fillRect(0, (700-10)*scaleY, canvas.width, 10*scaleY);
    }

    // balls + trails
    for (const b of balls){
      const now = performance.now();
      // maintain trail
      b.trail.push({x:b.x, y:b.y, t:now});
      while (b.trail.length > 12) b.trail.shift();
      // draw trail
      for (let i=b.trail.length-1;i>=0;i--){
        const p = b.trail[i];
        const age = (now - p.t)/200;
        if (age>1) continue;
        const alpha = (1-age) * 0.6;
        const color = ( (b.rampageUntil && now < b.rampageUntil) || b.piercing ) ? `rgba(120,220,255,${alpha})`
             : (buffs.FAST.active ? `rgba(255,140,90,${alpha})` : `rgba(255,255,255,${alpha*0.6})`);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p.x*scaleX, p.y*scaleY, (b.r*0.7)*((scaleX+scaleY)/2), 0, Math.PI*2);
        ctx.fill();
      }
      // ball body
      const bx = b.x * scaleX, by = b.y * scaleY, br = b.r * (scaleX+scaleY)/2;
      const grad = ctx.createRadialGradient(bx-3, by-4, 2, bx, by, br);
      const tail = (b.rampageUntil && now < b.rampageUntil);
      grad.addColorStop(0, '#fff');
      grad.addColorStop(1, (b.piercing||tail) ? '#9ff' : (buffs.FAST.active ? '#ff9a66' : '#cbd4ff'));
      ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI*2); ctx.fill();

      // wavy ripple
      if (buffs.WAVY.active){
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        const r1 = br + 2 + 2*Math.sin((now/100)+b.x*0.02);
        ctx.beginPath(); ctx.arc(bx, by, r1, 0, Math.PI*2); ctx.stroke();
      }

      // sticky indicator
      if (b.stuck){
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.fillRect((paddle.x + paddle.w/2 - 12)*scaleX, (paddle.y-6)*scaleY, 24*scaleX, 4*scaleY);
      }
    }

    // bricks (with subtle inner highlight)
    for (const b of bricks){
      const base = b.explosive ? getVar('--expl') : brickColor(b.colorIdx);
      const g = ctx.createLinearGradient((b.x)*scaleX, (b.y)*scaleY, (b.x)*scaleX, (b.y+b.h)*scaleY);
      g.addColorStop(0, base);
      g.addColorStop(1, '#1a1f3a');
      ctx.fillStyle = g;
      drawRoundedRect(b.x, b.y, b.w, b.h, 6); ctx.fill();
      // hp bar
      if (b.hp > 1){
        ctx.fillStyle = 'rgba(0,0,0,.25)';
        ctx.fillRect((b.x+4)*scaleX, (b.y+b.h-6)*scaleY, (b.w-8)*scaleX, 4*scaleY);
        ctx.fillStyle = 'rgba(255,255,255,.75)';
        const ratio = Math.max(0,(b.hp-1))/3;
        ctx.fillRect((b.x+4)*scaleX, (b.y+b.h-6)*scaleY, (b.w-8)*ratio*scaleX, 4*scaleY);
      }
    }

    // power-ups
    for (const p of powerups) drawPower(p);

    // particles
    for (let i=particles.length-1;i>=0;i--){
      const P = particles[i];
      P.x += P.vx; P.y += P.vy; P.vx *= 0.98; P.vy *= 0.98; P.life -= 16;
      if (P.life<=0){ particles.splice(i,1); continue; }
      const a = Math.max(0, Math.min(1, P.life/500));
      ctx.fillStyle = `rgba(255,220,180,${a*0.6})`;
      ctx.beginPath(); ctx.arc(P.x*scaleX, P.y*scaleY, P.size*((scaleX+scaleY)/2), 0, Math.PI*2); ctx.fill();
    }

    if (screenShake > 0){
      ctx.restore();
    }
  }

  function update(){
    const now = performance.now();

    // Buff timers
    for (const [k, b] of Object.entries(buffs)){
      if (k==='LONG') continue;
      if (b.active && b.dur && now > b.until){
        b.active = false;
        if (k === 'PIERCE'){ for (const ball of balls) ball.piercing = false; }
      }
    }
    computePaddleWidth();
    updateBuffBadges();

    if (keyL) paddle.x -= paddle.speed;
    if (keyR) paddle.x += paddle.speed;
    paddle.x = Math.max(0, Math.min(1100 - paddle.w, paddle.x));

    // Move balls
    const mulGlobal = speedMultiplier(now);
    for (const b of balls){
      if (b.rampageUntil && now > b.rampageUntil){ b.rampageUntil = 0; if (!buffs.PIERCE.active) b.piercing = false; }
      if (b.stuck){ b.x = paddle.x + paddle.w/2 + b.offsetX; b.y = paddle.y - b.r - 0.1; continue; }
      b.x += b.vx * mulGlobal;
      b.y += b.vy * mulGlobal;

      // Walls
      if (b.x - b.r < 0){ b.x = b.r; b.vx *= -1; beep(780,0.03); spawnParticles(b.x,b.y,'#99bbff',5,1.2,1.2,2); }
      if (b.x + b.r > 1100){ b.x = 1100 - b.r; b.vx *= -1; beep(780,0.03); spawnParticles(b.x,b.y,'#99bbff',5,1.2,1.2,2); }
      if (b.y - b.r < 0){ b.y = b.r; b.vy *= -1; beep(700,0.03); spawnParticles(b.x,b.y,'#99bbff',5,1.2,1.2,2); }

      // Bottom
      if (b.y - b.r > 700){
        if (buffs.SHIELD.active){
          buffs.SHIELD.active = false; b.y = 700 - b.r - 1; b.vy = -Math.abs(b.vy);
        }else{
          const idx = balls.indexOf(b); if (idx>=0) balls.splice(idx,1);
          break;
        }
      }

      // Paddle collision
      if (b.y + b.r >= paddle.y && b.y + b.r <= paddle.y + paddle.h &&
          b.x >= paddle.x && b.x <= paddle.x + paddle.w && b.vy > 0){
        const hitPos = (b.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
        const speed = Math.min(Math.hypot(b.vx, b.vy) * 1.02, b.speedCap);
        const angle = hitPos * (Math.PI/3);
        b.vx = Math.sin(angle) * speed; b.vy = -Math.cos(angle) * speed;
        b.y = paddle.y - b.r - 0.1;
        beep(880,0.03);
        spawnParticles(b.x, b.y, '#caddff', 8, 1.3, 1.5, 2.5);
        if (buffs.STICKY.active){ b.stuck = true; b.offsetX = b.x - (paddle.x + paddle.w/2); }
      }

      // Brick collisions
      let hit = -1;
      for (let i=0;i<bricks.length;i++){
        const bk = bricks[i];
        if (b.x + b.r > bk.x && b.x - b.r < bk.x + bk.w && b.y + b.r > bk.y && b.y - b.r < bk.y + bk.h){ hit = i; break; }
      }
      if (hit >= 0){
        const bk = bricks[hit];
        const inRampage = b.rampageUntil && now < b.rampageUntil;
        if (!inRampage && !b.piercing){
          const overlapL = (b.x + b.r) - bk.x;
          const overlapR = (bk.x + bk.w) - (b.x - b.r);
          const overlapT = (b.y + b.r) - bk.y;
          const overlapB = (bk.y + bk.h) - (b.y - b.r);
          const minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);
          if (minOverlap === overlapL) { b.x = bk.x - b.r; b.vx = -Math.abs(b.vx); }
          else if (minOverlap === overlapR) { b.x = bk.x + bk.w + b.r; b.vx = Math.abs(b.vx); }
          else if (minOverlap === overlapT) { b.y = bk.y - b.r; b.vy = -Math.abs(b.vy); }
          else { b.y = bk.y + bk.h + b.r; b.vy = Math.abs(b.vy); }
        } else if (inRampage){
          const overlapL = (b.x + b.r) - bk.x;
          const overlapR = (bk.x + bk.w) - (b.x - b.r);
          const overlapT = (b.y + b.r) - bk.y;
          const overlapB = (bk.y + bk.h) - (b.y - b.r);
          const minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);
          if (minOverlap === overlapL) { b.x = bk.x - b.r; b.vx = Math.abs(b.vx)||4; }
          else if (minOverlap === overlapR) { b.x = bk.x + bk.w + b.r; b.vx = -Math.abs(b.vx)||-4; }
          else if (minOverlap === overlapT) { b.y = bk.y - b.r; b.vy = Math.abs(b.vy)||4; }
          else { b.y = bk.y + bk.h + b.r; b.vy = -Math.abs(b.vy)||-4; }
          b.piercing = true;
        }
        bk.hp = (bk.hp||1) - 1; score += 10; updateHUD();
        spawnParticles(b.x, b.y, '#ffd9a0', 7, 1.4, 1.8, 2);
        if (bk.hp <= 0){
          const cx = bk.x + bk.w/2, cy = bk.y + bk.h/2;
          if (Math.random() < diff.dropRate) spawnPower(cx-12, cy);
          if (bk.explosive) explodeAt(cx, cy);
          bricks.splice(hit,1);
        }
        beep(520 + Math.random()*200, 0.03, 0.05);
      }
    }

    // If no balls left
    if (balls.length === 0){
      lives--; updateHUD();
      if (lives <= 0){
        running = false; paused = true;
        showCenter('éŠæˆ²çµæŸ', `åˆ†æ•¸ï¼š${score}<br>æŒ‰ Space æˆ–é»ç•«é¢å†ä¾†ä¸€å±€ï¼Œæˆ–æŒ‰ R é‡é–‹ã€‚`);
        return;
      } else {
        resetBalls(false); paused = true;
        showCenter('å¤±å»ä¸€æ¢å‘½', 'æŒ‰ Space æˆ–é»ç•«é¢ç¹¼çºŒ');
        return;
      }
    }

    // Power-ups falling
    for (let i=powerups.length-1; i>=0; i--){
      const p = powerups[i];
      p.y += p.vy;
      if (p.y + p.h >= paddle.y && p.x + p.w >= paddle.x && p.x <= paddle.x + paddle.w && p.y <= paddle.y + paddle.h){
        applyPower(p.type);
        powerups.splice(i,1);
        continue;
      }
      if (p.y > 710) powerups.splice(i,1);
    }

    // Particles decay handled in draw

    // Level clear
    if (bricks.length === 0){
      level++; updateHUD();
      try{ localStorage.setItem('breakout_save_v4', JSON.stringify({level, score, lives, difficulty: difficultySel.value})); }catch(e){}
      initBricks(); resetBalls();
      paused = true; showCenter(`é€²å…¥é—œå¡ ${level}`, 'æŒ‰ Space æˆ–é»ç•«é¢é–‹å§‹');
    }
  }

  function loop(){ if (!paused && running) update(); draw(); requestAnimationFrame(loop); }

  // Boot
  function boot(){
    resetGame();
    loop();
    const raw = localStorage.getItem('breakout_save_v4') || localStorage.getItem('breakout_save_v3') || localStorage.getItem('breakout_save_v2');
    if (raw){
      setTimeout(()=>{
        if (confirm('åµæ¸¬åˆ°å­˜æª”ï¼Œè¦è®€å–é€²åº¦å—ï¼Ÿ')) loadProgress();
      }, 400);
    }
  }
  boot();
})();
</script>

<script>
let gameStarted = false;

window.addEventListener("keydown", function (e) {
  if (!gameStarted && (e.code === "Space" || e.key === " ")) {
    startGame();
  }
});

window.addEventListener("click", function () {
  if (!gameStarted) {
    startGame();
  }
});

function startGame() {
  gameStarted = true;
  requestAnimationFrame(gameLoop);
}
</script>

</body>
</html>
