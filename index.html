<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rock打磚塊 Breakout（最終增強版）</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
  <style>
    /* 全面換用全新 UI 風格（取自 index_skin.html） */
    :root{
      --ink:#eaf2ff; --muted:#b8c7ea;
      --glass-1:rgba(255,255,255,.08); --glass-2:rgba(255,255,255,.06);
      --stroke:rgba(140,180,255,.28);
      --bg1:#13224a; --bg2:#081022;
      --hudGrad1:rgba(20,25,44,.62); --hudGrad2:rgba(12,20,42,.44);
      --stageGlass:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
      --panelPattern:none;
      --btnGlow:0 0 0 rgba(0,0,0,0);
      --hudBottom:96px;
      --heartGlow: rgba(0,0,0,0);
      /* 保留原本磚塊與道具顏色 */
      --brick1:#ff6b6b; --brick2:#ffd166; --brick3:#06d6a0; --brick4:#4cc9f0;
      --expl:#ff8c00; --power:#7aa2ff; --debuff:#ff6aa3;
      --glass-stroke:rgba(255,255,255,.12);
    }
    html,body{
      height:100%; margin:0; color:var(--ink);
      background: radial-gradient(140% 140% at 50% -12%, var(--bg1) 0%, #0e1a3a 50%, #0b1633 75%, var(--bg2) 100%);
      font-family: ui-sans-serif, -apple-system, system-ui, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:0 12px 24px}
    header{
      padding:calc(8px + env(safe-area-inset-top)) 0 10px;
      display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:space-between
    }
    h1{font-size:clamp(16px,2.6vw,22px);margin:0 8px 0 0;letter-spacing:.4px;opacity:.95}
    .small{font-size:12px;color:var(--muted)}

    /* HUD 與 UI */
    .hud{
      position:sticky;top:0;z-index:30;
      display:grid;gap:8px;align-items:center;
      grid-template-columns:1fr;max-width:min(1080px,96vw);margin:8px auto 0;
      border:1px solid var(--stroke);
      border-radius:18px;padding:10px;
      background:linear-gradient(180deg,var(--hudGrad1),var(--hudGrad2));
      backdrop-filter: blur(8px);
      box-shadow:0 6px 28px rgba(0,0,0,.28)
    }
    .stats{display:grid;grid-template-columns:auto auto 1fr;grid-auto-rows:minmax(36px,auto);gap:8px 10px;align-items:center}
    .stats .wide{grid-column:1 / -1}
    .pill{
      padding:8px 18px;border:1px solid var(--stroke);
      background:var(--glass-2);border-radius:999px;
      min-height:36px;display:flex;align-items:center;gap:10px;
      color:#d7e3ff;font-weight:650;font-size:15px
    }
    .pill b{color:#fff;font-variant-numeric:tabular-nums}
    .inline-controls{justify-self:end;display:flex;gap:8px;align-items:center;position:relative}
    .ic-btn{
      width:48px;height:36px;border-radius:12px;border:1px solid var(--stroke);
      background:radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.16), rgba(255,255,255,0) 58%), var(--glass-1);
      display:grid;place-items:center;cursor:pointer;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.05), 0 8px 20px rgba(0,0,0,.28), var(--btnGlow);
      color:#fff
    }
    .ic-btn:active{transform:translateY(1px)}
    .ic-btn .ico{font-size:18px;line-height:1}
    .menu{
      position:absolute;top:46px;right:0;min-width:280px;padding:10px;
      border:1px solid var(--stroke);border-radius:14px;
      background:rgba(12,18,36,.96);backdrop-filter:blur(10px);
      transform:scale(.96);opacity:0;pointer-events:none;transition:.16s ease;z-index:60
    }
    .menu.show{transform:scale(1);opacity:1;pointer-events:auto}
    .menu .item{display:flex;align-items:center;gap:10px;padding:10px;border:1px solid var(--stroke);border-radius:10px;background:var(--glass-2);margin-bottom:8px}
    .menu h4{margin:6px 0 8px;font-size:13px;color:#cfe0ff}
    .btn{
      padding:8px 12px;border-radius:10px;border:1px solid var(--stroke);cursor:pointer;
      background:var(--glass-2);color:#fff;box-shadow:var(--btnGlow)
    }
    .level-select{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .level-select select{
      min-width:120px;
      color:#d7e3ff;
    }
    .level-select select option{
      background:#0b1633;
      color:#d7e3ff;
    }
    .level-select select option.boss-level{
      color:#ffb347;
      font-weight:800;
      background:rgba(255,155,74,.22);
    }
    .level-select select.boss-selected{
      color:#ffb347;
      font-weight:700;
    }
    select,input[type="range"]{background:var(--glass-2);color:#fff;border:1px solid var(--stroke);border-radius:8px;padding:6px 10px}
    /* Buffs & Prompts */
    #buffs{
      position:sticky;z-index:22;
      top:calc(var(--hudBottom) + 6px);
      display:flex;align-items:center;
      max-width:min(1080px,96vw);margin:6px auto 0;padding-left:6px;
      overflow:auto;scrollbar-width:none;
      --buff-scale:1;
      font-size:calc(12px * var(--buff-scale));
      gap:calc(8px * var(--buff-scale));
    }
    #buffs::-webkit-scrollbar{display:none}
    #buffs .badge{
      display:inline-flex;align-items:center;
      gap:calc(8px * var(--buff-scale));
      padding:calc(6px * var(--buff-scale)) calc(10px * var(--buff-scale));
      border:1px solid var(--stroke);border-radius:999px;
      background:var(--glass-1);font-size:1em;white-space:nowrap;color:#cfe0ff
    }
    #playArea{
      position:relative;
      max-width:min(1080px,96vw);
      margin:12px auto 0;
      padding-top:72px;
    }
    #promptsDock{
      position:absolute;left:0;right:0;top:0;z-index:20;
      display:flex;gap:8px;justify-content:center;padding:0 6px;
      overflow:hidden;
    }
    #promptsDock .prompt{
      flex:1 1 calc((100% - 16px)/3);
      max-width:calc((100% - 16px)/3);
      min-width:0;height:48px;
      padding:8px 10px;border:1px solid var(--stroke);border-radius:12px;
      background:linear-gradient(180deg,var(--glass-1),var(--glass-2));
      backdrop-filter:blur(6px);
      box-shadow:0 8px 20px rgba(0,0,0,.3);
      font-size:12px;line-height:1.45;color:#eaf2ff;white-space:normal;
      word-break:break-word;overflow-wrap:anywhere;
      display:flex;align-items:center;justify-content:center;text-align:center;
      opacity:1;transition:opacity .4s
    }
    #promptsDock .prompt.fade{opacity:0}
    @media (min-width:768px){
      #playArea{padding-top:0;display:flex;gap:12px;align-items:flex-start;}
      #promptsDock{
        position:absolute;top:0;left:-200px;right:auto;width:180px;
        flex-direction:column;justify-content:flex-start;
      }
      #promptsDock .prompt{
        width:100%;height:60px;flex:none;
      }
    }
    /* Stage */
    .stage{position:relative;margin:0 auto 0;max-width:100%;border-radius:18px;padding:12px;box-sizing:border-box;background:var(--stageGlass);background-image:var(--panelPattern);background-blend-mode:overlay;}
    canvas#game{background:linear-gradient(180deg,#0d132a,#0b1226 55%, #091223);border:1px solid rgba(80,110,170,.45);border-radius:16px;display:block;width:100%;height:auto;margin:0 auto;box-shadow:inset 0 0 160px rgba(255,255,255,.03), 0 28px 90px rgba(0,0,0,.46);touch-action:none;}
    .legend{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;font-size:12px;color:#cfe0ff;margin-top:6px}
    .legend .item{padding:4px 8px;border-radius:10px;background:rgba(255,255,255,.05);border:1px solid var(--stroke);display:flex;align-items:center;gap:4px}
    .legend .box{width:14px;height:14px;border-radius:3px;display:inline-block;vertical-align:middle}
    .sealed{opacity:0.4;filter:grayscale(100%)}
    .unlockHint{font-size:0.8em;color:#f88;margin-left:4px;}
    #combo{
      position:absolute;
      top:8px;
      right:12px;
      font-size:19px;
      font-family:'Playfair Display',serif;
      font-weight:700;
      text-transform:none;
      font-variant-caps:normal;
      pointer-events:none;
      opacity:0;
      transform-origin:top right;
      transition:opacity .4s,transform .2s;
      text-shadow:0 1px 0 rgba(0,0,0,.6),0 2px 0 rgba(0,0,0,.6),0 3px 0 rgba(0,0,0,.5),0 4px 3px rgba(0,0,0,.7);
    }
    #combo.show{opacity:1}
    #combo.tier1{color:#ffffff}
    #combo.tier2{color:#00ff7f}
    #combo.tier3{color:#00bfff}
    #combo.tier4{color:#8a2be2}
    #combo.tier5{color:#ff69b4}
    #combo.tier6{color:#ffd700}
    #combo.glow{animation:goldBlink 1s infinite}
    #combo.pop{animation:comboPop .5s}
    #combo.glow.pop{animation:goldBlink 1s infinite,comboPop .5s}
    #combo.star{animation:comboStarGlow 1s linear infinite}
    #combo.star.pop{animation:comboStarGlow 1s linear infinite,comboPop .5s}
    @keyframes comboStarGlow{
      0%{color:#ff4d6d;text-shadow:0 0 8px #ff4d6d,0 0 16px #ff4d6d}
      25%{color:#ffd166;text-shadow:0 0 8px #ffd166,0 0 16px #ffd166}
      50%{color:#06d6a0;text-shadow:0 0 8px #06d6a0,0 0 16px #06d6a0}
      75%{color:#4cc9f0;text-shadow:0 0 8px #4cc9f0,0 0 16px #4cc9f0}
      100%{color:#ff4d6d;text-shadow:0 0 8px #ff4d6d,0 0 16px #ff4d6d}
    }
    #comboNotice{
      position:absolute;left:0;right:0;top:0;z-index:30;
      overflow:hidden;pointer-events:none;
      font-family:'Playfair Display',serif;font-weight:700;font-size:24px;
      color:#fff;text-shadow:0 2px 4px rgba(0,0,0,.6);
      opacity:0;transition:opacity 3s;
      display:flex;align-items:center;justify-content:center;
    }
    #comboNotice.show{opacity:1}
    #comboNotice.fade{opacity:0}
    #comboNotice .marqueeText{white-space:nowrap;display:inline-block;animation:comboMarquee 5s linear;}
    @keyframes comboPop{0%{transform:scale(.3) rotate(-15deg);}60%{transform:scale(1.4) rotate(10deg);}80%{transform:scale(.9) rotate(-5deg);}100%{transform:scale(1) rotate(0);}}
    @keyframes goldBlink{0%{text-shadow:0 0 6px rgba(255,215,0,.7);}50%{text-shadow:0 0 18px rgba(255,215,0,1);}100%{text-shadow:0 0 6px rgba(255,215,0,.7);}}
    @keyframes comboMarquee{0%{transform:translateX(100%);}100%{transform:translateX(-100%);}}
    /* Hearts and Nine-cat history */
    .hearts{filter:drop-shadow(0 0 10px var(--heartGlow));display:inline-block}
    .hearts.compact .life-icon{width:14px;height:14px}
    .fire-energy{margin-left:6px;display:none;color:#ffb347;font-weight:700;filter:drop-shadow(0 0 6px #ff8c00)}
    .cats{display:flex;margin-left:auto;gap:4px}
    .cats .cat-icon{width:14px;height:14px;display:inline-block}
    /* Gallery and overlay (retain original styles) */
    .overlay{position:fixed;inset:0;z-index:40;pointer-events:none}
    .gallery{position:absolute;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;z-index:4;pointer-events:auto}
    .gallery .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.75);opacity:0;transition:opacity .6s;}
    .gallery img{max-width:min(94vw,1040px);max-height:min(88vh,680px);border-radius:16px;box-shadow:0 30px 120px rgba(0,0,0,.6);opacity:0;transform:translateY(12px) scale(.98);transition:opacity .6s, transform .6s;}
    .gallery .hint{position:absolute;bottom:24px;color:#fff;font-size:16px;opacity:0;text-shadow:0 2px 10px rgba(0,0,0,.6);}
    .gallery.show .backdrop{opacity:1;}
    .gallery.show img{opacity:1;transform:translateY(0) scale(1);} 
    .gallery.show .hint{opacity:.9;}
    .gallery .dialog,
    .gallery-page .viewer .dialog{position:absolute;left:50%;transform:translateX(-50%);bottom:60px;background:rgba(0,0,0,.6);color:#fff;padding:12px 20px;border-radius:12px;font-size:18px;max-width:90%;text-align:center;display:none;z-index:2;}
    .gallery-page .viewer .options{position:absolute;left:50%;transform:translateX(-50%);bottom:20px;display:flex;gap:8px;z-index:2;}
    .gallery-page .viewer .options button.locked{filter:grayscale(1);opacity:0.5;cursor:default;}

    /* Gallery page overlay */
    .gallery-page{position:fixed;inset:0;display:none;z-index:70;align-items:center;justify-content:center;pointer-events:auto}
    .gallery-page .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.8)}
    .gallery-page .content{position:relative;z-index:2;width:min(96vw,1080px);max-height:92vh;display:flex;flex-direction:column;background:linear-gradient(180deg,rgba(10,14,30,.95),rgba(10,14,30,.88));border:1px solid var(--glass-stroke);border-radius:16px;padding:12px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .gallery-page .close{align-self:flex-end;cursor:pointer;font-size:24px;line-height:1}
    .gallery-page .thumbs{flex:1 1 auto;display:grid;grid-template-columns:repeat(5,1fr);gap:8px;overflow:auto;padding:4px}
    .gallery-page .thumb{position:relative;border:1px solid var(--stroke);border-radius:10px;overflow:hidden;cursor:pointer;aspect-ratio:1/1}
    .gallery-page .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .gallery-page .thumb.locked{cursor:default;filter:grayscale(1) brightness(.3)}
    .gallery-page .thumb.locked::after{content:'\1F512';position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:32px;background:rgba(0,0,0,.6)}
    .gallery-page .nav{display:flex;gap:12px;justify-content:center;padding-top:8px}
    .gallery-page .viewer{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.85);z-index:3}
    .gallery-page .viewer img{max-width:94vw;max-height:88vh;border-radius:16px;box-shadow:0 30px 120px rgba(0,0,0,.6)}

    /* Leaderboard overlay */
    .rank-page{position:fixed;inset:0;display:none;z-index:75;align-items:center;justify-content:center;pointer-events:auto}
    .rank-page .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.8)}
    .rank-page .content{position:relative;z-index:2;width:min(96vw,960px);max-height:92vh;display:flex;flex-direction:column;background:linear-gradient(180deg,rgba(10,14,30,.95),rgba(10,14,30,.88));border:1px solid var(--glass-stroke);border-radius:16px;padding:12px;box-shadow:0 20px 90px rgba(0,0,0,.5);overflow:auto;min-width:0}
    .rank-page .close{align-self:flex-end;cursor:pointer;font-size:24px;line-height:1}
    .rank-page table{width:100%;border-collapse:collapse;font-size:14px;margin-top:4px}
    .rank-page th,.rank-page td{border:1px solid var(--stroke);padding:4px 6px;text-align:center}
    @media (max-width: 600px){
      .rank-page table{font-size:12px;}
      .rank-page th,.rank-page td{padding:2px 4px;}
    }
    @media (max-width: 420px){
      .rank-page table{font-size:10px;}
    }

    /* Win and Game Over overlays */
    .win{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:6;pointer-events:auto}
    .win.show{display:flex;}
    .gameover{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:8;pointer-events:auto}
    .gameover.show{display:flex;}
    .gameover .backdrop{position:absolute;inset:0;background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .gameover .center{position:relative;z-index:2;text-align:center;background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75));padding:18px 22px;border:1px solid var(--glass-stroke);border-radius:16px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .win .backdrop{position:absolute;inset:0;background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .thumb-ring{position:absolute;inset:16px;pointer-events:none;display:grid;grid-template-columns:repeat(10,1fr);gap:6px;opacity:.95}
    .thumb-ring img{width:100%;height:100%;object-fit:cover;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,.5);}
    .win .center{position:relative;z-index:2;text-align:center;background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75));padding:18px 22px;border:1px solid var(--glass-stroke);border-radius:16px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .win h2{margin:4px 0 6px;font-size:28px;letter-spacing:2px}
    .win .small{opacity:.8;font-size:12px;margin-top:6px}
    .win .again{margin-top:10px}
    /* Note box */
    .center-note{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:auto;z-index:3}
    .note-box{background:linear-gradient(180deg, rgba(8,12,28,.9), rgba(8,12,28,.85));border:1px solid var(--glass-stroke);padding:16px 18px;border-radius:14px;text-align:center;max-width:min(90vw,860px);max-height:90vh;overflow:auto;box-shadow:0 12px 60px rgba(0,0,0,.5);font-size:14px;position:relative}
    .note-box h2{margin:0 0 8px 0;font-size:18px}
    .note-box p{margin:6px 0;line-height:1.6}
    @media (max-width:480px){
      .note-box{font-size:12px;}
      .note-box h2{font-size:16px;}
    }
    kbd{background:#0e1836;border:1px solid #2a356a;border-radius:6px;padding:2px 6px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:90%}
    .note-close{
      position:absolute;top:8px;right:8px;width:28px;height:28px;border-radius:999px;
      display:grid;place-items:center;cursor:pointer;user-select:none;
      border:1px solid var(--glass-stroke);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), rgba(255,255,255,.02));
      box-shadow: 0 6px 16px rgba(0,0,0,.25);
      color:#d7dcff;font-weight:800;line-height:1;
    }
    .note-close:hover{filter:brightness(1.1);}
    .note-close:active{transform:translateY(1px);}
    @media (max-width:390px){
      .pill{font-size:14px;padding:7px 14px}
      .ic-btn{width:44px;height:36px}
    }

  

/* === 修正下拉選單：避免全白看不到選項文字 === */
select { color: #fff; background: var(--glass-2); }
/* 強制下拉清單的選項可見（不同瀏覽器可能各自處理，但這能改善多數情況） */
select option { color: #0b1022; background: #eaf2ff; }
select optgroup { color: #0b1022; }
/* 菜單內的 select 維持深色外觀，但選單展開的選項仍是深字淺底 */
.menu select { color: #eaf2ff; background: rgba(20,28,52,.6); border:1px solid var(--stroke); }
.menu select option { color: #0b1022; background: #eaf2ff; }


/* === Canvas FX 層：在遊戲畫布下層繪製霓虹光束與彩虹暈 === */
.stage{position:relative}
.stage #fx{
  position:absolute; inset:12px; border-radius:16px; display:block; width:calc(100% - 24px); height:auto;
  pointer-events:none; filter: blur(0.2px);
}
.stage{--fxViz:0}

    /* === 科技．魅影幻彩（朦朧紫黑七彩霓虹） === */
    body[data-skin="科技．魅影幻彩"]{
      --ink:#f3e8ff;
      --muted:#d6c3ff;
      --stroke:rgba(200,160,255,.4);
      --bg1:#140022;
      --bg2:#05000c;
      --hudGrad1:rgba(30,10,60,.62);
      --hudGrad2:rgba(20,6,40,.44);
      --glass-1:rgba(255,255,255,.1);
      --glass-2:rgba(255,255,255,.07);
      --stageGlass:linear-gradient(180deg, rgba(80,40,120,.04), rgba(0,0,0,0));
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(160,80,255,.25);
    }
    body[data-skin="科技．魅影幻彩"] .stage{--fxViz:0}

    /* === 科技．賽博格綠（高質感賽博特效） === */
    body[data-skin="科技．賽博格綠"]{
      --ink:#eafff3;
      --muted:#aee4c8;
      --stroke:rgba(180,255,200,.4);
      --bg1:#02190f;
      --bg2:#00150a;
      --hudGrad1:rgba(0,40,20,.62);
      --hudGrad2:rgba(0,30,15,.44);
      --glass-1:rgba(255,255,255,.1);
      --glass-2:rgba(255,255,255,.07);
      --stageGlass:linear-gradient(180deg, rgba(0,50,30,.05), rgba(0,0,0,0));
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(30,200,100,.25);
    }
    body[data-skin="科技．賽博格綠"] .stage{--fxViz:0}

    /* === 宇宙．星辰絮語 === */
    body[data-skin="宇宙．星辰絮語"]{ --ink:#eef0ff; --muted:#c9c9ff; --stroke:rgba(160,140,255,.34); --bg1:#0c0b24; --bg2:#09081a; --hudGrad1:rgba(30,24,70,.58); --hudGrad2:rgba(20,18,50,.44); --glass-1:rgba(200,180,255,.10); --glass-2:rgba(160,140,255,.08); --stageGlass:linear-gradient(180deg, rgba(160,140,255,.05), rgba(0,0,0,0)); --panelPattern:radial-gradient(120px 80px at 20% 10%, rgba(110,80,255,.08), transparent 60%), radial-gradient(160px 120px at 80% 20%, rgba(180,100,255,.08), transparent 60%); --btnGlow:0 0 22px rgba(150,120,255,.25); }

    /* === 冰雪．極光絲綢 === */
    body[data-skin="冰雪．極光絲綢"]{ --ink:#f6fbff; --muted:#d7e9ff; --stroke:rgba(190,220,255,.38); --bg1:#0b1626; --bg2:#060b14; --hudGrad1:rgba(18,28,60,.56); --hudGrad2:rgba(10,20,44,.42); --glass-1:rgba(220,245,255,.12); --glass-2:rgba(210,235,255,.09); --stageGlass:linear-gradient(180deg, rgba(230,245,255,.04), transparent); --panelPattern:conic-gradient(from 0deg at 60% 40%, rgba(180,220,255,.06), rgba(160,210,255,.05), rgba(180,230,255,.06)); --btnGlow:0 0 20px rgba(180,220,255,.26); }
    body[data-skin="冰雪．極光絲綢"] .hearts .life-icon{ width:24px; height:24px; }
    body[data-skin="冰雪．極光絲綢"] .hearts .life-icon svg{ width:24px; height:24px; }

    /* === 烈陽．炙金幻焰 === */
    body[data-skin="烈陽．炙金幻焰"]{
      --ink:#fff6e8;
      --muted:#ffd3a6;
      --stroke:rgba(255,180,120,.36);
      --bg1:#3a1000;
      --bg2:#1a0400;
      --hudGrad1:rgba(90,30,0,.58);
      --hudGrad2:rgba(60,20,0,.44);
      --glass-1:rgba(255,170,80,.12);
      --glass-2:rgba(255,130,40,.09);
      --stageGlass:linear-gradient(180deg, rgba(255,160,40,.05), transparent);
      --panelPattern:none;
      --btnGlow:0 0 22px rgba(255,160,80,.28);
    }

    /* === 機械．齒輪騎士 === */
    body[data-skin="機械．齒輪騎士"]{
      --ink:#fff4e6;
      --muted:#e6cfa6;
      --stroke:rgba(200,150,80,.4);
      --bg1:#3d2b1f;
      --bg2:#1b120b;
      --hudGrad1:rgba(80,60,40,.6);
      --hudGrad2:rgba(50,40,30,.44);
      --glass-1:rgba(255,200,120,.12);
      --glass-2:rgba(200,150,90,.08);
      --stageGlass:linear-gradient(180deg, rgba(120,80,40,.05), transparent);
      --panelPattern:radial-gradient(40px 40px at 20% 30%, rgba(120,80,40,.1), transparent 60%),
                      radial-gradient(50px 50px at 80% 60%, rgba(160,110,50,.1), transparent 60%);
      --btnGlow:0 0 18px rgba(255,190,90,.25);
    }
    /* === 和風．無限之城 === */
    body[data-skin="和風．無限之城"]{
      --ink:#ffedc2;
      --muted:#cbb07a;
      --stroke:rgba(247,227,174,.35);
      --bg1:#130a00;
      --bg2:#060300;
      --hudGrad1:rgba(80,60,20,.55);
      --hudGrad2:rgba(50,35,10,.45);
      --glass-1:rgba(255,255,255,.08);
      --glass-2:rgba(255,255,255,.05);
      --stageGlass:linear-gradient(180deg, rgba(255,200,120,.07), transparent);
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(255,200,120,.25);
    }
    body[data-skin="和風．無限之城"] #game{
      /* 修正背景位置屬性拼寫錯誤，確保圖片正常顯示 */
      background:url("images/d1.JPG") center/cover no-repeat;
    }

/* HUD/按鍵的霓虹語彙（按鍵邊緣流光＋心形光暈） */

    /* 上傳排行榜進度提示 */
    #uploadOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #uploadOverlay .box {
      background: var(--bg1);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      width: 260px;
    }
    #uploadOverlay .progress {
      width: 100%;
      height: 10px;
      background: var(--glass-2);
      border-radius: 5px;
      overflow: hidden;
      margin-top: 12px;
    }
    #uploadOverlay .progress > div {
      height: 100%;
      width: 0%;
      background: var(--ink);
      transition: width 0.1s;
    }
    #uploadOverlay .percent {
      margin-top: 8px;
      font-size: 14px;
    }


/* === Mobile scaling & LED alignment tweaks (Game Director standard) === */
@media (max-width: 430px) {
  .wrap { padding: 8px; }
  .stage { max-width: 100vw; padding: 8px; }
  .stage #fx { inset: 8px; border-radius: 18px; }
  canvas#game { border-radius: 18px; }
  .legend { transform: scale(0.92); transform-origin: top center; }
  #buffs { --buff-scale: 0.9; }
}
</style>
</head>
<body>
  <!-- 新增 UI 包裝 -->
  <div class="wrap" id="app">
    <header>
      <h1>Rock打磚塊 — <span id="skinTitle">經典風格</span></h1>
      <span class="small" id="skinDesc">LED：三側一致深藍，右側鏡像，2s 呼吸。</span>
    </header>
    <!-- 頂部 HUD -->
    <section class="hud" aria-label="遊戲 HUD">
      <div class="stats">
        <div class="pill">分數 <b id="score">0</b></div>
        <div class="pill">關卡 <b id="level">1</b>/<span id="totalLevels">20</span></div>
        <div class="inline-controls">
          <button class="ic-btn" id="sndBtn" aria-haspopup="true" aria-expanded="false" aria-controls="soundMenu" title="聲音"><span class="ico">🔊</span></button>
          <div class="menu" id="soundMenu">
            <div class="item"><span>🎵</span><label><input type="checkbox" id="bgmOn"> BGM 開關</label></div>
            <div class="item"><span>🎚</span><label style="width:100%">BGM 音量 <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.7" style="width:60%" aria-label="BGM 音量"></label></div>
            <div class="item"><span>🔈</span><label><input type="checkbox" id="sfxOn" checked> 音效開關</label></div>
            <!-- 隱藏的舊版按鈕，用於腳本維持邏輯 -->
            <button id="soundBtn" style="display:none;"></button>
            <button id="bgmBtn" style="display:none;"></button>
          </div>
          <button class="ic-btn" id="optBtn" aria-haspopup="true" aria-expanded="false" aria-controls="optMenu" title="選項">⋯</button>
          <div class="menu" id="optMenu">
            <h4>遊戲</h4>
            <div class="item"><span>🎮</span>難度 <select id="difficulty" aria-label="難度">
              <option value="easy">簡單</option>
              <option value="normal" selected>一般</option>
              <option value="hard">困難</option>
            </select></div>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn" id="pauseBtn" style="display:none;">暫停/繼續</button>
              <button class="btn" id="resetBtn">重新開始</button>
              <button class="btn" id="saveBtn">存檔</button>
              <button class="btn" id="loadBtn">讀檔</button>
              <button class="btn" id="clearSaveBtn">清除存檔</button>
              <label class="btn level-select" id="levelJumpLabel">跳至關卡
                <select id="levelJumpSel" aria-label="跳至關卡"></select>
              </label>
            </div>
            <h4>其他</h4>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn" id="fsBtn">全螢幕</button>
              <button class="btn" id="tutorBtn">教學</button>
              <button class="btn" id="effectsBtn">效果說明</button>
              <button class="btn" id="galleryBtn">畫廊</button>
              <button class="btn" id="rankBtn">排行榜</button>
            </div>
            <div class="item"><span>🎨</span>Skin <select aria-label="Skin" id="skinSel">
              <option>經典．冷藍玻璃</option>
            </select></div>
          </div>
        </div>
        <div class="pill wide">生命 <b id="lives">3</b> <span class="hearts" id="hearts">❤️❤️❤️</span> <span id="fireEnergy" class="fire-energy"></span> <span class="cats" id="cats" style="display:none"></span></div>
      </div>
    </section>
    <div class="hud-sentinel" style="height:0"></div>
    <!-- Buffs / 提示 -->
    <div id="buffs" class="badges"></div>
    <div id="playArea">
      <div id="promptsDock"></div>
      <!-- 遊戲區域 -->
      <div class="stage">
        <canvas id="fx"></canvas>
<canvas id="game" width="1100" height="700"></canvas>
        <div id="combo" class="combo"></div>
        <div class="legend">
        <span class="item"><span class="box" style="background:var(--expl)"></span>爆炸磚</span>
        <span class="item"><span class="box" style="background:var(--brick2)"></span>一般磚</span>
        <span class="item"><span class="box" style="background:#888"></span>不可破壞磚</span>
        <span class="item"><span class="box" style="background:#bb7aff"></span>強反彈磚</span>
        <span class="item"><span class="box" style="background:#6ec6ff"></span>移動磚</span>
        <span class="item"><span class="box" style="background:#ff4d6d"></span>Boss磚</span>
        <span class="item"><span class="box" style="background:var(--power)"></span>增益道具</span>
        <span class="item"><span class="box" style="background:var(--debuff)"></span>減益道具</span>
      </div>
    </div>
  </div>

    <!-- 覆蓋層/畫廊/勝利/結束/提示 -->
    <div class="overlay">
      <div class="gallery" id="gallery">
        <div class="backdrop"></div>
        <img id="galleryImg" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" alt="關卡大圖" />
        <div class="hint" id="galleryHint">點一下顯示台詞 ▶</div>
        <div class="dialog" id="galleryDialog"></div>
      </div>

      <div class="gallery-page" id="galleryPage">
        <div class="backdrop"></div>
        <div class="content">
          <div class="close" id="galleryClose">❌</div>
          <div class="thumbs" id="galleryThumbs"></div>
          <div class="nav">
            <button class="btn" id="galleryPrev">前一頁</button>
            <span id="galleryPageInfo">1 / 2</span>
            <button class="btn" id="galleryNext">下一頁</button>
          </div>
        </div>
        <div class="viewer" id="galleryViewer">
          <img id="galleryViewerImg" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" alt="畫廊大圖" />
          <div class="options" id="viewerOptions"></div>
          <div class="dialog" id="viewerDialog"></div>
        </div>
      </div>

      <div class="rank-page" id="rankPage">
        <div class="backdrop"></div>
        <div class="content">
          <div class="close" id="rankClose">❌</div>
          <h2 style="text-align:center;margin:4px 0 8px;">排行榜</h2>
          <table id="rankTable">
            <thead>
              <tr>
                <th>名次</th>
                <th>玩家</th>
                <th>分數</th>
                <th>消耗生命</th>
                <th>接球數</th>
                <th>增益次數</th>
                <th>減益次數</th>
                <th>殺敵數</th>
                <th>殺Boss數</th>
                <th>最快死亡</th>
                <th>最久存活</th>
                <th>最高Combo數</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="win" id="win">
        <div class="backdrop"></div>
        <div class="thumb-ring" id="ring"></div>
        <div class="center">
          <h2>恭喜過關！</h2>
          <div style="font-size:28px;margin:6px 0;">總分數：<span id="finalScore">0</span></div>
          <div id="statsWin" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:360px"></div>
          <div class="small">作者： ChatGPT　／　指導者： Rock</div>
          <div class="again"><button class="btn" id="uploadWin">上傳排行榜</button> <button class="btn" id="againBtn">再玩一次</button></div>
        </div>
      </div>

      <div class="gameover" id="gameover">
        <div class="backdrop"></div>
        <div class="center">
          <h2>遊戲結束</h2>
          <div style="font-size:28px;margin:6px 0;">最終分數：<span id="finalScore2">0</span></div>
          <div id="statsOver" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:320px"></div>
          <div class="again"><button class="btn" id="uploadOver">上傳排行榜</button> <button class="btn" id="retryBtn">再次遊戲</button></div>
        </div>
      </div>
      
      <div class="center-note" id="centerNote">
        <div class="note-box" id="noteBox"><button class="note-close" id="noteClose" aria-label="關閉">×</button>
          <h2 id="noteTitle">按 <kbd>Space</kbd> 或點畫面開始</h2>
          <p id="noteText">
            操作：<kbd>←</kbd>/<kbd>→</kbd> 或 <kbd>A</kbd>/<kbd>D</kbd>；手指拖曳畫面也可移動平台。<br>
            已整合：背景逐步揭示 + 清關畫廊、增益/減益（含電漿球/凍結球/神聖球/鳳凰審判/9命怪貓）、爆炸磚、音效、難度、存讀檔、BGM、教學/效果說明、Boss與進階磚。
          </p>
        </div>
      </div>
</div>
  </div>
  <div id="uploadOverlay">
    <div class="box">
      <div>上傳中...</div>
      <div class="progress"><div id="uploadBar"></div></div>
      <div class="percent" id="uploadPercent">0%</div>
    </div>
  </div>

<!-- Load skin definitions before the game script.  This file defines
     window.SKINS, window.applySkin and initializes the default skin. -->
<script src="skin.js"></script>
<script>
(() => {

  // Google Apps Script 部署後的 Web App URL，需替換為您自己的網址
  const RANK_API = 'https://script.google.com/macros/s/AKfycbwuIqqynB0ohVwnMhcA3u2Gv9GimGqUvfCJ_Nw_UnoCuEMCHG_rGhlKA_pxOO51HHU/exec';
  // 逾時毫秒數：避免網路不穩或後端未回應導致 Promise 卡住
  const FETCH_TIMEOUT = 8000;
  // Apps Script backend 必須回應 CORS 標頭，才能跨網域存取
  // === 設定 ===
  const GAME_CONFIG = {
    totalLevels: 20,
    difficulty: {
      easy:   { paddleBaseW: 220, baseSpeed: 4, rowsBase: 6, dropRate: 0.72 },
      normal: { paddleBaseW: 180, baseSpeed: 4.5, rowsBase: 7, dropRate: 0.52 },
      hard:   { paddleBaseW: 140, baseSpeed: 6, rowsBase: 8, dropRate: 0.32 },
    },
    bricks: { explosiveChance: 0.18, brickHeight: 30, padding: 9, topOffset: 60, cols: 12 },
    powers: {
      // 既有
      WIDE:{label:'平台變寬',type:'buff',durationMs:30000,paddleWidthAdd:50,badge:'↔️'},
      LONG:{label:'平台變長(可疊)',type:'buff',durationMs:30000,longPerStackAdd:40,stacksMax:2,badge:'📏'},
      STICKY:{label:'黏性平台(上彈可暫黏)',type:'buff',durationMs:5000,sticky:true,badge:'🧲'},
      MULTI:{label:'多球',type:'buff',multiDuplicate:true,maxBalls:4,badge:'✨'},
      SLOW:{label:'全局慢速',type:'buff',durationMs:15000,speedMul:0.8,badge:'🐢'},
      PIERCE:{label:'穿透球',type:'buff',durationMs:12000,piercing:true,badge:'🎯'},
      SHIELD:{label:'護盾(掉球擋一次)',type:'buff',oneShotShield:true,badge:'🛡'},
      RAMPAGE:{label:'暴走球(短暫強穿)',type:'buff',durationMs:5000,forcePiercing:true,rampageMs:5000,badge:'🔥'},
      FAST:{label:'快速球',type:'debuff',durationMs:5000,globalSpeedMul:1.5,screenShakeOnApply:6,badge:'⚡'},
      WAVY:{label:'變速球',type:'debuff',durationMs:5000,wavy:{amp:0.6,base:1.2,periodMs:200},badge:'〰️'},
      COMBO:{label:'連擊之星',desc:'連擊時間延長2倍、得分×1.5',type:'buff',durationMs:30000,combo:{timeMul:2,scoreMul:1.5},badge:'🌟'},
      // 新增
      PLASMA:{label:'電漿球(擊中放出電漿圈清列)',type:'buff',durationMs:10000,plasma:{drift:1.2,radius:38,lifeMs:3000},badge:'⚡️'},
      FREEZE:{label:'凍結球(延遲停頓一下)',type:'buff',durationMs:10000,freeze:{delayMs:300,stopMs:2000},badge:'❄️'},
      HOLY:{label:'神聖球(十字清線)',type:'buff',durationMs:5000,holy:{},badge:'✝️'},
      TRACK:{label:'追蹤球(自動修正軌跡)',type:'buff',durationMs:10000,track:{},badge:'🧭'},
      MISSILE:{label:'飛彈球(擋板反彈時發射3枚)',type:'buff',durationMs:5000,missile:{speed:7,turn:0.08,lifeMs:4000},badge:'🚀'},
      HELL:{label:'地獄球(黑洞吞鄰近格)',type:'buff',durationMs:5000,hell:{speedMul:1.2,haloMs:2000},badge:'🕳️'},
      MEGA:{label:'特大球(半徑×3, 速度×0.8)',type:'buff',durationMs:5000,mega:{sizeMul:3,speedMul:0.8},badge:'🟢'},
      CHAIN:{label:'鎖鏈球(命中磚鎖10秒)',type:'debuff',durationMs:5000,chain:{lockMs:10000},badge:'⛓️'},
      NARROW:{label:'平台縮小(寬度減半)',type:'debuff',durationMs:5000,narrow:true,badge:'📉'},
      HOLE:{label:'平台空洞(中間1/3無效)',type:'debuff',durationMs:5000,hole:true,badge:'🕳'},
      PADSPIN:{label:'平台翻轉',desc:'平台旋轉8秒',type:'debuff',durationMs:8000,spin:{periodMs:8000},badge:'🌀'},
      PADBOOM:{label:'平台爆炸',desc:'閃爍後消失3秒',type:'debuff',explosion:{flashMs:3000,goneMs:3000},badge:'💣'},
      FIRE:{label:'火焰球(碰撞蓄能10秒爆炸)',type:'buff',durationMs:10000,badge:'🔥'},
      POISON:{label:'劇毒球(命中磚每2秒扣血)',type:'buff',durationMs:12000,poison:{tickMs:2000},badge:'☠️'},
      BLINK:{label:'瞬移球(彈後1秒頂部落下)',type:'buff',durationMs:10000,blink:{delayMs:1000},badge:'🌀'},
      LASER:{label:'自動雷射(每2秒兩端發射)',type:'special',durationMs:10000,specialWeight:0.1,laser:{intervalMs:2000},badge:'🔫'},
      FLIP:{label:'天地翻轉(改為左側擋板)',type:'special',durationMs:15000,specialWeight:0.1,badge:'🔄'},
      NINE:{label:'9命怪貓(生命變9)',type:'special',instant:true,badge:'🐱'},
      PHOENIX:{label:'鳳凰審判(消半場/不秒殺Boss)',type:'special',instant:true,badge:'🪽'},
      GATLING:{label:'火力壓制',desc:'平台機槍掃射8秒',type:'special',durationMs:11000,specialWeight:0.1,gatling:{chargeMs:3000,fireMs:8000,intervalMs:100,bulletSpeed:10},badge:'🔫'},
      SWORD:{label:'劍芒裂空',desc:'飛劍掃場',type:'special',durationMs:20000,specialWeight:0.1,badge:'🗡️'},
      GODSPEED:{label:'神速流轉(不落地/滿速)',type:'special',durationMs:10000,specialWeight:0.1,badge:'☄️'},
      STORM:{label:'雷射風暴',desc:'全場掃射',type:'special',durationMs:5000,specialWeight:0.1,storm:{},badge:'🌩️'},
      BLACKHOLE:{label:'黑洞吞噬',desc:'黑洞吞場',type:'special',durationMs:20000,specialWeight:0.1,badge:'⚫'},
      ANNIHIL:{label:'萬物銷毀',desc:'隨機毀磚',type:'special',specialWeight:0.1,annihil:{speedMul:3},badge:'💥'}

    },
    powerCapsule:{width:24,height:16,fallVy:2.2},
    caps:{paddleMaxW:300,ballSpeedMax:19.5}
  };

  // === 影像載入（支援 .png / .jpg） ===
  const IMG_PAIRS = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.png`, cg:`images/cg${i}.png`}));
  // 準備 jpg 後備
  const IMG_PAIRS_FALLBACK = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.jpg`, cg:`images/cg${i}.jpg`}));

  const DIALOGS = {
    bg1: [
      '這麼快就破冰而來？小心，我的心比寒霜更難融化哦。',
      '嗯……你的手指一定很靈巧，才能穿過我的冰陣。',
      '別站太近，我怕不小心凍住你的心。'
    ],
    bg2: [
      '感謝你的勇氣，願月神的祝福伴你繼續前行。',
      '你的光芒……比聖堂的星光還要耀眼。',
      '或許，我該為你的心祈禱，不要被我奪走。'
    ],
    bg3: [
      '不錯，你的命暫時保住了……至少在我懷裡。',
      '你打破的不只是磚塊，還是我對你的試探。',
      '別怕鐮刀，它只收割敵人……或者偷吻盟友。'
    ],
    bg4: [
      '你讓我等太久了……這杯酒早該敬你。',
      '別問我情報的價錢，也許……用一個吻就夠。',
      '嗯，動作俐落，今晚你值得更多獎勵。'
    ],
    bg5: [
      '孩子，你的靈魂比我想像的還要純淨……或者危險。',
      '在聖光下，連你的眼神都變得無法隱藏。',
      '我可以祝福你……或者誘惑你，你選哪個？'
    ],
    bg6: [
      '好劍法……不如找時間，與我切磋更多回合。',
      '你贏得了這場戰役，也贏得了我的注意。',
      '別急著走，真正的決戰在我心裡等你。'
    ],
    bg7: [
      '真有趣……你闖進來，就是為了見我嗎？',
      '小心點，我的笑容比地獄的火焰更致命。',
      '既然你贏了，那就……讓我好好品嚐你的靈魂吧。'
    ],
    bg8: [
      '你真幸運，能活著見到我。',
      '打磚塊很厲害？下次試試打破我的心防。',
      '看來……我得重新評估你是敵人，還是我的人。'
    ],
    bg9: [
      '唉呀，被你闖進來了，火焰可不只燒磚哦。',
      '你知道嗎？我喜歡會讓我心跳加速的對手。',
      '別走太快，我還沒決定是要吻你還是燒了你。'
    ],
    bg10: [
      '呀……你走得這麼快，不怕我偷走你的心嗎？',
      '獎勵？當然有，不過要用一點真心來換。',
      '你破了關，我的尾巴……可以多纏你一會兒。'
    ],
    cg1: [
      '你闖過來的樣子，像雪崩一樣驚心動魄。',
      '別動，我想看看你在冰霜映照下的眼神。',
      '小心，我的心情若融化……可是會淹沒你的。'
    ],
    cg2: [
      '你的步伐很輕，但足跡卻深深刻在我心上。',
      '你闖過這段路，讓我想起了失落的勇者傳說。',
      '聖堂的花為你而開……也許我也是。'
    ],
    cg3: [
      '你的膽量……足以和死神坐在同一張桌前。',
      '剛剛那一下，我幾乎想收割你的心而非靈魂。',
      '別退，我還沒決定要把你留在哪一邊。'
    ],
    cg4: [
      '你跑得快，還是我的心跳快？',
      '你贏了，獎品嘛……也許是我的陪伴一回合。',
      '下次見面前，記得多練習……我不喜歡慢吞吞的獵物。'
    ],
    cg5: [
      '你的名字，已經被我寫進禁忌的詩篇裡。',
      '在黑暗中，你的光……令人想犯罪。',
      '別以為破關了就能逃離，我的魔咒很黏人。'
    ],
    cg6: [
      '剛才那一擊……我都想跟你過招幾百次了。',
      '你的眼神告訴我，你不只是為勝利而戰。',
      '戰場上我很兇，但對贏得我心的人……很溫柔。'
    ],
    cg7: [
      '恭喜，你已經被惡魔的興趣鎖定。',
      '你的靈魂香氣……比我想像的還誘人。',
      '今晚，你最好鎖好門……或者乾脆敞開等我。'
    ],
    cg8: [
      '別回頭，我的影子已經纏上你了。',
      '動作還不錯，下次換我來試探你。',
      '你闖過的不是關卡，而是我的戒心。'
    ],
    cg9: [
      '花草會記住你的名字……就像我一樣。',
      '你的氣息，讓森林也安靜下來聆聽。',
      '小心哦，我的魔法會讓你捨不得離開。'
    ],
    cg10: [
      '他（狼）似乎喜歡你……我也是。',
      '你的勇氣，連森林裡的狼都低頭。',
      '想留下來吃點什麼嗎？除了點心，還有我。'
    ]
  };

  function makeImg(src, fallback){
    const im = new Image();
    im.decoding = 'async';
    im.loading = 'eager';
    im.src = src;
    if (fallback) {
      im.onerror = () => { if (im.src !== fallback) im.src = fallback; };
    }
    if (im.decode) { im.decode().catch(() => {}); }
    return im;
  }
  const IMG_MAP = new Array(10); // caches {bg, cg}
  function loadImagePair(i){
    if(!IMG_MAP[i]){
      IMG_MAP[i] = {
        bg: makeImg(IMG_PAIRS[i].bg, IMG_PAIRS_FALLBACK[i].bg),
        cg: makeImg(IMG_PAIRS[i].cg, IMG_PAIRS_FALLBACK[i].cg),
      };
    }
    return IMG_MAP[i];
  }

  // === 特殊增益解鎖 ===
  const SPECIAL_UNLOCK_LEVELS = {
    PHOENIX:1,
    GATLING:3,
    SWORD:5,
    GODSPEED:7,
    STORM:9,
    BLACKHOLE:10,
    ANNIHIL:15,
  };
  const defaultUnlocked=['LASER','FLIP','NINE'];
  let unlockedSpecials=new Set(defaultUnlocked);
  try{
    const stored=JSON.parse(localStorage.getItem('unlocked_specials')||'[]');
    if(Array.isArray(stored)) stored.forEach(k=>unlockedSpecials.add(k));
  }catch(e){}
  function saveUnlockedSpecials(){
    localStorage.setItem('unlocked_specials',JSON.stringify(Array.from(unlockedSpecials)));
  }
  let pendingUnlockNotice=null;
  let ALL_TYPES=[]; let NORMAL_TYPES=[];
  function recomputePowerTypes(){
    ALL_TYPES=Object.keys(GAME_CONFIG.powers).filter(k=>GAME_CONFIG.powers[k].type!=='special'||unlockedSpecials.has(k));
    NORMAL_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='special');
  }
  function unlockSpecials(clearLevel){
    for(const [key,req] of Object.entries(SPECIAL_UNLOCK_LEVELS)){
      if(clearLevel>=req && !unlockedSpecials.has(key)){
        unlockedSpecials.add(key);
        saveUnlockedSpecials();
        pendingUnlockNotice=`已解鎖特殊增益:${GAME_CONFIG.powers[key].label.split('(')[0]}`;
        recomputePowerTypes();
      }
    }
  }
  recomputePowerTypes();

  // === 參考 DOM ===
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const scoreEl=document.getElementById('score'), levelEl=document.getElementById('level'), livesEl=document.getElementById('lives');
  const pauseBtn=document.getElementById('pauseBtn'), resetBtn=document.getElementById('resetBtn'), fsBtn=document.getElementById('fsBtn');
  const soundBtn=document.getElementById('soundBtn'), saveBtn=document.getElementById('saveBtn'), loadBtn=document.getElementById('loadBtn'), clearSaveBtn=document.getElementById('clearSaveBtn');
  const levelJumpSel=document.getElementById('levelJumpSel');
  let refreshLevelJumpVisual=null;
  const tutorBtn=document.getElementById('tutorBtn'), effectsBtn=document.getElementById('effectsBtn'), galleryBtn=document.getElementById('galleryBtn'), rankBtn=document.getElementById('rankBtn');
  const centerNote=document.getElementById('centerNote'), noteTitle=document.getElementById('noteTitle'), noteText=document.getElementById('noteText'), noteBox=document.getElementById('noteBox');
  const difficultySel=document.getElementById('difficulty'), activeBuffsEl=document.getElementById('buffs'), promptsDock=document.getElementById('promptsDock');
  const ledStyleSel=document.getElementById('ledStyle');

  // 新增元素參考
  const heartsEl = document.getElementById('hearts');
  const fireEnergyEl = document.getElementById('fireEnergy');
  const catsEl = document.getElementById('cats');
  const totalLevelsEl = document.getElementById('totalLevels');
  const sfxOnEl = document.getElementById('sfxOn');
  const bgmOnEl = document.getElementById('bgmOn');
  const skinSel = document.getElementById('skinSel');
  const gallery=document.getElementById('gallery'), galleryImg=document.getElementById('galleryImg'), galleryHint=document.getElementById('galleryHint'), galleryDialog=document.getElementById('galleryDialog');
  const win=document.getElementById('win'), ring=document.getElementById('ring'), finalScore=document.getElementById('finalScore'), againBtn=document.getElementById('againBtn');
  document.getElementById('retryBtn')?.addEventListener('click', ()=>{ gameover.classList.remove('show'); gameOver=false; resetGame(); startGameWithCountdown(); });

  const bgmBtn=document.getElementById('bgmBtn'), bgmVol=document.getElementById('bgmVol');
  const gameover=document.getElementById('gameover'), finalScore2=document.getElementById('finalScore2');
  const retryBtn=document.getElementById('retryBtn');

  // Gallery page elements
  const galleryPage=document.getElementById('galleryPage'), galleryThumbs=document.getElementById('galleryThumbs'), galleryClose=document.getElementById('galleryClose'), galleryPrev=document.getElementById('galleryPrev'), galleryNext=document.getElementById('galleryNext'), galleryPageInfo=document.getElementById('galleryPageInfo'), galleryViewer=document.getElementById('galleryViewer'), galleryViewerImg=document.getElementById('galleryViewerImg'), viewerOptions=document.getElementById('viewerOptions'), viewerDialog=document.getElementById('viewerDialog');

  // Rank page elements
  const rankPage=document.getElementById('rankPage'), rankClose=document.getElementById('rankClose'), rankTableBody=document.querySelector('#rankTable tbody');
  const uploadWin=document.getElementById('uploadWin'), uploadOver=document.getElementById('uploadOver'),
        uploadOverlay=document.getElementById('uploadOverlay'), uploadBar=document.getElementById('uploadBar'),
        uploadPercent=document.getElementById('uploadPercent');

  // === Gallery page logic ===
  let galleryPageIdx = 0;
  function renderGalleryPage(){
    const type = galleryPageIdx===0?'bg':'cg';
    galleryThumbs.innerHTML='';
    for(let i=1;i<=10;i++){
      const key = `${type}${i}`;
      const div=document.createElement('div');
      div.className='thumb';
      const im=document.createElement('img');
      im.src=`images/${key}.png`;
      div.appendChild(im);
      if(!galleryUnlocks[key]){
        div.classList.add('locked');
      }else{
        div.addEventListener('click',()=>{
          openGalleryViewer(key);
        },{passive:true});
      }
      galleryThumbs.appendChild(div);
    }
    galleryPageInfo.textContent=`${galleryPageIdx+1} / 2`;
    galleryPrev.disabled = galleryPageIdx===0;
    galleryNext.disabled = galleryPageIdx===1;
  }

  function openGalleryViewer(key){
    galleryViewerImg.src=`images/${key}.png`;
    galleryViewer.style.display='flex';
    if(viewerDialog) viewerDialog.style.display='none';
    if(viewerOptions){
      viewerOptions.innerHTML='';
      const mask = dialogUnlocks[key] || 0;
      const lines = DIALOGS[key] || [];
      for(let i=0;i<3;i++){
        const btn=document.createElement('button');
        btn.className='btn';
        if(mask & (1<<i)){
          btn.textContent=`台詞${i+1}`;
          btn.addEventListener('click',e=>{ e.stopPropagation(); if(viewerDialog){ viewerDialog.textContent=lines[i]; viewerDialog.style.display='block'; } },{passive:true});
        }else{
          btn.textContent='🔒';
          btn.disabled=true;
          btn.classList.add('locked');
        }
        viewerOptions.appendChild(btn);
      }
    }
  }
  function openGalleryPage(){
    galleryPageIdx=0;
    renderGalleryPage();
    galleryPage.style.display='flex';
    window.__setMenuPause?.(true);
  }
  function closeGalleryPage(){
    galleryPage.style.display='none';
    galleryViewer.style.display='none';
    if(viewerDialog) viewerDialog.style.display='none';
    if(!menusOpen()) window.__setMenuPause?.(false);
  }
  galleryClose?.addEventListener('click', closeGalleryPage, {passive:true});
  galleryPrev?.addEventListener('click', ()=>{ if(galleryPageIdx>0){galleryPageIdx--; renderGalleryPage();}}, {passive:true});
  galleryNext?.addEventListener('click', ()=>{ if(galleryPageIdx<1){galleryPageIdx++; renderGalleryPage();}}, {passive:true});
  galleryViewer?.addEventListener('click', ()=>{ if(viewerDialog && viewerDialog.style.display==='block'){ viewerDialog.style.display='none'; } else { galleryViewer.style.display='none'; } }, {passive:true});
  viewerOptions?.addEventListener('click', e=>{ e.stopPropagation(); }, {passive:true});
  galleryBtn?.addEventListener('click', ()=>{
    openGalleryPage();
  }, {passive:true});

  // === Rank page logic ===
  async function fetchLeaderboard(){
    const controller = new AbortController();
    const to = setTimeout(()=>controller.abort(), FETCH_TIMEOUT);
    // GET leaderboard as JSON (supports both array-of-arrays and array-of-objects)
    const res = await fetch(RANK_API + '?t=' + Date.now(), { cache: 'no-store', signal: controller.signal });
    clearTimeout(to);
    if (!res.ok) throw new Error('fetch failed: ' + res.status);
    const text = await res.text();
    let data;
    try { data = JSON.parse(text); }
    catch { throw new Error('invalid json'); }
    // Normalize to array-of-arrays: [timestamp,name,score,lives,catches,powerUps,powerDowns,enemiesKilled,bossKilled,fastestDeath,longestSurvival,maxCombo]
    if (Array.isArray(data) && data.length && !Array.isArray(data[0]) && typeof data[0] === 'object') {
      // array of objects
      data = data.map(o => [
        o.timestamp ?? '',
        o.name ?? '',
        Number(o.score ?? 0),
        Number(o.lives ?? 0),
        Number(o.catches ?? 0),
        Number(o.powerUps ?? 0),
        Number(o.powerDowns ?? 0),
        Number(o.enemiesKilled ?? 0),
        Number(o.bossKilled ?? 0),
        Number(o.fastestDeath ?? 0),
        Number(o.longestSurvival ?? 0),
        Number(o.maxCombo ?? o.comboMax ?? 0),
      ]);
    }
    if (!Array.isArray(data)) throw new Error('unexpected data');
  return data;
  }
  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
  }
  function renderLeaderboard(data){
    rankTableBody.innerHTML='';
    try{
      data.sort((a,b)=>Number(b[2]||0)-Number(a[2]||0));
    }catch{}
    (data||[]).slice(0,20).forEach((row,i)=>{
      const tr=document.createElement('tr');
      const fd = Number(row[9]||0).toFixed(1);
      const ld = Number(row[10]||0).toFixed(1);
      const mc = Number(row[11]||0);
      tr.innerHTML = `<td>${i+1}</td>
        <td>${escapeHtml(row[1]??'')}</td>
        <td>${Number(row[2]||0)}</td>
        <td>${Number(row[3]||0)}</td>
        <td>${Number(row[4]||0)}</td>
        <td>${Number(row[5]||0)}</td>
        <td>${Number(row[6]||0)}</td>
        <td>${Number(row[7]||0)}</td>
        <td>${Number(row[8]||0)}</td>
        <td>${fd}</td>
        <td>${ld}</td>
        <td>${mc}</td>`;
      rankTableBody.appendChild(tr);
    });
    if(!rankTableBody.children.length){
      rankTableBody.innerHTML='<tr><td colspan="12">暫無資料</td></tr>';
    }
  }
  async function openRankPage(){
    document.getElementById('optMenu')?.classList.remove('show');
    rankPage.style.display='flex';
    rankTableBody.innerHTML='<tr><td colspan="12">載入中...</td></tr>';
    window.__setMenuPause?.(true);
    try{
      const data = await fetchLeaderboard();
      renderLeaderboard(data);
    }catch(e){
      console.error(e);
      rankTableBody.innerHTML='<tr><td colspan="12">載入失敗</td></tr>';
    }
  }
  function closeRankPage(){
    rankPage.style.display='none';
    if(!menusOpen()) window.__setMenuPause?.(false);
  }
  rankClose?.addEventListener('click', closeRankPage, {passive:true});
  rankBtn?.addEventListener('click', openRankPage, {passive:true});

    async function uploadScore(){
      if(scoreUploaded){
        alert('已上傳過，請勿再次上傳');
        return;
      }
      if(uploading){
        alert('上傳中，請勿再次點擊!');
        return;
      }
      const rawName = prompt('請輸入玩家名稱：\n注意: 姓名最多輸入8個字');
    if(rawName==null) return;
    const name = (rawName||'').trim();
    if(!name) return;
    if([...(name||'')].length>8){
      alert('名字這麼長是想怎樣啦? 請重新輸入!');
      return uploadScore();
    }
      const payload = {
        name,
        score,
        lives: stats.livesUsed,
        catches: stats.catches,
        powerUps: stats.buffs,
        powerDowns: stats.debuffs,
        enemiesKilled: stats.eliteKills,
        bossKilled: stats.bossKills,
        fastestDeath: stats.fastestDeath===Infinity?0:stats.fastestDeath,
        longestSurvival: stats.longestLife,
        maxCombo: stats.maxCombo
      };
      uploading = true;
      uploadOverlay.style.display='flex';
      let prog=0;
      const setProg=p=>{ uploadBar.style.width=p+'%'; uploadPercent.textContent=p+'%'; };
      setProg(0);
      const progTimer=setInterval(()=>{ if(prog<90){ prog+=5; setProg(prog); } },200);
      const controller = new AbortController();
      const to = setTimeout(()=>controller.abort(), FETCH_TIMEOUT);
      try{
        const res = await fetch(RANK_API, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain; charset=UTF-8' }, // simple request to avoid preflight
          body: JSON.stringify(payload),
          signal: controller.signal
        });
        const text = await res.text().catch(()=> '');
        clearTimeout(to);
        clearInterval(progTimer);
        setProg(100);
        uploadOverlay.style.display='none';
        if (res.ok && /ok/i.test(text.trim())) {
          alert('上傳完成');
          scoreUploaded = true;
        } else {
          alert('上傳失敗');
        }
      }catch(e){
        clearTimeout(to);
        clearInterval(progTimer);
        uploadOverlay.style.display='none';
        console.error(e);
        alert('上傳失敗');
      }finally{
        uploading = false;
      }
    }
  uploadWin?.addEventListener('click', uploadScore, {passive:true});
  uploadOver?.addEventListener('click', uploadScore, {passive:true});

  // === Skin initialization ===
  // Populate the skin dropdown and set up the current skin.  Skins are
  // defined in skin.js and exposed via the global SKINS object.  Each
  // option uses its key as the value; the displayed text comes from
  // selectLabel or falls back to the label.
  if (window.SKINS && skinSel) {
    // Remove any existing options before populating.
    skinSel.innerHTML = '';
    Object.keys(window.SKINS).forEach((key) => {
      const opt = document.createElement('option');
      opt.value = key;
      const s = window.SKINS[key];
      opt.textContent = (s.selectLabel || s.label || key);
      skinSel.appendChild(opt);
    });
    // Provide a UI update callback on window so skin.js can call it.
    window.updateSkinUI = function (skin) {
      const titleEl = document.getElementById('skinTitle');
      const descEl = document.getElementById('skinDesc');
      if (titleEl) titleEl.textContent = skin.label || '';
      if (descEl) descEl.textContent = skin.desc || '';
    };
    // Determine the initial skin from localStorage, with fallback.
    let initKey;
    try {
      initKey = localStorage.getItem('selected_skin') || 'classic';
    } catch (e) {
      initKey = 'classic';
    }
    if (!window.SKINS[initKey]) initKey = 'classic';
    skinSel.value = initKey;
    // Apply the initial skin using the helper from skin.js.  This also
    // stores the selection for later and updates the UI via updateSkinUI.
    if (typeof window.applySkin === 'function') {
      window.applySkin(initKey);
    }
    // Listen for changes and re-apply skins accordingly.
    skinSel.addEventListener('change', function () {
      if (typeof window.applySkin === 'function') {
        window.applySkin(this.value);
      }
    }, { passive: true });
  }

  /*
   * 新 UI 音效與 BGM 控制
   *
   * 為了沿用既有的聲音邏輯，我們用複選框控制隱藏的舊按鈕 soundBtn / bgmBtn。
   * 由於 soundsOn 與 bgmOn 在稍後才宣告（使用 let），這段初始化邏輯會在
   * 狀態宣告之後重新插入。這裡僅預留說明文字，實際邏輯見後方的插入區塊。
  */


  function menusOpen(){
    return !!(
      document.querySelector('#soundMenu.show, #optMenu.show') ||
      (galleryPage && galleryPage.style.display && galleryPage.style.display !== 'none') ||
      (rankPage && rankPage.style.display && rankPage.style.display !== 'none')
    );
  }

  // 關閉視窗按鈕（關閉後立即倒數、繼續遊戲）
  const noteClose = document.getElementById('noteClose');
  function closeNoteAndResume(){
    hideCenter();
    helpMode = null;
    // 在關閉說明視窗後恢復遊戲：先調整所有計時，再透過倒數繼續
    if(menusOpen()) return;
    if(running){ onResumeFromPause(); startCountdown(); } else { startGameWithCountdown(); }
  }
  noteClose.addEventListener('click', (e)=>{ e.stopPropagation(); closeNoteAndResume(); });

  // === 暫停與恢復計時 ===
  // 在暫停開始時呼叫，記錄當前時間以便恢復時修正各種定時器。
  function onPauseStart(){
    // 只在第一次暫停時記錄時間，避免重覆覆寫
    if(pauseStartedAt === null){
      pauseStartedAt = performance.now();
    }
  }

  // 在恢復遊戲時呼叫，將暫停期間的經過時間加回所有依賴絕對時間的定時器。
  function onResumeFromPause(){
    if(pauseStartedAt !== null){
      const delta = performance.now() - pauseStartedAt;
      pauseStartedAt = null;
      // 調整各增益 buff 的有效期
      for(const key of Object.keys(GAME_CONFIG.powers)){
        const b = buffs[key];
        if(!b) continue;
        // 通用 until 屬性
        if(b.active && b.until){ b.until += delta; }
        // LONG buff 的 stacks 為多個 until 時間
        if(key === 'LONG' && Array.isArray(b.stacks)){
          for(let i=0;i<b.stacks.length;i++){ b.stacks[i] += delta; }
        }
        // 萬物銷毀：調整起始與下次計時
        if(key === 'ANNIHIL'){
          if(b.start){ b.start += delta; }
          if(b.next){ b.next += delta; }
        }
      }
      // 調整天地翻轉特效的起止時間
      if(buffs.FLIP){
        const bf = buffs.FLIP;
        if(bf.startAt) bf.startAt += delta;
        if(bf.endAt) bf.endAt += delta;
      }
      // 調整下一次天空掉落與自動增益掉落時間
      if(nextSkyDropAt){ nextSkyDropAt += delta; }
      if(nextAutoBeneficialDropAt){ nextAutoBeneficialDropAt += delta; }
      // 調整 Boss 能力排程
      if(typeof nextBossAtkA !== 'undefined' && nextBossAtkA){ nextBossAtkA += delta; }
      if(typeof nextBossAtkB !== 'undefined' && nextBossAtkB){ nextBossAtkB += delta; }
      if(typeof bossChargeUntil !== 'undefined' && bossChargeUntil){ bossChargeUntil += delta; }
      if(typeof cyclopsShakeUntil !== 'undefined' && cyclopsShakeUntil){ cyclopsShakeUntil += delta; }
      if(typeof cyclopsForcedPetrifyAt !== 'undefined' && cyclopsForcedPetrifyAt){ cyclopsForcedPetrifyAt += delta; }
      if(gatling){ gatling.chargeUntil+=delta; gatling.fireStart+=delta; gatling.fireUntil+=delta; if(gatling.lastShot) gatling.lastShot+=delta; }
      if(spaceBossRevealScheduled) spaceBossRevealScheduled += delta;
      if(spaceBossNextAttackAt) spaceBossNextAttackAt += delta;
      if(spaceBossAttack){
        if(spaceBossAttack.start) spaceBossAttack.start += delta;
        if(spaceBossAttack.countdownEnd) spaceBossAttack.countdownEnd += delta;
        if(spaceBossAttack.fireStart) spaceBossAttack.fireStart += delta;
        if(spaceBossAttack.fireEnd) spaceBossAttack.fireEnd += delta;
        if(spaceBossAttack.sweepStart) spaceBossAttack.sweepStart += delta;
        if(spaceBossAttack.sweepEnd) spaceBossAttack.sweepEnd += delta;
      }
      if(spaceBossMarquee){ spaceBossMarquee.start+=delta; if(spaceBossMarquee.fadeStart) spaceBossMarquee.fadeStart+=delta; if(spaceBossMarquee.end) spaceBossMarquee.end+=delta; }
      for(const fx of spaceBossBursts){ if(fx.t0) fx.t0 += delta; }
      if(spaceBossPaddleRespawnAt) spaceBossPaddleRespawnAt += delta;
      if(spaceBossDeathAnim){ spaceBossDeathAnim.start+=delta; spaceBossDeathAnim.explosionAt+=delta; spaceBossDeathAnim.end+=delta; spaceBossDeathAnim.lastBurst+=delta; }
      if(spaceBossSuppressLifeLossUntil) spaceBossSuppressLifeLossUntil += delta;
      // 調整各種特效物件（粒子、雷射、黑洞等）的 till/until 終止時間
      const lists = [plasmas, holyFlashes, blackHoles, laserBeams, laserImpacts, missiles, hostileBeams, hostileArcs, hostileColumns, hazardClouds];
      for(const arr of lists){
        if(!arr) continue;
        for(const item of arr){
          if(item.until){ item.until += delta; }
          if(item.tEnd){ item.tEnd += delta; }
          if(item.t0){ item.t0 += delta; }
          if(item.lifeUntil){ item.lifeUntil += delta; }
          if(item.tStart){ item.tStart += delta; }
        }
      }
      // 調整球的凍結狀態
      for(const ball of balls){
        const fr = ball.freeze;
        if(fr && fr.t0){ fr.t0 += delta; }
        if(fr && fr.until){ fr.until += delta; }
      }
      if(combo>0 && comboLastTime){ comboLastTime += delta; }
    }
  }


  // === DPR 縮放 ===
  function resizeCanvasDPR(){ const dpr=Math.min(window.devicePixelRatio||1,2); const cssW=canvas.clientWidth; const cssH=Math.round(cssW*(700/1100)); canvas.style.height=cssH+'px'; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); scaleX=canvas.width/1100; scaleY=canvas.height/700; }
  let scaleX=1, scaleY=1; window.addEventListener('resize', resizeCanvasDPR, {passive:true}); resizeCanvasDPR();

  // === 狀態 ===
  let running=false, paused=true, level=1, score=0, lives=3, soundsOn=false;
  let nineCatEaten=0;
  let fireEnergy=0;
  let gameOver=false;
  let combo=0;
  let comboLastTime=0;
  const comboEl=document.getElementById('combo');
  let comboNoticeTriggered={50:false,100:false,200:false,300:false,400:false,500:false,800:false,1000:false};
  let stats={catches:0,buffs:0,debuffs:0,eliteKills:0,bossKills:0,lifeStart:0,fastestDeath:Infinity,longestLife:0,livesUsed:0,maxCombo:0};
  const SPACE_BOSS_MAX_HP = 30;
  const SPACE_BOSS_ATTACK_INTERVAL = 15000;
  const SPACE_BOSS_PADDLE_MIN_WIDTH = 60;
  const SPACE_BOSS_GUN_FIRE_RATE = 100; // ms between each burst per gun
  const SPACE_BOSS_GUN_FIRE_DURATION = 3000;
  const SPACE_BOSS_LASER_SWEEP_DURATION = 2000;
  const DRAGON_MAX_HP = 80;
  const DRAGON_BASE_MODEL_WIDTH = 260;
  let spaceBossPhase='inactive';
  let spaceBoss=null;
  let spaceBossPlaceholder=null;
  let spaceBossAnchor=null;
  let spaceBossRevealScheduled=0;
  let spaceBossBursts=[];
  let spaceBossMarquee=null;
  let spaceBossDefeatedAt=0;
  let spaceBossAttack=null;
  let spaceBossNextAttackAt=0;
  const spaceBossBullets=[];
  let spaceBossPaddlePenalty=0;
  let spaceBossPaddleRespawnAt=0;
  let spaceBossDeathAnim=null;
  let spaceBossLastPaddleCenter=0;
  let spaceBossPrevPaddleCenter=0;
  let spaceBossSuppressLifeLossUntil=0;

  let reaperPhase='inactive';
  let reaperBoss=null;
  let reaperPlaceholder=null;
  let reaperAnchor=null;
  let reaperRevealScheduled=0;
  let reaperBursts=[];
  let cyclopsFirstAttackAt=0;
  let cyclopsEventStarted=false;
  let cyclopsMarqueeShown=false;
  let cyclopsRowBlastIndex=-1;
  let cyclopsNextRowBlast=0;
  let cyclopsShellBurst=false;
  let cyclopsEventComplete=false;
  let cyclopsForcedPetrifyAt=0;
  let cyclopsForcedPetrifyFired=false;
  let reaperAfterimages=[];
  let reaperMarquee=null;
  let reaperDefeatedAt=0;
  let reaperDeathAnim=null;
  let reaperTeleportSchedule=null;
  let reaperTargetHighlightUntil=0;
  let reaperAttackState=null;
  let reaperSlashZone=null;
  let reaperSlashEffects=[];
  let reaperBlackHoleAttack=null;
  let reaperLifeLossCooldownUntil=0;
  let reaperPaddlePenalty=0;
  let reaperPenaltyLastUpdate=0;
  const REAPER_PADDLE_MIN_WIDTH=80;
  let dragonPhase='inactive';
  let dragonBoss=null;
  let dragonPlaceholder=null;
  let dragonAnchor=null;
  let dragonRevealScheduled=0;
  let dragonBursts=[];
  let dragonMarquee=null;
  let dragonDefeatedAt=0;
  let dragonDeathAnim=null;
  let dragonAttackState=null;
  let dragonNextAttackAt=0;
  const dragonDeathRayOrbs=[];
  const dragonDeathRayBeams=[];
  let demonShellBrick=null;
  let demonEventPhase='inactive';
  let demonEventTimerStart=0;
  let demonEventTriggeredAt=0;
  let demonEventMarquee=null;
  let demonEventWave=null;
  let demonEventRows=[];
  let demonEventNextRowAt=0;
  let demonFallingDebris=[];
  let demonEventShakeUntil=0;
  let demonCore=null;
  let demonEventTargets=0;
  let demonEventCleared=0;
  let demonPhase='inactive';
  let demonBoss=null;
  let demonRevealScheduled=0;
  let demonAfterimages=[];
  let demonDeathAnim=null;
  let demonDefeatedAt=0;

  function isSpaceBossActive(){
    return level===5 && spaceBossPhase==='active' && !!spaceBoss;
  }

  function isReaperActive(){
    return level===10 && reaperPhase==='active' && !!reaperBoss;
  }

  function isDragonActive(){
    return level===15 && dragonPhase==='active' && !!dragonBoss;
  }

  function isDemonActive(){
    return level===20 && demonPhase==='active' && !!demonBoss;
  }

  function getSpaceBossBounds(){
    if(!spaceBoss) return null;
    return {
      x: spaceBoss.x - spaceBoss.w/2,
      y: spaceBoss.y - spaceBoss.h/2,
      w: spaceBoss.w,
      h: spaceBoss.h
    };
  }

  function computeDragonHitZones(bossOverride=null){
    const boss = bossOverride || dragonBoss;
    if(!boss) return [];
    const scale = (boss.w||DRAGON_BASE_MODEL_WIDTH)/DRAGON_BASE_MODEL_WIDTH;
    const cx = boss.x;
    const cy = boss.y;
    const wingPhase = boss.wingPhase||0;
    const sine=Math.sin(wingPhase);
    const downstroke=Math.pow(Math.max(0, sine), 1.6);
    const upstroke=Math.pow(Math.max(0, -sine), 1.2);
    const flap=(downstroke*0.65 - upstroke*0.42);
    let wingLift = 26*flap;
    let wingSpread = 1.38 + flap*0.42;
    if(boss.pose==='deathRay'){
      wingLift += 18;
      wingSpread += 0.6;
    }
    const zones=[];
    const addZone=(ox, oy, radius)=>{
      zones.push({
        cx: cx + ox*scale,
        cy: cy + oy*scale,
        r: Math.max(6, radius*scale)
      });
    };

    addZone(0,-48,62);
    addZone(0,24,70);
    addZone(0,110,58);
    addZone(0,190,48);
    addZone(0,268,42);
    addZone(0,-132,28);

    addZone(96,-12,42);
    addZone(-96,-12,42);
    addZone(102,108,38);
    addZone(-102,108,38);

    const tailSegments=[
      {y:146,r:44},
      {y:214,r:38},
      {y:286,r:32},
      {y:344,r:28}
    ];
    for(const seg of tailSegments){ addZone(0,seg.y,seg.r); }

    const wingClusters=[
      {x:-150, y:-72-wingLift*0.15, r:76},
      {x:-212, y:18-wingLift*0.05, r:70},
      {x:-252, y:126+wingLift*0.18, r:64},
      {x:-220, y:202+wingLift*0.32, r:58}
    ];
    for(const cluster of wingClusters){
      addZone(cluster.x*wingSpread, cluster.y, cluster.r);
      addZone(-cluster.x*wingSpread, cluster.y, cluster.r);
    }

    return zones;
  }

  function getDragonBounds(){
    if(!dragonBoss) return null;
    const zones=computeDragonHitZones();
    if(!zones.length){
      return {
        x: dragonBoss.x - dragonBoss.w/2,
        y: dragonBoss.y - dragonBoss.h/2,
        w: dragonBoss.w,
        h: dragonBoss.h
      };
    }
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const zone of zones){
      minX=Math.min(minX, zone.cx - zone.r);
      minY=Math.min(minY, zone.cy - zone.r);
      maxX=Math.max(maxX, zone.cx + zone.r);
      maxY=Math.max(maxY, zone.cy + zone.r);
    }
    return {x:minX, y:minY, w:maxX-minX, h:maxY-minY};
  }

  function circleIntersectsSpaceBoss(cx, cy, radius){
    const bounds=getSpaceBossBounds();
    if(!bounds) return false;
    const nearestX = Math.max(bounds.x, Math.min(cx, bounds.x + bounds.w));
    const nearestY = Math.max(bounds.y, Math.min(cy, bounds.y + bounds.h));
    const dx = cx - nearestX;
    const dy = cy - nearestY;
    return dx*dx + dy*dy <= radius*radius;
  }

  function circleIntersectsDragon(cx, cy, radius){
    const zones=computeDragonHitZones();
    if(!zones.length) return false;
    for(const zone of zones){
      const dx=cx-zone.cx;
      const dy=cy-zone.cy;
      const rr=radius + zone.r;
      if(dx*dx + dy*dy <= rr*rr) return true;
    }
    return false;
  }

  function resolveDragonBallCollision(ball, radius, inRampage){
    const zones=computeDragonHitZones();
    if(!zones.length) return null;
    let best=null;
    for(const zone of zones){
      const dx=ball.x - zone.cx;
      const dy=ball.y - zone.cy;
      const dist=Math.hypot(dx,dy);
      const overlap=(zone.r + radius) - dist;
      if(overlap>0 && (!best || overlap>best.overlap)){
        best={zone, dx, dy, dist:dist||0.0001, overlap};
      }
    }
    if(!best) return null;
    const nx=best.dx/(best.dist||0.0001);
    const ny=best.dy/(best.dist||0.0001);
    const impactX=best.zone.cx + nx*best.zone.r;
    const impactY=best.zone.cy + ny*best.zone.r;
    ball.x = impactX + nx*(radius+0.5);
    ball.y = impactY + ny*(radius+0.5);
    const dot = ball.vx*nx + ball.vy*ny;
    ball.vx -= 2*dot*nx;
    ball.vy -= 2*dot*ny;
    if(inRampage || ball.piercing){
      ball.piercing=true;
    }
    if(Math.abs(ball.vx)<0.2){ ball.vx += nx*4; }
    if(Math.abs(ball.vy)<0.2){ ball.vy += ny*4; }
    const bounceAxis = Math.abs(nx) > Math.abs(ny) ? 'x' : 'y';
    return {impactX, impactY, bounceAxis};
  }

  function triggerBallBuffEffectsOnBossHit(ball, impactX, impactY, now){
    if(buffs.PLASMA.active){
      const cfg=GAME_CONFIG.powers.PLASMA.plasma;
      const ang=Math.random()*Math.PI*2;
      plasmas.push({
        x:impactX,
        y:impactY,
        vx:Math.cos(ang)*cfg.drift,
        vy:Math.sin(ang)*cfg.drift,
        until:now+cfg.lifeMs,
        radius:cfg.radius,
        phase:Math.random()*Math.PI*2
      });
      playSFX('plasma');
    }

    if(buffs.FREEZE.active && (ball.freeze.state==='idle' || !ball.freeze.state)){
      const f=GAME_CONFIG.powers.FREEZE.freeze;
      ball.freeze.state='delay';
      ball.freeze.t0=now;
      ball.freeze.delay=f.delayMs;
      ball.freeze.stop=f.stopMs;
      ball.freeze.oldVX=ball.vx;
      ball.freeze.oldVY=ball.vy;
    }

    if(buffs.HOLY.active){
      playSFX('holy');
      holyFlashes.push({x:impactX, y:impactY, until:now+350});
      const L=layout();
      const rowIdx=Math.round((impactY - L.top) / (brickH + L.pad));
      const colIdx=Math.round((impactX - L.pad) / (brickW + L.pad));
      const rowY=L.top + rowIdx*(brickH + L.pad) + brickH/2;
      const colX=L.pad + colIdx*(brickW + L.pad) + brickW/2;
      for(let i=bricks.length-1;i>=0;i--){
        const t=bricks[i];
        const sameRow=Math.abs((t.y+t.h/2) - rowY)<1;
        const sameCol=Math.abs((t.x+t.w/2) - colX)<1;
        if(sameRow || sameCol){ destroyBrick(i,'none'); }
      }
      if(isSpecialBossActive()){
        const bounds=getActiveBossBounds();
        let bossHit=false;
        if(bounds && rowY>=bounds.y && rowY<=bounds.y+bounds.h){
          const cx=bounds.x+bounds.w/2;
          damageActiveBoss(1,'holy',{x:cx,y:rowY});
          bossHit=true;
        }
        if(bounds && !bossHit && colX>=bounds.x && colX<=bounds.x+bounds.w){
          const cy=bounds.y+bounds.h/2;
          damageActiveBoss(1,'holy',{x:colX,y:cy});
        }
      }
      screenShake=Math.max(screenShake,4);
    }

    if(buffs.HELL.active){
      const holeSpin=(Math.random()>0.5?1:-1);
      blackHoles.push({
        x:impactX,
        y:impactY,
        r:40,
        until:now+GAME_CONFIG.powers.HELL.hell.haloMs,
        start:performance.now(),
        spinDir:holeSpin
      });
      playSFX('blackhole');
    }
  }

  function getReaperBounds(){
    if(!reaperBoss) return null;
    return {
      x: reaperBoss.x - reaperBoss.w/2,
      y: reaperBoss.y - reaperBoss.h/2,
      w: reaperBoss.w,
      h: reaperBoss.h
    };
  }

  function circleIntersectsReaper(cx, cy, radius){
    const bounds=getReaperBounds();
    if(!bounds) return false;
    const nearestX = Math.max(bounds.x, Math.min(cx, bounds.x + bounds.w));
    const nearestY = Math.max(bounds.y, Math.min(cy, bounds.y + bounds.h));
    const dx = cx - nearestX;
    const dy = cy - nearestY;
    return dx*dx + dy*dy <= radius*radius;
  }

  function getDemonBounds(){
    if(!demonBoss) return null;
    const hitW=demonBoss.hitW||demonBoss.w;
    const hitH=demonBoss.hitH||demonBoss.h;
    const offsetX=demonBoss.hitOffsetX||0;
    const offsetY=demonBoss.hitOffsetY||0;
    return {
      x: demonBoss.x + offsetX - hitW/2,
      y: demonBoss.y + offsetY - hitH/2,
      w: hitW,
      h: hitH
    };
  }

  function computeDemonHitZones(){
    if(!demonBoss) return [];
    const bounds=getDemonBounds();
    if(!bounds) return [];
    const cx=bounds.x + bounds.w/2;
    const hitW=bounds.w;
    const hitH=bounds.h;
    const top=bounds.y;
    const zones=[];

    const headH=hitH*0.22;
    const headW=hitW*0.56;
    zones.push({x:cx-headW/2, y:top, w:headW, h:headH});

    const torsoH=hitH*0.38;
    const torsoW=hitW*0.74;
    zones.push({x:cx-torsoW/2, y:top+headH*0.7, w:torsoW, h:torsoH});

    const waistH=hitH*0.26;
    const waistW=hitW*0.7;
    zones.push({x:cx-waistW/2, y:top+headH*0.7+torsoH*0.85, w:waistW, h:waistH});

    const legH=hitH*0.34;
    const legW=hitW*0.32;
    const legY=top+hitH*0.6;
    const legOffset=hitW*0.18;
    zones.push({x:cx-legOffset-legW/2, y:legY, w:legW, h:legH});
    zones.push({x:cx+legOffset-legW/2, y:legY, w:legW, h:legH});

    const armH=hitH*0.34;
    const armW=hitW*0.34;
    const armY=top+hitH*0.28;
    const armOffset=torsoW/2 + armW*0.3;
    zones.push({x:cx-armOffset-armW/2, y:armY, w:armW, h:armH});
    zones.push({x:cx+armOffset-armW/2, y:armY, w:armW, h:armH});

    return zones;
  }

  function demonPointInHitArea(px, py){
    const zones=computeDemonHitZones();
    for(const zone of zones){
      if(px>=zone.x && px<=zone.x+zone.w && py>=zone.y && py<=zone.y+zone.h){
        return true;
      }
    }
    return false;
  }

  function circleIntersectsRect(cx, cy, radius, rect){
    const nearestX=Math.max(rect.x, Math.min(cx, rect.x+rect.w));
    const nearestY=Math.max(rect.y, Math.min(cy, rect.y+rect.h));
    const dx=cx-nearestX;
    const dy=cy-nearestY;
    return dx*dx + dy*dy <= radius*radius;
  }

  function circleIntersectsDemon(cx, cy, radius){
    const zones=computeDemonHitZones();
    if(!zones.length) return false;
    for(const zone of zones){
      if(circleIntersectsRect(cx, cy, radius, zone)) return true;
    }
    return false;
  }

  function getDemonCloakBounds(){
    if(!demonBoss) return null;
    const cloakW=demonBoss.cloakW || ((demonBoss.hitW||demonBoss.w)*1.8);
    const cloakH=demonBoss.cloakH || ((demonBoss.hitH||demonBoss.h)*1.2);
    const offsetX=(demonBoss.cloakOffsetX!=null?demonBoss.cloakOffsetX:(demonBoss.hitOffsetX||0));
    const offsetY=(demonBoss.cloakOffsetY!=null?demonBoss.cloakOffsetY:(demonBoss.hitOffsetY||0));
    const cx=demonBoss.x + offsetX;
    const cy=demonBoss.y + offsetY + cloakH*0.1;
    return {
      x: cx - cloakW/2,
      y: cy - cloakH/2,
      w: cloakW,
      h: cloakH
    };
  }

  function demonCloakCenter(){
    const bounds=getDemonCloakBounds();
    if(!bounds) return null;
    return {x:bounds.x + bounds.w/2, y:bounds.y + bounds.h/2};
  }

  function resolveDemonBallCollision(ball, radius){
    const zones=computeDemonHitZones();
    if(!zones.length) return null;
    let best=null;
    for(const zone of zones){
      if(ball.x+radius<=zone.x || ball.x-radius>=zone.x+zone.w || ball.y+radius<=zone.y || ball.y-radius>=zone.y+zone.h) continue;
      const oL=(ball.x+radius)-zone.x;
      const oR=(zone.x+zone.w)-(ball.x-radius);
      const oT=(ball.y+radius)-zone.y;
      const oB=(zone.y+zone.h)-(ball.y-radius);
      const minOverlap=Math.min(oL,oR,oT,oB);
      if(minOverlap<=0) continue;
      if(!best || minOverlap<best.penetration){
        best={zone, penetration:minOverlap, oL, oR, oT, oB};
      }
    }
    return best;
  }

  function captureBallInCloak(ball, now){
    const center=demonCloakCenter();
    if(!center) return false;
    const anchor={dx:ball.x-center.x, dy:ball.y-center.y};
    ball.demonCloakState='captured';
    ball.demonCloakCapturedAt=now;
    ball.demonCloakReleaseAt=now+2000;
    ball.demonCloakAnchor=anchor;
    ball.demonCloakStoredSpeed=Math.max(Math.hypot(ball.vx, ball.vy), 4);
    ball.demonCloakStayStart=0;
    ball.demonCloakInside=true;
    const wrapRadius=Math.max(36, Math.min(120, Math.hypot(anchor.dx, anchor.dy)));
    ball.demonCloakWrapRadius=wrapRadius;
    ball.demonCloakWrapPhase=Math.atan2(anchor.dy, anchor.dx);
    ball.demonCloakWrapProgress=0;
    ball.demonCloakWrapDuration=900+Math.random()*400;
    ball.demonCloakLastUpdate=now;
    ball.vx=0;
    ball.vy=0;
    return true;
  }

  function releaseBallFromCloak(ball){
    const center=demonCloakCenter();
    const anchor=ball.demonCloakAnchor||{dx:0,dy:0};
    if(center){
      ball.x=center.x + anchor.dx;
      ball.y=center.y + anchor.dy;
    }
    const speedCap=ball.speedCap||GAME_CONFIG.caps.ballSpeedMax;
    const stored=Math.max(ball.demonCloakStoredSpeed||speedCap, 4);
    const speed=Math.min(speedCap, stored*1.2);
    const phase=ball.demonCloakWrapPhase||Math.atan2(anchor.dy, anchor.dx||1);
    const tangent={
      x:-Math.sin(phase),
      y:Math.abs(Math.cos(phase))*0.75 + 0.35
    };
    const dirX=tangent.x>=0?1:-1;
    const len=Math.hypot(tangent.x, tangent.y)||1;
    ball.vx=(tangent.x/len)*speed;
    ball.vy=(tangent.y/len)*speed;
    ball.demonCloakState='launched';
    ball.demonCloakReleaseAt=0;
    ball.demonCloakCapturedAt=0;
    ball.demonCloakWrapProgress=0;
    ball.demonCloakWrapRadius=0;
    ball.demonCloakLastUpdate=0;
    if(demonBoss){
      const now=performance.now();
      demonBoss.cloakWhipStart=now;
      demonBoss.cloakWhipDuration=420;
      demonBoss.cloakWhipUntil=now+420;
      demonBoss.cloakWhipStrength=Math.min(1.4, 0.7+(ball.demonCloakStoredSpeed?Math.min(ball.demonCloakStoredSpeed/10,0.8):0));
      demonBoss.cloakWhipDir=dirX||1;
    }
  }

  function handleDemonCloakState(ball, now){
    if(!demonBoss || demonPhase!=='active'){
      if(ball.demonCloakState==='captured'){
        const restore=Math.max(ball.demonCloakStoredSpeed||4,4);
        if(Math.abs(ball.vx)+Math.abs(ball.vy)<0.2){
          ball.vx=0;
          ball.vy=-restore;
        }
        ball.demonCloakState=null;
      }
      ball.demonCloakStoredSpeed=0;
      ball.demonCloakAnchor=null;
      ball.demonCloakStayStart=0;
      ball.demonCloakInside=false;
      ball.demonCloakWrapProgress=0;
      ball.demonCloakWrapRadius=0;
      ball.demonCloakLastUpdate=0;
      return false;
    }

    if(ball.demonCloakState==='captured'){
      const center=demonCloakCenter();
      if(center){
        const anchor=ball.demonCloakAnchor||{dx:0,dy:0};
        const dt=now-(ball.demonCloakLastUpdate||now);
        const wrapDuration=ball.demonCloakWrapDuration||1000;
        const progress=Math.max(0, Math.min(1, (ball.demonCloakWrapProgress||0) + (wrapDuration>0?dt/wrapDuration:0)));
        ball.demonCloakWrapProgress=progress;
        const baseRadius=ball.demonCloakWrapRadius||Math.max(36, Math.hypot(anchor.dx, anchor.dy));
        const eased=Math.pow(progress,0.85);
        const radius=Math.max(18, baseRadius*(1-eased) + 18*eased);
        const swirlSpeed=0.006 + 0.006*progress;
        ball.demonCloakWrapPhase=(ball.demonCloakWrapPhase||Math.atan2(anchor.dy, anchor.dx||1)) + dt*swirlSpeed;
        const phase=ball.demonCloakWrapPhase;
        const lift=Math.sin(progress*Math.PI*1.2)*10;
        const dx=Math.cos(phase)*radius;
        const dy=Math.sin(phase)*radius*0.65 + lift;
        const sway=Math.sin((now-(ball.demonCloakCapturedAt||now))/260)*3;
        ball.demonCloakAnchor={dx, dy:dy+sway};
        ball.x=center.x + dx;
        ball.y=center.y + dy + sway;
        ball.demonCloakLastUpdate=now;
      }
      ball.vx=0;
      ball.vy=0;
      if(ball.demonCloakReleaseAt && now>=ball.demonCloakReleaseAt){
        releaseBallFromCloak(ball);
      }
      return ball.demonCloakState==='captured';
    }

    const cloakBounds=getDemonCloakBounds();
    if(!cloakBounds) return false;
    const inCloak=(ball.x>=cloakBounds.x && ball.x<=cloakBounds.x+cloakBounds.w && ball.y>=cloakBounds.y && ball.y<=cloakBounds.y+cloakBounds.h);
    const wasInside=!!ball.demonCloakInside;
    ball.demonCloakInside=inCloak;
    if(inCloak && ball.demonCloakState!=='launched' && !demonPointInHitArea(ball.x, ball.y)){
      if(!wasInside){
        ball.demonCloakStayStart=now;
        if(Math.random()<0.05){
          if(captureBallInCloak(ball, now)){
            return true;
          }
        }
      }
    }else if(!inCloak){
      if(wasInside){ ball.demonCloakStayStart=0; }
      if(ball.demonCloakState!=='launched'){ ball.demonCloakState=null; }
    }
    return false;
  }

  function spaceBossImpactPoint(fromX, fromY){
    const bounds=getSpaceBossBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const targetX = spaceBoss.x;
    const targetY = spaceBoss.y;
    const dx = targetX - fromX;
    const dy = targetY - fromY;
    let bestT = Infinity;
    function test(t){
      if(t<=0 || t>=1e6) return;
      const ix = fromX + dx*t;
      const iy = fromY + dy*t;
      if(ix>=bounds.x-1e-6 && ix<=bounds.x+bounds.w+1e-6 && iy>=bounds.y-1e-6 && iy<=bounds.y+bounds.h+1e-6){
        if(t<bestT) bestT=t;
      }
    }
    if(Math.abs(dx)>1e-6){
      test((bounds.x - fromX)/dx);
      test((bounds.x + bounds.w - fromX)/dx);
    }
    if(Math.abs(dy)>1e-6){
      test((bounds.y - fromY)/dy);
      test((bounds.y + bounds.h - fromY)/dy);
    }
    if(bestT!==Infinity){
      return {x: fromX + dx*bestT, y: fromY + dy*bestT};
    }
    return {x: targetX, y: targetY};
  }

  function reaperImpactPoint(fromX, fromY){
    const bounds=getReaperBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const targetX = reaperBoss.x;
    const targetY = reaperBoss.y;
    const dx = targetX - fromX;
    const dy = targetY - fromY;
    let bestT = Infinity;
    function test(t){
      if(t<=0 || t>=1e6) return;
      const ix = fromX + dx*t;
      const iy = fromY + dy*t;
      if(ix>=bounds.x-1e-6 && ix<=bounds.x+bounds.w+1e-6 && iy>=bounds.y-1e-6 && iy<=bounds.y+bounds.h+1e-6){
        if(t<bestT) bestT=t;
      }
    }
    if(Math.abs(dx)>1e-6){
      test((bounds.x - fromX)/dx);
      test((bounds.x + bounds.w - fromX)/dx);
    }
    if(Math.abs(dy)>1e-6){
      test((bounds.y - fromY)/dy);
      test((bounds.y + bounds.h - fromY)/dy);
    }
    if(bestT!==Infinity){
      return {x: fromX + dx*bestT, y: fromY + dy*bestT};
    }
    return {x: targetX, y: targetY};
  }

  function demonImpactPoint(fromX, fromY){
    const bounds=getDemonBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const targetX = demonBoss.x;
    const targetY = demonBoss.y;
    const dx = targetX - fromX;
    const dy = targetY - fromY;
    let bestT = Infinity;
    function test(t){
      if(t<=0 || t>=1e6) return;
      const ix = fromX + dx*t;
      const iy = fromY + dy*t;
      if(ix>=bounds.x-1e-6 && ix<=bounds.x+bounds.w+1e-6 && iy>=bounds.y-1e-6 && iy<=bounds.y+bounds.h+1e-6){
        if(t<bestT) bestT=t;
      }
    }
    if(Math.abs(dx)>1e-6){
      test((bounds.x - fromX)/dx);
      test((bounds.x + bounds.w - fromX)/dx);
    }
    if(Math.abs(dy)>1e-6){
      test((bounds.y - fromY)/dy);
      test((bounds.y + bounds.h - fromY)/dy);
    }
    if(bestT!==Infinity){
      return {x: fromX + dx*bestT, y: fromY + dy*bestT};
    }
    return {x: targetX, y: targetY};
  }

  function highlightSpaceBossTarget(){
    if(isReaperActive()){
      const bounds=getReaperBounds();
      if(bounds){
        reaperTargetHighlightUntil = Math.max(reaperTargetHighlightUntil, performance.now()+600);
        pushLockBox(bounds.x, bounds.y, bounds.w, bounds.h, 'target');
      }
      return;
    }
    const bounds=getSpaceBossBounds();
    if(bounds){
      pushLockBox(bounds.x, bounds.y, bounds.w, bounds.h, 'target');
      return;
    }
    if(isDragonActive()){
      const dragonBounds=getDragonBounds();
      if(dragonBounds){
        pushLockBox(dragonBounds.x, dragonBounds.y, dragonBounds.w, dragonBounds.h, 'target');
      }
    }
  }
    let scoreUploaded=false;
    let uploading=false;
  let ledStyle = (localStorage.getItem('led_style')||'classic');
  function resetCombo(){
    combo=0; comboLastTime=0;
    comboNoticeTriggered={50:false,100:false,200:false,300:false,400:false,500:false,800:false,1000:false};
    if(comboEl){ comboEl.textContent=''; comboEl.className='combo'; comboEl.style.opacity=0; }
  }
  function showComboNotice(text,showMs=5000,fadeMs=3000){
    let notice=document.getElementById('comboNotice');
    if(!notice){
      notice=document.createElement('div');
      notice.id='comboNotice';
      document.getElementById('playArea').appendChild(notice);
    }
    notice.className='';
    notice.innerHTML='';
    const span=document.createElement('span');
    span.className='marqueeText';
    span.textContent=text;
    span.style.animation=`comboMarquee ${showMs}ms linear`;
    notice.appendChild(span);
    notice.style.transition=`opacity ${fadeMs/1000}s`;
    void notice.offsetWidth;
    notice.className='show';
    setTimeout(()=>notice.classList.add('fade'),showMs);
    setTimeout(()=>{notice.className=''; notice.innerHTML=''; notice.style.transition='';},showMs+fadeMs);
  }
  function incrementCombo(){
    combo++; comboLastTime=performance.now();
    if(combo>stats.maxCombo) stats.maxCombo=combo;
    if(!comboEl) return;
    comboEl.textContent='Combo '+combo;
    comboEl.className='combo show';
    if(combo>=200){ comboEl.classList.add('tier6','glow'); }
    else if(combo>=100){ comboEl.classList.add('tier5'); }
    else if(combo>=50){ comboEl.classList.add('tier4'); }
    else if(combo>=30){ comboEl.classList.add('tier3'); }
    else if(combo>=10){ comboEl.classList.add('tier2'); }
    else { comboEl.classList.add('tier1'); }
    if(buffs.COMBO?.active){ comboEl.classList.add('star'); }
    comboEl.classList.add('pop'); setTimeout(()=>comboEl.classList.remove('pop'),500);
    comboEl.style.opacity=1;
    if(combo===50 && !comboNoticeTriggered[50]){ comboNoticeTriggered[50]=true; showComboNotice('看來是個高手呢！'); }
    else if(combo===100 && !comboNoticeTriggered[100]){ comboNoticeTriggered[100]=true; showComboNotice('真是驚人！ 你……是怪物嗎？'); }
    else if(combo===200 && !comboNoticeTriggered[200]){ comboNoticeTriggered[200]=true; showComboNotice('難以置信！ 你……是神嗎？'); }
    else if(combo===300 && !comboNoticeTriggered[300]){ comboNoticeTriggered[300]=true; showComboNotice('你是還想突破天際到哪裡去呀？異次元嗎？'); }
    else if(combo===400 && !comboNoticeTriggered[400]){ comboNoticeTriggered[400]=true; showComboNotice('你這已經破碎虛空了吧？'); }
    else if(combo===500 && !comboNoticeTriggered[500]){ comboNoticeTriggered[500]=true; showComboNotice('算你狠！有種Combo 1000看看呀！'); }
    else if(combo===800 && !comboNoticeTriggered[800]){ comboNoticeTriggered[800]=true; showComboNotice('我看你是到不了Combo 1000的啦！是不是開始感覺手滑啦？'); }
    else if(combo===1000 && !comboNoticeTriggered[1000]){ comboNoticeTriggered[1000]=true; showComboNotice('快截圖給同事看吧！你是真正的連擊之神！',10000,5000); }
  }
  function getComboMultiplier(){
    if(combo>=1000) return 10;
    if(combo>=800) return 8;
    if(combo>=500) return 7;
    if(combo>=400) return 6;
    if(combo>=300) return 5;
    if(combo>=200) return 4;
    if(combo>=100) return 3;
    if(combo>=50) return 2;
    if(combo>=30) return 1.5;
    if(combo>=10) return 1.2;
    return 1;
  }
  function addScore(base){
    let mul=getComboMultiplier();
    if(buffs.COMBO?.active){ mul*=GAME_CONFIG.powers.COMBO.combo.scoreMul; }
    const d=difficultySel?.value;
    if(d==='easy') mul*=0.5;
    else if(d==='hard') mul*=1.2;
    score += Math.round(base * mul);
  }
  function scoreForBrick(b){ return b.boss ? 3000 : (b.elite ? 100 : 10); }
  const BOSS_DEFEAT_SCORE = {
    space: 5000,
    reaper: 10000,
    dragon: 20000,
    demon: 50000
  };
  const BOSS_HIT_SCORE = 30;
  function renderStatsHtml(){
    const fd = (stats.fastestDeath===Infinity)? '-' : stats.fastestDeath.toFixed(1);
    const ld = (stats.longestLife===0)? '-' : stats.longestLife.toFixed(1);
    return `<div class="grid">
      <div>消耗生命：<strong>${stats.livesUsed}</strong></div>
      <div>接球次數：<strong>${stats.catches}</strong></div>
      <div>增益次數：<strong>${stats.buffs}</strong></div>
      <div>減益次數：<strong>${stats.debuffs}</strong></div>
      <div>殺菁英數：<strong>${stats.eliteKills}</strong></div>
      <div>殺Boss數：<strong>${stats.bossKills}</strong></div>
      <div>最高Combo數：<strong>${stats.maxCombo}</strong></div>
      <div>最快死亡：<strong>${fd}</strong> s</div>
      <div>最久存活：<strong>${ld}</strong> s</div>
    </div>`;
  }

  let bgTime=0; let screenShake=0;
  let countdownTimer=null, countdownShow=0, resumePending=false;
  // === 新增暫停時間追蹤與自動增益掉落計時 ===
  // pauseStartedAt: 記錄暫停開始時的時間戳。當非 null 時表遊戲處於暫停狀態（包括開啟音效/選項菜單、教學說明等）。
  // lastBeneficialPickupAt: 上一次取得增益或特殊增益的時間戳，用於觸發十秒未拾取增益時自動掉落。
  // nextAutoBeneficialDropAt: 下一次自動掉落增益的預定時間，將在 update 中檢查並觸發。
  let pauseStartedAt = null;
  let lastBeneficialPickupAt = 0;
  let nextAutoBeneficialDropAt = 0;
  // 影像選擇：1~10 隨機 bg/cg，11~20 用對應未用者
  let imageChoice = new Array(10).fill(-1); // 0=bg,1=cg; -1: 未決
  let galleryUnlocks = {};
  try{ galleryUnlocks = JSON.parse(localStorage.getItem('gallery_unlocks')||'{}'); }catch(e){ galleryUnlocks={}; }
  function markImageUnlocked(type, idx){
    const key = `${type}${idx+1}`;
    if(!galleryUnlocks[key]){
      galleryUnlocks[key]=true;
      try{ localStorage.setItem('gallery_unlocks', JSON.stringify(galleryUnlocks)); }catch(e){}
    }
  }

  let dialogUnlocks = {};
  try{ dialogUnlocks = JSON.parse(localStorage.getItem('dialog_unlocks')||'{}'); }catch(e){ dialogUnlocks={}; }
  function unlockDialog(key, idx){
    const mask = dialogUnlocks[key] || 0;
    dialogUnlocks[key] = mask | (1<<idx);
    try{ localStorage.setItem('dialog_unlocks', JSON.stringify(dialogUnlocks)); }catch(e){}
  }
  function getRandomDialog(key){
    const lines = DIALOGS[key] || [];
    const mask = dialogUnlocks[key] || 0;
    const lockedIdx = [];
    for(let i=0;i<lines.length;i++){
      if(!(mask & (1<<i))) lockedIdx.push(i);
    }
    let idx;
    if(lockedIdx.length>0){
      idx = lockedIdx[Math.floor(Math.random()*lockedIdx.length)];
    }else{
      idx = Math.floor(Math.random()*lines.length);
    }
    return {idx, text: lines[idx]||''};
  }
  // BGM
  let audioCtx=null, bgmGain=null, bgmOn=false, bgmStarted=false;
  // 追蹤目前作用中的 BGM node，便於停止與清除
  let bgmNodes=new Set();

  // === 初始化新 UI 的聲音/BGM 控制 ===
  // 連結複選框至原有的 soundBtn/bgmBtn 按鈕，並同步本地儲存值
  if (sfxOnEl) {
    const stored = localStorage.getItem('sfx_on');
    // 若本地有設定則使用，否則沿用預設的 soundsOn
    soundsOn = (stored ?? (soundsOn ? '1' : '0')) === '1';
    sfxOnEl.checked = soundsOn;
    // 切換複選框即呼叫舊邏輯的按鈕 click，並依據更新後的變數同步複選框狀態
    sfxOnEl.addEventListener('change', () => {
      soundBtn.click();
      sfxOnEl.checked = soundsOn;
    });
  }
  if (bgmOnEl) {
    const stored = localStorage.getItem('bgm_on');
    bgmOn = (stored ?? (bgmOn ? '1' : '0')) === '1';
    bgmOnEl.checked = bgmOn;
    bgmOnEl.addEventListener('change', () => {
      bgmBtn.click();
      bgmOnEl.checked = bgmOn;
    });
  }
  // 初始化 BGM 音量滑桿
  if (localStorage.getItem('bgm_vol')) {
    const vol = parseFloat(localStorage.getItem('bgm_vol'));
    if (!isNaN(vol)) {
      bgmVol.value = String(vol);
      if (bgmGain) bgmGain.gain.value = vol;
    }
  }

  // 粒子 / 特效容器
  const particles=[]; // {x,y,vx,vy,life,size,color}
  const plasmas=[];   // {x,y,vx,vy,until,radius}
  const holyFlashes=[]; // {x,y,until}
  let phoenixAnim=null; // {x, tEnd}
  const fireBursts=[];  // 火焰片段 {x,y,life}
  const fireExplosions=[]; // 火焰球爆炸效果 {x,y,r,t0,life}

  // 新增容器：飛彈、黑洞特效、雷射光束
  const missiles=[]; // {x,y,vx,vy,targetId,targetType,lifeUntil,trail:[]}
  const blackHoles=[]; // {x,y,until}
  const laserBeams=[]; // {x1,y1,x2,y2,until}
  const laserImpacts=[]; // {x,y,t0,tEnd}
  const gatlingBullets=[]; // 火力壓制子彈 {x,y,vx,vy}
  const lockBoxes=[]; // {x,y,w,h,until,kind}
  let nextTreasureBrickAt=0;

  function scheduleNextTreasureBrick(now=performance.now()){
    nextTreasureBrickAt = now + 5000 + Math.random()*3000;
  }

  function isTrueBossFightActive(){
    return (spaceBossPhase==='active' && spaceBoss) || (reaperPhase==='active' && reaperBoss) || (dragonPhase==='active' && dragonBoss) || (demonPhase==='active' && demonBoss);
  }

  function spawnBossTreasureBrick(){
    if(!isTrueBossFightActive()) return;
    const L=layout();
    const width=Math.max(48, brickW||80);
    const height=Math.max(20, brickH||24);
    const pad=40;
    const minX=pad;
    const maxX=Math.max(minX, 1100 - pad - width);
    const spawnX=minX + Math.random()*(maxX - minX);
    const top=L?L.top:0;
    const spawnY=(top||0) - height - 12;
    const fallVy=GAME_CONFIG.powerCapsule.fallVy||2.2;
    addBrick(bricks, spawnX, spawnY, width, height, {
      hp:1,
      treasure:true,
      fallingTreasure:true,
      vy:fallVy,
      colorIdx:0
    });
    spawnParticles(spawnX + width/2, Math.max(spawnY + height/2, 0), '#a8e3ff', 14, 1.6, 2.6, 2.4);
    spawnParticles(spawnX + width/2, Math.max(spawnY + height/2, 0), '#ff9bf1', 10, 1.2, 2.0, 2.0);
    updateHUD();
  }

  // 特殊增益相關容器
  const swords=[]; // 劍芒裂空：{x,y,vx,vy,state,tx,ty}
  let swordFireStart=0, nextSwordFire=0;

  let stormTurret=null; // 雷射風暴：{x,y,chargeUntil,fireAt,shots,lastShot}
  let gatling=null; // 火力壓制：{x,y,chargeUntil,fireStart,fireUntil,lastShot,angle}

  const annihilSparks=[]; // 萬物銷毀：天空灑落的金色光點 {x,y,v}

  // === Boss 投射物 ===
  const hostileBeams=[]; // 線性光束彈 {x,y,vx,vy,color,hit,onHit}
  const hostileArcs=[];  // 弧形劍氣 {x,y,vx,vy,phase,amp,color,onHit}
  const hostileColumns=[]; // 直下石化光束 {x,w,tStart,tEnd,color,applied}
  const hazardClouds=[]; // 烏雲 {x,y,tEnd,spawned}

  function bossCenter(){
    if(isDragonActive() && dragonBoss) return {b:null, x:dragonBoss.x, y:dragonBoss.y, type:'dragon'};
    for(const b of bricks){ if(b.boss) return {b, x:b.x+b.w/2, y:b.y+b.h/2}; }
    return null;
  }

  function spawnLionBeamFrom(x,y){
    const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
    const ang=Math.atan2(ty-y, tx-x); const speed=6.0;
    hostileBeams.push({x:x, y:y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); screenShake=Math.max(screenShake,6); }});
    beep(1100,0.12,0.08);
  }
  function spawnLionBeam(){
    const bc=bossCenter(); if(!bc) return;
    bossChargeColor='255,215,90'; bossChargeUntil=performance.now()+2000;
    setTimeout(()=>{
      const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
      const ang=Math.atan2(ty-bc.y, tx-bc.x); const speed=6.0;
      hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); screenShake=Math.max(screenShake,6); }});
      beep(1100,0.12,0.08);
    },2000);
  }
  function spawnKnightArc(){
    const bc=bossCenter(); if(!bc) return;
    bossChargeColor='210,210,255'; bossChargeUntil=performance.now()+2000;
    setTimeout(()=>{
      const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
      const ang=Math.atan2(ty-bc.y, tx-bc.x);
      const speed=4.5;
      hostileArcs.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, phase:0, amp:32, color:'silver', onHit:()=>{ lives=Math.max(0, lives-1); updateHUD(); screenShake=Math.max(screenShake,10); }});
      beep(900,0.12,0.07);
    },2000);
  }
  function spawnCyclopsColumn(opts={}){
    const bc=bossCenter(); if(!bc) return;
    const now=performance.now();
    bossChargeColor='255,235,150';
    bossChargeUntil=now+3000;
    if(isDragonActive() && dragonBoss){
      dragonBoss.petrifyCharge={start:now,end:now+3000};
      dragonMarquee={text:'危險！ 毀滅之龍即將使出石化光束!', start:now, fadeStart:now+2600, end:now+3000, style:'elegant'};
    }
    setTimeout(()=>{
      const center=bossCenter();
      if(!center){
        if(dragonBoss) dragonBoss.petrifyCharge=null;
        return;
      }
      const releaseAt=performance.now();
      hostileColumns.push({x:center.x, w:150, tStart:releaseAt, tEnd:releaseAt+1000, color:'#eedc9a', applied:false});
      cyclopsShakeUntil=releaseAt+2000;
      if(isDragonActive() && dragonBoss){
        dragonBoss.petrifyCharge=null;
      }
      noteCyclopsFirstAttack(releaseAt);
      beep(500,0.12,0.08);
      if(opts.onComplete){ setTimeout(()=>{ opts.onComplete(); },1000); }
    },3000);
  }
  function finishDragonAttack(expectType=null){
    const now=performance.now();
    if(expectType && dragonAttackState && dragonAttackState.type!==expectType){ return; }
    dragonAttackState=null;
    dragonDeathRayOrbs.length=0;
    dragonDeathRayBeams.length=0;
    if(dragonBoss){
      dragonBoss.pose=null;
      dragonBoss.moveTarget=null;
      dragonBoss.nextMove=now+1400;
    }
    dragonNextAttackAt=now+20000;
  }

  function maybeStartDragonAttack(now){
    if(!isDragonActive() || !dragonBoss) return;
    if(dragonAttackState) return;
    if(!dragonNextAttackAt){ dragonNextAttackAt=now+3000; }
    if(now<dragonNextAttackAt) return;
    const options=['petrify','deathRay','annihilation'];
    const pick=options[Math.floor(Math.random()*options.length)];
    startDragonAttack(pick);
  }

  function startDragonAttack(type){
    if(!dragonBoss) return;
    const now=performance.now();
    if(type==='petrify'){
      dragonAttackState={type:'petrify', startedAt:now, phase:'charge'};
      spawnCyclopsColumn({onComplete:()=>finishDragonAttack('petrify')});
    }else if(type==='deathRay'){
      const L=layout();
      const targetY=L.top+120;
      dragonBoss.moveTarget=null;
      dragonAttackState={
        type:'deathRay',
        startedAt:now,
        phase:'countdown',
        overrideMovement:true,
        targetX:550,
        targetY,
        countdownEnd:now+3000,
        nextOrb:now,
        countdownValue:3,
        nextCountdownTick:now+1000,
        fireIndex:0,
        fireNext:0,
        lockedTarget:null,
        beamTravel:900,
        beamFade:320
      };
      dragonDeathRayOrbs.length=0;
      dragonBoss.pose='deathRay';
      dragonMarquee={text:'危險！ 毀滅之龍即將使出破壞死光! 3', start:now, fadeStart:now+2600, end:now+3000, style:'elegant'};
    }else if(type==='annihilation'){
      const L=layout();
      const tag=`annihilation_${now}`;
      const rowY=L.top + brickH + L.pad*0.5;
      const challengeBricks=[];
      for(let c=0;c<L.cols;c++){
        const x=L.pad + c*(brickW+L.pad);
        addBrick(bricks, x, rowY, brickW, brickH, {hp:1, colorIdx:c%4, annihilationTag:tag});
        challengeBricks.push(brickIdCounter-1);
      }
      updateHUD();
      dragonBoss.moveTarget=null;
      dragonAttackState={
        type:'annihilation',
        startedAt:now,
        phase:'challenge',
        overrideMovement:true,
        countdownEnd:now+10000,
        bricksTag:tag,
        challengeBricks,
        targetY:Math.max(L.top-240, dragonBoss.baseY-220),
        returnY:dragonBoss.baseY,
        explosionEnd:0,
        hideDragon:false
      };
      dragonBoss.pose=null;
      dragonMarquee={text:'危險！ 毀滅之龍即將使出萬物銷毀!', start:now, fadeStart:now+9000, end:now+10000, style:'elegant'};
      showPrompt('請於10sec內擊毀所有磚塊阻止萬物銷毀');
    }
    dragonNextAttackAt=0;
  }

  function updateDragonAttackState(now, dt){
    if(!dragonAttackState){
      maybeStartDragonAttack(now);
      return false;
    }
    const state=dragonAttackState;
    if(state.type==='petrify'){
      return false;
    }
    if(state.type==='deathRay'){
      const travelDuration = state.beamTravel || 900;
      const fadeDuration = state.beamFade || 320;
      const speed=Math.min(0.28, (dt/1000)*0.9);
      const tx=state.targetX||dragonBoss.x;
      const ty=state.targetY||dragonBoss.baseY;
      dragonBoss.x += (tx - dragonBoss.x)*speed;
      dragonBoss.baseY += (ty - dragonBoss.baseY)*speed;

      for(const orb of dragonDeathRayOrbs){
        if(!orb.angle){ orb.angle=Math.random()*Math.PI*2; }
        const rot=0.0024*dt;
        orb.angle += rot;
        const radius=orb.radius||(110+Math.random()*40);
        orb.radius=radius;
        const verticalScale=orb.vertScale||0.55+Math.random()*0.25;
        orb.vertScale=verticalScale;
        orb.x = dragonBoss.x + Math.cos(orb.angle)*radius;
        orb.y = dragonBoss.y - 40 + Math.sin(orb.angle)*radius*verticalScale;
      }

      if(state.phase==='countdown'){
        if(now>=state.nextOrb){
          state.nextOrb=now+500;
          dragonDeathRayOrbs.push({createdAt:now});
        }
        if(state.countdownValue>1 && now>=state.nextCountdownTick){
          state.countdownValue--;
          state.nextCountdownTick+=1000;
          if(dragonMarquee){ dragonMarquee.text=`危險！ 毀滅之龍即將使出破壞死光! ${state.countdownValue}`; }
          beep(720+(3-state.countdownValue)*40,0.08,0.05);
        }
        if(now>=state.countdownEnd){
          state.phase='firing';
          state.fireNext=now;
          if(dragonMarquee){
            dragonMarquee.text='破壞死光啟動！';
            dragonMarquee.start=now;
            dragonMarquee.fadeStart=now+800;
            dragonMarquee.end=now+1400;
          }
        }
      }
      if(state.phase==='firing' && now>=state.fireNext){
        const orb=dragonDeathRayOrbs.shift();
        if(orb){
          const pr=paddleRect();
          let target=state.lockedTarget;
          if(!target || now>=paddleGoneUntil){
            target={x:pr.x+pr.w/2, y:pr.y+pr.h/2};
            state.lockedTarget={...target};
          }
          dragonDeathRayBeams.push({
            x1:orb.x||dragonBoss.x,
            y1:orb.y||dragonBoss.y,
            x2:target.x,
            y2:target.y,
            start:now,
            impactAt:now+travelDuration,
            end:now+travelDuration+fadeDuration,
            hit:false
          });
          state.fireNext=now+500;
        }else{
          state.phase='cooldown';
          state.cooldownUntil=now+800;
        }
      }
      for(const beam of dragonDeathRayBeams){
        if(beam.hit) continue;
        const impactAt=beam.impactAt || beam.end;
        if(now>=impactAt){
          beam.hit=true;
          const targetX=beam.x2;
          const targetY=beam.y2;
          const pr=paddleRect();
          const intersects = pr.w>0 && pr.h>0 && segmentIntersectsRect(beam.x1, beam.y1, targetX, targetY, pr);
          if(intersects){
            spawnParticles(targetX, targetY, '#ffec8a', 36, 2.4, 4.0, 4.0);
            dragonBursts.push({type:'flare',x:targetX,y:targetY,r0:0,r1:280,t0:now,life:900,color:'255,225,150'});
            screenShake=Math.max(screenShake,14);
            playSFX('fireExplosion');
            if(now>=paddleGoneUntil){
              paddleGoneUntil=now+3000;
            }
          }
        }
      }
      if(state.phase==='cooldown' && now>=state.cooldownUntil && !dragonDeathRayBeams.length){
        finishDragonAttack('deathRay');
      }
      return true;
    }
    if(state.type==='annihilation'){
      if(state.phase==='challenge'){
        const speed=Math.min(0.32, (dt/1000)*1.1);
        dragonBoss.x += (550 - dragonBoss.x)*speed;
        dragonBoss.baseY += (state.targetY - dragonBoss.baseY)*speed;
        if(dragonBoss.baseY<=state.targetY+2){ state.hideDragon=true; }
        const remain = bricks.some(b=>b.annihilationTag===state.bricksTag);
        if(!remain){
          state.phase='returning';
          state.hideDragon=false;
          state.returnStart=now;
          if(dragonMarquee){
            dragonMarquee.text='成功阻止萬物銷毀!';
            dragonMarquee.start=now;
            dragonMarquee.fadeStart=now+1600;
            dragonMarquee.end=now+2000;
          }
        }else if(now>=state.countdownEnd){
          state.phase='detonate';
          state.detonated=false;
          state.detonateStart=now;
          state.explosionEnd=now+5000;
          state.hideDragon=true;
          dragonMarquee={text:'萬物銷毀啟動!', start:now, fadeStart:now+4200, end:now+5000, style:'alert'};
        }
        return true;
      }
      if(state.phase==='detonate'){
        if(!state.detonated){
          state.detonated=true;
          screenShake=Math.max(screenShake,36);
          playSFX('dragonAnnihilation');
          const nowDet=now;
          for(let i=bricks.length-1;i>=0;i--){
            const b=bricks[i];
            const cx=b.x+b.w/2, cy=b.y+b.h/2;
            spawnParticles(cx, cy, '#ffe7a6', 30, 2.8, 4.0, 4.2);
            dragonBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:280,t0:nowDet,life:1200,color:'255,220,150'});
            bricks.splice(i,1);
          }
          const L=layout();
          const stageHeight=L.rows*(brickH+L.pad) - L.pad;
          const centerX=550;
          const centerY=L.top + stageHeight/2;
          dragonBursts.push({type:'apocalypse',x:centerX,y:centerY,r0:140,r1:960,t0:nowDet,life:2600,color:'255,236,190'});
          dragonBursts.push({type:'shockwave',x:centerX,y:centerY,r0:0,r1:1100,width:46,t0:nowDet,life:2200,color:'255,230,180'});
          const emberParticles=Array.from({length:90},()=>({
            angle:Math.random()*Math.PI*2,
            radius:40+Math.random()*220,
            speed:260+Math.random()*360,
            size:10+Math.random()*18,
            drift:(Math.random()*0.6-0.3)
          }));
          dragonBursts.push({type:'emberRain',x:centerX,y:centerY,t0:nowDet,life:2400,count:emberParticles.length,particles:emberParticles});
          const aftershockDelays=[0,200,420,660,900];
          aftershockDelays.forEach((delay, idx)=>{
            setTimeout(()=>{
              screenShake=Math.max(screenShake, Math.max(18, 30 - idx*4));
              if(idx>0){ playSFX('fireExplosion'); }
            }, delay);
          });
          updateHUD();
          paddleGoneUntil=Math.max(paddleGoneUntil, now+5500);
        }
        if(now>=state.explosionEnd){
          state.phase='returning';
          state.hideDragon=false;
          dragonBoss.baseY=state.targetY;
          dragonBoss.y=state.targetY;
          dragonBoss.x=550;
        }
        return true;
      }
      if(state.phase==='returning'){
        const speed=Math.min(0.26, (dt/1000)*0.9);
        dragonBoss.x += (550 - dragonBoss.x)*speed;
        dragonBoss.baseY += (state.returnY - dragonBoss.baseY)*speed;
        if(Math.abs(dragonBoss.baseY-state.returnY)<2 && Math.abs(dragonBoss.x-550)<3){
          finishDragonAttack('annihilation');
        }
        return true;
      }
      return true;
    }
    return false;
  }

  function spawnDemonBeam(){
    const bc=bossCenter(); if(!bc) return;
    bossChargeColor='255,60,80'; bossChargeUntil=performance.now()+2000;
    setTimeout(()=>{
      const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
      const ang=Math.atan2(ty-bc.y, tx-bc.x); const speed=7.2;
      hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'red', hit:false, onHit:()=>{ lives=Math.max(0, lives-1); updateHUD(); screenShake=Math.max(screenShake,12); }});
      beep(600,0.14,0.09);
    },2000);
  }
  function spawnDemonClouds(){
    showPrompt('哈哈哈! 接受惡魔的詛咒吧!');
    const picks = Array.from({length:5}, ()=> 40 + Math.random()*(1100-80));
    const y = layout().top - 10;
    const tEnd = performance.now() + 1000;
    for(const x of picks){ hazardClouds.push({x,y,tEnd,spawned:false}); }
  }
  function noteCyclopsFirstAttack(at){
    if(level!==15 || cyclopsFirstAttackAt) return;
    cyclopsFirstAttackAt = at;
    cyclopsMarqueeShown=false;
    cyclopsEventStarted=false;
    cyclopsEventComplete=false;
    cyclopsForcedPetrifyAt=0;
    cyclopsForcedPetrifyFired=false;
    cyclopsRowBlastIndex=-1;
    cyclopsNextRowBlast=0;
    cyclopsShellBurst=false;
  }
  function updateCyclopsEvent(){
    if(level!==15 || !cyclopsFirstAttackAt || cyclopsEventComplete) return;
    const now=performance.now();
    const triggerAt = cyclopsFirstAttackAt + 5000;
    if(now>=triggerAt){
      if(!cyclopsMarqueeShown){
        showComboNotice('竟然妄想踏入神之領域嗎? 真是愚蠢的人類!',5000,3000);
        cyclopsMarqueeShown=true;
      }
      if(!cyclopsEventStarted){
        cyclopsEventStarted=true;
        const L=layout();
        cyclopsRowBlastIndex=L.rows-1;
        cyclopsNextRowBlast=now;
      }
    }
    if(cyclopsEventStarted){
      screenShake=Math.max(screenShake,20);
      if(cyclopsRowBlastIndex>=0 && now>=cyclopsNextRowBlast){
        cyclopsBlastRow(cyclopsRowBlastIndex);
        cyclopsRowBlastIndex--;
        cyclopsNextRowBlast=now+500;
      }
      if(cyclopsRowBlastIndex<0){
        cyclopsEventStarted=false;
        cyclopsEventComplete=true;
      }
    }
  }

  function prepareDemonRows(){
    const L=layout();
    const spacing = brickH + L.pad;
    const rowsMap=new Map();
    for(const b of bricks){
      if(b.demonShell) continue;
      if(b.fallingTreasure) continue;
      const row=Math.round((b.y - L.top)/spacing);
      if(!rowsMap.has(row)) rowsMap.set(row, []);
      rowsMap.get(row).push(b);
    }
    demonEventRows = Array.from(rowsMap.entries())
      .sort((a,b)=>b[0]-a[0])
      .map(([,arr])=>{
        const copy=arr.slice();
        for(let i=copy.length-1;i>0;i--){
          const j=Math.floor(Math.random()*(i+1));
          [copy[i], copy[j]]=[copy[j], copy[i]];
        }
        return copy;
      });
    demonEventTargets = demonEventRows.reduce((sum,row)=>sum+row.length,0);
    demonEventCleared=0;
  }

  function dropDemonRow(row, now){
    if(!Array.isArray(row)) return;
    const debris=[];
    for(const brick of row){
      const idx=bricks.indexOf(brick);
      if(idx>=0){
        revealBrickArea(brick);
        bricks.splice(idx,1);
      }
      demonEventCleared++;
      const baseColor = brick.treasure ? '#ffd166' : brick.boss ? '#ff4d6d' : brick.unbreakable ? '#888888' : brick.strong ? '#bb7aff' : brick.moving ? '#6ec6ff' : brick.explosive ? getVar('--expl') : brickColor(brick.colorIdx||0);
      debris.push({
        x:brick.x,
        y:brick.y,
        w:brick.w,
        h:brick.h,
        color:baseColor,
        treasure:!!brick.treasure,
        vx:(Math.random()-0.5)*1.4,
        vy:2.1 + Math.random()*2.0,
        gravity:0.16 + Math.random()*0.07,
        angle:(Math.random()-0.5)*0.25,
        spin:(Math.random()-0.5)*0.06
      });
    }
    if(debris.length){
      demonFallingDebris.push(...debris);
      screenShake=Math.max(screenShake,16);
    }
    if(row){ row.length=0; }
  }

  function startDemonEvent(now){
    if(demonEventPhase!=='awaiting') return;
    demonEventPhase='collapse';
    demonPhase='event';
    demonEventTriggeredAt=now;
    const shell=demonShellBrick;
    const cx=shell? shell.x + shell.w/2 : 1100/2;
    const cy=shell? shell.y + shell.h/2 : layout().top;
    demonEventMarquee={
      text:'跪伏於我的力量之下吧!',
      start:now,
      fadeStart:now+5000,
      end:now+8000,
      style:'elegant'
    };
    demonEventWave={x:cx, y:cy, start:now, duration:2000, maxRadius:Math.hypot(1100,700)};
    demonEventShakeUntil = now + 7000;
    prepareDemonRows();
    demonEventNextRowAt=now;
    if(demonEventTargets===0){
      explodeDemonShell(now);
      return;
    }
    screenShake=Math.max(screenShake,26);
  }

  function explodeDemonShell(now){
    if(!demonShellBrick) return;
    const shell=demonShellBrick;
    const idx=bricks.indexOf(shell);
    if(idx>=0) bricks.splice(idx,1);
    const cx=shell.x + shell.w/2;
    const cy=shell.y + shell.h/2;
    spawnParticles(cx,cy,'#fff5d6',120,3.2,5.0,5.5);
    spawnParticles(cx,cy,'#8a6bff',90,2.6,4.2,4.6);
    spawnParticles(cx,cy,'#d476ff',70,2.3,3.8,4.2);
    demonEventWave={x:cx,y:cy,start:now,duration:2600,maxRadius:Math.hypot(1100,700)};
    demonCore={x:cx,y:cy,start:now,visibleUntil:now+4000};
    screenShake=Math.max(screenShake,22);
    demonShellBrick=null;
    demonEventPhase='revealed';
    demonPhase='intro';
    demonRevealScheduled=now+1400;
    demonAfterimages=[];
  }

  function updateDemonEvent(now){
    if(level!==20){
      return;
    }
    if(demonEventPhase==='awaiting'){
      if(running && !paused && !resumePending){
        if(!demonEventTimerStart){
          demonEventTimerStart=now;
        }else if(now - demonEventTimerStart >= 10000){
          startDemonEvent(now);
        }
      }
    }else if(demonEventPhase==='collapse'){
      if(demonEventRows.length && now>=demonEventNextRowAt){
        const row=demonEventRows.shift();
        dropDemonRow(row, now);
        demonEventNextRowAt = now + 1000;
      }
      if(demonEventTargets>0 && demonEventCleared>=demonEventTargets){
        explodeDemonShell(now);
      }
    }else if(demonEventPhase==='revealed'){
      if(demonCore && now>=demonCore.visibleUntil){
        demonCore=null;
        demonEventPhase='complete';
      }
    }

    if(demonEventMarquee && now>=demonEventMarquee.end){
      demonEventMarquee=null;
    }
    if(demonEventWave && now>=demonEventWave.start + demonEventWave.duration){
      demonEventWave=null;
    }
    if(demonEventShakeUntil && now<demonEventShakeUntil){
      screenShake=Math.max(screenShake,18);
    }
  }

  function drawDemonMarquee(now){
    if(level!==20 || !demonEventMarquee) return;
    const evt=demonEventMarquee;
    if(now<evt.start) return;
    if(now>=evt.end){
      demonEventMarquee=null;
      return;
    }
    let alpha=1;
    if(evt.fadeStart && now>evt.fadeStart){
      const span=Math.max(1, evt.end - evt.fadeStart);
      alpha=Math.max(0, 1 - (now - evt.fadeStart)/span);
    }
    if(alpha<=0) return;
    const L=layout();
    const areaHeight=60;
    const top=Math.max(16, L.top - areaHeight - 14);
    const width=Math.min(560, 1100-120);
    const x=(1100-width)/2;
    const radius=20;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, top, width, areaHeight, radius);
    const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
    grad.addColorStop(0,'rgba(48,22,10,0.9)');
    grad.addColorStop(1,'rgba(28,12,6,0.88)');
    ctx.fillStyle=grad;
    ctx.fill();
    ctx.strokeStyle='rgba(255,210,150,0.85)';
    ctx.lineWidth=2.4;
    drawRoundedRect(x, top, width, areaHeight, radius);
    ctx.stroke();
    const innerX=x+10;
    const innerY=top+6;
    const innerW=width-20;
    const innerH=areaHeight-12;
    ctx.save();
    drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
    const innerGrad=ctx.createLinearGradient(innerX*scaleX, innerY*scaleY, innerX*scaleX, (innerY+innerH)*scaleY);
    innerGrad.addColorStop(0,'rgba(140,70,30,0.45)');
    innerGrad.addColorStop(1,'rgba(80,34,14,0.35)');
    ctx.fillStyle=innerGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(255,220,180,0.45)';
    ctx.lineWidth=1.4;
    ctx.stroke();
    ctx.restore();
    ctx.save();
    drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
    ctx.clip();
    ctx.fillStyle='#ffeedd';
    const fontSize=Math.max(20, Math.round(26*((scaleX+scaleY)/2)));
    ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.shadowColor='rgba(255,150,110,0.55)';
    ctx.shadowBlur=14*((scaleX+scaleY)/2);
    ctx.fillText(evt.text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
    ctx.restore();
  }


  function renderDemonFigure(entity, now, opts={}){
    if(!entity) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const baseSize=entity.h||entity.w||150;
    const size=baseSize/150;
    let alpha = opts.alpha!=null ? opts.alpha : 1;
    if(entity.deathFade!=null) alpha*=entity.deathFade;
    if(alpha<=0) return;
    ctx.save();
    ctx.translate(entity.x*scaleX, entity.y*scaleY);
    ctx.scale(scaleAvg*size, scaleAvg*size);
    const ghostMul = opts.ghost ? 0.65 : 1;
    ctx.globalAlpha *= Math.max(0, Math.min(1, alpha*ghostMul));

    const flash = entity.hitFlashUntil && now<entity.hitFlashUntil;
    const hoverPhase = entity.hoverPhase||0;
    const whipActive = entity.cloakWhipUntil && now<entity.cloakWhipUntil;
    let whipStrength=0;
    let whipDir=entity.cloakWhipDir||1;
    if(whipActive){
      const duration=Math.max(1, (entity.cloakWhipDuration||360));
      const start=entity.cloakWhipStart|| (entity.cloakWhipUntil-duration);
      const total=Math.max(1, entity.cloakWhipUntil-start);
      const phase=Math.max(0, Math.min(1, 1-((entity.cloakWhipUntil-now)/total)));
      whipStrength=(entity.cloakWhipStrength||1)*Math.sin(phase*Math.PI);
    }

    const palette={
      metalDark: flash ? 'rgba(238,234,242,0.96)' : 'rgba(24,26,34,0.96)',
      metalMid: flash ? 'rgba(255,250,252,0.92)' : 'rgba(46,48,62,0.92)',
      metalEdge: flash ? 'rgba(255,255,255,0.86)' : 'rgba(134,138,166,0.75)',
      accent: flash ? 'rgba(255,200,160,0.95)' : 'rgba(210,70,40,0.92)',
      glowCore: flash ? 'rgba(255,220,210,0.85)' : 'rgba(255,90,50,0.8)',
      glowOuter: flash ? 'rgba(255,220,220,0.45)' : 'rgba(160,20,30,0.38)',
      horn: flash ? 'rgba(220,210,240,0.92)' : 'rgba(44,42,62,0.92)',
      visor: flash ? 'rgba(255,248,246,0.9)' : 'rgba(18,18,24,0.88)',
      eye: flash ? 'rgba(255,150,110,0.95)' : 'rgba(255,50,40,0.95)'
    };
    const bodyStretch=1.3;

    // ground shadow
    ctx.save();
    ctx.globalAlpha*=0.32;
    ctx.fillStyle='rgba(0,0,0,0.6)';
    ctx.scale(1,0.34);
    ctx.beginPath();
    ctx.ellipse(0,240,72,30,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // aura glow
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const auraPulse = 0.55 + 0.25*Math.sin(now/240 + hoverPhase*0.7);
    ctx.globalAlpha*=0.55 + auraPulse*0.25;
    const aura=ctx.createRadialGradient(0,20,18,0,20,190);
    aura.addColorStop(0,palette.glowCore);
    aura.addColorStop(0.45,palette.glowOuter);
    aura.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=aura;
    ctx.beginPath();
    ctx.ellipse(0,30,120,140,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // tattered cloak with long flowing hem (only below the pauldrons)
    ctx.save();
    ctx.translate(0,-12);
    const cloakPhase=entity.cloakPhase||0;
    const baseCloakSway = entity.cloakSway!=null ? entity.cloakSway : 0.18;
    const cloakSwayStrength = baseCloakSway + (whipStrength?0.35*whipStrength:0);
    const hoverLift = Math.sin(hoverPhase*0.7)*4;
    const whipSwing=whipStrength?whipDir*(32+60*cloakSwayStrength)*whipStrength:0;
    const anchorLift = Math.sin(cloakPhase*0.5 + hoverPhase*0.45)*6*cloakSwayStrength + whipStrength*10;
    const swayLeft = Math.sin(cloakPhase - whipStrength*0.4)* (16 + 34*cloakSwayStrength) - whipSwing;
    const swayRight = Math.sin(cloakPhase + Math.PI*0.65 + whipStrength*0.4)* (18 + 36*cloakSwayStrength) + whipSwing;
    const ragAmplitude = 26 + 48*cloakSwayStrength + (whipStrength?38*whipStrength:0);
    const hemBase = 288 + hoverLift*0.25;
    const hemDrift = (t)=>Math.sin(cloakPhase + t*Math.PI*1.9 + hoverPhase*0.5)*ragAmplitude;
    const ragJut = (i)=> (i%2===0 ? -ragAmplitude*0.85 : ragAmplitude*0.3);
    const cloak=ctx.createLinearGradient(0,-40,0,320);
    cloak.addColorStop(0, flash ? 'rgba(255,220,220,0.5)' : 'rgba(96,8,18,0.96)');
    cloak.addColorStop(0.38, flash ? 'rgba(255,200,200,0.42)' : 'rgba(140,0,18,0.94)');
    cloak.addColorStop(1, flash ? 'rgba(255,188,188,0.34)' : 'rgba(56,0,8,0.88)');
    ctx.beginPath();
    ctx.moveTo(-118,36 + anchorLift + hoverLift*0.3);
    ctx.bezierCurveTo(-198,96 - swayLeft*0.4, -218,212 + hoverLift*0.25, -202, hemBase - ragAmplitude*0.45);
    const segments=12;
    for(let i=0;i<=segments;i++){
      const t=i/segments;
      const x=-202 + (404*t) + Math.sin(cloakPhase*0.8 + t*Math.PI*2.1)*18*cloakSwayStrength;
      const wave=hemDrift(t);
      const jag = (i===0||i===segments) ? -ragAmplitude*0.4 : ragJut(i);
      ctx.lineTo(x, hemBase + wave + jag);
    }
    ctx.bezierCurveTo(218,212 + hoverLift*0.25, 198,96 - swayRight*0.4, 118,36 + anchorLift + hoverLift*0.3);
    ctx.quadraticCurveTo(56,18 + swayRight*0.12, 42,74 + anchorLift*0.15);
    ctx.quadraticCurveTo(0,24, -42,74 + anchorLift*0.15);
    ctx.quadraticCurveTo(-56,18 + swayLeft*0.12, -118,36 + anchorLift + hoverLift*0.3);
    ctx.closePath();
    ctx.fillStyle=cloak;
    ctx.fill();
    ctx.strokeStyle=flash ? 'rgba(255,226,220,0.56)' : 'rgba(54,0,8,0.7)';
    ctx.lineWidth=3.6;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=flash ? 'rgba(255,230,224,0.62)' : 'rgba(200,40,40,0.44)';
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(-56,18 + anchorLift*0.3 + hoverLift*0.2);
    ctx.quadraticCurveTo(-42,138 + swayLeft*0.08,-32,hemBase-18 + swayLeft*0.05);
    ctx.moveTo(56,18 + anchorLift*0.3 + hoverLift*0.2);
    ctx.quadraticCurveTo(42,138 + swayRight*0.08,32,hemBase-18 + swayRight*0.05);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0,12 + anchorLift*0.2 + hoverLift*0.2);
    ctx.quadraticCurveTo(-4,144 + (swayLeft+swayRight)*0.04,0,hemBase-12 + (swayLeft+swayRight)*0.04);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // lower tabard, battle skirt and waist armour
    ctx.save();
    ctx.translate(0,62);
    ctx.scale(1, bodyStretch);
    const tabard=ctx.createLinearGradient(0,-44,0,156);
    tabard.addColorStop(0, flash ? 'rgba(255,232,232,0.84)' : 'rgba(80,20,32,0.9)');
    tabard.addColorStop(0.5, flash ? 'rgba(255,214,214,0.76)' : 'rgba(46,12,20,0.82)');
    tabard.addColorStop(1, flash ? 'rgba(255,206,206,0.68)' : 'rgba(26,6,12,0.7)');
    ctx.fillStyle=tabard;
    ctx.beginPath();
    ctx.moveTo(-36,-10);
    ctx.quadraticCurveTo(-10,-92,0,-98);
    ctx.quadraticCurveTo(10,-92,36,-10);
    ctx.quadraticCurveTo(22,188,0,208);
    ctx.quadraticCurveTo(-22,188,-36,-10);
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth=2.4;
    ctx.strokeStyle=palette.metalEdge;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(0,-44);
    ctx.lineTo(0,182);
    ctx.stroke();
    ctx.restore();

    const innerPlates=ctx.createLinearGradient(0,-20,0,146);
    innerPlates.addColorStop(0, flash ? 'rgba(255,226,226,0.72)' : 'rgba(96,30,44,0.86)');
    innerPlates.addColorStop(1, flash ? 'rgba(255,210,210,0.62)' : 'rgba(52,14,24,0.78)');
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(12,-24);
      ctx.quadraticCurveTo(54,-80,62,-14);
      ctx.quadraticCurveTo(48,122,16,188);
      ctx.lineTo(-4,122);
      ctx.closePath();
      ctx.fillStyle=innerPlates;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2;
      ctx.stroke();
      ctx.restore();
    }

    const skirtPanel=ctx.createLinearGradient(-110,-20,-10,160);
    skirtPanel.addColorStop(0, flash ? 'rgba(255,224,224,0.82)' : 'rgba(66,16,24,0.86)');
    skirtPanel.addColorStop(1, flash ? 'rgba(255,204,204,0.62)' : 'rgba(28,8,14,0.72)');
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(30,-6);
      ctx.quadraticCurveTo(102,-84,118,12);
      ctx.quadraticCurveTo(110,188,38,214);
      ctx.quadraticCurveTo(22,112,30,-6);
      ctx.closePath();
      ctx.fillStyle=skirtPanel;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.2;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=1.8;
      ctx.beginPath();
      ctx.moveTo(52,18);
      ctx.quadraticCurveTo(84,112,46,198);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    const waist=ctx.createLinearGradient(-70,-48,70,66);
    waist.addColorStop(0,palette.metalMid);
    waist.addColorStop(1,palette.metalDark);
    ctx.fillStyle=waist;
    ctx.beginPath();
    ctx.moveTo(-88,-22);
    ctx.quadraticCurveTo(0,-86,88,-22);
    ctx.lineTo(68,68);
    ctx.quadraticCurveTo(0,98,-68,68);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(-52,-8);
    ctx.quadraticCurveTo(0,-44,52,-8);
    ctx.moveTo(-48,38);
    ctx.quadraticCurveTo(0,70,48,38);
    ctx.stroke();
    ctx.restore();

    const waistPlates=ctx.createLinearGradient(-50,-18,50,80);
    waistPlates.addColorStop(0,palette.metalDark);
    waistPlates.addColorStop(1,palette.metalMid);
    ctx.fillStyle=waistPlates;
    ctx.beginPath();
    ctx.moveTo(-58,-10);
    ctx.quadraticCurveTo(-18,-58,-6,-32);
    ctx.lineTo(-10,62);
    ctx.quadraticCurveTo(-36,70,-52,36);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=1.8;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(58,-10);
    ctx.quadraticCurveTo(18,-58,6,-32);
    ctx.lineTo(10,62);
    ctx.quadraticCurveTo(36,70,52,36);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    const layeredSkirt=ctx.createLinearGradient(-20,-12,-20,200);
    layeredSkirt.addColorStop(0, flash ? 'rgba(255,230,220,0.82)' : 'rgba(70,18,26,0.92)');
    layeredSkirt.addColorStop(1, flash ? 'rgba(255,206,198,0.7)' : 'rgba(32,8,12,0.78)');
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(34,0);
      ctx.quadraticCurveTo(92,-48,122,30);
      ctx.quadraticCurveTo(112,196,40,216);
      ctx.quadraticCurveTo(24,128,34,0);
      ctx.closePath();
      ctx.fillStyle=layeredSkirt;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=1.6;
      ctx.beginPath();
      ctx.moveTo(52,28);
      ctx.quadraticCurveTo(86,132,44,204);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    const frontSkirt=ctx.createLinearGradient(0,-18,0,210);
    frontSkirt.addColorStop(0, flash ? 'rgba(255,224,214,0.84)' : 'rgba(78,18,26,0.92)');
    frontSkirt.addColorStop(1, flash ? 'rgba(255,200,188,0.68)' : 'rgba(34,10,14,0.78)');
    ctx.beginPath();
    ctx.moveTo(-42,12);
    ctx.quadraticCurveTo(-12,-68,0,-82);
    ctx.quadraticCurveTo(12,-68,42,12);
    ctx.quadraticCurveTo(26,188,0,214);
    ctx.quadraticCurveTo(-26,188,-42,12);
    ctx.closePath();
    ctx.fillStyle=frontSkirt;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.2;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(0,-26);
    ctx.lineTo(0,198);
    ctx.moveTo(-18,64);
    ctx.lineTo(18,64);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // legs, greaves and sabatons
    ctx.save();
    ctx.translate(0,102);
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      const thigh=ctx.createLinearGradient(12,-70,78,160);
      thigh.addColorStop(0,palette.metalMid);
      thigh.addColorStop(1,palette.metalDark);
      ctx.beginPath();
      ctx.moveTo(20,-52);
      ctx.quadraticCurveTo(58,-28,54,38);
      ctx.quadraticCurveTo(46,112,18,142);
      ctx.quadraticCurveTo(6,52,10,-12);
      ctx.closePath();
      ctx.fillStyle=thigh;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.6;
      ctx.stroke();

      const shin=ctx.createLinearGradient(14,-10,74,210);
      shin.addColorStop(0,palette.metalMid);
      shin.addColorStop(1,'rgba(26,26,40,0.92)');
      ctx.beginPath();
      ctx.moveTo(18,18);
      ctx.quadraticCurveTo(60,72,56,156);
      ctx.quadraticCurveTo(42,214,12,204);
      ctx.quadraticCurveTo(0,148,10,36);
      ctx.closePath();
      ctx.fillStyle=shin;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      const sabaton=ctx.createLinearGradient(12,120,76,220);
      sabaton.addColorStop(0,'rgba(34,34,48,0.95)');
      sabaton.addColorStop(1,'rgba(8,8,14,0.92)');
      ctx.beginPath();
      ctx.moveTo(18,154);
      ctx.quadraticCurveTo(66,182,68,210);
      ctx.quadraticCurveTo(46,226,12,214);
      ctx.quadraticCurveTo(0,188,6,164);
      ctx.closePath();
      ctx.fillStyle=sabaton;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(34,-20);
      ctx.quadraticCurveTo(48,72,28,152);
      ctx.moveTo(28,96);
      ctx.quadraticCurveTo(40,138,26,186);
      ctx.stroke();
      ctx.restore();

      ctx.beginPath();
      ctx.moveTo(14,174);
      ctx.quadraticCurveTo(40,188,16,208);
      ctx.strokeStyle=flash ? 'rgba(255,204,170,0.75)' : 'rgba(86,24,20,0.68)';
      ctx.lineWidth=1.6;
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();

    // torso armour layers
    ctx.save();
    ctx.translate(0,-16);
    const chest=ctx.createLinearGradient(-74,-162,74,148);
    chest.addColorStop(0,palette.metalMid);
    chest.addColorStop(1,palette.metalDark);
    ctx.fillStyle=chest;
    ctx.beginPath();
    ctx.moveTo(-64,-68);
    ctx.quadraticCurveTo(0,-136,64,-68);
    ctx.lineTo(82,48);
    ctx.quadraticCurveTo(0,96,-82,48);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const breastplate=ctx.createLinearGradient(-56,-118,56,80);
    breastplate.addColorStop(0,palette.metalDark);
    breastplate.addColorStop(1,palette.metalMid);
    ctx.fillStyle=breastplate;
    ctx.beginPath();
    ctx.moveTo(-48,-46);
    ctx.quadraticCurveTo(-12,-106,0,-112);
    ctx.quadraticCurveTo(12,-106,48,-46);
    ctx.lineTo(40,54);
    ctx.quadraticCurveTo(0,84,-40,54);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.8;
    ctx.stroke();

    const chestCrest=ctx.createLinearGradient(-40,-80,40,32);
    chestCrest.addColorStop(0,palette.metalMid);
    chestCrest.addColorStop(1,palette.metalDark);
    ctx.fillStyle=chestCrest;
    ctx.beginPath();
    ctx.moveTo(-34,-26);
    ctx.quadraticCurveTo(0,-68,34,-26);
    ctx.quadraticCurveTo(18,40,0,64);
    ctx.quadraticCurveTo(-18,40,-34,-26);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const abdomen=ctx.createLinearGradient(-32,-26,32,104);
    abdomen.addColorStop(0,palette.metalMid);
    abdomen.addColorStop(1,palette.metalDark);
    ctx.fillStyle=abdomen;
    ctx.beginPath();
    ctx.moveTo(-30,-6);
    ctx.lineTo(30,-6);
    ctx.quadraticCurveTo(20,84,0,106);
    ctx.quadraticCurveTo(-20,84,-30,-6);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const waistExtension=ctx.createLinearGradient(-38,18,38,160);
    waistExtension.addColorStop(0,palette.metalDark);
    waistExtension.addColorStop(1,palette.metalMid);
    ctx.fillStyle=waistExtension;
    ctx.beginPath();
    ctx.moveTo(-38,32);
    ctx.lineTo(38,32);
    ctx.quadraticCurveTo(26,138,0,158);
    ctx.quadraticCurveTo(-26,138,-38,32);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=2.4;
    ctx.beginPath();
    ctx.moveTo(0,-52);
    ctx.lineTo(0,138);
    ctx.moveTo(-18,34);
    ctx.lineTo(18,34);
    ctx.moveTo(-16,-4);
    ctx.lineTo(16,-4);
    ctx.moveTo(-16,96);
    ctx.lineTo(16,96);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // left arm assembly with shortened proportions
    ctx.save();
    ctx.translate(0,-18);
    const leftArmSwing=Math.sin(now/340 + hoverPhase*0.65);

    ctx.save();
    ctx.translate(-96,36);
    ctx.rotate(-0.12 + Math.sin(hoverPhase*0.6)*0.04);
    ctx.scale(0.9,0.6);
    const leftUpper=ctx.createLinearGradient(-34,-28,44,140);
    leftUpper.addColorStop(0,palette.metalMid);
    leftUpper.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-18,-26);
    ctx.quadraticCurveTo(-58,10,-44,96);
    ctx.quadraticCurveTo(-18,146,12,140);
    ctx.quadraticCurveTo(-4,68,-6,-20);
    ctx.closePath();
    ctx.fillStyle=leftUpper;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-26,-4);
    ctx.lineTo(-12,86);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.translate(-24,112);
    ctx.rotate(-0.18 + Math.sin(now/260 + hoverPhase)*0.06 + leftArmSwing*0.02);
    const leftFore=ctx.createLinearGradient(-32,-20,36,140);
    leftFore.addColorStop(0,palette.metalMid);
    leftFore.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-16,-14);
    ctx.quadraticCurveTo(-46,18,-32,78);
    ctx.quadraticCurveTo(0,114,22,98);
    ctx.quadraticCurveTo(6,20,-16,-14);
    ctx.closePath();
    ctx.fillStyle=leftFore;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(-10,14);
    ctx.lineTo(-6,74);
    ctx.stroke();
    ctx.restore();

    ctx.beginPath();
    ctx.moveTo(-22,78);
    ctx.quadraticCurveTo(-36,108,-10,120);
    ctx.quadraticCurveTo(6,104,-2,84);
    ctx.closePath();
    ctx.fillStyle=flash ? 'rgba(255,222,212,0.9)' : 'rgba(48,22,26,0.9)';
    ctx.fill();
    ctx.restore();
    ctx.restore();

    // left shoulder armour layers (rendered above the arm connection)
    ctx.save();
    ctx.translate(0,-18);
    const leftShoulderBase=ctx.createLinearGradient(-162,-72,-36,124);
    leftShoulderBase.addColorStop(0,palette.metalMid);
    leftShoulderBase.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-82,-18);
    ctx.quadraticCurveTo(-160,-108,-172,12);
    ctx.quadraticCurveTo(-148,112,-90,104);
    ctx.quadraticCurveTo(-70,30,-82,-18);
    ctx.closePath();
    ctx.fillStyle=leftShoulderBase;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const leftShoulderMid=ctx.createLinearGradient(-148,-36,-60,96);
    leftShoulderMid.addColorStop(0,palette.metalDark);
    leftShoulderMid.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(-78,-2);
    ctx.quadraticCurveTo(-128,-48,-134,20);
    ctx.quadraticCurveTo(-118,104,-84,94);
    ctx.closePath();
    ctx.fillStyle=leftShoulderMid;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const leftShoulderRidge=ctx.createLinearGradient(-120,-12,-70,60);
    leftShoulderRidge.addColorStop(0,palette.metalMid);
    leftShoulderRidge.addColorStop(1,palette.metalEdge);
    ctx.beginPath();
    ctx.moveTo(-86,18);
    ctx.quadraticCurveTo(-120,-18,-120,28);
    ctx.quadraticCurveTo(-110,88,-92,82);
    ctx.closePath();
    ctx.fillStyle=leftShoulderRidge;
    ctx.fill();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-110,8);
    ctx.quadraticCurveTo(-98,72,-88,86);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // right arm assembly with shortened proportions
    ctx.save();
    ctx.translate(0,-18);
    const rightArmSwing=Math.sin(now/320 + hoverPhase*0.8);

    ctx.save();
    ctx.translate(96,36);
    ctx.rotate(0.14 + rightArmSwing*0.06);
    ctx.scale(0.9,0.6);
    const upper=ctx.createLinearGradient(-28,-26,42,140);
    upper.addColorStop(0,palette.metalMid);
    upper.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-14,-26);
    ctx.quadraticCurveTo(44,6,34,102);
    ctx.quadraticCurveTo(10,150,-18,144);
    ctx.quadraticCurveTo(-30,62,-18,-18);
    ctx.closePath();
    ctx.fillStyle=upper;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-2,-4);
    ctx.lineTo(10,86);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.translate(24,118);
    ctx.rotate(0.26 + rightArmSwing*0.1);
    const fore=ctx.createLinearGradient(-30,-18,38,150);
    fore.addColorStop(0,palette.metalMid);
    fore.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-12,-18);
    ctx.quadraticCurveTo(36,16,30,96);
    ctx.quadraticCurveTo(10,126,-16,120);
    ctx.quadraticCurveTo(-32,48,-12,-18);
    ctx.closePath();
    ctx.fillStyle=fore;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    const gauntlet=ctx.createLinearGradient(-18,32,28,120);
    gauntlet.addColorStop(0,palette.metalDark);
    gauntlet.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(-14,40);
    ctx.lineTo(22,40);
    ctx.quadraticCurveTo(26,76,2,96);
    ctx.quadraticCurveTo(-20,78,-14,40);
    ctx.closePath();
    ctx.fillStyle=gauntlet;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.2;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(0,8);
    ctx.lineTo(12,70);
    ctx.stroke();
    ctx.restore();

    ctx.beginPath();
    ctx.moveTo(-4,86);
    ctx.quadraticCurveTo(18,124,30,104);
    ctx.quadraticCurveTo(16,78,6,74);
    ctx.closePath();
    ctx.fillStyle=flash ? 'rgba(255,226,212,0.88)' : 'rgba(54,24,30,0.88)';
    ctx.fill();
    ctx.restore();
    ctx.restore();

    // right shoulder armour layers (rendered above the arm connection)
    ctx.save();
    ctx.translate(0,-18);
    const rightShoulderBase=ctx.createLinearGradient(24,-60,180,120);
    rightShoulderBase.addColorStop(0,palette.metalMid);
    rightShoulderBase.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(68,-12);
    ctx.quadraticCurveTo(150,-94,168,12);
    ctx.quadraticCurveTo(140,116,86,104);
    ctx.quadraticCurveTo(66,36,68,-12);
    ctx.closePath();
    ctx.fillStyle=rightShoulderBase;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const rightShoulderMid=ctx.createLinearGradient(54,-32,156,88);
    rightShoulderMid.addColorStop(0,palette.metalDark);
    rightShoulderMid.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(74,2);
    ctx.quadraticCurveTo(128,-46,134,18);
    ctx.quadraticCurveTo(118,108,90,94);
    ctx.closePath();
    ctx.fillStyle=rightShoulderMid;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const rightShoulderRidge=ctx.createLinearGradient(90,-6,128,66);
    rightShoulderRidge.addColorStop(0,palette.metalMid);
    rightShoulderRidge.addColorStop(1,palette.metalEdge);
    ctx.beginPath();
    ctx.moveTo(84,20);
    ctx.quadraticCurveTo(118,-16,116,30);
    ctx.quadraticCurveTo(110,86,94,82);
    ctx.closePath();
    ctx.fillStyle=rightShoulderRidge;
    ctx.fill();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(106,8);
    ctx.quadraticCurveTo(96,70,90,88);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    ctx.restore();
    ctx.restore();
    // chest core glow
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.translate(0,24);
    const core=ctx.createRadialGradient(0,0,4,0,0,30);
    core.addColorStop(0,palette.glowCore);
    core.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=core;
    ctx.beginPath();
    ctx.arc(0,0,24,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // mech helm with angular visor
    ctx.save();
    const headScale=0.7;
    ctx.translate(0,-74);
    ctx.scale(headScale, headScale);
    const helmBase=ctx.createLinearGradient(-48,-90,48,92);
    helmBase.addColorStop(0,palette.metalMid);
    helmBase.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-46,42);
    ctx.lineTo(-30,-12);
    ctx.quadraticCurveTo(-8,-96,0,-104);
    ctx.quadraticCurveTo(8,-96,30,-12);
    ctx.lineTo(46,42);
    ctx.quadraticCurveTo(0,92,-46,42);
    ctx.closePath();
    ctx.fillStyle=helmBase;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3;
    ctx.stroke();

    const helmPlates=ctx.createLinearGradient(-36,-54,36,68);
    helmPlates.addColorStop(0,palette.metalDark);
    helmPlates.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(-34,28);
    ctx.lineTo(-18,-18);
    ctx.quadraticCurveTo(0,-64,18,-18);
    ctx.lineTo(34,28);
    ctx.quadraticCurveTo(0,70,-34,28);
    ctx.closePath();
    ctx.fillStyle=helmPlates;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    const facePlate=ctx.createLinearGradient(-26,-12,26,44);
    facePlate.addColorStop(0,'rgba(20,22,34,0.92)');
    facePlate.addColorStop(1,'rgba(10,12,20,0.9)');
    ctx.beginPath();
    ctx.moveTo(-32,14);
    ctx.lineTo(-14,-24);
    ctx.quadraticCurveTo(0,-44,14,-24);
    ctx.lineTo(32,14);
    ctx.quadraticCurveTo(0,48,-32,14);
    ctx.closePath();
    ctx.fillStyle=facePlate;
    ctx.fill();

    const maskRidge=ctx.createLinearGradient(-16,-32,16,28);
    maskRidge.addColorStop(0,palette.metalMid);
    maskRidge.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-18,-12);
    ctx.quadraticCurveTo(0,-28,18,-12);
    ctx.quadraticCurveTo(10,28,0,38);
    ctx.quadraticCurveTo(-10,28,-18,-12);
    ctx.closePath();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=1.8;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=flash ? 'rgba(255,232,220,0.7)' : 'rgba(210,130,90,0.5)';
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(-16,-6);
    ctx.quadraticCurveTo(0,-22,16,-6);
    ctx.stroke();
    ctx.restore();

    const eyeScale=0.7;
    const eyeBase=28*eyeScale;
    const eyeLength=66*eyeScale;
    const eyeTilt=Math.PI/4;
    ctx.fillStyle=palette.eye;
    ctx.save();
    ctx.translate(-30,-18);
    ctx.rotate(-eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-eyeBase/2,0);
    ctx.lineTo(eyeBase/2,0);
    ctx.lineTo(0,eyeLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.translate(30,-18);
    ctx.rotate(eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-eyeBase/2,0);
    ctx.lineTo(eyeBase/2,0);
    ctx.lineTo(0,eyeLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const eyeGlow=flash ? 'rgba(255,220,210,0.6)' : 'rgba(255,70,40,0.55)';
    ctx.fillStyle=eyeGlow;
    const glowBase=eyeBase*0.6;
    const glowLength=eyeLength*0.6;
    ctx.save();
    ctx.translate(-32,-22);
    ctx.rotate(-eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-glowBase/2,0);
    ctx.lineTo(glowBase/2,0);
    ctx.lineTo(0,glowLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.translate(32,-22);
    ctx.rotate(eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-glowBase/2,0);
    ctx.lineTo(glowBase/2,0);
    ctx.lineTo(0,glowLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=flash ? 'rgba(255,236,226,0.8)' : 'rgba(255,80,60,0.75)';
    ctx.beginPath();
    ctx.moveTo(-4,-42);
    ctx.lineTo(0,-50);
    ctx.lineTo(4,-42);
    ctx.lineTo(4,30);
    ctx.quadraticCurveTo(0,40,-4,30);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    const crest=ctx.createLinearGradient(-12,-72,12,-12);
    crest.addColorStop(0,palette.metalEdge);
    crest.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-12,-58);
    ctx.lineTo(0,-86);
    ctx.lineTo(12,-58);
    ctx.quadraticCurveTo(0,-40,-12,-58);
    ctx.closePath();
    ctx.fillStyle=crest;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=1.6;
    ctx.stroke();

    const antenna=ctx.createLinearGradient(0,-120,0,-20);
    antenna.addColorStop(0,palette.metalDark);
    antenna.addColorStop(1,palette.metalMid);
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(14,-18);
      ctx.lineTo(92,-112);
      ctx.lineTo(54,-12);
      ctx.closePath();
      ctx.fillStyle=antenna;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=1.4;
      ctx.beginPath();
      ctx.moveTo(44,-42);
      ctx.lineTo(70,-94);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }
    ctx.restore();
    ctx.restore();

    ctx.restore();

    ctx.restore();

    ctx.restore();
  }


  function renderDemonAfterimageFigure(state, now, alpha){
    if(!state) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const baseSize=state.h||state.w||150;
    const size=baseSize/150;
    const t0=state.t0||now;
    const elapsed=Math.max(0, now-t0);
    const hoverPhase=state.hoverPhase||0;
    ctx.save();
    ctx.translate(state.x*scaleX, state.y*scaleY);
    ctx.scale(scaleAvg*size, scaleAvg*size);
    ctx.globalAlpha *= alpha;

    const auraPulse = 0.55 + 0.35*Math.sin(elapsed/220 + hoverPhase*0.6);
    ctx.fillStyle = `rgba(190,140,255,${0.22*auraPulse})`;
    ctx.beginPath();
    ctx.ellipse(0,34,92,164,0,0,Math.PI*2);
    ctx.fill();

    const cloakPhase=state.cloakPhase||0;
    const cloakSwayStrength=state.cloakSway!=null?state.cloakSway:0.2;
    const ragAmplitude=10 + 28*cloakSwayStrength;
    const hoverLift=Math.sin(hoverPhase*0.7 + elapsed*0.0012)*3;

    // spectral cloak trail
    ctx.fillStyle=`rgba(220,60,90,${0.14 + 0.06*Math.sin(elapsed/240)})`;
    ctx.strokeStyle=`rgba(255,120,160,${0.12 + 0.04*Math.sin(elapsed/200)})`;
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(-112,-52 + hoverLift*0.4);
    ctx.bezierCurveTo(-174,-6, -182,110 + hoverLift*0.2, -156,212 + hoverLift);
    const hemBase=230 + hoverLift*0.12;
    ctx.lineTo(-156, hemBase + Math.sin(cloakPhase + hoverPhase*0.45)*ragAmplitude - ragAmplitude*0.55);
    for(let i=1;i<8;i++){
      const t=i/8;
      const x=-156 + 312*t;
      const wave=Math.sin(cloakPhase + t*Math.PI*1.6 + hoverPhase*0.45)*ragAmplitude;
      const jag=(i%2===0?-ragAmplitude*0.55:ragAmplitude*0.28);
      ctx.lineTo(x, hemBase + wave + jag);
    }
    ctx.lineTo(156, hemBase + Math.sin(cloakPhase + Math.PI*1.6 + hoverPhase*0.45)*ragAmplitude - ragAmplitude*0.55);
    ctx.bezierCurveTo(182,110 + hoverLift*0.2, 174,-6, 112,-52 + hoverLift*0.4);
    ctx.quadraticCurveTo(36,-126,0,-134);
    ctx.quadraticCurveTo(-36,-126,-112,-52 + hoverLift*0.4);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=`rgba(255,160,200,${0.1 + 0.04*Math.sin(elapsed/180)})`;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-46,-60 + hoverLift*0.3);
    ctx.quadraticCurveTo(-32,36, -18,208 + hoverLift*0.1);
    ctx.moveTo(46,-60 + hoverLift*0.3);
    ctx.quadraticCurveTo(32,36, 18,208 + hoverLift*0.1);
    ctx.moveTo(0,-120 + hoverLift*0.3);
    ctx.quadraticCurveTo(-6,18,0,216 + hoverLift*0.1);
    ctx.stroke();
    ctx.restore();

    // elongated armour silhouette
    ctx.fillStyle='rgba(220,170,255,0.26)';
    ctx.beginPath();
    ctx.moveTo(-30,-28);
    ctx.quadraticCurveTo(0,-118,30,-28);
    ctx.quadraticCurveTo(18,164,0,198);
    ctx.quadraticCurveTo(-18,164,-30,-28);
    ctx.closePath();
    ctx.fill();

    // battle skirt glow
    ctx.beginPath();
    ctx.moveTo(-50,10);
    ctx.quadraticCurveTo(-10,-94,50,10);
    ctx.quadraticCurveTo(28,226,0,262);
    ctx.quadraticCurveTo(-28,226,-50,10);
    ctx.closePath();
    ctx.fillStyle='rgba(210,150,255,0.22)';
    ctx.fill();

    const orbPulse = 1 + 0.18*Math.sin(elapsed/260 + hoverPhase*0.9);
    ctx.save();
    ctx.translate(22,84);
    ctx.scale(orbPulse, orbPulse);
    ctx.fillStyle='rgba(255,220,255,0.26)';
    ctx.beginPath();
    ctx.arc(0,0,26,0,Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(255,200,255,0.35)';
    ctx.lineWidth=3.4;
    ctx.beginPath();
    ctx.arc(0,0,20,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();
    ctx.restore();
  }

  function drawDemonAfterimages(now){
    if(!demonAfterimages.length) return;
    for(const ghost of demonAfterimages){
      const life=ghost.life||420;
      const age=now-ghost.t0;
      const alpha=Math.max(0, 1 - age/life);
      if(alpha<=0) continue;
      const ghostState={
        x:ghost.x,
        y:ghost.y + Math.sin((now-ghost.t0)/260)*4,
        w:ghost.w,
        h:ghost.h,
        hoverPhase:ghost.hoverPhase,
        cloakPhase:ghost.cloakPhase,
        cloakSway:ghost.cloakSway,
        t0:ghost.t0
      };
      const fadeAlpha = ghost.fade ? alpha*alpha : alpha;
      renderDemonAfterimageFigure(ghostState, now, fadeAlpha);
    }
  }

  function drawDemonLayer(now){
    if(level!==20) return;
    drawDemonCore(now);
    drawDemonAfterimages(now);
    if(demonBoss && (demonPhase==='active' || demonPhase==='dying')){
      renderDemonFigure(demonBoss, now);
    }
    if(demonDeathAnim && demonPhase!=='defeated'){
      const anim=demonDeathAnim;
      const elapsed=now-anim.start;
      const life=Math.max(1, (anim.duration||2200));
      const prog=Math.max(0, Math.min(1, elapsed/life));
      const cx=(anim.centerX||550)*scaleX;
      const cy=(anim.centerY|| (layout().top+160))*scaleY;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const outer=200*((scaleX+scaleY)/2)*(1+prog*0.6);
      const glow=ctx.createRadialGradient(cx,cy,0,cx,cy,outer);
      glow.addColorStop(0,`rgba(240,220,255,${0.55*(1-prog)})`);
      glow.addColorStop(0.55,`rgba(180,120,220,${0.4*(1-prog)})`);
      glow.addColorStop(1,'rgba(110,50,200,0)');
      ctx.fillStyle=glow;
      ctx.beginPath();
      ctx.arc(cx,cy,outer,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawDemonCloakWraps(now, layer='front'){
    if(level!==20 || demonPhase!=='active' || !demonBoss) return;
    if(!Array.isArray(balls) || !balls.length) return;
    const captured=balls.filter(b=>b && b.demonCloakState==='captured');
    if(!captured.length) return;
    const center=demonCloakCenter();
    if(!center) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const centerX=center.x*scaleX;
    const centerY=center.y*scaleY;
    for(const ball of captured){
      const progress=Math.max(0, Math.min(1, ball.demonCloakWrapProgress||0));
      const ballX=ball.x*scaleX;
      const ballY=ball.y*scaleY;
      const anchor=ball.demonCloakAnchor||{dx:0,dy:0};
      const wrapRadius=Math.max(ball.r*scaleAvg*1.8, Math.hypot((anchor.dx||0)*scaleX, (anchor.dy||0)*scaleY)*0.6, 22*scaleAvg);
      const dx=ballX-centerX;
      const dy=ballY-centerY;
      const baseAngle=Math.atan2(dy, dx);
      const swirl=ball.demonCloakWrapPhase||baseAngle;
      if(layer==='behind'){
        ctx.save();
        ctx.globalAlpha=0.45 + 0.25*progress;
        ctx.lineCap='round';
        ctx.lineJoin='round';
        ctx.strokeStyle=`rgba(140,0,28,${0.55+0.3*progress})`;
        ctx.lineWidth=(16 + 18*progress)*scaleAvg;
        const ctrlX=centerX + dx*0.45 + Math.cos(swirl)*wrapRadius*0.55;
        const ctrlY=centerY + dy*0.45 + Math.sin(swirl)*wrapRadius*0.45;
        const tailX=ballX - Math.cos(baseAngle)*wrapRadius*0.55;
        const tailY=ballY - Math.sin(baseAngle)*wrapRadius*0.35;
        ctx.beginPath();
        ctx.moveTo(centerX - 18*scaleAvg, centerY - 28*scaleAvg);
        ctx.quadraticCurveTo(ctrlX, ctrlY, tailX, tailY);
        ctx.stroke();
        ctx.restore();
        continue;
      }
      if(layer!=='front') continue;
      ctx.save();
      ctx.translate(ballX, ballY);
      ctx.rotate(baseAngle + Math.PI/2);
      const flapW=wrapRadius*(0.85 + 0.45*progress);
      const flapLen=wrapRadius*(1.28 + 0.55*progress);
      const topLift=wrapRadius*(0.68 + 0.24*progress);
      ctx.beginPath();
      ctx.moveTo(-flapW*0.62, -wrapRadius*0.24);
      ctx.quadraticCurveTo(-flapW*1.05, flapLen*0.18, -flapW*0.2, flapLen*0.82);
      ctx.quadraticCurveTo(0, flapLen*(1.1+0.22*progress), flapW*0.2, flapLen*0.82);
      ctx.quadraticCurveTo(flapW*1.05, flapLen*0.18, flapW*0.62, -wrapRadius*0.24);
      ctx.quadraticCurveTo(flapW*0.18, -topLift, 0, -topLift*1.08);
      ctx.quadraticCurveTo(-flapW*0.18, -topLift, -flapW*0.62, -wrapRadius*0.24);
      ctx.closePath();
      const grad=ctx.createLinearGradient(0,-topLift*1.1,0,flapLen*(1.12+0.2*progress));
      grad.addColorStop(0,`rgba(200,48,58,${0.55+0.2*progress})`);
      grad.addColorStop(0.5,`rgba(140,0,24,${0.78+0.18*progress})`);
      grad.addColorStop(1,`rgba(70,0,12,${0.92+0.06*progress})`);
      ctx.fillStyle=grad;
      ctx.shadowColor=`rgba(255,120,150,${0.18+0.22*progress})`;
      ctx.shadowBlur=26*scaleAvg*progress;
      ctx.fill();
      ctx.shadowBlur=0;
      ctx.strokeStyle=`rgba(255,200,210,${0.18+0.18*progress})`;
      ctx.lineWidth=2.4*scaleAvg;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -topLift*0.82);
      ctx.quadraticCurveTo(-flapW*0.12, flapLen*0.34, 0, flapLen*0.96);
      ctx.strokeStyle=`rgba(255,180,200,${0.18+0.2*progress})`;
      ctx.lineWidth=1.2*scaleAvg;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, -topLift*0.82);
      ctx.quadraticCurveTo(flapW*0.12, flapLen*0.34, 0, flapLen*0.96);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,120,140,${0.18+0.24*progress})`;
      ctx.lineWidth=3.2*scaleAvg;
      ctx.beginPath();
      ctx.arc(ballX, ballY, wrapRadius*0.72, baseAngle-0.5, baseAngle+1.05);
      ctx.stroke();
      ctx.restore();
    }
  }

  function activateDemonBoss(){
    if(level!==20) return;
    const now=performance.now();
    const L=layout();
    const cx=1100/2;
    const baseY=L.top + 160;
    demonBoss={
      x:cx,
      y:baseY,
      baseY,
      w:90,
      h:90,
      hitW:150,
      hitH:220,
      hitOffsetY:10,
      cloakW:260,
      cloakH:260,
      cloakOffsetY:20,
      hp:90,
      maxHp:90,
      hoverPhase:0,
      cloakPhase:Math.random()*Math.PI*2,
      cloakSway:0,
      hitFlashUntil:0,
      hitCooldownUntil:0,
      lastUpdate:now,
      lastAfterimage:0,
      deathFade:1,
      spawnAt:now
    };
    demonPhase='active';
    demonAfterimages=[];
    screenShake=Math.max(screenShake,16);
    spawnParticles(cx, baseY, '#dcb6ff', 110, 2.0, 3.2, 3.0);
    spawnParticles(cx, baseY, '#f0e4ff', 80, 1.8, 2.6, 2.4);
    demonEventWave={x:cx,y:baseY,start:now,duration:2000,maxRadius:Math.hypot(1100,700)};
  }

  function damageDemonBoss(amount=1, source='generic', impact){
    if(demonPhase!=='active' || !demonBoss) return false;
    const now=performance.now();
    if(demonBoss.hitCooldownUntil && now<demonBoss.hitCooldownUntil) return false;
    demonBoss.hitCooldownUntil=now+140;
    demonBoss.hp=Math.max(0, demonBoss.hp-amount);
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    demonBoss.hitFlashUntil=now+220;
    const ix=(impact&&impact.x!=null)?impact.x:demonBoss.x;
    const iy=(impact&&impact.y!=null)?impact.y:demonBoss.y;
    spawnParticles(ix,iy,'#dcb6ff',24,1.8,3.0,2.8);
    screenShake=Math.max(screenShake,4);
    if(demonBoss.hp<=0){
      defeatDemonBoss();
    }
    return true;
  }

  function defeatDemonBoss(){
    if(demonPhase==='dying' || demonPhase==='defeated') return;
    const now=performance.now();
    const centerX=demonBoss?demonBoss.x:550;
    const centerY=demonBoss?demonBoss.y:(layout().top+160);
    demonPhase='dying';
    demonDeathAnim={start:now, duration:2200, vanishAt:now+900, lastSpark:0, centerX:centerX, centerY:centerY};
    demonEventWave={x:centerX,y:centerY,start:now,duration:2600,maxRadius:Math.hypot(1100,700)};
    demonEventMarquee={text:'成功擊殺Boss: 魔王埃里赫曼!', start:now, fadeStart:now+5000, end:now+5000};
    if(demonBoss){
      demonBoss.hp=0;
      demonBoss.hitFlashUntil=now+260;
    }
    addScore(BOSS_DEFEAT_SCORE.demon);
    stats.bossKills++;
    updateHUD();
    screenShake=Math.max(screenShake,24);
    spawnParticles(centerX,centerY,'#fff5ff',200,3.0,4.4,4.8);
    spawnParticles(centerX,centerY,'#c08cff',150,2.4,3.6,3.8);
    spawnParticles(centerX,centerY,'#ffd1ff',120,2.6,3.8,3.6);
    spawnPower(centerX-12, centerY, {forceType:'NINE'});
  }

  function updateDemonBoss(){
    if(level!==20) return;
    const now=performance.now();
    if(demonPhase==='intro' && !demonBoss && demonRevealScheduled && now>=demonRevealScheduled){
      activateDemonBoss();
    }
    if(demonPhase==='active' && demonBoss){
      const dt = now - (demonBoss.lastUpdate||now);
      demonBoss.lastUpdate=now;
      const prevX=demonBoss.x;
      const prevBaseY=demonBoss.baseY;
      if(!demonBoss.moveTarget || now>=demonBoss.nextMove){
        const L=layout();
        const minX=210;
        const maxX=890;
        const minY=L.top + 100;
        const maxY=L.top + 260;
        demonBoss.moveTarget={x:minX + Math.random()*(maxX-minX), y:minY + Math.random()*(maxY-minY)};
        demonBoss.nextMove = now + 1400 + Math.random()*1400;
      }
      if(demonBoss.moveTarget){
        const speed=Math.min(0.22, (dt/1000)*0.75);
        demonBoss.x += (demonBoss.moveTarget.x - demonBoss.x)*speed;
        demonBoss.baseY += (demonBoss.moveTarget.y - demonBoss.baseY)*speed;
      }
      demonBoss.hoverPhase += dt*0.0026;
      demonBoss.cloakPhase += dt*0.0018;
      const moveDelta=Math.hypot(demonBoss.x-prevX, demonBoss.baseY-prevBaseY);
      const baseSway=0.16 + Math.abs(Math.sin(demonBoss.hoverPhase))*0.1;
      const swayTarget=Math.min(1.1, baseSway + moveDelta*14);
      demonBoss.cloakSway = (demonBoss.cloakSway||0) + (swayTarget - (demonBoss.cloakSway||0))*0.35;
      demonBoss.y = demonBoss.baseY + Math.sin(demonBoss.hoverPhase)*14;
      if(!demonBoss.lastAfterimage || now - demonBoss.lastAfterimage > 140){
        demonAfterimages.push({x:demonBoss.x, y:demonBoss.y, baseY:demonBoss.baseY, w:demonBoss.w, h:demonBoss.h, hoverPhase:demonBoss.hoverPhase, cloakPhase:demonBoss.cloakPhase, cloakSway:demonBoss.cloakSway, t0:now, life:420});
        if(demonAfterimages.length>6){ demonAfterimages.splice(0, demonAfterimages.length-6); }
        demonBoss.lastAfterimage=now;
      }
    }else if(demonPhase==='dying' && demonDeathAnim){
      const anim=demonDeathAnim;
      const elapsed=now-anim.start;
      const fadeDuration=Math.max(1, (anim.vanishAt|| (anim.start+900)) - anim.start);
      if(demonBoss){
        const dt = now - (demonBoss.lastUpdate||now);
        demonBoss.lastUpdate=now;
        demonBoss.hoverPhase += dt*0.002;
        demonBoss.y = demonBoss.baseY + Math.min(120, elapsed*0.18);
        demonBoss.deathFade = Math.max(0, 1 - elapsed/fadeDuration);
        if(!anim.lastSpark || now-anim.lastSpark>90){
          const ox=(Math.random()-0.5)*demonBoss.w*0.6;
          const oy=(Math.random()-0.5)*demonBoss.h*0.6;
          spawnParticles(demonBoss.x+ox, demonBoss.y+oy, '#dcb6ff', 16, 1.4, 2.4, 2.5);
          anim.lastSpark=now;
        }
        if(elapsed>=fadeDuration){
          demonAfterimages.push({x:demonBoss.x, y:demonBoss.y, baseY:demonBoss.baseY, w:demonBoss.w, h:demonBoss.h, hoverPhase:demonBoss.hoverPhase, cloakPhase:demonBoss.cloakPhase, cloakSway:demonBoss.cloakSway, t0:now, life:600, fade:true});
          if(demonAfterimages.length>8){ demonAfterimages.splice(0, demonAfterimages.length-8); }
          demonBoss=null;
        }
      }
      if(elapsed>=(anim.duration||2200)){
        demonPhase='defeated';
        demonDeathAnim=null;
        demonDefeatedAt=now;
      }
    }
    for(let i=demonAfterimages.length-1;i>=0;i--){
      const ghost=demonAfterimages[i];
      const life=ghost.life||520;
      if(now-ghost.t0>=life){ demonAfterimages.splice(i,1); }
    }
  }

  function demonClampPoint(x, y){
    const bounds=getDemonBounds();
    if(!bounds) return {x, y};
    return {
      x: Math.max(bounds.x, Math.min(x, bounds.x + bounds.w)),
      y: Math.max(bounds.y, Math.min(y, bounds.y + bounds.h))
    };
  }

  function drawDemonWave(now){
    if(level!==20 || !demonEventWave) return;
    const wave=demonEventWave;
    const life = wave.duration||1;
    const prog = Math.max(0, Math.min(1,(now-wave.start)/life));
    const radius = (wave.maxRadius||Math.hypot(1100,700)) * prog;
    const alpha = 0.45*(1-prog);
    if(alpha<=0) return;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const maxR = radius*((scaleX+scaleY)/2);
    const minR = maxR*0.35;
    const grad=ctx.createRadialGradient(wave.x*scaleX, wave.y*scaleY, minR, wave.x*scaleX, wave.y*scaleY, Math.max(minR+1,maxR));
    grad.addColorStop(0,`rgba(210,170,255,${alpha})`);
    grad.addColorStop(0.6,`rgba(160,110,255,${alpha*0.6})`);
    grad.addColorStop(1,'rgba(110,40,200,0)');
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(wave.x*scaleX, wave.y*scaleY, Math.max(minR+1,maxR),0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawDemonCore(now){
    if(level!==20 || !demonCore) return;
    const life = demonCore.visibleUntil ? Math.max(1, demonCore.visibleUntil - demonCore.start) : 1;
    const remain = demonCore.visibleUntil ? Math.max(0, demonCore.visibleUntil - now) : life;
    const alpha = Math.max(0, Math.min(1, remain/life));
    const baseRadius = 34*((scaleX+scaleY)/2);
    const pulse = 1 + 0.08*Math.sin(now/160);
    const outer = baseRadius*1.6*pulse;
    const cx=demonCore.x*scaleX;
    const cy=demonCore.y*scaleY;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const glow=ctx.createRadialGradient(cx, cy, 0, cx, cy, outer);
    glow.addColorStop(0,`rgba(230,210,255,${0.6*alpha})`);
    glow.addColorStop(0.45,`rgba(170,100,255,${0.45*alpha})`);
    glow.addColorStop(1,'rgba(90,30,200,0)');
    ctx.fillStyle=glow;
    ctx.beginPath();
    ctx.arc(cx,cy,outer,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.fillStyle=`rgba(200,120,255,${0.9*alpha})`;
    ctx.beginPath();
    ctx.arc(cx,cy,baseRadius*pulse,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  function cyclopsBlastRow(rowIndex){
    const L=layout();
    const rowHeight = brickH + L.pad;
    let removed=false;
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const row=Math.round(((b.y - L.top) / rowHeight));
      if(row!==rowIndex) continue;
      if(b.boss){
        if(b.cyclops && !cyclopsShellBurst){
          cyclopsShellBurst=true;
          startDragonReveal(b);
        }
        continue;
      }
      const cx=b.x+b.w/2, cy=b.y+b.h/2;
      spawnParticles(cx,cy,'#ffe6a1',28,2.4,3.2,3.6);
      spawnParticles(cx,cy,'#ffb46d',18,2.0,2.8,3.2);
      if(!b.fallingTreasure){ revealBrickArea(b); }
      bricks.splice(i,1);
      removed=true;
    }
    if(removed){
      screenShake=Math.max(screenShake,18);
      playSFX('fireExplosion');
      updateHUD();
    }
  }
  let nextBossAtkA=0, nextBossAtkB=0, bossChargeUntil=0, bossChargeColor='', cyclopsShakeUntil=0;

  function updateBossAbilities(){
    const bossLv = (level%5===0)? level : 0;
    if(!bossLv) return;
    if(level===5 && spaceBossPhase!=='inactive') return;
    if(level===15 && (dragonPhase==='dying' || dragonPhase==='defeated' || dragonPhase==='inactive')) return;
    const now=performance.now();
    if(bossLv===5){ if(now>=nextBossAtkA){ spawnLionBeam(); nextBossAtkA = now + 10000; } }
    else if(bossLv===10){ if(now>=nextBossAtkA){ spawnKnightArc(); nextBossAtkA = now + 15000; } }
    else if(bossLv===15){
      if(!cyclopsForcedPetrifyFired && cyclopsForcedPetrifyAt && now>=cyclopsForcedPetrifyAt){
        if(dragonPhase==='awaiting'){ spawnCyclopsColumn(); }
        cyclopsForcedPetrifyFired=true;
      }
      if(dragonPhase!=='awaiting'){ cyclopsForcedPetrifyFired=true; cyclopsForcedPetrifyAt=0; }
      maybeStartDragonAttack(now);
    }
    else if(bossLv===20){ /* 第20關新事件期間暫停原有攻擊 */ }
  }

  function drawAndStepBossProjectiles(){
    const pr=paddleRect();
    // 金/紅雷射
    for(let i=hostileBeams.length-1;i>=0;i--){
      const b = hostileBeams[i];
      b.x += b.vx; b.y += b.vy;
      // render
      const x1 = (b.x - b.vx*2)*scaleX, y1=(b.y - b.vy*2)*scaleY;
      const x2 = b.x*scaleX, y2=b.y*scaleY;
      ctx.save(); ctx.globalCompositeOperation='lighter';
      if(b.color==='gold'){
        const grd=ctx.createLinearGradient(x1,y1,x2,y2);
        grd.addColorStop(0,'rgba(255,240,160,0)');
        grd.addColorStop(1,'rgba(255,220,120,0.95)');
        ctx.strokeStyle=grd; ctx.lineWidth=6; ctx.shadowColor='rgba(255,230,150,0.9)'; ctx.shadowBlur=15;
      }else if(b.color==='red'){
        const grd=ctx.createLinearGradient(x1,y1,x2,y2);
        grd.addColorStop(0,'rgba(255,120,120,0)');
        grd.addColorStop(1,'rgba(255,60,80,0.95)');
        ctx.strokeStyle=grd; ctx.lineWidth=6; ctx.shadowColor='rgba(255,40,60,0.9)'; ctx.shadowBlur=20;
      }else{
        ctx.strokeStyle='rgba(255,80,120,0.8)'; ctx.lineWidth=5;
      }
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
      // hit check
      if(!b.hit && x2>=pr.x*scaleX && x2<= (pr.x+pr.w)*scaleX && y2>=pr.y*scaleY && y2<= (pr.y+pr.h)*scaleY){
        b.hit=true; b.onHit?.(pr); spawnParticles(b.x,b.y,'#ffd',12,1.6,2.2,2.5);
      }
      // out of bounds
      if(b.x<0||b.x>1100||b.y<0||b.y>700){ hostileBeams.splice(i,1); }
    }
    // 弧形劍氣
    for(let i=hostileArcs.length-1;i>=0;i--){
      const a = hostileArcs[i];
      a.phase += 0.15;
      a.x += a.vx + Math.sin(a.phase)*0.9;
      a.y += a.vy + Math.cos(a.phase)*0.4;
      // render
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const grad=ctx.createLinearGradient((a.x-a.vx*4)*scaleX,(a.y-a.vy*4)*scaleY,a.x*scaleX,a.y*scaleY);
      grad.addColorStop(0,'rgba(200,200,255,0)');
      grad.addColorStop(1,'rgba(220,220,255,0.9)');
      ctx.strokeStyle=grad; ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(a.x*scaleX, a.y*scaleY, 22*((scaleX+scaleY)/2), Math.PI*0.2, Math.PI*1.2);
      ctx.stroke();
      // 粒子
      for(let k=0;k<5;k++){ particles.push({x:a.x, y:a.y, vx:(Math.random()-0.5)*0.8, vy:(Math.random()-0.5)*0.8, life:220, size:1.6, color:'rgba(200,200,255,0.7)'}); }
      ctx.restore();
      // hit
      if(a.x>=pr.x && a.x<=pr.x+pr.w && a.y>=pr.y && a.y<=pr.y+pr.h){
        a.onHit?.(); hostileArcs.splice(i,1);
      }
      if(a.x<0||a.x>1100||a.y>700||a.y<0){ hostileArcs.splice(i,1); }
    }
    // 石化柱
    for(let i=hostileColumns.length-1;i>=0;i--){
      const c = hostileColumns[i];
      const now=performance.now();
      if(now>c.tEnd){ hostileColumns.splice(i,1); continue; }
      const x = (c.x - c.w/2)*scaleX, y = (layout().top)*scaleY;
      const w = c.w*scaleX, h = (700 - layout().top)*scaleY;
      const alpha = 0.5 + 0.5*Math.sin(now/80);
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const grd = ctx.createLinearGradient(c.x*scaleX, layout().top*scaleY, c.x*scaleX, 700*scaleY);
      grd.addColorStop(0, 'rgba(245,228,150,0.85)'); grd.addColorStop(1, 'rgba(240,210,120,0.35)');
      ctx.fillStyle = grd; ctx.fillRect(x, y, w, h);
      ctx.restore();
      // 命中平台：僵直3秒
      const pr = paddleRect();
      if(!c.applied){
        const inter = !( pr.x+pr.w < (c.x - c.w/2) || pr.x > (c.x + c.w/2) );
        if(inter){ paddleStunUntil = Math.max(paddleStunUntil, performance.now()+3000); screenShake=Math.max(screenShake,7); c.applied=true; }
      }
    }
    // 烏雲
    for(let i=hazardClouds.length-1;i>=0;i--){
      const cl = hazardClouds[i];
      const now=performance.now();
      // draw cloud
      ctx.save();
      const x = cl.x*scaleX, y=cl.y*scaleY;
      ctx.globalAlpha = 0.9 * Math.max(0, (cl.tEnd - now)/1000);
      ctx.fillStyle='rgba(60,60,80,0.9)';
      ctx.beginPath(); ctx.arc(x-20,y,14,0,Math.PI*2); ctx.arc(x,y-6,18,0,Math.PI*2); ctx.arc(x+18,y,16,0,Math.PI*2); ctx.fill();
      ctx.restore();
      if(now>=cl.tEnd && !cl.spawned){
        // 掉落減益道具
        const debuffs = ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type==='debuff');
        const type = debuffs[Math.floor(Math.random()*debuffs.length)] || 'FAST';
        // 生成一個減益道具，速度略快，方向根據當前翻轉狀態
        {
          const baseSpeed = GAME_CONFIG.powerCapsule.fallVy;
          const speed = baseSpeed * 1.4;
          const horizontal = orientLeft;
          let px = cl.x - 12;
          let py = cl.y;
          if(horizontal){
            // 水平掉落：從右側開始
            px = 1100 - 40;
            const L = layout();
            py = L.top + 20 + Math.random() * (700 - 60 - L.top);
          }
          powerups.push({
            x: px,
            y: py,
            w: GAME_CONFIG.powerCapsule.width,
            h: GAME_CONFIG.powerCapsule.height,
            speed: speed,
            horizontal: horizontal,
            type: type,
            isDebuff: true,
            isSpecial: false,
            phase: Math.random()*Math.PI*2
          });
        }
        cl.spawned=true;
      }
      if(now > cl.tEnd + 2000){ hazardClouds.splice(i,1); }
    }
  }

  // 天地翻轉狀態
  let orientLeft=false; // true 時改為左側擋板模式
  let paddleStunUntil=0;
  let paddleGoneUntil=0;


  function spawnParticles(x,y,color,count=10,spread=1.6,speed=3,size=3){
    for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const v=speed*(.4+Math.random()); particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:400+Math.random()*300,size:size*(.6+Math.random()*0.8),color}); }
  }

  // === 工具 ===
  function getDiff(){ return GAME_CONFIG.difficulty[difficultySel.value]; }
  function brickColor(i){ return [getVar('--brick1'),getVar('--brick2'),getVar('--brick3'),getVar('--brick4')][i%4]; }
  function getVar(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }
  function clampHP(h){ return Math.max(1, Math.min(4, (h|0))); }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo((x+r)*scaleX,y*scaleY); ctx.arcTo((x+w)*scaleX,y*scaleY,(x+w)*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo((x+w)*scaleX,(y+h)*scaleY,x*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo(x*scaleX,(y+h)*scaleY,x*scaleX,y*scaleY,r*scaleX); ctx.arcTo(x*scaleX,y*scaleY,(x+w)*scaleX,y*scaleY,r*scaleX); ctx.closePath(); }

  // === 統一鎖定框（顯示 1 秒） ===
  function pushLockBox(x,y,w,h,kind='target'){ lockBoxes.push({x,y,w,h,until:performance.now()+1000,kind}); }
  function drawLockBoxes(){
    const now=performance.now();
    for(let i=lockBoxes.length-1;i>=0;i--){
      const b=lockBoxes[i];
      if(now>b.until){ lockBoxes.splice(i,1); continue; }
      const t = 1 - Math.max(0, (b.until-now)/1000);
      const pulse = 0.7 + 0.3*Math.sin(now/100);
      let col = b.kind==='paddle' ? 'rgba(120,220,255,'+(0.6*pulse)+')' : 'rgba(255,220,140,'+(0.6*pulse)+')';
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle = col;
      ctx.lineWidth = 2 + 2*pulse;
      drawRoundedRect(b.x, b.y, b.w, b.h, 10);
      ctx.stroke();
      ctx.restore();
    }
  }


  
  function drawBossEmblem(b){
    const cx = (b.x + b.w/2)*scaleX, cy = (b.y + b.h/2)*scaleY;
    if(b.cyclops && b.cyclopsRevealed){
      const pulse = 0.7 + 0.3*Math.sin(performance.now()/240);
      const radius = Math.min(b.w,b.h)*0.36*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.shadowColor=`rgba(255,220,120,${0.5+0.4*pulse})`;
      ctx.shadowBlur=30*((scaleX+scaleY)/2);
      const grad=ctx.createRadialGradient(cx,cy,radius*0.15,cx,cy,radius);
      grad.addColorStop(0,'rgba(255,255,220,0.98)');
      grad.addColorStop(0.45,'rgba(255,230,150,0.9)');
      grad.addColorStop(1,'rgba(255,170,60,0.08)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(cx,cy,radius,0,Math.PI*2);
      ctx.fill();
      ctx.shadowBlur=0;
      ctx.lineWidth=2.4*((scaleX+scaleY)/2);
      ctx.strokeStyle=`rgba(255,245,200,${0.75+0.2*pulse})`;
      ctx.beginPath();
      ctx.arc(cx,cy,radius*0.72,0,Math.PI*2);
      ctx.stroke();
      ctx.strokeStyle=`rgba(255,210,120,${0.25+0.2*Math.sin(performance.now()/180)})`;
      ctx.lineWidth=1.6*((scaleX+scaleY)/2);
      ctx.beginPath();
      const swing=performance.now()/520;
      ctx.arc(cx,cy,radius*1.18,swing, swing+Math.PI*1.1);
      ctx.stroke();
      ctx.restore();
      return;
    }
    const t = performance.now()/600;
    // 裝甲層
    ctx.save();
    const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
    g.addColorStop(0,'#5f0d2a'); g.addColorStop(1,'#130812');
    ctx.fillStyle = g; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.fill();
    // 外框呼吸
    const glow = 0.5 + 0.5*Math.sin(t*2);
    ctx.strokeStyle = 'rgba(255,90,120,'+(0.6*glow)+')'; ctx.lineWidth = 3 + 2*glow;
    drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke();
    // Emblem
    ctx.translate(cx, cy);
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,230,230,0.9)';
    const idx = ['獅','騎','目','魔'].indexOf(b.face);
    if(idx===0){
      // 獅：鬃毛圓環 + 牙
      ctx.beginPath(); ctx.arc(0,0, Math.min(b.w,b.h)*0.22*scaleX, 0, Math.PI*2); ctx.stroke();
      for(let i=0;i<6;i++){ const a = i*Math.PI/3; ctx.beginPath(); ctx.moveTo(Math.cos(a)*18, Math.sin(a)*18); ctx.lineTo(Math.cos(a)*30, Math.sin(a)*30); ctx.stroke(); }
      ctx.beginPath(); ctx.moveTo(-14,8); ctx.lineTo(-6,14); ctx.moveTo(14,8); ctx.lineTo(6,14); ctx.stroke();
    }else if(idx===1){
      // 頭盔 + 羽飾
      ctx.beginPath(); ctx.arc(0,0,22,Math.PI*0.15, Math.PI*0.85); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-14,0); ctx.lineTo(14,0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-10,-10); ctx.lineTo(0,-22); ctx.lineTo(10,-10); ctx.stroke();
    }else if(idx===2){
      // 獨眼：巨眼 + 眼瞼
      ctx.beginPath(); ctx.ellipse(0,0,26,18,0,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,0); ctx.lineTo(26,0); ctx.stroke();
    }else{
      // 五芒星 + 角
      ctx.beginPath();
      for(let i=0;i<5;i++){ const a = -Math.PI/2 + i*2*Math.PI/5; const x = Math.cos(a)*22, y=Math.sin(a)*22;
        const a2 = -Math.PI/2 + ((i*2+2)%10)*Math.PI/5; const x2=Math.cos(a2)*9, y2=Math.sin(a2)*9;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); ctx.lineTo(x2,y2);
      } ctx.closePath(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,-18); ctx.lineTo(-10,-30); ctx.moveTo(26,-18); ctx.lineTo(10,-30); ctx.stroke();
    }
    ctx.restore();
  }

  // === Buff/De-buff 顯示 ===
  function badgeIcon(k){ return (GAME_CONFIG.powers[k]?.badge)||'●'; }
  function fitBuffBadges(){
    if(!activeBuffsEl) return;
    activeBuffsEl.style.setProperty('--buff-scale','1');
    const total=activeBuffsEl.scrollWidth;
    const avail=activeBuffsEl.clientWidth;
    const base=window.innerWidth<=430?0.9:1;
    let scale=base;
    if(total*base>avail){ scale=avail/total; }
    activeBuffsEl.style.setProperty('--buff-scale',scale);
  }
  function updateBuffBadges(){ activeBuffsEl.innerHTML=''; const now=performance.now();
    // LONG 堆疊
    const longAct=buffs.LONG.stacks.filter(t=>t>now);
    if(longAct.length){
      const s=document.createElement('span');
      s.className='badge';
      const leftSec=(Math.max(...longAct)-now)/1000;
      s.textContent=`${badgeIcon('LONG')} LONG×${longAct.length} ${leftSec.toFixed(1)}s`;
      activeBuffsEl.appendChild(s);
    }
    // 其它
    for(const key of Object.keys(GAME_CONFIG.powers)){ if(key==='LONG') continue; const b=buffs[key]; if(!b?.active) continue; const left=b.until&&b.until>now?((b.until-now)/1000).toFixed(1)+'s':''; const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon(key)} ${key}${left?' '+left:''}`; activeBuffsEl.appendChild(s); }
    fitBuffBadges();
  }
  window.addEventListener('resize', fitBuffBadges);

  const promptQueue=[];
  function showPrompt(text){
    if(!promptsDock) return;
    const div=document.createElement('div');
    div.className='prompt';
    div.textContent=text;
    promptsDock.appendChild(div);
    promptQueue.push(div);
    while(promptQueue.length>3){ const old=promptQueue.shift(); old.remove(); }
    setTimeout(()=>{ div.classList.add('fade'); setTimeout(()=>{ const idx=promptQueue.indexOf(div); if(idx>=0) promptQueue.splice(idx,1); div.remove(); },400); },5000);
  }

  // === Buff 狀態 ===
  const buffs={WIDE:{active:false,until:0},STICKY:{active:false,until:0},MULTI:{active:false,until:0},SLOW:{active:false,until:0},PIERCE:{active:false,until:0},SHIELD:{active:false,until:0},RAMPAGE:{active:false,until:0},FAST:{active:false,until:0},WAVY:{active:false,until:0,start:0},COMBO:{active:false,until:0},LONG:{active:false,until:0,stacks:[]},PLASMA:{active:false,until:0},FREEZE:{active:false,until:0},HOLY:{active:false,until:0},TRACK:{active:false,until:0},MISSILE:{active:false,until:0},HELL:{active:false,until:0},MEGA:{active:false,until:0,applied:false},CHAIN:{active:false,until:0},NARROW:{active:false,until:0},HOLE:{active:false,until:0},PADSPIN:{active:false,until:0,start:0},PADBOOM:{active:false,until:0,explodeAt:0,returnAt:0,exploded:false},FLIP:{active:false,until:0},GODSPEED:{active:false,until:0},LASER:{active:false,until:0,lastShot:0},GATLING:{active:false,until:0},FIRE:{active:false,until:0},POISON:{active:false,until:0},BLINK:{active:false,until:0},SWORD:{active:false,until:0},STORM:{active:false,until:0},BLACKHOLE:{active:false,until:0,deaths:0},ANNIHIL:{active:false,until:0,start:0,next:0}};

  // === 擋板 & 球 ===
  let diff=getDiff(); const paddle={w:diff.paddleBaseW,h:18,x:1100/2-diff.paddleBaseW/2,y:700-50,speed:12};
let balls=[]; function makeBall(stuck=false,x=null){ return {x:x??(1100/2),y:700/2,r:10,vx:5,vy:-5,speedCap:GAME_CONFIG.caps.ballSpeedMax,piercing:false,stuck:stuck,offsetX:0,rampageUntil:0,trail:[],freeze:{state:'idle',t0:0,until:0,oldVX:0,oldVY:0,delay:0,stop:0},blinkAt:0,loopBrick:null,loopHits:0,lastBrickId:null,lastBrickHitTime:0,sameBrickHits:0,lastBounce:null,speedBoostSuppressedUntil:0,lastCeilingBounce:0}; }

  function isSpeedSuppressed(ball, now){
    return !!(ball?.speedBoostSuppressedUntil && now < ball.speedBoostSuppressedUntil);
  }

  function suppressSpeedBoost(ball, now, duration=1000){
    if(!ball) return;
    const target = now + duration;
    if(!ball.speedBoostSuppressedUntil || ball.speedBoostSuppressedUntil < target){
      ball.speedBoostSuppressedUntil = target;
    }
  }

  function noteCeilingBounce(ball, now){
    if(!ball) return;
    if(ball.lastCeilingBounce && now - ball.lastCeilingBounce <= 1000){
      suppressSpeedBoost(ball, now);
    }
    ball.lastCeilingBounce = now;
  }

  function applyBounceNudge(ball, axis){
    const sp=Math.hypot(ball.vx,ball.vy);
    if(sp<=0.0001) return;
    const minFrac=0.18;
    if(axis==='y'){
      let sign=Math.sign(ball.vx);
      if(!sign) sign=Math.random()<0.5?-1:1;
      const target=Math.max(Math.abs(ball.vx), sp*minFrac);
      const newVX=sign*target;
      const vySign=Math.sign(ball.vy)||1;
      const remain=Math.sqrt(Math.max(sp*sp - newVX*newVX, 0));
      ball.vx=newVX;
      ball.vy=vySign*remain;
    }else if(axis==='x'){
      let sign=Math.sign(ball.vy);
      if(!sign) sign=Math.random()<0.5?-1:1;
      const target=Math.max(Math.abs(ball.vy), sp*minFrac);
      const newVY=sign*target;
      const vxSign=Math.sign(ball.vx)||1;
      const remain=Math.sqrt(Math.max(sp*sp - newVY*newVY, 0));
      ball.vx=vxSign*remain;
      ball.vy=newVY;
    }
  }

  function noteBounce(ball, x, y, axis, now){
    if(!ball) return;
    const last=ball.lastBounce;
    const maxDist=8;
    const maxInterval=800;
    if(last && last.axis===axis && now-last.time<=maxInterval){
      const dx=x-last.x;
      const dy=y-last.y;
      if(Math.hypot(dx,dy)<=maxDist){
        const count=last.count+1;
        ball.lastBounce={axis,time:now,x,y,count};
        if(count>=3){
          applyBounceNudge(ball, axis);
          ball.lastBounce={axis,time:now,x,y,count:0};
        }
        return;
      }
    }
    ball.lastBounce={axis,time:now,x,y,count:1};
  }

  // === 聲音與BGM ===

  // === BGM 主題依關卡段落 ===
  function bgmThemeForLevel(lv){
    if(lv<=4) return 'picnic';      // 開心郊遊
    if(lv===5) return 'lion';       // 獅子王決戰
    if(lv<=9) return 'castle';      // 攻入城堡
    if(lv===10) return 'duel';      // 騎士對決
    if(lv<=14) return 'valley';     // 潛入巨人山谷
    if(lv===15) return 'giant';     // 決戰巨人
    if(lv<=19) return 'demon';      // 惡魔城
    return 'finale';                // 最終魔王
  }

  // === BGM 變奏資料 ===
  function midi(n){ return 440*Math.pow(2,(n-69)/12); }
  const transposeSeq=(seq,s)=>seq.map(ch=>Array.isArray(ch)?ch.map(n=>n+s):ch+s);
  const rotateSeq=(arr,k)=>arr.slice(k).concat(arr.slice(0,k));

  function buildTheme(tempo, chords, melody){
    const play=(ch,mel,start,tone)=>{
      const beat=60/tempo;
      ch.forEach((c,i)=>c.forEach(n=>tone(midi(n),'triangle', start+i*4*beat, 3.8*beat, 0.04)));
      mel.forEach((m,i)=>tone(midi(m),'sine', start+i*2*beat, 1.6*beat, 0.045));
      for(let i=0;i<32;i++){ tone(100,'square', start+i*beat, 0.05*beat, 0.015); }
      return 32*beat;
    };
    return {
      tempo,
      patterns:[
        (t,tn)=>play(chords, melody, t, tn),
        (t,tn)=>play(transposeSeq(chords,2), melody, t, tn),
        (t,tn)=>play(chords, transposeSeq(melody,2), t, tn),
        (t,tn)=>play(rotateSeq(chords,2), melody, t, tn)
      ]
    };
  }

  const BGM_PATTERNS={
    picnic: buildTheme(100,
      [[60,64,67],[65,69,72],[67,71,74],[60,64,67],[57,60,64],[62,65,69],[67,71,74],[60,64,67]],
      [72,74,76,79,76,74,72,69,72,74,76,74,72,69,67,69]),
    lion: buildTheme(120,
      [[62,65,69],[58,62,65],[60,64,67],[62,65,69],[65,69,72],[60,64,67],[62,65,69],[57,62,65]],
      [74,74,76,74,72,71,72,74,76,74,72,69,67,69,71,72]),
    castle: buildTheme(90,
      [[64,67,71],[60,64,67],[62,65,69],[59,62,67],[64,67,71],[60,64,67],[62,65,69],[64,67,71]],
      [76,74,72,71,72,74,76,78,76,74,72,71,69,71,72,74]),
    duel: buildTheme(110,
      [[67,71,74],[64,67,71],[60,64,67],[62,65,69],[67,71,74],[60,64,67],[57,60,64],[62,65,69]],
      [79,76,74,72,74,76,79,81,79,76,74,72,74,76,77,79]),
    valley: buildTheme(100,
      [[69,73,76],[66,69,73],[62,66,69],[64,69,72],[69,73,76],[64,69,72],[62,66,69],[59,62,66]],
      [81,78,76,74,76,78,81,83,81,78,76,74,76,78,79,81]),
    giant: buildTheme(80,
      [[65,68,72],[63,66,70],[60,63,67],[58,61,65],[65,68,72],[60,63,67],[63,66,70],[65,68,72]],
      [77,75,72,70,72,75,77,79,77,75,72,70,72,75,77,79]),
    demon: buildTheme(140,
      [[71,74,78],[67,71,74],[69,72,76],[65,69,72],[71,74,78],[67,71,74],[69,72,76],[71,74,78]],
      [83,81,78,76,78,81,83,85,83,81,78,76,78,81,83,85]),
    finale: buildTheme(150,
      [[60,63,67],[65,68,72],[70,74,77],[65,68,72],[60,63,67],[65,68,72],[70,74,77],[72,75,79]],
      [72,75,77,79,77,75,72,70,72,75,77,75,72,70,68,70])
  };

  let currentBGMTheme=null;
  let bgmTimer=null;
  function startBGMTheme(theme){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || !bgmOn) return;
    clearInterval(bgmTimer);
    bgmTimer=null;
    stopBGM();
    bgmStarted=true;
    currentBGMTheme=theme;
    const data=BGM_PATTERNS[theme];
    let variant=0;
    const beat=60/data.tempo;
    const patternDur=32*beat;
    const scheduleAhead=0.1;
    function tone(freq,type,start,dur,gain=0.045){
      const o=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value=0; o.connect(g); g.connect(bgmGain);
      o.start(start); g.gain.setTargetAtTime(gain,start,0.015);
      g.gain.setTargetAtTime(0.0001,start+dur-0.03,0.02);
      o.stop(start+dur+0.1);
      // 將 node 記錄於集合中，並在播放結束後移除以避免累積
      bgmNodes.add(o); bgmNodes.add(g);
      o.onended = () => { try{o.disconnect();}catch{} try{g.disconnect();}catch{} bgmNodes.delete(o); bgmNodes.delete(g); };
    }
    function playVariant(){
      if(!bgmOn || !bgmStarted) return;
      const base=audioCtx.currentTime+0.05;
      data.patterns[variant](base, tone);
      variant=(variant+1)%data.patterns.length;
    }
    // 於所有變奏播放完後，自動回到第一種變奏，並持續循環
    playVariant();
    bgmTimer=setInterval(playVariant, Math.max(0,(patternDur-scheduleAhead))*1000);
  }
  function applyBGMThemeForLevel(){
    const theme = bgmThemeForLevel(level);
    if(theme!==currentBGMTheme){ startBGMTheme(theme); }
  }

  function ensureAudio(){ if(!audioCtx){ const AC=(window.AudioContext||window.webkitAudioContext); if(AC){ audioCtx=new AC(); } } if(audioCtx && !bgmGain){ bgmGain=audioCtx.createGain(); bgmGain.gain.value=parseFloat(localStorage.getItem('bgm_vol')||'0.7'); bgmGain.connect(audioCtx.destination); } }
  function beep(freq=600,dur=0.05,vol=0.06){ if(!soundsOn||!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.stop(); }, Math.max(10, dur*1000)); }

  function playSFX(type){
    if(!soundsOn) return; if(!audioCtx) ensureAudio(); if(!audioCtx) return;
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    switch(type){
      case 'explosion':
        o.type='sawtooth';
        o.frequency.setValueAtTime(200, now);
        o.frequency.exponentialRampToValueAtTime(40, now+0.4);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.4);
        o.start(now); o.stop(now+0.4); break;
      case 'laser':
        o.type='square';
        o.frequency.setValueAtTime(1200, now);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.15);
        o.start(now); o.stop(now+0.15); break;
      case 'sword':
        o.type='triangle';
        o.frequency.setValueAtTime(900, now);
        o.frequency.linearRampToValueAtTime(600, now+0.1);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.2);
        o.start(now); o.stop(now+0.2); break;
      case 'pierce':
        o.type='square';
        o.frequency.setValueAtTime(700, now);
        g.gain.setValueAtTime(0.04, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.1);
        o.start(now); o.stop(now+0.1); break;
      case 'holy':
        o.type='sine';
        o.frequency.setValueAtTime(880, now);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.5);
        o.start(now); o.stop(now+0.5); break;
      case 'missile':
        o.type='sawtooth';
        o.frequency.setValueAtTime(1000, now);
        o.frequency.linearRampToValueAtTime(300, now+0.3);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.3);
        o.start(now); o.stop(now+0.3); break;
      case 'blackhole':{
        o.type='sine';
        o.frequency.setValueAtTime(90, now);
        o.frequency.exponentialRampToValueAtTime(28, now+0.8);
        g.gain.setValueAtTime(0.09, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        const sub=audioCtx.createOscillator();
        const subGain=audioCtx.createGain();
        sub.type='sawtooth';
        sub.frequency.setValueAtTime(45, now);
        sub.frequency.exponentialRampToValueAtTime(18, now+0.8);
        subGain.gain.setValueAtTime(0.04, now);
        subGain.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        sub.connect(subGain); subGain.connect(audioCtx.destination);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='triangle';
        shimmer.frequency.setValueAtTime(620, now);
        shimmer.frequency.linearRampToValueAtTime(980, now+0.25);
        shimmer.frequency.exponentialRampToValueAtTime(320, now+0.8);
        shimmerGain.gain.setValueAtTime(0.02, now);
        shimmerGain.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        shimmer.connect(shimmerGain); shimmerGain.connect(audioCtx.destination);
        o.start(now); o.stop(now+0.8);
        sub.start(now); sub.stop(now+0.8);
        shimmer.start(now+0.05); shimmer.stop(now+0.8);
        break;
      }
      case 'phoenix':
        o.type='sine';
        o.frequency.setValueAtTime(800, now);
        o.frequency.linearRampToValueAtTime(1200, now+0.15);
        o.frequency.linearRampToValueAtTime(600, now+0.3);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.4);
        const oP=audioCtx.createOscillator(), gP=audioCtx.createGain();
        oP.type='sine'; gP.gain.value=0.05; oP.connect(gP); gP.connect(audioCtx.destination);
        oP.frequency.setValueAtTime(1200, now);
        oP.frequency.linearRampToValueAtTime(2000, now+0.15);
        oP.frequency.linearRampToValueAtTime(900, now+0.3);
        o.start(now); o.stop(now+0.4); oP.start(now); oP.stop(now+0.4); break;
      case 'spaceBossVolleyCharge':
        o.type='sawtooth';
        o.frequency.setValueAtTime(260, now);
        o.frequency.exponentialRampToValueAtTime(120, now+0.5);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.5);
        o.start(now); o.stop(now+0.5); break;
      case 'spaceBossVolleyShot':
        o.type='triangle';
        o.frequency.setValueAtTime(1400, now);
        o.frequency.exponentialRampToValueAtTime(520, now+0.18);
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.18);
        o.start(now); o.stop(now+0.2); break;
      case 'spaceBossLaserCharge':
        o.type='sine';
        o.frequency.setValueAtTime(320, now);
        o.frequency.linearRampToValueAtTime(960, now+0.8);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        const oCharge=audioCtx.createOscillator(), gCharge=audioCtx.createGain();
        oCharge.type='sawtooth'; gCharge.gain.value=0.02; oCharge.connect(gCharge); gCharge.connect(audioCtx.destination);
        oCharge.frequency.setValueAtTime(180, now);
        oCharge.frequency.linearRampToValueAtTime(540, now+0.8);
        o.start(now); o.stop(now+0.8); oCharge.start(now); oCharge.stop(now+0.8); break;
      case 'spaceBossLaserSweep':
        o.type='square';
        o.frequency.setValueAtTime(900, now);
        g.gain.setValueAtTime(0.07, now);
        g.gain.linearRampToValueAtTime(0.02, now+0.5);
        const oSweep=audioCtx.createOscillator(), gSweep=audioCtx.createGain();
        oSweep.type='triangle'; gSweep.gain.value=0.03; oSweep.connect(gSweep); gSweep.connect(audioCtx.destination);
        oSweep.frequency.setValueAtTime(400, now);
        oSweep.frequency.exponentialRampToValueAtTime(1200, now+0.5);
        o.start(now); o.stop(now+0.5); oSweep.start(now); oSweep.stop(now+0.5); break;
      case 'annihil':
        o.type='sawtooth';
        o.frequency.setValueAtTime(300, now);
        o.frequency.exponentialRampToValueAtTime(60, now+0.3);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.3);
        o.start(now); o.stop(now+0.3); break;
      case 'steam':
        o.type='sawtooth';
        o.frequency.setValueAtTime(800, now);
        o.frequency.exponentialRampToValueAtTime(200, now+0.4);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.4);
        o.start(now); o.stop(now+0.4); break;
      case 'gatlingShoot':
        o.type='square';
        o.frequency.setValueAtTime(900, now);
        g.gain.setValueAtTime(0.04, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.07);
        o.start(now); o.stop(now+0.07); break;
      case 'gatlingHit':
        o.type='sawtooth';
        o.frequency.setValueAtTime(300, now);
        o.frequency.exponentialRampToValueAtTime(80, now+0.15);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.15);
        o.start(now); o.stop(now+0.15); break;
      case 'plasma':
        o.type='square';
        o.frequency.setValueAtTime(1200, now);
        o.frequency.exponentialRampToValueAtTime(300, now+0.2);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.2);
        o.start(now); o.stop(now+0.2); break;
      case 'plasmaHit':
        o.type='sawtooth';
        o.frequency.setValueAtTime(600, now);
        o.frequency.exponentialRampToValueAtTime(120, now+0.2);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.2);
        o.start(now); o.stop(now+0.2); break;
      case 'dragonAnnihilation':{
        o.type='sawtooth';
        o.frequency.setValueAtTime(160, now);
        o.frequency.exponentialRampToValueAtTime(30, now+1.2);
        g.gain.setValueAtTime(0.12, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+1.2);
        const sub=audioCtx.createOscillator();
        const subGain=audioCtx.createGain();
        sub.type='sine';
        sub.frequency.setValueAtTime(48, now);
        sub.frequency.exponentialRampToValueAtTime(18, now+1.4);
        subGain.gain.setValueAtTime(0.16, now);
        subGain.gain.exponentialRampToValueAtTime(0.001, now+1.4);
        sub.connect(subGain); subGain.connect(audioCtx.destination);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='triangle';
        shimmer.frequency.setValueAtTime(960, now);
        shimmer.frequency.exponentialRampToValueAtTime(320, now+0.9);
        shimmerGain.gain.setValueAtTime(0.03, now);
        shimmerGain.gain.exponentialRampToValueAtTime(0.001, now+0.9);
        shimmer.connect(shimmerGain); shimmerGain.connect(audioCtx.destination);
        const buffer=audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*1.2), audioCtx.sampleRate);
        const data=buffer.getChannelData(0);
        for(let i=0;i<data.length;i++){
          const t=i/data.length;
          data[i]=(Math.random()*2-1)*(1-Math.pow(t,0.45))*0.6;
        }
        const noise=audioCtx.createBufferSource();
        const noiseGain=audioCtx.createGain();
        noise.buffer=buffer;
        noiseGain.gain.setValueAtTime(0.18, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, now+1.1);
        noise.connect(noiseGain); noiseGain.connect(audioCtx.destination);
        o.start(now); o.stop(now+1.2);
        sub.start(now); sub.stop(now+1.4);
        shimmer.start(now+0.05); shimmer.stop(now+0.9);
        noise.start(now); noise.stop(now+1.2);
        break;
      }
      case 'fireExplosion':
        o.type='sawtooth';
        o.frequency.setValueAtTime(400, now);
        o.frequency.exponentialRampToValueAtTime(30, now+0.6);
        g.gain.setValueAtTime(0.1, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.6);
        o.start(now); o.stop(now+0.6); break;
      case 'win':
        o.type='triangle';
        g.gain.setValueAtTime(0.04, now);
        o.frequency.setValueAtTime(660, now);
        o.start(now); o.stop(now+0.2);
        const o2=audioCtx.createOscillator(), g2=audioCtx.createGain();
        o2.type='triangle'; g2.gain.value=0.04; o2.connect(g2); g2.connect(audioCtx.destination);
        o2.frequency.setValueAtTime(880, now+0.2);
        o2.start(now+0.2); o2.stop(now+0.5); break;
      case 'lose':
        o.type='sawtooth';
        o.frequency.setValueAtTime(200, now);
        o.frequency.exponentialRampToValueAtTime(60, now+0.6);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.6);
        o.start(now); o.stop(now+0.6); break;
      default:
        o.type='square';
        o.frequency.setValueAtTime(600, now);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.1);
    o.start(now); o.stop(now+0.1); break;
    }
  }

  // 專屬齒輪騎士的按鍵蒸汽音效
  document.addEventListener('click', (e) => {
    if(window.currentSkin && window.currentSkin.cssSkin === '機械．齒輪騎士' && e.target.closest('button')){
      playSFX('steam');
    }
  }, {passive:true});

  function startBGM(){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || bgmStarted) return; audioCtx.resume?.(); bgmStarted=true; applyBGMThemeForLevel();
  }
  function stopBGM(){
    clearInterval(bgmTimer);
    bgmTimer=null;
    bgmStarted=false;
    bgmNodes.forEach(n=>{try{n.disconnect?.();}catch{}});
    bgmNodes.clear();
  }

  // === 磚塊與揭示 ===
  let bricks=[]; let brickW=0, brickH=GAME_CONFIG.bricks.brickHeight; let revealRects=[];
  let brickIdCounter=0;
  function layout(){ return {rows:getDiff().rowsBase+Math.floor((level-1)%3), cols:GAME_CONFIG.bricks.cols, pad:GAME_CONFIG.bricks.padding, top:GAME_CONFIG.bricks.topOffset, h:GAME_CONFIG.bricks.brickHeight}; }

  // 取得本關顯示影像（1~10隨機BG/CG；11~20用另一張）
  function getLevelImage(levelNum){
    const idx=((levelNum-1)%10);
    const imgs = loadImagePair(idx);
    let img;
    if(levelNum<=10){
      if(imageChoice[idx]<0){ imageChoice[idx]= Math.random()<0.5 ? 0:1; }
      img = imageChoice[idx]===0? imgs.bg : imgs.cg;
    }else{
      if(imageChoice[idx]<0){ imageChoice[idx]=0; } // 保底
      img = imageChoice[idx]===0? imgs.cg : imgs.bg;
    }
    return img;
  }

  function getLevelImageKey(levelNum){
    const idx=((levelNum-1)%10);
    if(levelNum<=10){
      if(imageChoice[idx]<0){ imageChoice[idx]= Math.random()<0.5 ? 0:1; }
      return imageChoice[idx]===0 ? `bg${idx+1}` : `cg${idx+1}`;
    }else{
      if(imageChoice[idx]<0){ imageChoice[idx]=0; }
      return imageChoice[idx]===0 ? `cg${idx+1}` : `bg${idx+1}`;
    }
  }

  // 特殊磚模板
  function addBrick(list, x,y,w,h, opts={}){
    const id = (opts.id!=null)?opts.id:brickIdCounter++;
    list.push(Object.assign({id,x,y,w,h,hp:opts.unbreakable?Infinity:(opts.hp||1), colorIdx:0, explosive:false, unbreakable:false, strong:false, moving:false, vx:0, vy:0, boss:false, face:''}, opts));
  }

  
  function postAdjustAndDensify(L){
    // 將一般磚血量平滑上限為 4，並補磚至 >= 3/4 面積
    const rows=L.rows, cols=L.cols, pad=L.pad;
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // 佔用網格
    const occ = Array.from({length:rows}, ()=> Array(cols).fill(false));
    function markRect(x,y,w,h){
      const cellW = brickW, cellH = brickH;
      const c0 = Math.max(0, Math.min(cols-1, Math.round((x - L.pad) / (cellW + L.pad)) ));
      const r0 = Math.max(0, Math.min(rows-1, Math.round((y - L.top) / (cellH + L.pad)) ));
      const cellsX = Math.max(1, Math.round((w + L.pad) / (cellW + L.pad)));
      const cellsY = Math.max(1, Math.round((h + L.pad) / (cellH + L.pad)));
      for(let rr=0; rr<cellsY; rr++){
        for(let cc=0; cc<cellsX; cc++){
          const c = Math.min(cols-1, c0 + cc);
          const r = Math.min(rows-1, r0 + rr);
          occ[r][c] = true;
        }
      }
    }
    // 先夾血量 + 標記既有佔用
    for(const b of bricks){
      if(!b.unbreakable && !b.boss){
        b.hp = clampHP(b.hp||1);
      }
      markRect(b.x,b.y,b.w,b.h);
    }
    // 計算覆蓋度
    let filled = 0;
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(occ[r][c]) filled++;
    const target = Math.ceil(rows*cols * 0.75);
    if(filled >= target) return;

    // 由中心往外補磚，維持美感
    const midC = (cols-1)/2, midR = (rows-1)/2;
    const empties = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(!occ[r][c]){
          const score = (c-midC)**2 + (r-midR)**2;
          empties.push({r,c,score});
        }
      }
    }
    

    empties.sort((a,b)=> a.score - b.score);
    const baseHP = Math.min(1 + Math.floor((level-1)/5), 3);
    let idx=0;
    while(filled < target && idx<empties.length){
      const {r,c} = empties[idx++];
      if(occ[r][c]) continue;
      let hp = baseHP + ((level>=13 && r>rows/2)?1:0);
      hp = clampHP(hp);
      const moving = (Math.random()<0.08) && (r%2===0);
      const vx = moving ? ((Math.random()<0.5?-1:1)*0.6) : 0;
      addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp, colorIdx:(r%4), moving, vx});
      occ[r][c] = true  
      filled += 1;
    }
  }

  function initBricks(){
    const L=layout();
    const totalPad=(L.cols+1)*L.pad; brickW=Math.floor((1100-totalPad)/L.cols); brickH=L.h; bricks=[]; revealRects=[]; brickIdCounter=0;
    spaceBoss=null;
    spaceBossAnchor=null;
    spaceBossPlaceholder=null;
    spaceBossBursts=[];
    spaceBossMarquee=null;
    spaceBossRevealScheduled=0;
    spaceBossDefeatedAt=0;
    spaceBossAttack=null;
    spaceBossNextAttackAt=0;
    spaceBossBullets.length=0;
    spaceBossPaddlePenalty=0;
    spaceBossPaddleRespawnAt=0;
    spaceBossDeathAnim=null;
    spaceBossSuppressLifeLossUntil=0;
    spaceBossPhase = (level===5?'awaiting':'inactive');
    reaperBoss=null;
    reaperAnchor=null;
    reaperPlaceholder=null;
    reaperBursts=[];
    reaperAfterimages=[];
    reaperMarquee=null;
    reaperRevealScheduled=0;
    reaperDefeatedAt=0;
    reaperDeathAnim=null;
    reaperTeleportSchedule=null;
    reaperTargetHighlightUntil=0;
    reaperAttackState=null;
    reaperSlashZone=null;
    reaperSlashEffects=[];
    reaperBlackHoleAttack=null;
    reaperLifeLossCooldownUntil=0;
    reaperPaddlePenalty=0;
    reaperPenaltyLastUpdate=0;
    reaperPhase = (level===10?'awaiting':'inactive');
    dragonBoss=null;
    dragonAnchor=null;
    dragonPlaceholder=null;
    dragonBursts=[];
    dragonMarquee=null;
    dragonRevealScheduled=0;
    dragonDefeatedAt=0;
    dragonDeathAnim=null;
    dragonAttackState=null;
    dragonNextAttackAt=0;
    dragonDeathRayOrbs.length=0;
    dragonDeathRayBeams.length=0;
      dragonPhase = (level===15?'awaiting':'inactive');
      // Reset Cyclops/dragon forced petrify trigger so level 15 always re-schedules it
      cyclopsForcedPetrifyAt=0;
      cyclopsForcedPetrifyFired=false;
      cyclopsFirstAttackAt=0;
    cyclopsEventStarted=false;
    cyclopsMarqueeShown=false;
    cyclopsRowBlastIndex=-1;
    cyclopsNextRowBlast=0;
    cyclopsShellBurst=false;
    cyclopsEventComplete=false;
    demonShellBrick=null;
    demonEventPhase = (level===20?'awaiting':'inactive');
    demonEventTimerStart=0;
    demonEventTriggeredAt=0;
    demonEventMarquee=null;
    demonEventWave=null;
    demonEventRows=[];
    demonEventNextRowAt=0;
    demonFallingDebris=[];
    demonEventShakeUntil=0;
    demonCore=null;
    demonEventTargets=0;
    demonEventCleared=0;
    demonPhase = (level===20?'awaiting':'inactive');
    demonBoss=null;
    demonRevealScheduled=0;
    demonAfterimages=[];
    demonDeathAnim=null;
    demonDefeatedAt=0;
    const lvlImg = getLevelImage(level);
    if (lvlImg && lvlImg.decode) { lvlImg.decode().catch(()=>{}); }
    // 依關卡設計關卡布局
    generateLevel(level, L);
    postAdjustAndDensify(L);
    // 放置菁英磚（第6關以後，最多2個）
    if(level>=6){ let placed=0; const candidates=bricks.filter(b=>!b.unbreakable && !b.boss);
      const cx=1100/2, cy=(layout().top + (layout().rows* (brickH+layout().pad) - layout().pad))/2;
      candidates.sort((a,b)=> (Math.hypot((a.x+a.w/2)-cx,(a.y+a.h/2)-cy) - Math.hypot((b.x+b.w/2)-cx,(b.y+b.h/2)-cy)) );
      for(const b of candidates){ if(placed>=2) break; b.elite=true; b.hp=Math.min(5, Math.max(3, b.hp||3)); placed++; }
    }
    // 重置 Boss 計時
    nextBossAtkA = nextBossAtkB = bossChargeUntil = cyclopsShakeUntil = 0; bossChargeColor='';
    if(level===15){
      // 進入第15關時預先排程強制石化光束。
      // 石化光束需蓄力3秒，因此預留 5 秒的進場緩衝後立即開始蓄力，
      // 讓光束在倒數結束時（約進場 5 秒）擊中舞台、觸發真身現身。
      const forcedDelay = 5000; // 進場後希望光束命中的時間
      const petrifyCharge = 3000; // 光束施放所需蓄力時間
      cyclopsForcedPetrifyAt = performance.now() + Math.max(0, forcedDelay - petrifyCharge);
    }
  }

  
  
  // === 修正：過關判定改為只看「可破壞磚」是否清空 ===
  function hasBreakables(){
    if(level===5){
      const now=performance.now();
      const breakables = bricks.some(b => !b.unbreakable && !b.treasure);
      if(breakables) return true;
      if(spaceBossPhase==='awaiting'){ startSpaceBossReveal(); return true; }
      if(spaceBossPhase==='intro' || spaceBossPhase==='active' || spaceBossPhase==='dying') return true;
      if(spaceBossPhase==='defeated' && spaceBossDefeatedAt && now < spaceBossDefeatedAt + 3000){
        return true;
      }
      return false;
    }
    if(level===10){
      const now=performance.now();
      const breakables = bricks.some(b => !b.unbreakable && !b.placeholderBoss && !b.treasure);
      if(breakables) return true;
      if(reaperPhase==='awaiting'){ startReaperReveal(); return true; }
      if(reaperPhase==='intro' || reaperPhase==='active' || reaperPhase==='dying') return true;
      if(reaperPhase==='defeated' && reaperDefeatedAt && now < reaperDefeatedAt + 3000){
        return true;
      }
      return false;
    }
    if(level===15){
      const now=performance.now();
      const hasBreakable = bricks.some(b => !b.unbreakable && !b.treasure && !b.placeholderBoss);
      if(hasBreakable) return true;
      if(dragonPhase==='awaiting'){
        if(dragonPlaceholder){ startDragonReveal(); return true; }
        const hasBossShell = bricks.some(b=>b.boss);
        if(hasBossShell) return true;
      }
      if(dragonPhase==='intro' || dragonPhase==='active' || dragonPhase==='dying') return true;
      if(dragonPhase==='defeated' && dragonDefeatedAt && now < dragonDefeatedAt + 3000){
        return true;
      }
      return false;
    }
    if(level===20){
      const now=performance.now();
      const remaining = bricks.some(b => !b.unbreakable && !b.demonShell);
      if(remaining) return true;
      if(demonPhase==='intro' || demonPhase==='event' || demonPhase==='active' || demonPhase==='dying') return true;
      if(demonPhase==='defeated' && demonDefeatedAt && now < demonDefeatedAt + 3000) return true;
      if(demonEventPhase && demonEventPhase!=='inactive' && demonEventPhase!=='complete') return true;
      return false;
    }
    return bricks.some(b => !b.unbreakable);
  }

  // === 第5關太空戰艦 Boss ===
  function startSpaceBossReveal(){
    if(spaceBossPhase!=='awaiting') return;
    const now=performance.now();
    spaceBossPhase='intro';
    let anchor=spaceBossAnchor;
    if(spaceBossPlaceholder){
      anchor={x:spaceBossPlaceholder.x, y:spaceBossPlaceholder.y, w:spaceBossPlaceholder.w, h:spaceBossPlaceholder.h};
      const cx=anchor.x+anchor.w/2;
      const cy=anchor.y+anchor.h/2;
      spawnParticles(cx,cy,'#fff5d6',120,3.2,5.0,5.5);
      spawnParticles(cx,cy,'#8ab6ff',90,2.6,4.2,4.6);
      spawnParticles(cx,cy,'#ff9fde',70,2.3,3.8,4.2);
      spaceBossBursts.push({type:'ring',x:cx,y:cy,r0:24,r1:420,width:18,t0:now,life:1400,color:'255,220,180'});
      spaceBossBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:240,t0:now,life:1100,color:'140,200,255'});
      spaceBossBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:160,t0:now,life:900,color:'255,180,220'});
      const idx=bricks.indexOf(spaceBossPlaceholder);
      if(idx>=0) bricks.splice(idx,1);
      spaceBossPlaceholder=null;
      spaceBossAnchor=anchor;
    }
    if(!spaceBossAnchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      const anchorW=brickW*2+L.pad;
      const anchorH=brickH*2+L.pad;
      const anchorX=L.pad + bx*(brickW+L.pad);
      spaceBossAnchor={x:anchorX,y:L.top,w:anchorW,h:anchorH};
    }
    spaceBossRevealScheduled = now + 900;
    screenShake=Math.max(screenShake,8);
    playSFX('fireExplosion');
  }

  function activateSpaceBoss(){
    if(spaceBossPhase!=='intro' || spaceBoss) return;
    let anchor=spaceBossAnchor;
    if(!anchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      anchor={x:L.pad + bx*(brickW+L.pad), y:L.top, w:brickW*2+L.pad, h:brickH*2+L.pad};
      spaceBossAnchor=anchor;
    }
    const cx=anchor.x+anchor.w/2;
    const baseY=anchor.y+anchor.h+80;
    const now=performance.now();
    spaceBoss={
      x:cx,
      y:baseY,
      baseY,
      w:220,
      h:120,
      vx:(Math.random()<0.5?-1:1)*2.6,
      hp:SPACE_BOSS_MAX_HP,
      maxHp:SPACE_BOSS_MAX_HP,
      hitCooldownUntil:0,
      hitFlashUntil:0,
      spawnAt:now,
      guns:[
        {offsetX:-70,offsetY:32,phase:0,angle:Math.PI/2,spin:0},
        {offsetX:0,offsetY:42,phase:1.2,angle:Math.PI/2,spin:0},
        {offsetX:70,offsetY:32,phase:2.3,angle:Math.PI/2,spin:0}
      ],
      lasers:[
        {offsetX:-92,offsetY:-4,phase:0.6,angle:Math.PI},
        {offsetX:92,offsetY:-4,phase:1.8,angle:Math.PI}
      ],
      thrusterPhase:0
    };
    spaceBossPhase='active';
    spaceBossBursts.push({type:'halo',x:cx,y:baseY,r0:40,r1:260,t0:now,life:1600,color:'130,200,255'});
    spaceBossAttack=null;
    spaceBossNextAttackAt=now + SPACE_BOSS_ATTACK_INTERVAL;
    spaceBossBullets.length=0;
    spaceBossPaddlePenalty=0;
    spaceBossPaddleRespawnAt=0;
    spaceBossDeathAnim=null;
    spaceBossMarquee={text:'有趣！ 讓你見識我的真面目吧!', start:now, fadeStart:now+2600, end:now+3200, style:'alert'};
    scheduleNextTreasureBrick(now);
  }

  function damageSpaceBoss(amount=1, source='generic', impact){
    if(spaceBossPhase!=='active' || !spaceBoss) return false;
    const now=performance.now();
    if(spaceBoss.hitCooldownUntil && now<spaceBoss.hitCooldownUntil) return false;
    const dmg = amount>0 ? 1 : 0;
    if(!dmg) return false;
    spaceBoss.hitCooldownUntil = now + 140;
    spaceBoss.hp = Math.max(0, spaceBoss.hp - dmg);
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    spaceBoss.hitFlashUntil = now + 220;
    const jitterX=(Math.random()-0.5)*spaceBoss.w*0.4;
    const jitterY=(Math.random()-0.5)*spaceBoss.h*0.3;
    const colorMap={
      laser:'255,210,240',
      missile:'255,215,180',
      gatling:'255,220,180',
      plasma:'190,240,255',
      blackhole:'200,220,255',
      phoenix:'255,210,200',
      sword:'255,240,220'
    };
    const burstColor=colorMap[source]||'160,220,255';
    spaceBossBursts.push({type:'spark',x:spaceBoss.x+jitterX,y:spaceBoss.y+jitterY,r0:0,r1:140,t0:now,life:600,color:burstColor});
    if(impact && impact.x!=null && impact.y!=null){
      spawnParticles(impact.x, impact.y, '#b8d6ff', 22, 1.6, 2.6, 2.4);
    }
    spawnParticles(spaceBoss.x+jitterX, spaceBoss.y+jitterY, '#8fbaff', 18, 1.5, 2.6, 2.3);
    screenShake=Math.max(screenShake,5);
    const toneMap={laser:820, missile:680, gatling:720, plasma:760, blackhole:640, phoenix:700, ball:780, sword:840};
    const freq=toneMap[source]||760;
    beep(freq,0.04,0.04);
    if(spaceBoss.hp<=0){ defeatSpaceBoss(); }
    return true;
  }

  function defeatSpaceBoss(){
    if(spaceBossPhase!=='active' || !spaceBoss) return;
    const now=performance.now();
    const sb=spaceBoss;
    const fake={x:sb.x-sb.w/2,y:sb.y-sb.h/2,w:sb.w,h:sb.h};
    bossKillEffect(fake,{dropNineCat:'always'});
    addScore(BOSS_DEFEAT_SCORE.space);
    stats.bossKills++;
    updateHUD();
    spawnParticles(sb.x, sb.y, '#ffe9b2', 160, 3.2, 5.6, 6.0);
    spaceBossBursts.push({type:'ring',x:sb.x,y:sb.y,r0:40,r1:520,width:24,t0:now,life:2000,color:'255,200,150'});
    spaceBossBursts.push({type:'flare',x:sb.x,y:sb.y,r0:0,r1:320,t0:now,life:1600,color:'255,235,200'});
    spaceBossBursts.push({type:'spark',x:sb.x,y:sb.y,r0:0,r1:200,t0:now,life:1200,color:'200,240,255'});
    screenShake=Math.max(screenShake,12);
    playSFX('fireExplosion');
    spaceBossPhase='dying';
    spaceBossAttack=null;
    spaceBossBullets.length=0;
    spaceBossNextAttackAt=0;
    spaceBossMarquee={text:'成功擊殺Boss: 太空戰艦!', start:now, fadeStart:now+5000, end:now+5000, style:'victory'};
    nextTreasureBrickAt=0;
    spaceBossDeathAnim={
      start:now,
      startY:sb.y,
      dropDistance:220,
      fallDuration:3000,
      explosionAt:now+3000,
      bigExplosionEnd:now+5000,
      vanishAt:now+5000,
      finishAt:now+8000,
      lastBurst:now,
      bigBang:false,
      dropSpawned:false
    };
  }

  function updateSpaceBoss(){
    if(level!==5) return;
    const now=performance.now();
    if(spaceBossPhase==='intro' && !spaceBoss && spaceBossRevealScheduled && now>=spaceBossRevealScheduled){ activateSpaceBoss(); }
    if(spaceBossPhase==='active' && spaceBoss){
      const sb=spaceBoss;
      sb.x += sb.vx;
      const margin=110;
      if(sb.x - sb.w/2 < margin){ sb.x = margin + sb.w/2; sb.vx = Math.abs(sb.vx); }
      if(sb.x + sb.w/2 > 1100 - margin){ sb.x = 1100 - margin - sb.w/2; sb.vx = -Math.abs(sb.vx); }
      sb.y = sb.baseY + Math.sin((now - sb.spawnAt)/650)*28;
      sb.thrusterPhase = (sb.thrusterPhase||0) + 0.08;
      const atkMode = spaceBossAttack?.mode;
      const atkState = spaceBossAttack?.state;
      const pr = paddleRect();
      for(const gun of sb.guns){
        gun.spin=(gun.spin||0)+0.28;
        if(atkMode===1 && atkState==='firing'){
          const gx = sb.x + gun.offsetX;
          const gy = sb.y + gun.offsetY;
          const tx = pr.x + pr.w/2;
          const ty = pr.y + pr.h/2;
          const dir = Math.atan2(ty-gy, tx-gx);
          gun.angle = dir + Math.PI/2;
        }else{
          gun.angle = Math.PI/2 + Math.sin((now/520)+gun.phase)*0.45;
        }
      }
      for(const laser of sb.lasers){
        if(atkMode===2 && atkState==='sweeping' && spaceBossAttack?.currentTarget){
          const lx = sb.x + laser.offsetX;
          const ly = sb.y + laser.offsetY;
          const target = spaceBossAttack.currentTarget;
          const dir = Math.atan2(target.y-ly, target.x-lx);
          laser.angle = dir + Math.PI/2;
        }else{
          laser.angle = Math.PI + Math.sin((now/900)+laser.phase)*0.22;
        }
      }
      if(sb.hitFlashUntil && now>sb.hitFlashUntil){ sb.hitFlashUntil=0; }
    }
    if(spaceBossPhase==='dying' && spaceBoss){
      const anim=spaceBossDeathAnim;
      if(anim){
        const fallProg=Math.min(1, Math.max(0,(now-anim.start)/anim.fallDuration));
        spaceBoss.y = anim.startY + fallProg*anim.dropDistance;
        const burstInterval = anim.bigBang ? 80 : 110;
        if(now-anim.lastBurst>burstInterval){
          anim.lastBurst=now;
          const jitterX=(Math.random()-0.5)*spaceBoss.w*0.9;
          const jitterY=(Math.random()-0.3)*spaceBoss.h*0.9;
          spawnParticles(spaceBoss.x+jitterX, spaceBoss.y+jitterY, '#ffe6b8', 34, 2.6, 3.8, 3.6);
          spaceBossBursts.push({type:'spark',x:spaceBoss.x+jitterX,y:spaceBoss.y+jitterY,r0:0,r1:260,t0:now,life:850,color:'255,180,120'});
          screenShake=Math.max(screenShake,6);
        }
        if(!anim.bigBang && now>=anim.explosionAt){
          anim.bigBang=true;
          anim.bigBangStart=now;
          screenShake=Math.max(screenShake,22);
          spawnParticles(spaceBoss.x,spaceBoss.y,'#fff2d6',260,3.8,5.6,6.4);
          spawnParticles(spaceBoss.x,spaceBoss.y,'#ffddb8',160,3.4,5.0,5.2);
          spaceBossBursts.push({type:'ring',x:spaceBoss.x,y:spaceBoss.y,r0:90,r1:660,width:36,t0:now,life:2200,color:'255,220,190'});
          spaceBossBursts.push({type:'flare',x:spaceBoss.x,y:spaceBoss.y,r0:0,r1:460,t0:now,life:2400,color:'255,244,220'});
          spaceBossBursts.push({type:'halo',x:spaceBoss.x,y:spaceBoss.y,r0:120,r1:720,t0:now,life:2600,color:'255,200,150'});
          playSFX('explosion');
          if(!anim.dropSpawned){
            spawnPower(spaceBoss.x-12, spaceBoss.y, {forceType:'NINE'});
            anim.dropSpawned=true;
          }
        }
        if(anim.bigBang && anim.bigBangStart && now-anim.bigBangStart<anim.bigExplosionEnd-anim.explosionAt){
          const theta=Math.random()*Math.PI*2;
          const dist=spaceBoss.w*0.4+Math.random()*spaceBoss.w*0.3;
          const px=spaceBoss.x+Math.cos(theta)*dist;
          const py=spaceBoss.y+Math.sin(theta)*dist;
          spaceBossBursts.push({type:'spark',x:px,y:py,r0:0,r1:320,t0:now,life:900,color:'255,210,180'});
        }
        if(now>=anim.vanishAt){
          spaceBossPhase='defeated';
          spaceBossDefeatedAt=now;
          spaceBoss=null;
          spaceBossDeathAnim=null;
        }
      }
    }
    for(let i=spaceBossBursts.length-1;i>=0;i--){ const fx=spaceBossBursts[i]; const life=fx.life||1000; if(now>fx.t0+life){ spaceBossBursts.splice(i,1); } }
    updateSpaceBossAttack(now);
    updateSpaceBossBullets(now);
    updateSpaceBossPaddleRespawn(now);
  }

  function startSpaceBossAttack(mode, now){
    if(!spaceBoss) return;
    const pr=paddleRect();
    spaceBossNextAttackAt=0;
    if(mode===1){
      spaceBossAttack={
        mode:1,
        state:'countdown',
        start:now,
        countdownEnd:now+3000,
        fireStart:now+3000,
        fireEnd:now+3000+SPACE_BOSS_GUN_FIRE_DURATION,
        lastShot:0
      };
      spaceBossMarquee={text:'危險！ 太空戰艦即將進行火力壓制!', start:now, fadeStart:now+3000, end:now+3200, style:'alert', countdownDuration:3000};
      playSFX('spaceBossVolleyCharge');
    }else{
      const baseTarget={x:pr.x+pr.w/2, y:pr.y+pr.h/2};
      const movement=spaceBossLastPaddleCenter-spaceBossPrevPaddleCenter;
      let dir=0;
      if(Math.abs(movement)>1){ dir = movement>0?1:-1; }
      spaceBossAttack={
        mode:2,
        state:'countdown',
        start:now,
        countdownEnd:now+3000,
        sweepStart:now+3000,
        sweepEnd:now+3000+SPACE_BOSS_LASER_SWEEP_DURATION,
        baseTarget,
        sweepDir:dir,
        maxSweep:1100/3,
        currentTarget:{...baseTarget},
        hitApplied:false
      };
      spaceBossMarquee={text:'危險！ 太空戰艦即將使出致命雷射!', start:now, fadeStart:now+3000, end:now+3200, style:'alert', countdownDuration:3000};
      playSFX('spaceBossLaserCharge');
    }
  }

  function updateSpaceBossAttack(now){
    if(level!==5) return;
    if(spaceBossPhase!=='active' || !spaceBoss){
      spaceBossAttack=null;
      return;
    }
    if(!spaceBossAttack){
      if(spaceBossNextAttackAt && now>=spaceBossNextAttackAt){
        const mode = Math.random()<0.5 ? 1 : 2;
        startSpaceBossAttack(mode, now);
      }
      return;
    }
    const atk=spaceBossAttack;
    if(atk.state==='countdown'){
      if(now>=atk.countdownEnd){
        if(atk.mode===1){
          atk.state='firing';
          atk.lastShot=0;
        }else{
          atk.state='sweeping';
          atk.currentTarget={...atk.baseTarget};
          playSFX('spaceBossLaserSweep');
        }
        spaceBossMarquee=null;
      }
      return;
    }
    if(atk.mode===1){
      if(now>=atk.fireEnd){
        spaceBossAttack=null;
        spaceBossNextAttackAt=now+SPACE_BOSS_ATTACK_INTERVAL;
        return;
      }
      if(now-atk.lastShot>=SPACE_BOSS_GUN_FIRE_RATE){
        const pr=paddleRect();
        let tx=pr.x+pr.w/2;
        let ty=pr.y+pr.h/2;
        if(pr.w<=0 || pr.h<=0){
          tx = spaceBossLastPaddleCenter || 1100/2;
          ty = 700-50;
        }
        for(const gun of spaceBoss.guns){
          const originX=spaceBoss.x+gun.offsetX;
          const originY=spaceBoss.y+gun.offsetY;
          const ang=Math.atan2(ty-originY, tx-originX);
          const speed=11;
          spaceBossBullets.push({x:originX, y:originY, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, born:now});
          spaceBossBursts.push({type:'muzzle',x:originX,y:originY,r0:6,r1:60,t0:now,life:220,color:'255,210,120'});
        }
        atk.lastShot=now;
        playSFX('spaceBossVolleyShot');
      }
    }else if(atk.mode===2){
      const sweepProg = Math.min(1, Math.max(0,(now-atk.sweepStart)/SPACE_BOSS_LASER_SWEEP_DURATION));
      const offset = atk.sweepDir * atk.maxSweep * sweepProg;
      atk.currentTarget = {x: atk.baseTarget.x + offset, y: atk.baseTarget.y};
      if(!atk.hitApplied){
        const pr=paddleRect();
        if(pr.w>0 && pr.h>0){
          const mounts=spaceBoss.lasers || [];
          for(const laser of mounts){
            const originX = spaceBoss.x + laser.offsetX;
            const originY = spaceBoss.y + laser.offsetY;
            if(segmentIntersectsRect(originX, originY, atk.currentTarget.x, atk.currentTarget.y, pr)){
              atk.hitApplied=true;
              spaceBossLaserStrike();
              break;
            }
          }
        }
      }
      if(now>=atk.sweepEnd){
        spaceBossAttack=null;
        spaceBossNextAttackAt=now+SPACE_BOSS_ATTACK_INTERVAL;
      }
    }
  }

  function updateSpaceBossBullets(now){
    for(let i=spaceBossBullets.length-1;i>=0;i--){
      const b=spaceBossBullets[i];
      b.x+=b.vx;
      b.y+=b.vy;
      if(b.x<-40||b.x>1140||b.y<-40||b.y>760){ spaceBossBullets.splice(i,1); continue; }
      let removed=false;
      for(let j=bricks.length-1;j>=0;j--){
        const bk=bricks[j];
        if(!bk?.fallingTreasure) continue;
        if(b.x>=bk.x && b.x<=bk.x+bk.w && b.y>=bk.y && b.y<=bk.y+bk.h){
          spawnParticles(b.x, b.y, '#ffe08a', 14, 2.0, 3.0, 2.8);
          damageBrick(j,1,'laser');
          spaceBossBullets.splice(i,1);
          removed=true;
          break;
        }
      }
      if(removed) continue;
      if(now<paddleGoneUntil) continue;
      const pr=paddleRect();
      if(b.x>=pr.x && b.x<=pr.x+pr.w && b.y>=pr.y && b.y<=pr.y+pr.h){
        spaceBossBullets.splice(i,1);
        spaceBossBulletHit(pr);
      }
    }
  }

  function spaceBossBulletHit(pr){
    const centerX=pr.x+pr.w/2;
    const centerY=pr.y+pr.h/2;
    spawnParticles(centerX, centerY, '#ffdf9a', 26, 2.4, 3.6, 3.2);
    screenShake=Math.max(screenShake,4);
    const desired=desiredPaddleWidth();
    const effective=Math.max(SPACE_BOSS_PADDLE_MIN_WIDTH, desired - spaceBossPaddlePenalty);
    if(effective-SPACE_BOSS_PADDLE_MIN_WIDTH>0.5){
      spaceBossPaddlePenalty=Math.min(desired - SPACE_BOSS_PADDLE_MIN_WIDTH, spaceBossPaddlePenalty + 10);
      computePaddleWidth();
      return;
    }
    const now=performance.now();
    if(now<paddleGoneUntil) return;
    spaceBossPaddlePenalty=0;
    computePaddleWidth();
    paddleGoneUntil=now+3000;
    spaceBossPaddleRespawnAt=paddleGoneUntil;
    spaceBossSuppressLifeLossUntil = spaceBossPaddleRespawnAt + 200;
    spawnParticles(centerX, centerY, '#ffb347', 80, 3.0, 4.4, 4.2);
    spaceBossBursts.push({type:'ring',x:centerX,y:centerY,r0:20,r1:220,width:18,t0:now,life:600,color:'255,180,90'});
    screenShake=Math.max(screenShake,10);
    lives--; updateHUD();
    if(lives<=0){ running=false; paused=true; showGameOver(); return; }
    balls.length=0;
  }

  function updateSpaceBossPaddleRespawn(now){
    if(spaceBossPaddleRespawnAt && now>=spaceBossPaddleRespawnAt){
      spaceBossPaddleRespawnAt=0;
      if(lives>0 && !paused){ resetBalls(false); startCountdown(); }
      spaceBossSuppressLifeLossUntil=0;
    }
  }

  function spaceBossLaserStrike(){
    if(paddleGoneUntil>performance.now()) return;
    lives=Math.max(0, lives-1);
    updateHUD();
    screenShake=Math.max(screenShake,12);
    const pr=paddleRect();
    spawnParticles(pr.x+pr.w/2, pr.y+pr.h/2, '#ff6a88', 60, 3.0, 4.6, 4.0);
    if(lives<=0){ running=false; paused=true; showGameOver(); return; }
    balls.length=0;
    paddleGoneUntil=performance.now()+1500;
    spaceBossPaddleRespawnAt=paddleGoneUntil+1500;
    spaceBossSuppressLifeLossUntil = spaceBossPaddleRespawnAt + 200;
  }

  function segmentIntersectsRect(x1,y1,x2,y2, rect){
    const rx=rect.x, ry=rect.y, rw=rect.w, rh=rect.h;
    const left=rx, right=rx+rw, top=ry, bottom=ry+rh;
    if(x1>=left && x1<=right && y1>=top && y1<=bottom) return true;
    if(x2>=left && x2<=right && y2>=top && y2<=bottom) return true;
    if(segmentsIntersect(x1,y1,x2,y2,left,top,right,top)) return true;
    if(segmentsIntersect(x1,y1,x2,y2,right,top,right,bottom)) return true;
    if(segmentsIntersect(x1,y1,x2,y2,right,bottom,left,bottom)) return true;
    if(segmentsIntersect(x1,y1,x2,y2,left,bottom,left,top)) return true;
    return false;
  }

  function segmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4){
    const denom=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
    if(Math.abs(denom)<1e-6) return false;
    const pre=(x1*y2 - y1*x2);
    const post=(x3*y4 - y3*x4);
    const x=(pre*(x3-x4)-(x1-x2)*post)/denom;
    const y=(pre*(y3-y4)-(y1-y2)*post)/denom;
    if(x<Math.min(x1,x2)-1e-6 || x>Math.max(x1,x2)+1e-6) return false;
    if(x<Math.min(x3,x4)-1e-6 || x>Math.max(x3,x4)+1e-6) return false;
    if(y<Math.min(y1,y2)-1e-6 || y>Math.max(y1,y2)+1e-6) return false;
    if(y<Math.min(y3,y4)-1e-6 || y>Math.max(y3,y4)+1e-6) return false;
    return true;
  }

  function drawSpaceBossLayer(){
    if(spaceBossPhase==='inactive' && !spaceBossBursts.length) return;
    const now=performance.now();
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    for(const fx of spaceBossBursts){
      const life=fx.life||1000;
      const prog=Math.max(0, Math.min(1, (now-fx.t0)/life));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      if(fx.type==='ring'){
        const rad=(fx.r0||0)+((fx.r1||200)-(fx.r0||0))*easeOut(prog);
        const alpha=1-prog;
        ctx.strokeStyle=`rgba(${fx.color||'255,255,255'},${0.55*alpha})`;
        ctx.lineWidth=(fx.width||14)*((scaleX+scaleY)/2)*(1-prog*0.7);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2), 0, Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='flare'){
        const rad=(fx.r1||200)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(10, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0, `rgba(${fx.color||'200,220,255'},${0.35*(1-prog)})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='spark'){
        const rad=(fx.r1||80)*prog*((scaleX+scaleY)/2);
        ctx.strokeStyle=`rgba(${fx.color||'160,220,255'},${0.7*(1-prog)})`;
        ctx.lineWidth=2*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.moveTo(fx.x*scaleX-rad, fx.y*scaleY);
        ctx.lineTo(fx.x*scaleX+rad, fx.y*scaleY);
        ctx.moveTo(fx.x*scaleX, fx.y*scaleY-rad);
        ctx.lineTo(fx.x*scaleX, fx.y*scaleY+rad);
        ctx.stroke();
      }else if(fx.type==='halo'){
        const rad=(fx.r0||30)+((fx.r1||220)-(fx.r0||30))*prog;
        ctx.strokeStyle=`rgba(${fx.color||'140,200,255'},${0.25*(1-prog)})`;
        ctx.lineWidth=8*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='muzzle'){
        const rad=(fx.r0||6)+((fx.r1||60)-(fx.r0||6))*prog;
        const alpha=1-prog;
        ctx.fillStyle=`rgba(${fx.color||'255,200,120'},${0.6*alpha})`;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2), 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }
    if(spaceBoss && (spaceBossPhase==='active' || spaceBossPhase==='intro' || spaceBossPhase==='dying')){
      drawSpaceBossShip(spaceBoss, now);
      drawSpaceBossAttacks(now);
    }else if(spaceBossPhase==='intro' && spaceBossAnchor){
      const cx=(spaceBossAnchor.x+spaceBossAnchor.w/2)*scaleX;
      const cy=(spaceBossAnchor.y+spaceBossAnchor.h+60)*scaleY;
      const rad=Math.max(spaceBossAnchor.w, spaceBossAnchor.h)*1.2*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      g.addColorStop(0,'rgba(140,200,255,0.18)');
      g.addColorStop(1,'rgba(140,200,255,0)');
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }else if(spaceBossPhase==='active' && !spaceBoss && spaceBossAttack){
      drawSpaceBossAttacks(now);
    }
  }

  function drawSpaceBossAttacks(now){
    ctx.save();
    for(const b of spaceBossBullets){
      const r=4*((scaleX+scaleY)/2);
      const grad=ctx.createRadialGradient(b.x*scaleX,b.y*scaleY,0,b.x*scaleX,b.y*scaleY,r);
      grad.addColorStop(0,'rgba(255,255,255,0.95)');
      grad.addColorStop(0.6,'rgba(255,200,140,0.8)');
      grad.addColorStop(1,'rgba(255,120,60,0)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(b.x*scaleX,b.y*scaleY,r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    if(spaceBossAttack && spaceBossAttack.mode===2 && spaceBossAttack.state==='sweeping' && spaceBoss){
      const target=spaceBossAttack.currentTarget;
      const mounts=spaceBoss.lasers||[];
      for(const laser of mounts){
        const ox=(spaceBoss.x+laser.offsetX);
        const oy=(spaceBoss.y+laser.offsetY);
        drawSpaceBossLaserBeam(ox, oy, target.x, target.y, now);
      }
    }
  }

  function drawSpaceBossLaserBeam(x1,y1,x2,y2, now){
    const sx1=x1*scaleX, sy1=y1*scaleY, sx2=x2*scaleX, sy2=y2*scaleY;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const pulse=0.7+0.3*Math.sin(now/60);
    ctx.strokeStyle=`rgba(255,90,110,${0.35*pulse})`;
    ctx.lineWidth=10;
    ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    const grad=ctx.createLinearGradient(sx1,sy1,sx2,sy2);
    grad.addColorStop(0,'rgba(255,200,200,0.4)');
    grad.addColorStop(1,'rgba(255,80,120,0.9)');
    ctx.strokeStyle=grad;
    ctx.lineWidth=5;
    ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    ctx.restore();
  }

  function drawSpaceBossShip(sb, now){
    const s=(scaleX+scaleY)/2;
    ctx.save();
    ctx.translate(sb.x*scaleX, sb.y*scaleY);
    const bodyW=sb.w*scaleX;
    const bodyH=sb.h*scaleY;
    const grad=ctx.createLinearGradient(-bodyW*0.5, -bodyH*0.6, bodyW*0.5, bodyH*0.6);
    grad.addColorStop(0,'rgba(130,210,255,0.95)');
    grad.addColorStop(0.45,'rgba(90,110,220,0.95)');
    grad.addColorStop(1,'rgba(24,32,82,0.98)');
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.45, -bodyH*0.45);
    ctx.quadraticCurveTo(0, -bodyH*0.75, bodyW*0.45, -bodyH*0.45);
    ctx.quadraticCurveTo(bodyW*0.62, 0, bodyW*0.45, bodyH*0.5);
    ctx.quadraticCurveTo(0, bodyH*0.8, -bodyW*0.45, bodyH*0.5);
    ctx.quadraticCurveTo(-bodyW*0.62, 0, -bodyW*0.45, -bodyH*0.45);
    ctx.closePath();
    ctx.fillStyle=grad;
    ctx.shadowColor='rgba(90,150,255,'+(0.35+(sb.hitFlashUntil && now<sb.hitFlashUntil?0.45:0))+')';
    ctx.shadowBlur=32*s;
    ctx.fill();
    ctx.shadowBlur=0;
    ctx.strokeStyle='rgba(220,240,255,0.45)';
    ctx.lineWidth=4*s;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-bodyW*0.6, -bodyH*0.05);
    ctx.quadraticCurveTo(-bodyW*0.9, bodyH*0.05, -bodyW*0.5, bodyH*0.55);
    ctx.lineTo(-bodyW*0.35, bodyH*0.3);
    ctx.closePath();
    ctx.fillStyle='rgba(40,60,120,0.85)';
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(bodyW*0.6, -bodyH*0.05);
    ctx.quadraticCurveTo(bodyW*0.9, bodyH*0.05, bodyW*0.5, bodyH*0.55);
    ctx.lineTo(bodyW*0.35, bodyH*0.3);
    ctx.closePath();
    ctx.fill();

    const cockpitGrad=ctx.createRadialGradient(0,-bodyH*0.18,0,0,-bodyH*0.18,bodyW*0.28);
    cockpitGrad.addColorStop(0,'rgba(255,255,255,0.9)');
    cockpitGrad.addColorStop(1,'rgba(90,130,220,0.45)');
    ctx.beginPath();
    ctx.ellipse(0, -bodyH*0.1, bodyW*0.28, bodyH*0.24, 0, 0, Math.PI*2);
    ctx.fillStyle=cockpitGrad;
    ctx.fill();

    const thrusters=[{x:-bodyW*0.25,y:bodyH*0.55},{x:bodyW*0.25,y:bodyH*0.55}];
    const thrusterPhase=sb.thrusterPhase||0;
    for(let i=0;i<thrusters.length;i++){
      const t=thrusters[i];
      const radius=(28+6*Math.sin(thrusterPhase*4+i*Math.PI))*s;
      const tg=ctx.createRadialGradient(t.x,t.y,0,t.x,t.y,Math.max(radius,10));
      tg.addColorStop(0,'rgba(255,240,180,0.95)');
      tg.addColorStop(0.6,'rgba(255,180,60,0.75)');
      tg.addColorStop(1,'rgba(255,120,0,0)');
      ctx.fillStyle=tg;
      ctx.beginPath();
      ctx.arc(t.x,t.y,Math.max(radius,10),0,Math.PI*2);
      ctx.fill();
    }

    for(const gun of sb.guns){
      const gx=gun.offsetX*scaleX;
      const gy=gun.offsetY*scaleY;
      ctx.save();
      ctx.translate(gx, gy);
      ctx.rotate(gun.angle);
      const barrelLen=34*s;
      const barrelWidth=8*s;
      ctx.fillStyle='rgba(160,210,255,0.95)';
      ctx.fillRect(-barrelWidth/2, -barrelLen, barrelWidth, barrelLen);
      ctx.save();
      ctx.translate(0, -barrelLen);
      ctx.rotate(gun.spin||0);
      for(let k=0;k<3;k++){
        const ang=k*Math.PI*2/3;
        ctx.beginPath();
        ctx.fillStyle='rgba(255,255,255,0.9)';
        ctx.arc(Math.cos(ang)*4*s, Math.sin(ang)*4*s, 2.4*s, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      ctx.restore();
      ctx.save();
      ctx.translate(gx, gy);
      ctx.fillStyle='#1c2246';
      ctx.beginPath(); ctx.arc(0,0,12*s,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(120,180,255,0.8)';
      ctx.lineWidth=2*s; ctx.stroke();
      ctx.restore();
    }

    for(const laser of sb.lasers){
      const lx=laser.offsetX*scaleX;
      const ly=laser.offsetY*scaleY;
      ctx.save();
      ctx.translate(lx, ly);
      ctx.rotate(laser.angle);
      const towerW=14*s;
      const towerH=48*s;
      const lg=ctx.createLinearGradient(0,0,0,-towerH);
      lg.addColorStop(0,'rgba(90,150,255,0.9)');
      lg.addColorStop(1,'rgba(220,255,255,0.6)');
      ctx.fillStyle=lg;
      ctx.fillRect(-towerW/2, -towerH, towerW, towerH);
      ctx.beginPath();
      ctx.strokeStyle='rgba(200,240,255,0.5)';
      ctx.lineWidth=2*s;
      ctx.moveTo(0,-towerH);
      ctx.lineTo(0,-towerH-12*s);
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.translate(lx, ly);
      ctx.fillStyle='#121b36';
      ctx.beginPath(); ctx.arc(0,0,14*s,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(80,140,255,0.8)';
      ctx.lineWidth=2*s; ctx.stroke();
      ctx.restore();
    }

    ctx.restore();
  }

  function drawSpaceBossMarquee(){
    if(!spaceBossMarquee) return;
    const now=performance.now();
    const {start, fadeStart, end, text} = spaceBossMarquee;
    const style=spaceBossMarquee.style||'marquee';
    if(now>=end){ spaceBossMarquee=null; return; }
    let alpha=1;
    if(style!=='victory' && now>fadeStart){ alpha = Math.max(0, 1 - (now - fadeStart)/(end - fadeStart||1)); }
    const fallbackCanvasWidth = (typeof canvas!=='undefined' && canvas && canvas.clientWidth) ? canvas.clientWidth : 0;
    const viewW = (typeof window!=='undefined' && window.innerWidth) ? window.innerWidth : fallbackCanvasWidth;
    let deviceBoost=1;
    if(viewW && viewW<=600){ deviceBoost=1.4; }
    else if(viewW && viewW<=900){ deviceBoost=1.18; }
    const scaleAvg=(scaleX+scaleY)/2;
    const textScale=Math.max(0.6, scaleAvg*deviceBoost);
    const numberScale=Math.max(0.6, scaleAvg*(deviceBoost>1?deviceBoost+0.05:1));
    const marqueeScale=Math.max(0.6, scaleAvg*(deviceBoost>1?deviceBoost:1));
    const areaHeightBase=52;
    const areaHeight = deviceBoost>1 ? Math.round(areaHeightBase * 1.18) : areaHeightBase;
    const topBase=Math.max(12, layout().top - areaHeight - 14);
    const x=40;
    const width=1100-80;
    const radius=18;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, topBase, width, areaHeight, radius);
    if(style==='victory'){
      const grad=ctx.createLinearGradient(x*scaleX, topBase*scaleY, x*scaleX, (topBase+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(40,56,104,0.95)');
      grad.addColorStop(1,'rgba(18,28,70,0.95)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,220,180,0.8)';
      ctx.lineWidth=2.4;
      drawRoundedRect(x, topBase, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+12;
      const innerY=topBase+6;
      const innerW=width-24;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-8);
      ctx.save();
      ctx.clip();
      ctx.fillStyle='rgba(255,235,210,0.18)';
      ctx.fillRect(innerX*scaleX, innerY*scaleY, innerW*scaleX, innerH*scaleY);
      ctx.restore();
      ctx.fillStyle='#ffeede';
      const victoryFont=Math.max(24, Math.round(28*marqueeScale));
      ctx.font=`${victoryFont}px 'Playfair Display', serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,220,170,0.6)';
      ctx.shadowBlur=18*marqueeScale;
      ctx.fillText(text, (x+width/2)*scaleX, (topBase+areaHeight/2)*scaleY);
      ctx.shadowBlur=0;
      ctx.strokeStyle='rgba(255,220,170,0.45)';
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo((x+32)*scaleX, (topBase+areaHeight-10)*scaleY);
      ctx.lineTo((x+width-32)*scaleX, (topBase+areaHeight-10)*scaleY);
      ctx.stroke();
    }else{
      const grad=ctx.createLinearGradient(x*scaleX, topBase*scaleY, x*scaleX, (topBase+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(32,48,92,0.9)');
      grad.addColorStop(1,'rgba(16,28,60,0.92)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(160,200,255,0.85)';
      ctx.lineWidth=2;
      drawRoundedRect(x, topBase, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+10;
      const innerY=topBase+6;
      const innerW=width-20;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.save();
      ctx.clip();
      if(style==='alert'){
        const midY=(innerY+innerH/2)*scaleY;
        ctx.fillStyle='#f5f9ff';
        const alertFont=Math.max(18, Math.round(24*textScale));
        ctx.font=`${alertFont}px 'Noto Sans TC','Playfair Display',sans-serif`;
        ctx.textBaseline='middle';
        ctx.textAlign='left';
        ctx.shadowColor='rgba(120,200,255,0.45)';
        ctx.shadowBlur=10*textScale;
        ctx.fillText(text, (innerX+16)*scaleX, midY);
        const cd=spaceBossMarquee.countdownDuration;
        if(cd){
          const remain=Math.max(0, cd - (now-start));
          const num=Math.max(0, Math.ceil(remain/1000));
          if(num>0){
            ctx.shadowBlur=0;
            ctx.fillStyle='rgba(255,180,140,0.9)';
            const countdownFont=Math.max(22, Math.round(32*numberScale));
            ctx.font=`${countdownFont}px 'Playfair Display',serif`;
            ctx.textAlign='right';
            ctx.fillText(String(num), (innerX+innerW-16)*scaleX, midY);
          }
        }
      } else {
        const pxSpeed=180;
        const baseX=(innerX+innerW)*scaleX;
        const midY=(innerY+innerH/2)*scaleY;
        ctx.fillStyle='#f5f9ff';
        const marqueeFont=Math.max(18, Math.round(24*marqueeScale));
        ctx.font=`${marqueeFont}px 'Noto Sans TC','Playfair Display',sans-serif`;
        ctx.textBaseline='middle';
        ctx.shadowColor='rgba(120,200,255,0.55)';
        ctx.shadowBlur=12*marqueeScale;
        const repeated=`✦  ${text}  ✦  `;
        const textWidth=Math.max(1, ctx.measureText(repeated).width);
        let drawX = baseX - ((now-start)/1000*pxSpeed % textWidth);
        while(drawX > (innerX- textWidth/scaleX)*scaleX){ drawX -= textWidth; }
        while(drawX < (innerX + innerW)*scaleX){ ctx.fillText(repeated, drawX, midY); drawX += textWidth; }
      }
    }
    ctx.restore();
    ctx.restore();
  }

  function drawBossNameplate(name, hp, maxHp, x, y, barW, barH, palette){
    const scaleAvg=(scaleX+scaleY)/2;
    const textPrimary=palette.textPrimary||'#f0f4ff';
    const textSecondary=palette.textSecondary||'#f7f9ff';
    const glow=palette.glow||'rgba(120,180,255,0.45)';
    const safeLeft=24*scaleAvg;
    const safeRight=canvas.width - 28*scaleAvg;
    const labelAnchor=(x - 18)*scaleX;
    ctx.save();
    ctx.textAlign='left';

    const nameFont=Math.max(10, Math.round(13*1.2*scaleAvg));
    ctx.font=`${nameFont}px 'Noto Sans TC','Playfair Display',sans-serif`;
    ctx.textBaseline='bottom';
    ctx.fillStyle=textPrimary;
    ctx.shadowColor=glow;
    ctx.shadowBlur=6*scaleAvg;
    const nameMetrics=ctx.measureText(name);
    let nameX=Math.max(safeLeft, Math.min(labelAnchor, safeRight - nameMetrics.width));
    ctx.fillText(name, nameX, (y - 8)*scaleY);
    ctx.shadowBlur=0;

    const hpFont=Math.max(12, Math.round(12*1.5*scaleAvg));
    ctx.font=`${hpFont}px 'Playfair Display','Noto Sans TC',sans-serif`;
    ctx.textBaseline='top';
    ctx.fillStyle=textSecondary;
    const hpText=`${hp.toLocaleString()}/${maxHp.toLocaleString()}`;
    const hpMetrics=ctx.measureText(hpText);
    let hpX=Math.max(safeLeft, Math.min(labelAnchor, safeRight - hpMetrics.width));
    ctx.fillText(hpText, hpX, (y + barH + 8)*scaleY);
    ctx.restore();
  }

  function drawSpaceBossHPBar(){
    if(spaceBossPhase!=='active' || !spaceBoss) return;
    const L=layout();
    const barW=32;
    const maxH = 700 - (L.top + 80);
    const barH=Math.max(180, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, spaceBoss.hp/spaceBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(34,56,104,0.95)');
    frameGrad.addColorStop(1,'rgba(18,26,62,0.9)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(170,210,255,0.55)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(10,18,42,0.92)');
    bg.addColorStop(1,'rgba(20,30,60,0.88)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(255,120,150,0.2)');
      fillGrad.addColorStop(0.4,'rgba(255,140,160,0.55)');
      fillGrad.addColorStop(1,'rgba(255,230,240,0.95)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    const segments=10;
    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - innerH*i/segments)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS 太空戰艦', spaceBoss.hp, spaceBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(32,52,92,0.94)',
      bgBottom:'rgba(18,28,60,0.9)',
      frame:'rgba(170,210,255,0.75)',
      glow:'rgba(140,200,255,0.6)',
      textPrimary:'#e9f2ff',
      textSecondary:'#f0f5ff'
    });
    ctx.restore();
  }

  function drawSpaceBossHUD(){
    drawSpaceBossMarquee();
    drawSpaceBossHPBar();
  }

  // === 第10關 暗黑死神 Boss ===
  function startReaperReveal(){
    if(reaperPhase!=='awaiting') return;
    const now=performance.now();
    reaperPhase='intro';
    let anchor=reaperAnchor;
    if(reaperPlaceholder){
      anchor={x:reaperPlaceholder.x, y:reaperPlaceholder.y, w:reaperPlaceholder.w, h:reaperPlaceholder.h};
      const cx=anchor.x+anchor.w/2;
      const cy=anchor.y+anchor.h/2;
      spawnParticles(cx,cy,'#fdf0ff',140,3.2,5.2,5.6);
      spawnParticles(cx,cy,'#c4a6ff',110,2.8,4.4,4.8);
      spawnParticles(cx,cy,'#ff96cf',90,2.4,3.8,4.2);
      reaperBursts.push({type:'ring',x:cx,y:cy,r0:28,r1:420,width:18,t0:now,life:1400,color:'220,140,255'});
      reaperBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:260,t0:now,life:1200,color:'150,110,220'});
      reaperBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:180,t0:now,life:950,color:'255,160,220'});
      const idx=bricks.indexOf(reaperPlaceholder);
      if(idx>=0) bricks.splice(idx,1);
      reaperPlaceholder=null;
      reaperAnchor=anchor;
    }
    if(!reaperAnchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      const anchorW=brickW*2+L.pad;
      const anchorH=brickH*2+L.pad;
      const anchorX=L.pad + bx*(brickW+L.pad);
      reaperAnchor={x:anchorX,y:L.top,w:anchorW,h:anchorH};
    }
    reaperRevealScheduled = now + 900;
    reaperMarquee={text:'有一套！ 讓我親自會會你!', start:now, fadeStart:now+5000, end:now+8000, style:'alert'};
    screenShake=Math.max(screenShake,8);
    playSFX('fireExplosion');
  }

  function activateReaperBoss(){
    if(reaperPhase!=='intro' || reaperBoss) return;
    let anchor=reaperAnchor;
    if(!anchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      anchor={x:L.pad + bx*(brickW+L.pad), y:L.top, w:brickW*2+L.pad, h:brickH*2+L.pad};
      reaperAnchor=anchor;
    }
    const cx=anchor.x+anchor.w/2;
    const baseY=anchor.y+anchor.h+140;
    const now=performance.now();
    reaperBoss={
      x:cx,
      y:baseY,
      baseY,
      w:160,
      h:220,
      vx:(Math.random()<0.5?-1:1)*1.6,
      hp:40,
      maxHp:40,
      hitCooldownUntil:0,
      hitFlashUntil:0,
      spawnAt:now,
      cloakPhase:Math.random()*Math.PI*2,
      hiddenUntil:0
    };
    reaperTeleportSchedule={
      nextSingle: now + 10000,
      nextBurst: now + 30000,
      burstRemaining: 0,
      burstInterval: 220,
      nextBurstTeleport: 0,
      burstActive:false
    };
    reaperPhase='active';
    reaperAttackState={nextAttack: now + 15000, current:null};
    reaperSlashZone=null;
    reaperBlackHoleAttack=null;
    reaperBursts.push({type:'halo',x:cx,y:baseY-40,r0:60,r1:320,t0:now,life:1700,color:'200,140,255'});
    screenShake=Math.max(screenShake,6);
    scheduleNextTreasureBrick(now);
  }

  function performReaperTeleport(rapid=false){
    if(!reaperBoss) return;
    const now=performance.now();
    const oldX=reaperBoss.x;
    const oldY=reaperBoss.y;
    reaperAfterimages.push({x:oldX,y:oldY,t0:now,life:700,scale:1});
    const L=layout();
    const minX=140, maxX=1100-140;
    const minY=L.top+90, maxY=L.top+320;
    reaperBursts.push({type:'ring',x:oldX,y:oldY,r0:30,r1:260,width:16,t0:now,life:800,color:'210,130,255'});
    reaperBursts.push({type:'flare',x:oldX,y:oldY,r0:0,r1:200,t0:now,life:720,color:'150,110,220'});
    const newX = minX + Math.random()*(maxX-minX);
    const newY = minY + Math.random()*(maxY-minY);
    reaperBoss.x = newX;
    reaperBoss.y = newY;
    reaperAfterimages.push({x:newX,y:newY,t0:now,life:520,scale:1.12,emerge:true});
    reaperBursts.push({type:'flare',x:newX,y:newY,r0:0,r1:240,t0:now,life:760,color:'255,150,210'});
    const freq=rapid?760:680;
    beep(freq,0.04,0.04);
    beep(freq-240,0.03,0.05);
    screenShake=Math.max(screenShake, rapid?4:3);
  }

  function reaperApplyLifeLoss(now, reason='reaper'){
    if(now<reaperLifeLossCooldownUntil) return;
    if(now<paddleGoneUntil) return;
    reaperLifeLossCooldownUntil = now + 600;
    if(stats.lifeStart){
      const dur=(now-stats.lifeStart)/1000;
      if(dur<stats.fastestDeath) stats.fastestDeath=dur;
      if(dur>stats.longestLife) stats.longestLife=dur;
    }
    stats.livesUsed++;
    if(buffs.BLACKHOLE.active){ buffs.BLACKHOLE.deaths=Math.min(8,(buffs.BLACKHOLE.deaths||0)+1); }
    if(buffs.ANNIHIL.active){ buffs.ANNIHIL.active=false; }
    lives=Math.max(0, lives-1);
    updateHUD();
    const pr=paddleRect();
    const cx=pr.x+pr.w/2;
    const cy=pr.y+pr.h/2;
    spawnParticles(cx, cy, '#ff6a9a', 70, 2.6, 3.8, 3.4);
    screenShake=Math.max(screenShake,12);
    playSFX('explosion');
    balls.length=0;
    if(lives<=0){ running=false; paused=true; showGameOver(); return; }
    resetBalls(false);
    startCountdown();
  }

  function startReaperSlash(now){
    const segment=Math.floor(Math.random()*3);
    const zoneWidth=1100/3;
    const zoneHeight=140;
    const zoneX=segment*zoneWidth;
    const zoneY=700-zoneHeight;
    reaperSlashZone={x:zoneX,y:zoneY,w:zoneWidth,h:zoneHeight,start:now,countdownEnd:now+3000};
    reaperMarquee={text:'危險！ 暗黑死神即將使出死神斬!', start:now, fadeStart:now+3000, end:now+3000, style:'alert'};
    return {
      type:'slash',
      stage:'countdown',
      start:now,
      countdownEnd:now+3000,
      area:{x:zoneX,y:zoneY,w:zoneWidth,h:zoneHeight},
      slashes:0,
      nextSlash:now+3000,
      vanishEnd:0,
      resolved:false,
      reappeared:false
    };
  }

  function spawnReaperSlashStrike(state, now){
    const area=state.area;
    const baseX=area.x + Math.random()*area.w;
    const len=area.h*1.8;
    const angle=-Math.PI/3 + Math.random()*(2*Math.PI/3);
    const cos=Math.cos(angle);
    const sin=Math.sin(angle);
    const centerY=area.y + area.h*0.4;
    const x1=baseX - cos*len;
    const y1=area.y + area.h - sin*len;
    const x2=baseX + cos*len;
    const y2=area.y + area.h + sin*len;
    reaperSlashEffects.push({x1,y1,x2,y2,start:now,life:240});
    reaperBursts.push({type:'flare',x:baseX,y:centerY,r0:0,r1:240,t0:now,life:240,color:'255,80,120'});
    spawnParticles(baseX, centerY, '#ff6a88', 20, 1.6, 2.6, 2.4);
    screenShake=Math.max(screenShake,8);
    playSFX('sword');
    const pr=paddleRect();
    if(pr.w>0 && segmentIntersectsRect(x1,y1,x2,y2, pr)){
      reaperApplyLifeLoss(now,'reaperSlash');
    }
    for(let j=bricks.length-1;j>=0;j--){
      const bk=bricks[j];
      if(!bk?.fallingTreasure) continue;
      if(segmentIntersectsRect(x1,y1,x2,y2, bk)){
        spawnParticles(bk.x+bk.w/2, bk.y+bk.h/2, '#ffd6ff', 16, 2.0, 3.2, 3.0);
        damageBrick(j,1,'sword');
      }
    }
  }

  function updateReaperSlash(state, now){
    if(state.stage==='countdown'){
      if(now>=state.countdownEnd){
        state.stage='slashing';
        state.nextSlash=now;
        state.vanishEnd=now+3000;
        if(reaperBoss){ reaperBoss.hiddenUntil = Math.max(reaperBoss.hiddenUntil||0, state.vanishEnd); }
        reaperSlashZone=null;
      }
    }else if(state.stage==='slashing'){
      if(state.slashes<30 && now>=state.nextSlash){
        spawnReaperSlashStrike(state, now);
        state.slashes++;
        state.nextSlash=now+100;
        if(state.slashes>=30){ state.stage='recover'; }
      }
      if(now>=state.vanishEnd){ state.stage='recover'; }
    }
    if(state.stage==='recover'){
      if(!state.reappeared && reaperBoss && now>=state.vanishEnd){
        state.reappeared=true;
        reaperBoss.hiddenUntil=0;
        reaperAfterimages.push({x:reaperBoss.x,y:reaperBoss.y,t0:now,life:520,scale:1.05,emerge:true});
      }
      if(now>=state.vanishEnd+400){ state.resolved=true; }
    }
    if(state.resolved){
      reaperAttackState.current=null;
      reaperAttackState.nextAttack = now + 15000;
    }
  }

  function startReaperBlackHole(now){
    const state={
      type:'blackhole',
      stage:'countdown',
      start:now,
      countdownEnd:now+3000,
      projectile:null,
      projectileTrail:[],
      hole:null,
      resolved:false,
      baseDesiredWidth:desiredPaddleWidth(),
      didKill:false
    };
    reaperMarquee={text:'危險！ 暗黑死神即將使出黑洞吞噬!', start:now, fadeStart:now+3000, end:now+3000, style:'alert'};
    reaperBlackHoleAttack=state;
    return state;
  }

  function applyReaperHolePull(hole, now){
    const pr=paddleRect();
    const px=pr.x+pr.w/2;
    const py=pr.y+pr.h/2;
    const radius = hole?.radius || hole?.r || 0;
    const dx=hole.x - px;
    const dy=hole.y - py;
    const dist=Math.hypot(dx, dy);
    const influence = radius>0 ? Math.max(0, 1 - dist/(radius)) : 1;
    if(!orientLeft){
      paddle.x += dx*0.024*influence;
      paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x));
    }else{
      paddle.y += dy*0.028*influence;
      paddle.y=Math.max(0, Math.min(700-paddle.w, paddle.y));
    }
    const pullRange = radius>0 ? radius*1.35 : 220;
    for(const p of powerups){
      const cx=p.x + p.w/2;
      const cy=p.y + p.h/2;
      const pdx=hole.x - cx;
      const pdy=hole.y - cy;
      const pdist=Math.hypot(pdx, pdy);
      if(pdist>pullRange) continue;
      const weight = Math.max(0, 1 - pdist/pullRange);
      p.x += pdx * 0.06 * weight;
      p.y += pdy * 0.06 * weight;
      p.x = Math.max(-20, Math.min(1100 - p.w + 20, p.x));
      p.y = Math.max(-40, Math.min(720, p.y));
    }
  }

  function updateReaperBlackHole(state, now){
    if(state.stage==='countdown'){
      if(now>=state.countdownEnd){
        state.stage='projectile';
        if(reaperBoss){
          const pr=paddleRect();
          const targetX=pr.x+pr.w/2;
          const targetY=pr.y+pr.h/2;
          const startX=reaperBoss.x;
          const startY=reaperBoss.y-reaperBoss.h*0.2;
          const dx=targetX-startX;
          const dy=(targetY-startY);
          const dist=Math.hypot(dx,dy)||1;
          const speed=4.5;
          state.projectile={x:startX,y:startY,vx:(dx/dist)*speed,vy:(dy/dist)*speed,radius:22};
          state.projectileTrail=[];
          playSFX('blackhole');
        }else{
          state.resolved=true;
        }
      }
    }else if(state.stage==='projectile'){
      const proj=state.projectile;
      if(!proj){
        state.resolved=true;
      }else{
        proj.x+=proj.vx;
        proj.y+=proj.vy;
        state.projectileTrail.push({x:proj.x,y:proj.y,t:now});
        if(state.projectileTrail.length>18) state.projectileTrail.shift();
        if(proj.y>=700-100){
          const holeX=proj.x;
          const holeY=700-90;
          const holeRadius=Math.round(160*0.7);
          const spinDir=(Math.random()>0.5?1:-1);
          state.hole={x:holeX,y:holeY,start:now,end:now+3000,nextTick:now+1000,baseDesired:state.baseDesiredWidth,radius:holeRadius,spinDir,vortexPhase:Math.random()*Math.PI*2};
          reaperBursts.push({type:'ring',x:holeX,y:holeY-60,r0:40,r1:360,width:22,t0:now,life:1600,color:'210,170,255'});
          reaperBursts.push({type:'flare',x:holeX,y:holeY-40,r0:0,r1:320,t0:now,life:1400,color:'170,140,255'});
          blackHoles.push({x:holeX,y:holeY,r:holeRadius,until:now+3000,start:now,spinDir});
          state.stage='hole';
          state.projectile=null;
          state.projectileTrail=[];
        }
      }
    }else if(state.stage==='hole'){
      const hole=state.hole;
      if(!hole){
        state.resolved=true;
      }else{
        applyReaperHolePull(hole, now);
        if(now>=hole.nextTick){
          const prNow=paddleRect();
          const px=prNow.x+prNow.w/2;
          const py=prNow.y+prNow.h/2;
          const radius=hole.radius || hole.r || 0;
          const dist=Math.hypot((hole.x||0)-px, (hole.y||0)-py);
          const inRange = radius<=0 || dist<=radius;
          if(inRange){
            const desired=Math.max(hole.baseDesired||0, desiredPaddleWidth());
            hole.baseDesired=desired;
            const cap=Math.max(0, desired - REAPER_PADDLE_MIN_WIDTH);
            if(reaperPaddlePenalty < cap){
              const before=reaperPaddlePenalty;
              reaperPaddlePenalty=Math.min(cap, reaperPaddlePenalty + 40);
              if(reaperPaddlePenalty!==before){ computePaddleWidth(); }
            }else if(!state.didKill){
              reaperApplyLifeLoss(now,'blackhole');
              state.didKill=true;
            }
          }
          hole.nextTick = now + 1000;
        }
        if(now>=hole.end){ state.resolved=true; }
      }
    }
    if(state.resolved){
      reaperAttackState.current=null;
      reaperAttackState.nextAttack = now + 15000;
      reaperBlackHoleAttack=null;
    }
  }

  function updateReaperAttacks(now){
    if(reaperPhase!=='active' || !reaperBoss) return;
    if(!reaperAttackState){ reaperAttackState={nextAttack: now + 15000, current:null}; }
    if(reaperAttackState.current){
      const curr=reaperAttackState.current;
      if(curr.type==='slash'){ updateReaperSlash(curr, now); }
      else if(curr.type==='blackhole'){ updateReaperBlackHole(curr, now); }
      return;
    }
    if(now>=reaperAttackState.nextAttack){
      const modes=['slash','blackhole'];
      const pick=modes[Math.floor(Math.random()*modes.length)];
      if(pick==='slash'){ reaperAttackState.current=startReaperSlash(now); }
      else { reaperAttackState.current=startReaperBlackHole(now); }
    }
  }

  function damageReaperBoss(amount=1, source='generic', impact){
    if(reaperPhase!=='active' || !reaperBoss) return false;
    const now=performance.now();
    if(reaperBoss.hiddenUntil && now<reaperBoss.hiddenUntil) return false;
    if(reaperBoss.hitCooldownUntil && now<reaperBoss.hitCooldownUntil) return false;
    const dmg = amount>0?1:0;
    if(!dmg) return false;
    reaperBoss.hitCooldownUntil = now + 160;
    reaperBoss.hp = Math.max(0, reaperBoss.hp - dmg);
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    reaperBoss.hitFlashUntil = now + 260;
    const jitterX=(Math.random()-0.5)*reaperBoss.w*0.35;
    const jitterY=(Math.random()-0.5)*reaperBoss.h*0.25;
    const colorMap={
      laser:'240,190,255',
      missile:'255,200,200',
      gatling:'255,210,200',
      plasma:'200,230,255',
      blackhole:'210,220,255',
      phoenix:'255,180,210',
      sword:'255,200,220',
      holy:'255,240,220'
    };
    const burstColor=colorMap[source]||'210,150,255';
    reaperBursts.push({type:'spark',x:reaperBoss.x+jitterX,y:reaperBoss.y+jitterY,r0:0,r1:150,t0:now,life:720,color:burstColor});
    spawnParticles(reaperBoss.x+jitterX, reaperBoss.y+jitterY, '#d9c7ff', 20, 1.5, 2.6, 2.4);
    if(impact && impact.x!=null && impact.y!=null){
      spawnParticles(impact.x, impact.y, '#ff9bd0', 16, 1.4, 2.4, 2.2);
    }
    screenShake=Math.max(screenShake,5);
    const toneMap={laser:760, missile:680, gatling:720, plasma:780, blackhole:660, phoenix:820, sword:880, ball:800, holy:920};
    const freq=toneMap[source]||780;
    beep(freq,0.04,0.04);
    if(reaperBoss.hp<=0){ defeatReaperBoss(); }
    return true;
  }

  function defeatReaperBoss(){
    if(reaperPhase!=='active' || !reaperBoss) return;
    const now=performance.now();
    const rb=reaperBoss;
    addScore(BOSS_DEFEAT_SCORE.reaper);
    stats.bossKills++;
    updateHUD();
    reaperAttackState=null;
    reaperSlashZone=null;
    reaperSlashEffects=[];
    reaperBlackHoleAttack=null;
    reaperPaddlePenalty=0;
    reaperPenaltyLastUpdate=0;
    computePaddleWidth();
    reaperPhase='dying';
    reaperDefeatedAt=now;
    reaperTeleportSchedule=null;
    reaperDeathAnim={
      start:now,
      startY:rb.y,
      dropDistance:260,
      fallDuration:3000,
      bigExplosionStart:now+3000,
      bigExplosionEnd:now+5000,
      vanishAt:now+5000,
      finishAt:now+8000,
      lastBurst:now,
      smallBurstInterval:180,
      bigBang:false,
      lastX:rb.x,
      lastY:rb.y,
      lastW:rb.w,
      lastH:rb.h,
      dropSpawned:false
    };
    reaperBursts.push({type:'ring',x:rb.x,y:rb.y,r0:60,r1:560,width:26,t0:now,life:2200,color:'255,170,230'});
    reaperBursts.push({type:'flare',x:rb.x,y:rb.y,r0:0,r1:360,t0:now,life:1900,color:'210,140,255'});
    spawnParticles(rb.x, rb.y, '#ffe5ff', 180, 3.4, 5.6, 6.2);
    screenShake=Math.max(screenShake,14);
    playSFX('fireExplosion');
    reaperMarquee={text:'成功擊殺Boss: 暗黑死神!', start:now, fadeStart:now+5000, end:now+5000, style:'victorySolid'};
    nextTreasureBrickAt=0;
  }

  function updateReaperBoss(){
    if(level!==10) return;
    const now=performance.now();
    if(reaperPhase==='intro' && !reaperBoss && reaperRevealScheduled && now>=reaperRevealScheduled){ activateReaperBoss(); }
    if(reaperPhase==='active' && reaperBoss){
      reaperBoss.x += reaperBoss.vx;
      const margin=150;
      if(reaperBoss.x - reaperBoss.w/2 < margin){ reaperBoss.x = margin + reaperBoss.w/2; reaperBoss.vx = Math.abs(reaperBoss.vx); }
      if(reaperBoss.x + reaperBoss.w/2 > 1100 - margin){ reaperBoss.x = 1100 - margin - reaperBoss.w/2; reaperBoss.vx = -Math.abs(reaperBoss.vx); }
      reaperBoss.y = reaperBoss.baseY + Math.sin((now - reaperBoss.spawnAt)/780)*42;
      reaperBoss.cloakPhase += 0.03;
      const activeAttack=reaperAttackState && reaperAttackState.current;
      const teleportLocked = !!(activeAttack && activeAttack.stage && activeAttack.stage!=='countdown');
      if(reaperTeleportSchedule && !teleportLocked){
        if(reaperTeleportSchedule.burstActive){
          if(now>=reaperTeleportSchedule.nextBurstTeleport){
            performReaperTeleport(true);
            reaperTeleportSchedule.burstRemaining--;
            if(reaperTeleportSchedule.burstRemaining>0){
              reaperTeleportSchedule.nextBurstTeleport = now + reaperTeleportSchedule.burstInterval;
            }else{
              reaperTeleportSchedule.burstActive=false;
              reaperTeleportSchedule.nextSingle = now + 10000;
              reaperTeleportSchedule.nextBurst = now + 30000;
            }
          }
        }else if(now>=reaperTeleportSchedule.nextBurst){
          reaperTeleportSchedule.burstActive=true;
          reaperTeleportSchedule.burstRemaining=5;
          reaperTeleportSchedule.nextBurstTeleport=now;
          performReaperTeleport(true);
          reaperTeleportSchedule.burstRemaining--;
          if(reaperTeleportSchedule.burstRemaining>0){
            reaperTeleportSchedule.nextBurstTeleport = now + reaperTeleportSchedule.burstInterval;
          }else{
            reaperTeleportSchedule.burstActive=false;
            reaperTeleportSchedule.nextSingle = now + 10000;
            reaperTeleportSchedule.nextBurst = now + 30000;
          }
        }else if(now>=reaperTeleportSchedule.nextSingle){
          performReaperTeleport(false);
          reaperTeleportSchedule.nextSingle = now + 10000;
        }
      }
      updateReaperAttacks(now);
    }else if(reaperAttackState && reaperAttackState.current){
      updateReaperAttacks(now);
    }
    if(reaperPhase==='dying'){
      const anim=reaperDeathAnim;
      if(anim){
        const bossSprite=reaperBoss;
        const elapsed=now-anim.start;
        const prog=Math.max(0, Math.min(1, elapsed/anim.fallDuration));
        if(bossSprite){
          bossSprite.y = anim.startY + anim.dropDistance*prog;
          bossSprite.vx = 0;
          anim.lastX = bossSprite.x;
          anim.lastY = bossSprite.y;
          anim.lastW = bossSprite.w;
          anim.lastH = bossSprite.h;
        }
        if(now-anim.lastBurst>=(anim.smallBurstInterval||220) && now<anim.bigExplosionStart && bossSprite){
          anim.lastBurst=now;
          anim.smallBurstInterval=140+Math.random()*120;
          const sx=bossSprite.x + (Math.random()-0.5)*bossSprite.w*0.7;
          const sy=bossSprite.y + (Math.random()-0.5)*bossSprite.h*0.7;
          reaperBursts.push({type:'spark',x:sx,y:sy,r0:0,r1:200,t0:now,life:920,color:'255,170,220'});
          reaperBursts.push({type:'flare',x:sx,y:sy,r0:0,r1:280,t0:now,life:700,color:'200,120,255'});
          spawnParticles(sx, sy, '#ffd9f1', 34, 1.8, 3.2, 3.6);
        }
        if(!anim.bigBang && now>=anim.bigExplosionStart){
          anim.bigBang=true;
          const bx=anim.lastX;
          const by=anim.lastY;
          spawnParticles(bx, by, '#fff0ff', 280, 3.8, 6.2, 6.6);
          spawnParticles(bx, by, '#ffe0ff', 220, 3.4, 5.6, 6.0);
          reaperBursts.push({type:'ring',x:bx,y:by,r0:80,r1:640,width:34,t0:now,life:2200,color:'255,200,240'});
          reaperBursts.push({type:'flare',x:bx,y:by,r0:0,r1:480,t0:now,life:2000,color:'230,170,255'});
          reaperBursts.push({type:'halo',x:bx,y:by,r0:120,r1:720,t0:now,life:2400,color:'255,180,240'});
          screenShake=Math.max(screenShake,16);
          playSFX('fireExplosion');
          if(!anim.dropSpawned){
            spawnPower(bx-12, by, {forceType:'NINE'});
            anim.dropSpawned=true;
          }
        }
        if(anim.bigBang && now<anim.bigExplosionEnd){
          const theta=Math.random()*Math.PI*2;
          const spanW=(bossSprite?bossSprite.w:(anim.lastW||120));
          const dist=spanW*0.5 + Math.random()*spanW*0.5;
          const px=anim.lastX + Math.cos(theta)*dist;
          const py=anim.lastY + Math.sin(theta)*dist;
          reaperBursts.push({type:'spark',x:px,y:py,r0:0,r1:320,t0:now,life:860,color:'255,190,240'});
        }
        if(bossSprite && now>=anim.vanishAt){
          reaperBoss=null;
        }
        if(now>=anim.finishAt){
          reaperPhase='defeated';
          reaperDefeatedAt=now;
          reaperDeathAnim=null;
        }
      }
    }
    for(let i=reaperBursts.length-1;i>=0;i--){ const fx=reaperBursts[i]; const life=fx.life||1000; if(now>fx.t0+life) reaperBursts.splice(i,1); }
    for(let i=reaperAfterimages.length-1;i>=0;i--){ const af=reaperAfterimages[i]; if(now>af.t0+(af.life||600)) reaperAfterimages.splice(i,1); }
    for(let i=reaperSlashEffects.length-1;i>=0;i--){ const slash=reaperSlashEffects[i]; if(now>slash.start+(slash.life||200)){ reaperSlashEffects.splice(i,1); } }
    if(!reaperPenaltyLastUpdate) reaperPenaltyLastUpdate=now;
    const activeHole = reaperBlackHoleAttack && reaperBlackHoleAttack.stage==='hole';
    if(reaperPaddlePenalty>0){
      if(!activeHole){
        const dt=now - reaperPenaltyLastUpdate;
        if(dt>0){
          const recover=(dt/1000)*120;
          if(recover>0){
            const before=reaperPaddlePenalty;
            reaperPaddlePenalty=Math.max(0, reaperPaddlePenalty - recover);
            if(Math.abs(before-reaperPaddlePenalty)>0.5){ computePaddleWidth(); }
          }
        }
      }
    }
    reaperPenaltyLastUpdate=now;
  }

  function drawReaperBoss(rb, now){
    const s=(scaleX+scaleY)/2;
    ctx.save();
    ctx.translate(rb.x*scaleX, rb.y*scaleY);
    if(rb.hiddenUntil && now<rb.hiddenUntil){
      const fade=1-Math.max(0, Math.min(1,(rb.hiddenUntil-now)/3000));
      const radius=rb.w*0.9*s*(1+0.1*Math.sin(now/160));
      const grad=ctx.createRadialGradient(0,0,radius*0.2,0,0,radius);
      grad.addColorStop(0,`rgba(130,90,200,${0.18+0.22*fade})`);
      grad.addColorStop(1,'rgba(130,90,200,0)');
      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(0,0,radius,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
      return;
    }
    const float=Math.sin((now-rb.spawnAt)/520 + rb.cloakPhase*0.6)*8*s;
    ctx.translate(0, float);

    const bodyW=rb.w*0.58*s;
    const bodyH=rb.h*0.64*s;
    const flutterA=Math.sin(now/340 + rb.cloakPhase)*0.28;
    const flutterB=Math.sin(now/220 + rb.cloakPhase*1.4)*0.22;
    const flutterC=Math.sin(now/180 + rb.cloakPhase*0.8)*0.18;

    ctx.save();
    const cloakPath=new Path2D();
    cloakPath.moveTo(-bodyW*0.5, -bodyH*0.08);
    cloakPath.quadraticCurveTo(-bodyW*0.86, -bodyH*0.86, -bodyW*0.28, -bodyH*1.32);
    cloakPath.quadraticCurveTo(0, -bodyH*1.44, bodyW*0.28, -bodyH*1.32);
    cloakPath.quadraticCurveTo(bodyW*0.86, -bodyH*0.86, bodyW*0.5, -bodyH*0.08);
    const ragged=12;
    for(let i=0;i<=ragged;i++){
      const t=i/ragged;
      const offset=-bodyW*0.5 + t*bodyW;
      const sway=Math.sin(now/540 + rb.cloakPhase*0.7 + t*Math.PI)*bodyW*0.08;
      const drop=bodyH*(1.04 + 0.18*Math.sin(t*Math.PI + now/320));
      const wave=Math.sin(now/280 + rb.cloakPhase*0.6 + t*Math.PI*1.8)*bodyH*0.16;
      const crest=drop - bodyH*(0.16 + 0.12*Math.cos(t*Math.PI*2 + now/360));
      cloakPath.quadraticCurveTo(offset + sway*0.6, crest, offset + sway, drop + wave);
    }
    cloakPath.quadraticCurveTo(bodyW*0.7, bodyH*0.34 + flutterB*bodyH*0.36, bodyW*0.46, bodyH*0.94 + flutterC*bodyH*0.28);
    cloakPath.quadraticCurveTo(bodyW*0.18, bodyH*(1.04+flutterB*0.16), 0, bodyH*(0.88 + flutterA*0.3));
    cloakPath.quadraticCurveTo(-bodyW*0.18, bodyH*(1.04-flutterB*0.16), -bodyW*0.46, bodyH*0.94 - flutterC*bodyH*0.28);
    cloakPath.quadraticCurveTo(-bodyW*0.7, bodyH*0.34 - flutterB*bodyH*0.36, -bodyW*0.5, -bodyH*0.08);
    cloakPath.closePath();
    const cloakGrad=ctx.createLinearGradient(0,-bodyH*1.36,0,bodyH*1.2);
    cloakGrad.addColorStop(0,'rgba(34,18,50,0.98)');
    cloakGrad.addColorStop(0.42,'rgba(18,8,26,0.98)');
    cloakGrad.addColorStop(0.78,'rgba(10,6,20,0.96)');
    cloakGrad.addColorStop(1,'rgba(4,2,12,0.94)');
    ctx.fillStyle=cloakGrad;
    ctx.shadowColor='rgba(200,150,255,0.42)';
    ctx.shadowBlur=30*s;
    ctx.fill(cloakPath);
    ctx.shadowBlur=0;
    ctx.strokeStyle='rgba(150,120,220,0.36)';
    ctx.lineWidth=3.6*s;
    ctx.stroke(cloakPath);
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(255,180,240,0.18)';
    ctx.lineWidth=5*s;
    ctx.stroke(cloakPath);
    ctx.restore();
    if(rb.hitFlashUntil && now<rb.hitFlashUntil){
      ctx.strokeStyle='rgba(255,210,250,0.9)';
      ctx.lineWidth=4.8*s;
      ctx.stroke();
    }
    ctx.save();
    ctx.clip();
    const liningGrad=ctx.createLinearGradient(0,-bodyH,0,bodyH*1.18);
    liningGrad.addColorStop(0,'rgba(160,36,52,0.62)');
    liningGrad.addColorStop(0.52,'rgba(120,18,42,0.5)');
    liningGrad.addColorStop(1,'rgba(70,6,24,0.36)');
    ctx.globalAlpha=0.85;
    ctx.fillStyle=liningGrad;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.34, -bodyH*0.02);
    ctx.quadraticCurveTo(-bodyW*0.22, bodyH*0.56, -bodyW*0.32, bodyH*(0.92+flutterC*0.12));
    ctx.quadraticCurveTo(-bodyW*0.08, bodyH*(0.98+flutterA*0.16), 0, bodyH*(0.82 + flutterB*0.16));
    ctx.quadraticCurveTo(bodyW*0.08, bodyH*(0.98-flutterA*0.16), bodyW*0.32, bodyH*(0.9-flutterC*0.12));
    ctx.quadraticCurveTo(bodyW*0.22, bodyH*0.56, bodyW*0.34, -bodyH*0.02);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.restore();

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.42, -bodyH*0.18);
    ctx.quadraticCurveTo(-bodyW*0.64, -bodyH*0.76, -bodyW*0.18, -bodyH*1.24);
    ctx.quadraticCurveTo(0, -bodyH*1.36, bodyW*0.18, -bodyH*1.24);
    ctx.quadraticCurveTo(bodyW*0.64, -bodyH*0.76, bodyW*0.42, -bodyH*0.18);
    ctx.closePath();
    const hoodGrad=ctx.createLinearGradient(0,-bodyH*1.4,0,-bodyH*0.2);
    hoodGrad.addColorStop(0,'rgba(42,18,56,0.98)');
    hoodGrad.addColorStop(1,'rgba(16,8,28,0.98)');
    ctx.fillStyle=hoodGrad;
    ctx.fill();
    ctx.save();
    ctx.clip();
    const hoodInner=ctx.createRadialGradient(0,-bodyH*0.92, bodyW*0.08, 0,-bodyH*0.92, bodyW*0.46);
    hoodInner.addColorStop(0,'rgba(210,40,70,0.55)');
    hoodInner.addColorStop(1,'rgba(80,0,20,0.25)');
    ctx.fillStyle=hoodInner;
    ctx.fillRect(-bodyW*0.6, -bodyH*1.4, bodyW*1.2, bodyH*1.4);
    ctx.restore();
    ctx.restore();

    const headR=bodyW*0.26;
    const headY=-bodyH*0.84;
    const skullW=headR*2.05;
    const skullH=headR*1.78;
    ctx.save();
    ctx.translate(0, headY);
    ctx.shadowColor='rgba(255,200,240,0.45)';
    ctx.shadowBlur=16*s;
    const skullPath=new Path2D();
    skullPath.moveTo(-skullW*0.5, -skullH*0.05);
    skullPath.quadraticCurveTo(0, -skullH*0.86, skullW*0.5, -skullH*0.05);
    skullPath.quadraticCurveTo(skullW*0.62, skullH*0.44, skullW*0.28, skullH*0.78);
    skullPath.quadraticCurveTo(skullW*0.1, skullH*0.96, -skullW*0.1, skullH*0.96);
    skullPath.quadraticCurveTo(-skullW*0.28, skullH*0.78, -skullW*0.62, skullH*0.44);
    skullPath.closePath();
    const skullGrad=ctx.createLinearGradient(0,-skullH,0,skullH);
    skullGrad.addColorStop(0,'#fffafd');
    skullGrad.addColorStop(0.58,'#f1e6f5');
    skullGrad.addColorStop(1,'#e2d1e6');
    ctx.fillStyle=skullGrad;
    ctx.fill(skullPath);
    ctx.strokeStyle='rgba(110,80,150,0.45)';
    ctx.lineWidth=2.1*s;
    ctx.stroke(skullPath);

    ctx.fillStyle='#1a1325';
    ctx.beginPath();
    ctx.ellipse(-skullW*0.22, -skullH*0.1, skullW*0.2, skullH*0.3, -0.04, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(skullW*0.22, -skullH*0.1, skullW*0.2, skullH*0.3, 0.04, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle='rgba(255,255,255,0.16)';
    ctx.beginPath();
    ctx.ellipse(-skullW*0.28, -skullH*0.26, skullW*0.08, skullH*0.14, -0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(skullW*0.28, -skullH*0.26, skullW*0.08, skullH*0.14, 0.2, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle='#1f1528';
    ctx.beginPath();
    ctx.moveTo(0, skullH*0.12);
    ctx.lineTo(-skullW*0.08, skullH*0.38);
    ctx.lineTo(skullW*0.08, skullH*0.38);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle='rgba(140,100,170,0.65)';
    ctx.lineWidth=1.6*s;
    ctx.beginPath();
    ctx.moveTo(-skullW*0.3, skullH*0.54);
    ctx.lineTo(skullW*0.3, skullH*0.54);
    ctx.stroke();
    ctx.beginPath();
    for(let i=-2;i<=2;i++){
      const ratio=i/2;
      const tx=ratio*skullW*0.12;
      const ty=skullH*0.7 - Math.abs(ratio)*skullH*0.08;
      ctx.moveTo(tx, skullH*0.54);
      ctx.lineTo(tx, ty);
    }
    ctx.stroke();

    ctx.fillStyle='rgba(255,255,255,0.22)';
    ctx.beginPath();
    ctx.ellipse(0, -skullH*0.36, skullW*0.3, skullH*0.32, 0, 0, Math.PI);
    ctx.fill();

    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const skullGlow=ctx.createRadialGradient(0, headY, headR*0.2, 0, headY, headR*1.2);
    skullGlow.addColorStop(0,'rgba(255,210,250,0.45)');
    skullGlow.addColorStop(1,'rgba(255,210,250,0)');
    ctx.fillStyle=skullGlow;
    ctx.beginPath();
    ctx.arc(0, headY, headR*1.25, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    const handleSwing=-0.12 + Math.sin(now/520 + rb.cloakPhase)*0.05;
    ctx.rotate(handleSwing);
    ctx.translate(bodyW*0.32, -bodyH*0.12);
    const handleLen=bodyH*1.46;
    const handleGrad=ctx.createLinearGradient(0,-handleLen,0,bodyH*0.2);
    handleGrad.addColorStop(0,'#360208');
    handleGrad.addColorStop(0.48,'#821123');
    handleGrad.addColorStop(1,'#d12a3a');
    ctx.lineCap='round';
    ctx.lineJoin='round';
    ctx.strokeStyle=handleGrad;
    ctx.lineWidth=7.2*s;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.02,0);
    ctx.quadraticCurveTo(bodyW*0.08, -handleLen*0.32, bodyW*0.02, -handleLen*0.64);
    ctx.quadraticCurveTo(-bodyW*0.02, -handleLen*0.84, bodyW*0.04, -handleLen);
    ctx.stroke();

    ctx.strokeStyle='rgba(255,190,200,0.4)';
    ctx.lineWidth=1.6*s;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.015, -handleLen*0.14);
    ctx.quadraticCurveTo(bodyW*0.04, -handleLen*0.5, -bodyW*0.006, -handleLen*0.9);
    ctx.stroke();

    ctx.fillStyle='rgba(255,140,160,0.75)';
    ctx.beginPath();
    ctx.ellipse(0, -handleLen*0.3, bodyW*0.085, bodyW*0.05, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(0, -handleLen*0.56, bodyW*0.078, bodyW*0.044, 0, 0, Math.PI*2);
    ctx.fill();

    const clampH=bodyW*0.18;
    ctx.fillStyle='#741320';
    ctx.fillRect(-bodyW*0.05, -handleLen-clampH, bodyW*0.1, clampH);
    ctx.fillStyle='rgba(255,200,210,0.35)';
    ctx.fillRect(-bodyW*0.05, -handleLen-clampH, bodyW*0.1, clampH*0.32);

    ctx.save();
    ctx.translate(0, -handleLen-clampH);
    ctx.rotate(-Math.PI/12);
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.28, bodyW*0.08);
    ctx.quadraticCurveTo(bodyW*0.5, -bodyH*0.62, bodyW*0.84, bodyH*0.02);
    ctx.quadraticCurveTo(bodyW*0.34, bodyH*0.34, -bodyW*0.32, bodyH*0.18);
    ctx.quadraticCurveTo(-bodyW*0.12, -bodyH*0.02, -bodyW*0.28, bodyW*0.08);
    ctx.closePath();
    const bladeGrad=ctx.createLinearGradient(-bodyW*0.3, bodyH*0.25, bodyW*0.86, -bodyH*0.46);
    bladeGrad.addColorStop(0,'#fef5ff');
    bladeGrad.addColorStop(0.38,'#f38aa2');
    bladeGrad.addColorStop(0.76,'#7d1628');
    ctx.fillStyle=bladeGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(140,20,46,0.9)';
    ctx.lineWidth=2.6*s;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-bodyW*0.06, bodyW*0.02);
    ctx.quadraticCurveTo(bodyW*0.42, -bodyH*0.36, bodyW*0.68, bodyH*0.06);
    ctx.strokeStyle='rgba(255,240,250,0.78)';
    ctx.lineWidth=2*s;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-bodyW*0.24, bodyW*0.12);
    ctx.quadraticCurveTo(bodyW*0.22, bodyH*0.24, -bodyW*0.12, bodyH*0.24);
    ctx.strokeStyle='rgba(120,0,28,0.35)';
    ctx.lineWidth=3*s;
    ctx.stroke();
    ctx.restore();

    ctx.restore();

    ctx.strokeStyle='rgba(210,160,255,0.32)';
    ctx.lineWidth=2.4*s;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.44, -bodyH*0.08);
    ctx.quadraticCurveTo(-bodyW*0.28, -bodyH*0.64, -bodyW*0.12, -bodyH*1.04);
    ctx.quadraticCurveTo(0, -bodyH*1.18, bodyW*0.12, -bodyH*1.04);
    ctx.quadraticCurveTo(bodyW*0.28, -bodyH*0.64, bodyW*0.44, -bodyH*0.08);
    ctx.stroke();

    const auraGrad=ctx.createRadialGradient(0, bodyH*0.18, bodyW*0.2, 0, bodyH*0.18, bodyW*1.15);
    auraGrad.addColorStop(0,'rgba(150,100,220,0.32)');
    auraGrad.addColorStop(1,'rgba(150,100,220,0)');
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=auraGrad;
    ctx.beginPath();
    ctx.arc(0, bodyH*0.18, bodyW*1.15, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawReaperLayer(){
    if(level!==10) return;
    if(reaperPhase==='inactive' && !reaperBursts.length && !reaperAfterimages.length) return;
    const now=performance.now();
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    for(const fx of reaperBursts){
      const life=fx.life||1000;
      const prog=Math.max(0, Math.min(1, (now-fx.t0)/life));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      if(fx.type==='ring'){
        const rad=(fx.r0||0)+((fx.r1||220)-(fx.r0||0))*easeOut(prog);
        const alpha=1-prog;
        ctx.strokeStyle=`rgba(${fx.color||'220,150,255'},${0.55*alpha})`;
        ctx.lineWidth=(fx.width||16)*((scaleX+scaleY)/2)*(1-prog*0.7);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='flare'){
        const rad=(fx.r1||220)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(10, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0, `rgba(${fx.color||'200,140,255'},${0.36*(1-prog)})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='spark'){
        const rad=(fx.r1||90)*prog*((scaleX+scaleY)/2);
        ctx.strokeStyle=`rgba(${fx.color||'220,160,255'},${0.7*(1-prog)})`;
        ctx.lineWidth=2.4*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.moveTo(fx.x*scaleX-rad, fx.y*scaleY);
        ctx.lineTo(fx.x*scaleX+rad, fx.y*scaleY);
        ctx.moveTo(fx.x*scaleX, fx.y*scaleY-rad);
        ctx.lineTo(fx.x*scaleX, fx.y*scaleY+rad);
        ctx.stroke();
      }else if(fx.type==='halo'){
        const rad=(fx.r0||40)+((fx.r1||240)-(fx.r0||40))*prog;
        ctx.strokeStyle=`rgba(${fx.color||'200,150,255'},${0.25*(1-prog)})`;
        ctx.lineWidth=8*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }
    if(reaperSlashZone){
      const zone=reaperSlashZone;
      const pulse=0.5+0.5*Math.sin(now/140);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createLinearGradient(zone.x*scaleX, (zone.y+zone.h/2)*scaleY, (zone.x+zone.w)*scaleX, (zone.y+zone.h/2)*scaleY);
      grad.addColorStop(0,`rgba(255,70,100,${0.08+0.12*pulse})`);
      grad.addColorStop(0.5,`rgba(255,90,140,${0.22+0.25*pulse})`);
      grad.addColorStop(1,`rgba(255,70,100,${0.08+0.12*pulse})`);
      ctx.fillStyle=grad;
      ctx.fillRect(zone.x*scaleX, zone.y*scaleY, zone.w*scaleX, zone.h*scaleY);
      ctx.strokeStyle=`rgba(255,150,190,${0.35+0.3*pulse})`;
      ctx.lineWidth=3*((scaleX+scaleY)/2);
      ctx.strokeRect(zone.x*scaleX, zone.y*scaleY, zone.w*scaleX, zone.h*scaleY);
      ctx.restore();
    }
    for(const slash of reaperSlashEffects){
      const life=slash.life||240;
      const prog=Math.max(0, Math.min(1,(now-slash.start)/life));
      const alpha=1-prog;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createLinearGradient(slash.x1*scaleX, slash.y1*scaleY, slash.x2*scaleX, slash.y2*scaleY);
      grad.addColorStop(0,`rgba(255,120,160,${0.08*alpha})`);
      grad.addColorStop(0.5,`rgba(255,80,130,${0.85*alpha})`);
      grad.addColorStop(1,`rgba(255,120,160,${0.08*alpha})`);
      ctx.strokeStyle=grad;
      ctx.lineWidth=4*((scaleX+scaleY)/2)*(1+0.4*(1-prog));
      ctx.beginPath();
      ctx.moveTo(slash.x1*scaleX, slash.y1*scaleY);
      ctx.lineTo(slash.x2*scaleX, slash.y2*scaleY);
      ctx.stroke();
      ctx.restore();
    }
    const countdownAttack=reaperAttackState && reaperAttackState.current;
    if(countdownAttack && countdownAttack.stage==='countdown'){
      const remain=Math.ceil((countdownAttack.countdownEnd-now)/1000);
      if(remain>0){
        const L=layout();
        const anchorY=Math.max(L.top - 36, 68);
        const scaleAvg=(scaleX+scaleY)/2;
        const fontSize=Math.round(74*scaleAvg);
        if(countdownAttack.type==='slash'){
          ctx.save();
          ctx.globalCompositeOperation='lighter';
          const glow=ctx.createRadialGradient(canvas.width/2, anchorY*scaleY, 0, canvas.width/2, anchorY*scaleY, 140*scaleAvg);
          glow.addColorStop(0,'rgba(255,130,200,0.42)');
          glow.addColorStop(1,'rgba(255,130,200,0)');
          ctx.fillStyle=glow;
          ctx.beginPath();
          ctx.arc(canvas.width/2, anchorY*scaleY, 140*scaleAvg, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
        ctx.save();
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
        if(countdownAttack.type==='slash'){
          ctx.fillStyle='rgba(255,235,248,0.95)';
          ctx.shadowColor='rgba(255,160,210,0.85)';
        }else{
          ctx.fillStyle='rgba(230,230,255,0.92)';
          ctx.shadowColor='rgba(180,170,255,0.85)';
        }
        ctx.shadowBlur=(countdownAttack.type==='slash'?26:22)*scaleAvg;
        ctx.fillText(String(remain), canvas.width/2, anchorY*scaleY);
        ctx.restore();
      }
    }
    if(reaperBlackHoleAttack){
      const atk=reaperBlackHoleAttack;
      if(atk.projectile){
        const trail=atk.projectileTrail||[];
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        for(const t of trail){
          const age=Math.max(0, Math.min(1,(now-t.t)/400));
          const alpha=1-age;
          const r=atk.projectile.radius*((scaleX+scaleY)/2)*0.6*alpha;
          ctx.fillStyle=`rgba(150,90,220,${0.18*alpha})`;
          ctx.beginPath();
          ctx.arc(t.x*scaleX, t.y*scaleY, r, 0, Math.PI*2);
          ctx.fill();
        }
        const rad=atk.projectile.radius*((scaleX+scaleY)/2)*(1+0.15*Math.sin(now/120));
        const grad=ctx.createRadialGradient(atk.projectile.x*scaleX, atk.projectile.y*scaleY, rad*0.2, atk.projectile.x*scaleX, atk.projectile.y*scaleY, rad);
        grad.addColorStop(0,'rgba(20,10,40,0.9)');
        grad.addColorStop(0.4,'rgba(130,60,200,0.75)');
        grad.addColorStop(1,'rgba(255,140,220,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(atk.projectile.x*scaleX, atk.projectile.y*scaleY, rad, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      if(atk.stage==='hole' && atk.hole){
        const hole=atk.hole;
        const life=Math.max(1, (hole.end||now) - (hole.start||now));
        const age=Math.max(0, Math.min(1, (now - (hole.start||now))/life));
        const spinDir=hole.spinDir||1;
        const scaleAvg=(scaleX+scaleY)/2;
        const baseR=(hole.radius||160)*scaleAvg;
        const x=hole.x*scaleX;
        const y=hole.y*scaleY;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const warp=ctx.createRadialGradient(x,y,baseR*0.32,x,y,baseR*1.3);
        warp.addColorStop(0,`rgba(30,12,60,${0.85-0.35*age})`);
        warp.addColorStop(0.45,`rgba(110,60,200,${0.65-0.25*age})`);
        warp.addColorStop(0.78,'rgba(220,200,255,0.28)');
        warp.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=warp;
        ctx.beginPath();
        ctx.arc(x,y,baseR*1.3,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle=`rgba(230,210,255,${0.32*(1-age)+0.12*Math.sin(now/160)})`;
        ctx.lineWidth=5.2*scaleAvg;
        ctx.beginPath();
        ctx.arc(x,y,baseR*1.08,0,Math.PI*2);
        ctx.stroke();
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate((now/220 + (hole.vortexPhase||0))*spinDir);
        const armCount=5;
        for(let a=0;a<armCount;a++){
          const theta=a*(Math.PI*2/armCount);
          const armR=baseR*(0.46 + a*0.08);
          ctx.beginPath();
          ctx.strokeStyle=`rgba(255,230,255,${(0.18-0.02*a)*(1-age)})`;
          ctx.lineWidth=(2.4+a*0.6)*scaleAvg;
          ctx.arc(0,0,armR,theta,theta+Math.PI*0.55);
          ctx.stroke();
        }
        ctx.restore();
        ctx.restore();
      }
    }
    for(const af of reaperAfterimages){
      const life=af.life||600;
      const prog=Math.max(0, Math.min(1, (now-af.t0)/life));
      const alpha=(af.emerge?prog:1-prog)*0.4;
      const scale=(af.scale||1)*(1+(af.emerge?0.2*prog:0));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.translate(af.x*scaleX, af.y*scaleY);
      ctx.scale(scale, scale);
      ctx.globalAlpha=alpha;
      ctx.fillStyle='rgba(200,150,255,0.6)';
      ctx.beginPath();
      ctx.ellipse(0,0, reaperBoss?reaperBoss.w*0.28*((scaleX+scaleY)/2):70*((scaleX+scaleY)/2), reaperBoss?reaperBoss.h*0.36*((scaleX+scaleY)/2):90*((scaleX+scaleY)/2),0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    if(reaperBoss && (reaperPhase==='active' || reaperPhase==='intro' || reaperPhase==='dying')){
      drawReaperBoss(reaperBoss, now);
    }else if(reaperPhase==='intro' && reaperAnchor){
      const cx=(reaperAnchor.x+reaperAnchor.w/2)*scaleX;
      const cy=(reaperAnchor.y+reaperAnchor.h+80)*scaleY;
      const rad=Math.max(reaperAnchor.w, reaperAnchor.h)*1.3*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      g.addColorStop(0,'rgba(200,140,255,0.18)');
      g.addColorStop(1,'rgba(200,140,255,0)');
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    if(reaperTargetHighlightUntil && now<reaperTargetHighlightUntil){
      const bounds=getReaperBounds();
      if(bounds){
        const a=Math.max(0, Math.min(1,(reaperTargetHighlightUntil-now)/600));
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle=`rgba(255,160,230,${0.6*a})`;
        ctx.lineWidth=4;
        drawRoundedRect(bounds.x-6,bounds.y-6,bounds.w+12,bounds.h+12,16);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function drawReaperMarquee(){
    if(!reaperMarquee) return;
    const now=performance.now();
    const {start, fadeStart, end, text} = reaperMarquee;
    const style=reaperMarquee.style||'marquee';
    if(now>=end){ reaperMarquee=null; return; }
    let alpha=1;
    if(style!=='victorySolid' && now>fadeStart){ alpha = Math.max(0, 1 - (now - fadeStart)/(end - fadeStart||1)); }
    const scaleAvg=(scaleX+scaleY)/2;
    const textScale=Math.max(0.6, scaleAvg);
    const areaHeight=56;
    const top=Math.max(12, layout().top - areaHeight - 14);
    const x=40;
    const width=1100-80;
    const radius=18;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, top, width, areaHeight, radius);
    if(style==='victorySolid'){
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(46,32,84,0.96)');
      grad.addColorStop(1,'rgba(18,18,54,0.96)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,210,230,0.75)';
      ctx.lineWidth=2.2;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      ctx.fillStyle='#ffe9fa';
      const fontSize=Math.max(24, Math.round(30*textScale));
      ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,190,230,0.6)';
      ctx.shadowBlur=18*textScale;
      ctx.fillText(text, (x+width/2)*scaleX, (top+areaHeight/2)*scaleY);
      ctx.shadowBlur=0;
    }else{
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(34,26,70,0.92)');
      grad.addColorStop(1,'rgba(20,16,46,0.94)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(200,180,255,0.85)';
      ctx.lineWidth=2;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+12;
      const innerY=top+6;
      const innerW=width-24;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.save();
      ctx.clip();
      ctx.fillStyle='#fef7ff';
      const fontSize=Math.max(18, Math.round(24*textScale));
      ctx.font=`${fontSize}px 'Noto Sans TC','Playfair Display',sans-serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(200,160,255,0.5)';
      ctx.shadowBlur=12*textScale;
      ctx.fillText(text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawReaperHPBar(){
    if((reaperPhase!=='active' && reaperPhase!=='dying') || !reaperBoss) return;
    const L=layout();
    const barW=32;
    const maxH=700-(L.top+80);
    const barH=Math.max(200, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, reaperBoss.hp/reaperBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(40,20,60,0.96)');
    frameGrad.addColorStop(1,'rgba(24,12,42,0.92)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(210,160,255,0.6)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(12,10,26,0.92)');
    bg.addColorStop(1,'rgba(26,18,40,0.88)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(255,110,160,0.22)');
      fillGrad.addColorStop(0.35,'rgba(255,120,200,0.6)');
      fillGrad.addColorStop(1,'rgba(255,220,250,0.95)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    ctx.strokeStyle='rgba(255,255,255,0.14)';
    ctx.lineWidth=1;
    const segments=reaperBoss.maxHp;
    const step=innerH/segments;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - step*i)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS 暗黑死神', reaperBoss.hp, reaperBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(40,20,60,0.95)',
      bgBottom:'rgba(24,12,42,0.9)',
      frame:'rgba(210,160,255,0.7)',
      glow:'rgba(200,160,255,0.55)',
      textPrimary:'#eae0ff',
      textSecondary:'#f5ebff'
    });
    ctx.restore();
  }

  function drawReaperHUD(){
    drawReaperMarquee();
    drawReaperHPBar();
  }

  // === 第15關 毀滅之龍 Boss ===
  function startDragonReveal(fromBrick){
    if(level!==15) return;
    if(dragonPhase!=='awaiting' && dragonPhase!=='intro') return;
    const now=performance.now();
    dragonPhase='intro';
    let source=fromBrick || dragonPlaceholder;
    if(fromBrick){
      const idx=bricks.indexOf(fromBrick);
      if(idx>=0) bricks.splice(idx,1);
    }else if(dragonPlaceholder){
      const idx=bricks.indexOf(dragonPlaceholder);
      if(idx>=0) bricks.splice(idx,1);
    }
    dragonPlaceholder=null;
    if(!source){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      const w=brickW*2 + L.pad;
      const h=brickH*2 + L.pad;
      source={x:L.pad + bx*(brickW+L.pad), y:L.top, w, h};
    }
    dragonAnchor={x:source.x, y:source.y, w:source.w, h:source.h};
    const cx=dragonAnchor.x+dragonAnchor.w/2;
    const cy=dragonAnchor.y+dragonAnchor.h/2;
    spawnParticles(cx,cy,'#fff2c7',120,2.8,4.2,4.5);
    spawnParticles(cx,cy,'#ffbc5e',90,2.4,3.8,4.0);
    spawnParticles(cx,cy,'#ffd36f',80,2.0,3.2,3.6);
    dragonBursts.push({type:'ring',x:cx,y:cy,r0:30,r1:460,width:22,t0:now,life:1600,color:'255,215,120'});
    dragonBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:320,t0:now,life:1400,color:'255,210,140'});
    dragonBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:220,t0:now,life:1200,color:'255,240,200'});
    playSFX('fireExplosion');
    screenShake=Math.max(screenShake,24);
    dragonRevealScheduled = now + 1000;
  }

  function activateDragonBoss(){
    if(level!==15) return;
    if(dragonPhase!=='intro' || dragonBoss) return;
    const L=layout();
    let anchor=dragonAnchor;
    if(!anchor){
      const bx=Math.floor(L.cols/2)-1;
      const w=brickW*2 + L.pad;
      const h=brickH*2 + L.pad;
      anchor={x:L.pad + bx*(brickW+L.pad), y:L.top, w, h};
      dragonAnchor=anchor;
    }
    const cx=anchor.x+anchor.w/2;
    const baseY=Math.max(L.top + 160, anchor.y + anchor.h + 140);
    const now=performance.now();
    dragonBoss={
      x:cx,
      y:baseY,
      baseY,
      w:120,
      h:75,
      hp:DRAGON_MAX_HP,
      maxHp:DRAGON_MAX_HP,
      wingPhase:Math.random()*Math.PI*2,
      hoverPhase:Math.random()*Math.PI*2,
      moveTarget:null,
      nextMove:now+800,
      pose:null,
      hitCooldownUntil:0,
      hitFlashUntil:0,
      lastUpdate:now,
      petrifyCharge:null
    };
    dragonPhase='active';
    dragonBursts.push({type:'halo',x:cx,y:baseY-20,r0:80,r1:420,t0:now,life:1800,color:'255,215,140'});
    dragonMarquee={text:'毀滅之龍現身了!', start:now, fadeStart:now+3200, end:now+3600, style:'alert'};
    scheduleNextTreasureBrick(now);
  }

  function dragonImpactPoint(fromX, fromY){
    if(!dragonBoss) return {x:fromX, y:fromY};
    const bounds=getDragonBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const dx=dragonBoss.x - fromX;
    const dy=dragonBoss.y - fromY;
    if(dx===0 && dy===0) return {x:dragonBoss.x, y:dragonBoss.y};
    const halfW=bounds.w/2;
    const halfH=bounds.h/2;
    const scale=Math.sqrt((dx*dx)/(halfW*halfW) + (dy*dy)/(halfH*halfH));
    if(!isFinite(scale) || scale===0) return {x:dragonBoss.x, y:dragonBoss.y};
    const t=1/scale;
    return {x:dragonBoss.x - dx*t, y:dragonBoss.y - dy*t};
  }

  function dragonClampPoint(x, y){
    const bounds=getDragonBounds();
    if(!bounds) return {x, y};
    return {
      x: Math.max(bounds.x, Math.min(x, bounds.x + bounds.w)),
      y: Math.max(bounds.y, Math.min(y, bounds.y + bounds.h))
    };
  }

  function damageDragonBoss(amount=1, source='generic', impact){
    if(dragonPhase!=='active' || !dragonBoss) return false;
    const now=performance.now();
    if(dragonBoss.hitCooldownUntil && now<dragonBoss.hitCooldownUntil) return false;
    dragonBoss.hitCooldownUntil=now+140;
    dragonBoss.hp=Math.max(0, dragonBoss.hp-amount);
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    dragonBoss.hitFlashUntil=now+220;
    const ix=(impact&&impact.x!=null)?impact.x:dragonBoss.x;
    const iy=(impact&&impact.y!=null)?impact.y:dragonBoss.y;
    dragonBursts.push({type:'ember',x:ix,y:iy,t0:now,life:600});
    spawnParticles(ix,iy,'#ffd97a',18,2.0,3.0,3.2);
    screenShake=Math.max(screenShake,4);
    if(dragonBoss.hp<=0){ defeatDragonBoss(); }
    return true;
  }

  function defeatDragonBoss(){
    if(dragonPhase==='dying' || dragonPhase==='defeated') return;
    const now=performance.now();
    dragonPhase='dying';
    dragonMarquee={text:'成功擊殺Boss: 毀滅之龍!', start:now, fadeStart:now+5000, end:now+5000, style:'victorySolid'};
    dragonDeathAnim={start:now, fallDuration:3000, bigExplosionStart:now+3000, bigExplosionEnd:now+5000, lastSmallBurst:0, bigExplosionTriggered:false, finished:false};
    dragonAttackState=null;
    dragonDeathRayOrbs.length=0;
    dragonDeathRayBeams.length=0;
    if(dragonBoss){
      dragonBoss.petrifyCharge=null;
      const cx=dragonBoss.x, cy=dragonBoss.y;
      dragonBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:360,t0:now,life:1500,color:'255,220,150'});
      dragonBursts.push({type:'ring',x:cx,y:cy,r0:60,r1:520,width:26,t0:now,life:1800,color:'255,210,130'});
    }
    addScore(BOSS_DEFEAT_SCORE.dragon);
    stats.bossKills++;
    updateHUD();
    screenShake=Math.max(screenShake,20);
    playSFX('fireExplosion');
    const dropX=(dragonBoss?dragonBoss.x:550)-12;
    const dropY=dragonBoss?dragonBoss.y:300;
    spawnPower(dropX, dropY, {forceType:'NINE'});
  }

  function updateDragonBoss(){
    if(level!==15) return;
    const now=performance.now();
    if(dragonPhase==='intro' && !dragonBoss && dragonRevealScheduled && now>=dragonRevealScheduled){
      activateDragonBoss();
    }
    if(dragonPhase==='active' && dragonBoss){
      const dt = now - (dragonBoss.lastUpdate||now);
      dragonBoss.lastUpdate=now;
      const handledMovement = updateDragonAttackState(now, dt);
      if(!handledMovement){
        if(!dragonBoss.moveTarget || now>=dragonBoss.nextMove){
          const L=layout();
          const minX=170;
          const maxX=930;
          const minY=L.top+140;
          const maxY=Math.min(L.top+300, dragonBoss.baseY+80);
          dragonBoss.moveTarget={x:minX+Math.random()*(maxX-minX), y:minY+Math.random()*(maxY-minY)};
          dragonBoss.nextMove=now+2200+Math.random()*1600;
        }
        if(dragonBoss.moveTarget){
          const speed=Math.min(0.18, (dt/1000)*0.6);
          dragonBoss.x += (dragonBoss.moveTarget.x - dragonBoss.x)*speed;
          dragonBoss.baseY += (dragonBoss.moveTarget.y - dragonBoss.baseY)*speed;
        }
      }
      dragonBoss.hoverPhase += dt*0.002;
      dragonBoss.y = dragonBoss.baseY + Math.sin(dragonBoss.hoverPhase)*10;
      dragonBoss.wingPhase += dt*0.0065;
    }else if(dragonPhase==='dying'){
      const anim=dragonDeathAnim;
      if(anim){
        if(dragonBoss){
          if(now<anim.bigExplosionStart){
            const dur=anim.fallDuration||3000;
            const prog=Math.max(0, Math.min(1,(now-anim.start)/dur));
            const drop=160;
            dragonBoss.y = dragonBoss.baseY + prog*drop;
            if(!anim.lastSmallBurst || now-anim.lastSmallBurst>140){
              anim.lastSmallBurst=now;
              const ox=(Math.random()-0.5)*dragonBoss.w*0.7;
              const oy=(Math.random()-0.4)*dragonBoss.h*0.7;
              const px=dragonBoss.x+ox;
              const py=dragonBoss.y+oy;
              dragonBursts.push({type:'spark',x:px,y:py,r0:0,r1:240,t0:now,life:900,color:'255,210,150'});
              spawnParticles(px,py,'#ffdd9b',24,2.2,3.4,3.6);
            }
          }else if(now<anim.bigExplosionEnd){
            if(!anim.bigExplosionTriggered){
              anim.bigExplosionTriggered=true;
              const cx=dragonBoss.x, cy=dragonBoss.y;
              dragonBursts.push({type:'mega',x:cx,y:cy,r0:140,r1:720,t0:now,life:2000});
              dragonBursts.push({type:'halo',x:cx,y:cy,r0:160,r1:680,t0:now,life:2400,color:'255,220,150'});
              spawnParticles(cx,cy,'#fff2d6',300,3.8,5.6,6.0);
              spawnParticles(cx,cy,'#ffe4a6',200,3.4,4.8,5.2);
              screenShake=Math.max(screenShake,32);
              playSFX('fireExplosion');
            }
          }else{
            dragonBoss=null;
          }
        }else if(!anim.finished && now>=anim.bigExplosionEnd){
          anim.finished=true;
          dragonDefeatedAt=now;
          dragonPhase='defeated';
          dragonDeathAnim=null;
        }
      }
    }
    for(let i=dragonBursts.length-1;i>=0;i--){ const fx=dragonBursts[i]; const life=fx.life||1200; if(now>fx.t0+life){ dragonBursts.splice(i,1); } }
    if(dragonMarquee && now>=dragonMarquee.end){ dragonMarquee=null; }
  }

  function renderDragonBody(boss, now){
    if(dragonAttackState && dragonAttackState.hideDragon){ return; }
    const scaleAvg=(scaleX+scaleY)/2;
    const bodyScale=boss.w/260;
    ctx.save();
    ctx.translate(boss.x*scaleX, boss.y*scaleY);
    ctx.scale(scaleAvg*bodyScale, scaleAvg*bodyScale);
    const wingCycle=boss.wingPhase;
    const sine=Math.sin(wingCycle);
    const downstroke=Math.pow(Math.max(0, sine), 1.6);
    const upstroke=Math.pow(Math.max(0, -sine), 1.2);
    const flap=(downstroke*0.65 - upstroke*0.42) + Math.sin(now*0.0032)*0.08;
    const flash = boss.hitFlashUntil && now<boss.hitFlashUntil;
    const wingLift = 26*flap;
    const wingSpread = 1.38 + flap*0.42;
    const metalGradient=(x0,y0,x1,y1)=>{
      const g=ctx.createLinearGradient(x0,y0,x1,y1);
      g.addColorStop(0, flash?'#fff9ed':'#fcefd6');
      g.addColorStop(0.35, flash?'#ffe4a4':'#f5c86f');
      g.addColorStop(0.7, flash?'#ffc660':'#d88d35');
      g.addColorStop(1, flash?'#ffad40':'#a95c18');
      return g;
    };
    const darkMetal=(alpha=1)=>`rgba(110,64,22,${(flash?0.55:0.38)*alpha})`;

    const tailSwing=Math.sin(now/340 + boss.wingPhase*1.6)*5.8;
    const charge=boss.petrifyCharge;
    let chargeProgress=0;
    if(charge){
      const duration=(charge.end||0)-(charge.start||0) || 1;
      chargeProgress=Math.max(0, Math.min(1,(now-charge.start)/duration));
    }
    if(chargeProgress>0){
      const pulse=0.55+Math.sin(now/140)*0.45;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.shadowColor=`rgba(255,210,160,${0.55+0.35*chargeProgress})`;
      ctx.shadowBlur=36+chargeProgress*32;

      const auraRadius=220 + 160*chargeProgress + pulse*30;
      const coreGlow=ctx.createRadialGradient(0,-32,0,0,-32,auraRadius);
      coreGlow.addColorStop(0,'rgba(255,244,222,0.95)');
      coreGlow.addColorStop(0.35,'rgba(255,208,150,0.8)');
      coreGlow.addColorStop(0.75,'rgba(255,150,60,0.36)');
      coreGlow.addColorStop(1,'rgba(255,90,30,0)');
      ctx.fillStyle=coreGlow;
      ctx.globalAlpha=0.55+0.4*chargeProgress;
      ctx.beginPath();
      ctx.ellipse(0,8,auraRadius*0.55,auraRadius*0.78,0,0,Math.PI*2);
      ctx.fill();

      const haloRadius=140 + 120*chargeProgress + pulse*18;
      ctx.globalAlpha=0.85;
      ctx.lineWidth=6.5 + chargeProgress*3.5;
      ctx.strokeStyle=`rgba(255,220,170,${0.55+0.3*pulse})`;
      ctx.beginPath();
      ctx.ellipse(0,-46,haloRadius*0.6,haloRadius*0.84,0,0,Math.PI*2);
      ctx.stroke();

      const filamentCount=6;
      for(let i=0;i<filamentCount;i++){
        const ang=(now/420) + i*(Math.PI*2/filamentCount);
        const reach=160 + chargeProgress*180 + pulse*20;
        ctx.save();
        ctx.rotate(ang);
        ctx.translate(0,-24);
        ctx.globalAlpha=0.55+0.35*chargeProgress;
        ctx.strokeStyle=`rgba(255,228,190,${0.45+0.25*pulse})`;
        ctx.lineWidth=4.5 + chargeProgress*2.8;
        ctx.beginPath();
        ctx.moveTo(0,-28);
        ctx.quadraticCurveTo(reach*0.28,-reach*0.62,reach,0);
        ctx.quadraticCurveTo(reach*0.36,reach*0.48,reach*0.08,reach*0.74);
        ctx.stroke();
        ctx.restore();
      }

      const sparkCount=12;
      ctx.globalAlpha=0.65;
      for(let i=0;i<sparkCount;i++){
        const ang=(now/260) + i*(Math.PI*2/sparkCount);
        const radius=haloRadius + 50 + Math.sin(now/180 + i)*26*chargeProgress;
        const sx=Math.cos(ang)*radius;
        const sy=Math.sin(ang)*radius*0.88 - 18;
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(ang);
        ctx.fillStyle='rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.ellipse(0,0,6 + chargeProgress*3.2,2.6 + chargeProgress*1.4,0,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }
    ctx.save();
    ctx.translate(0,62);
    const tailBaseSwing=tailSwing;
    const tailRipple=Math.sin(now/260 + boss.wingPhase*2.2)*3.6;
    ctx.rotate(tailBaseSwing*Math.PI/180);
    const tailSegments=12;
    const segmentSpacing=22;
    const tailLength=tailSegments*segmentSpacing;
    for(let i=0;i<tailSegments;i++){
      const prog=i/(tailSegments-1);
      const segOffset=i*segmentSpacing;
      const segWidth=42 - prog*18;
      const segHeight=28 - prog*10;
      ctx.save();
      ctx.translate(0,segOffset);
      ctx.rotate((tailRipple*prog)*Math.PI/180);
      if(i%2===0){
        const outerW=segWidth*0.52;
        const outerH=segHeight*0.5;
        const innerW=outerW*0.56;
        const innerH=outerH*0.58;
        ctx.fillStyle=metalGradient(-outerW, -outerH*0.6, outerW, outerH*1.2);
        ctx.beginPath();
        ctx.ellipse(0,0,outerW,outerH,0,0,Math.PI*2);
        ctx.ellipse(0,0,innerW,innerH,0,0,Math.PI*2,true);
        ctx.fill('evenodd');
        ctx.strokeStyle=`rgba(255,234,208,${flash?0.9:0.72})`;
        ctx.lineWidth=1.8;
        ctx.beginPath();
        ctx.ellipse(0,0,outerW,outerH,0,0,Math.PI*2);
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.85);
        ctx.lineWidth=1.2;
        ctx.beginPath();
        ctx.ellipse(0,0,innerW*1.02,innerH*1.02,0,0,Math.PI*2);
        ctx.stroke();
      }else{
        const bladeW=segWidth*0.6;
        const bladeH=segHeight*1.26;
        ctx.fillStyle=metalGradient(-bladeW*0.8, -bladeH*0.4, bladeW*0.9, bladeH*0.9);
        ctx.beginPath();
        ctx.moveTo(-bladeW*0.46,-bladeH*0.2);
        ctx.quadraticCurveTo(-bladeW*0.62,bladeH*0.38,-bladeW*0.2,bladeH*0.84);
        ctx.lineTo(bladeW*0.2,bladeH*0.84);
        ctx.quadraticCurveTo(bladeW*0.62,bladeH*0.34,bladeW*0.46,-bladeH*0.2);
        ctx.quadraticCurveTo(0,-bladeH*0.82,-bladeW*0.46,-bladeH*0.2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,238,214,${flash?0.92:0.76})`;
        ctx.lineWidth=1.9;
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.88);
        ctx.lineWidth=1.1;
        ctx.beginPath();
        ctx.moveTo(0,-bladeH*0.72);
        ctx.lineTo(0,bladeH*0.74);
        ctx.moveTo(-bladeW*0.24,-bladeH*0.12);
        ctx.lineTo(-bladeW*0.06,bladeH*0.62);
        ctx.moveTo(bladeW*0.24,-bladeH*0.12);
        ctx.lineTo(bladeW*0.06,bladeH*0.62);
        ctx.stroke();
      }
      ctx.restore();

      if(i<tailSegments-1){
        const nodeProg=(i+0.5)/(tailSegments-1);
        ctx.save();
        ctx.translate(0,segOffset+segmentSpacing*0.5);
        ctx.rotate((tailRipple*nodeProg)*Math.PI/180);
        const nodeGrad=metalGradient(-12,-8,12,14);
        ctx.fillStyle=nodeGrad;
        ctx.beginPath();
        ctx.ellipse(0,0,8.4,6.2,0,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle=`rgba(255,244,220,${flash?0.94:0.78})`;
        ctx.lineWidth=1.2;
        ctx.stroke();
        ctx.strokeStyle=`rgba(255,212,150,${flash?0.7:0.56})`;
        ctx.lineWidth=0.9;
        ctx.beginPath();
        ctx.ellipse(0,0,5.4,3.8,0,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.save();
    ctx.translate(0,tailLength+12);
    const spearAngle=tailBaseSwing*0.38 + Math.sin(now/320 + boss.wingPhase*2.6)*6;
    ctx.rotate(spearAngle*Math.PI/180);
    const spearGrad=metalGradient(-22,-36,22,68);
    ctx.fillStyle=spearGrad;
    ctx.beginPath();
    ctx.moveTo(-10,-12);
    ctx.quadraticCurveTo(-22,28,-6,74);
    ctx.lineTo(0,92);
    ctx.lineTo(6,74);
    ctx.quadraticCurveTo(22,28,10,-12);
    ctx.quadraticCurveTo(0,-42,-10,-12);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,236,210,${flash?0.92:0.76})`;
    ctx.lineWidth=2.2;
    ctx.stroke();
    ctx.strokeStyle=darkMetal(0.88);
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(0,-28);
    ctx.lineTo(0,76);
    ctx.stroke();
    for(const side of [-1,1]){
      ctx.beginPath();
      ctx.moveTo(side*4,42);
      ctx.lineTo(side*28,14);
      ctx.lineTo(side*10,68);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    ctx.strokeStyle=`rgba(255,246,228,${flash?0.92:0.8})`;
    ctx.lineWidth=1.1;
    ctx.beginPath();
    ctx.moveTo(-12,52);
    ctx.quadraticCurveTo(0,82,12,52);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    function drawWing(side){
      ctx.save();
      ctx.scale(side,1);
      ctx.translate(-42,-34);
      ctx.rotate((-32 + flap*18)*Math.PI/180);

      // wing root armor
      ctx.fillStyle=metalGradient(-68,-60,42,110);
      ctx.beginPath();
      ctx.moveTo(-60,-34);
      ctx.lineTo(16,-20);
      ctx.lineTo(22,36);
      ctx.lineTo(-48,68);
      ctx.lineTo(-82,30);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,235,210,${flash?0.9:0.74})`;
      ctx.lineWidth=2.6;
      ctx.stroke();

      const outerBlades=[
        {base:[-24,-14], ctrl:[-150,-148-wingLift*0.5], tip:[-304,-168-wingLift*0.74], width:54, curvature:34, tipWidth:20},
        {base:[-22,10], ctrl:[-188,-112-wingLift*0.32], tip:[-312,-94-wingLift*0.38], width:46, curvature:28, tipWidth:18},
        {base:[-18,36], ctrl:[-228,-52-wingLift*0.16], tip:[-298,26+wingLift*0.04], width:40, curvature:26, tipWidth:16},
        {base:[-14,60], ctrl:[-234,40+wingLift*0.22], tip:[-262,112+wingLift*0.28], width:36, curvature:24, tipWidth:14},
        {base:[-10,84], ctrl:[-202,104+wingLift*0.34], tip:[-226,168+wingLift*0.42], width:32, curvature:22, tipWidth:12}
      ];
      const innerBlades=[
        {base:[-18,4], ctrl:[-120,-46-wingLift*0.22], tip:[-182,-12-wingLift*0.18], width:28, curvature:18, tipWidth:10, serrations:4, serrationDepth:10},
        {base:[-16,24], ctrl:[-148,-4-wingLift*0.12], tip:[-190,42+wingLift*0.04], width:26, curvature:16, tipWidth:10, serrations:5, serrationDepth:9},
        {base:[-12,46], ctrl:[-162,48+wingLift*0.18], tip:[-188,106+wingLift*0.24], width:24, curvature:14, tipWidth:9, serrations:5, serrationDepth:8},
        {base:[-10,68], ctrl:[-150,96+wingLift*0.28], tip:[-174,150+wingLift*0.34], width:22, curvature:12, tipWidth:8, serrations:6, serrationDepth:7},
        {base:[-8,88], ctrl:[-138,138+wingLift*0.36], tip:[-158,188+wingLift*0.46], width:20, curvature:11, tipWidth:7, serrations:6, serrationDepth:6}
      ];

      function drawBladeLayer(blades, palette){
        for(const blade of blades){
          const baseX=blade.base[0];
          const baseY=blade.base[1];
          const ctrlX=blade.ctrl[0]*wingSpread;
          const ctrlY=blade.ctrl[1];
          const tipX=blade.tip[0]*wingSpread;
          const tipY=blade.tip[1];
          const angle=Math.atan2(tipY-baseY, tipX-baseX);
          const perpX=-Math.sin(angle);
          const perpY=Math.cos(angle);
          const leadingBaseX=baseX+perpX*blade.width*0.58;
          const leadingBaseY=baseY+perpY*blade.width*0.58;
          const trailingBaseX=baseX-perpX*blade.width*0.44;
          const trailingBaseY=baseY-perpY*blade.width*0.44;
          const leadingCtrlX=ctrlX+perpX*(blade.curvature||0);
          const leadingCtrlY=ctrlY+perpY*(blade.curvature||0);
          const trailingCtrlX=ctrlX-perpX*((blade.curvature||0)*0.74);
          const trailingCtrlY=ctrlY-perpY*((blade.curvature||0)*0.74);
          const leadingTipX=tipX+perpX*(blade.tipWidth||blade.width*0.32);
          const leadingTipY=tipY+perpY*(blade.tipWidth||blade.width*0.32);
          const trailingTipX=tipX-perpX*(blade.tipWidth||blade.width*0.22);
          const trailingTipY=tipY-perpY*(blade.tipWidth||blade.width*0.22);

          const grad=ctx.createLinearGradient(leadingBaseX, leadingBaseY, leadingTipX, leadingTipY);
          grad.addColorStop(0, palette.light);
          grad.addColorStop(0.45, palette.mid);
          grad.addColorStop(1, palette.edge);
          ctx.fillStyle=grad;

          ctx.beginPath();
          ctx.moveTo(leadingBaseX, leadingBaseY);
          ctx.quadraticCurveTo(leadingCtrlX, leadingCtrlY, leadingTipX, leadingTipY);
          if(blade.serrations){
            ctx.lineTo(trailingTipX, trailingTipY);
            for(let i=blade.serrations;i>=1;i--){
              const t=i/blade.serrations;
              const px=trailingTipX+(trailingBaseX-trailingTipX)*t;
              const py=trailingTipY+(trailingBaseY-trailingTipY)*t;
              const offset=(i%2===0?-1:1)*(blade.serrationDepth||6);
              ctx.lineTo(px+perpX*offset*0.6, py+perpY*offset*0.6);
            }
            ctx.lineTo(trailingBaseX, trailingBaseY);
          }else{
            ctx.quadraticCurveTo(trailingCtrlX, trailingCtrlY, trailingBaseX, trailingBaseY);
          }
          ctx.lineTo(baseX+perpX*blade.width*0.12, baseY+perpY*blade.width*0.12);
          ctx.closePath();
          ctx.fill();

          ctx.strokeStyle=palette.outline;
          ctx.lineWidth=2.2;
          ctx.stroke();

          ctx.strokeStyle=darkMetal();
          ctx.lineWidth=1.4;
          ctx.beginPath();
          ctx.moveTo(baseX, baseY);
          ctx.quadraticCurveTo(ctrlX, ctrlY+(palette.veinLift||0), tipX, tipY);
          ctx.stroke();

          ctx.strokeStyle=palette.highlight;
          ctx.lineWidth=1.1;
          ctx.beginPath();
          ctx.moveTo(leadingBaseX, leadingBaseY);
          ctx.quadraticCurveTo(leadingCtrlX, leadingCtrlY, leadingTipX, leadingTipY);
          ctx.stroke();
        }
      }

      const outerPalette={
        light: flash?'#fff3d8':'#f3d1a2',
        mid: flash?'#f6c98d':'#d9a05e',
        edge: flash?'#ca7e40':'#8f5224',
        outline: flash?'#ffe9cc':'#f2c8a0',
        highlight: flash?'#fff2df':'#f4d7b7',
        veinLift:12
      };
      drawBladeLayer(outerBlades, outerPalette);

      // metallic spars between layers
      ctx.save();
      ctx.strokeStyle=metalGradient(-42,4,-210*wingSpread,152+wingLift*0.36);
      ctx.lineWidth=5.4;
      ctx.beginPath();
      ctx.moveTo(-26,6);
      ctx.quadraticCurveTo(-182*wingSpread,-18-wingLift*0.24,-248*wingSpread,86+wingLift*0.28);
      ctx.quadraticCurveTo(-208*wingSpread,128+wingLift*0.32,-188*wingSpread,170+wingLift*0.4);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,204,148,${flash?0.86:0.52})`;
      ctx.lineWidth=3.6;
      ctx.shadowColor=`rgba(255,220,170,${flash?0.72:0.42})`;
      ctx.shadowBlur=18;
      ctx.beginPath();
      ctx.moveTo(-22,12);
      ctx.quadraticCurveTo(-176*wingSpread,-6-wingLift*0.18,-232*wingSpread,94+wingLift*0.3);
      ctx.quadraticCurveTo(-198*wingSpread,136+wingLift*0.34,-176*wingSpread,180+wingLift*0.46);
      ctx.stroke();
      ctx.restore();

      const innerPalette={
        light: flash?'#ffe9c8':'#ecc190',
        mid: flash?'#f0b272':'#c6864b',
        edge: flash?'#b96a32':'#7c3e19',
        outline: flash?'#ffe3c4':'#f0c09a',
        highlight: flash?'#ffeedf':'#f6dcbc',
        veinLift:18
      };
      drawBladeLayer(innerBlades, innerPalette);

      // trailing edge spikes
      ctx.fillStyle=metalGradient(-210*wingSpread,80+wingLift*0.2,-160*wingSpread,160+wingLift*0.4);
      ctx.beginPath();
      ctx.moveTo(-230*wingSpread,94+wingLift*0.32);
      ctx.lineTo(-190*wingSpread,106+wingLift*0.36);
      ctx.lineTo(-204*wingSpread,140+wingLift*0.42);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,230,200,${flash?0.82:0.7})`;
      ctx.lineWidth=1.8;
      ctx.stroke();
      ctx.restore();
    }
    drawWing(-1);
    drawWing(1);

    ctx.shadowColor='rgba(255,218,150,0.62)';
    ctx.shadowBlur=26;
    ctx.fillStyle=metalGradient(-70,-132,70,132);
    ctx.beginPath();
    ctx.moveTo(-70,108);
    ctx.lineTo(-96,36);
    ctx.quadraticCurveTo(-82,-96,0,-134);
    ctx.quadraticCurveTo(82,-96,96,36);
    ctx.lineTo(70,108);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur=0;
    ctx.strokeStyle=`rgba(255,240,212,${flash?0.94:0.8})`;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const chestSegments=[
      {y:-86, h:36, w0:70, w1:96},
      {y:-40, h:32, w0:66, w1:92},
      {y:6, h:32, w0:58, w1:82},
      {y:44, h:34, w0:52, w1:74}
    ];
    for(const seg of chestSegments){
      ctx.fillStyle=metalGradient(-seg.w1, seg.y-seg.h, seg.w1, seg.y+seg.h*1.4);
      ctx.beginPath();
      ctx.moveTo(-seg.w0, seg.y);
      ctx.lineTo(-seg.w1, seg.y+seg.h);
      ctx.quadraticCurveTo(0, seg.y+seg.h*1.32, seg.w1, seg.y+seg.h);
      ctx.lineTo(seg.w0, seg.y);
      ctx.quadraticCurveTo(0, seg.y-seg.h*0.75, -seg.w0, seg.y);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,232,205,${flash?0.9:0.74})`;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.6;
      ctx.beginPath();
      ctx.moveTo(-seg.w0*0.42, seg.y+seg.h*0.12);
      ctx.quadraticCurveTo(0, seg.y+seg.h*0.46, seg.w0*0.42, seg.y+seg.h*0.12);
      ctx.stroke();
    }

    ctx.save();
    ctx.translate(0,-8);
    ctx.fillStyle=metalGradient(-24,-42,24,52);
    ctx.beginPath();
    ctx.moveTo(-20,-12);
    ctx.lineTo(-34,28);
    ctx.quadraticCurveTo(0,52,34,28);
    ctx.lineTo(20,-12);
    ctx.quadraticCurveTo(0,-32,-20,-12);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,228,190,${flash?0.92:0.78})`;
    ctx.lineWidth=2.2;
    ctx.stroke();
    ctx.strokeStyle=`rgba(255,250,220,${flash?0.96:0.82})`;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(0,-20);
    ctx.lineTo(0,32);
    ctx.stroke();
    ctx.restore();

    // lower limbs
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.translate(44,96);
      const gaitPhase=now/420 + side*0.7;
      const legSwing=side*3 + Math.sin(gaitPhase)*5.4;
      const legLift=Math.sin(gaitPhase+Math.PI/2)*3.2;
      ctx.translate(0,-legLift);
      ctx.rotate(legSwing*Math.PI/180);

      const limbGradient=(x0,y0,x1,y1)=>{
        const g=ctx.createLinearGradient(x0,y0,x1,y1);
        g.addColorStop(0, flash?'#fff7e8':'#fbe8c8');
        g.addColorStop(0.38, flash?'#ffd99c':'#f3c27d');
        g.addColorStop(0.72, flash?'#f0a95a':'#d78a3f');
        g.addColorStop(1, flash?'#b86a28':'#8d4616');
        return g;
      };

      // segmented thigh armor
      ctx.fillStyle=limbGradient(-40,-36,42,96);
      ctx.beginPath();
      ctx.moveTo(-34,-26);
      ctx.lineTo(-56,32);
      ctx.lineTo(-24,96);
      ctx.lineTo(18,88);
      ctx.lineTo(38,24);
      ctx.lineTo(6,-32);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,236,210,${flash?0.92:0.76})`;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-24,-12,30,76);
      ctx.beginPath();
      ctx.moveTo(-16,-10);
      ctx.lineTo(-36,40);
      ctx.lineTo(-10,76);
      ctx.lineTo(18,62);
      ctx.lineTo(24,18);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,242,220,${flash?0.94:0.8})`;
      ctx.lineWidth=1.8;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.92);
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(-20,8);
      ctx.lineTo(14,60);
      ctx.moveTo(-32,34);
      ctx.lineTo(-4,82);
      ctx.stroke();

      // articulated knee and shin plates
      ctx.fillStyle=limbGradient(-16,66,36,132);
      ctx.beginPath();
      ctx.moveTo(-12,64);
      ctx.lineTo(-24,110);
      ctx.lineTo(12,126);
      ctx.lineTo(24,82);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,238,214,${flash?0.9:0.74})`;
      ctx.lineWidth=1.9;
      ctx.stroke();

      ctx.fillStyle=limbGradient(4,80,48,144);
      ctx.beginPath();
      ctx.moveTo(14,82);
      ctx.lineTo(46,114);
      ctx.lineTo(22,72);
      ctx.lineTo(6,68);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,246,226,${flash?0.94:0.82})`;
      ctx.lineWidth=1.4;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-20,106,30,174);
      ctx.beginPath();
      ctx.moveTo(-18,102);
      ctx.lineTo(-8,150);
      ctx.lineTo(14,162);
      ctx.lineTo(32,128);
      ctx.lineTo(10,108);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,234,208,${flash?0.88:0.72})`;
      ctx.lineWidth=1.8;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-10,124,26,182);
      ctx.beginPath();
      ctx.moveTo(-4,122);
      ctx.lineTo(-2,158);
      ctx.lineTo(16,156);
      ctx.lineTo(22,124);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,220,${flash?0.92:0.78})`;
      ctx.lineWidth=1.4;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.88);
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo(-8,110);
      ctx.lineTo(12,160);
      ctx.moveTo(-2,144);
      ctx.lineTo(20,138);
      ctx.stroke();

      // armored foot with toe blades
      ctx.fillStyle=limbGradient(-26,150,34,206);
      ctx.beginPath();
      ctx.moveTo(-24,148);
      ctx.lineTo(-16,198);
      ctx.lineTo(12,206);
      ctx.lineTo(40,168);
      ctx.lineTo(16,144);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,238,214,${flash?0.9:0.74})`;
      ctx.lineWidth=1.6;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-8,158,20,202);
      ctx.beginPath();
      ctx.moveTo(-6,154);
      ctx.lineTo(10,198);
      ctx.lineTo(26,180);
      ctx.lineTo(18,150);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,224,${flash?0.94:0.8})`;
      ctx.lineWidth=1.3;
      ctx.stroke();

      const toes=[
        {x:-14,y:186,rot:-16},
        {x:2,y:194,rot:0},
        {x:20,y:186,rot:18}
      ];
      for(const toe of toes){
        ctx.save();
        ctx.translate(toe.x,toe.y);
        ctx.rotate(toe.rot*Math.PI/180);
        ctx.fillStyle=limbGradient(-8,-6,22,48);
        ctx.beginPath();
        ctx.moveTo(-6,-2);
        ctx.quadraticCurveTo(-20,12,-14,36);
        ctx.lineTo(20,40);
        ctx.lineTo(14,4);
        ctx.quadraticCurveTo(4,-10,-6,-2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,246,226,${flash?0.94:0.8})`;
        ctx.lineWidth=1.2;
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.84);
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-2,0);
        ctx.lineTo(12,32);
        ctx.stroke();
        ctx.restore();
      }

      const knuckles=[{x:-18,y:172},{x:0,y:178},{x:18,y:170}];
      for(const node of knuckles){
        ctx.save();
        ctx.translate(node.x,node.y);
        const knuckleGrad=ctx.createRadialGradient(0,0,0,0,0,8);
        knuckleGrad.addColorStop(0, flash?'rgba(255,250,236,0.98)':'rgba(255,244,224,0.86)');
        knuckleGrad.addColorStop(1, flash?'rgba(255,204,150,0.4)':'rgba(240,184,120,0.34)');
        ctx.fillStyle=knuckleGrad;
        ctx.beginPath();
        ctx.ellipse(0,0,7,5,0,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }

    // upper arms and claws
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.translate(72,-12);
      const reachPhase=now/360 + side*0.6;
      const shoulderLift=Math.cos(reachPhase)*3.2;
      const armSwing=-6*side + Math.sin(reachPhase)*6.2;
      ctx.translate(0, shoulderLift);
      ctx.rotate(armSwing*Math.PI/180);

      const armGradient=(x0,y0,x1,y1)=>{
        const g=ctx.createLinearGradient(x0,y0,x1,y1);
        g.addColorStop(0, flash?'#fff9ec':'#fce9ce');
        g.addColorStop(0.3, flash?'#ffe0a8':'#f6c47e');
        g.addColorStop(0.68, flash?'#f0a868':'#d1843c');
        g.addColorStop(1, flash?'#b86a2c':'#823f18');
        return g;
      };

      // layered shoulder armor
      ctx.fillStyle=armGradient(-56,-42,44,118);
      ctx.beginPath();
      ctx.moveTo(-54,-24);
      ctx.lineTo(-80,36);
      ctx.lineTo(-46,116);
      ctx.lineTo(6,86);
      ctx.lineTo(34,18);
      ctx.lineTo(-8,-32);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,238,214,${flash?0.92:0.78})`;
      ctx.lineWidth=2.6;
      ctx.stroke();

      ctx.fillStyle=armGradient(-34,-12,32,74);
      ctx.beginPath();
      ctx.moveTo(-24,-8);
      ctx.lineTo(-48,46);
      ctx.lineTo(-18,90);
      ctx.lineTo(14,70);
      ctx.lineTo(26,18);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,224,${flash?0.94:0.82})`;
      ctx.lineWidth=1.9;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(-30,12);
      ctx.lineTo(8,74);
      ctx.moveTo(-44,40);
      ctx.lineTo(-10,92);
      ctx.stroke();

      // forearm plating
      ctx.fillStyle=armGradient(-30,72,34,152);
      ctx.beginPath();
      ctx.moveTo(-22,68);
      ctx.lineTo(-52,130);
      ctx.lineTo(-22,150);
      ctx.lineTo(8,104);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,240,220,${flash?0.92:0.8})`;
      ctx.lineWidth=1.8;
      ctx.stroke();

      ctx.fillStyle=armGradient(-10,108,28,178);
      ctx.beginPath();
      ctx.moveTo(-12,108);
      ctx.lineTo(-34,170);
      ctx.lineTo(-6,184);
      ctx.lineTo(14,132);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,226,${flash?0.94:0.82})`;
      ctx.lineWidth=1.5;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.86);
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo(-38,150);
      ctx.lineTo(-8,100);
      ctx.moveTo(-18,120);
      ctx.lineTo(6,162);
      ctx.stroke();

      // wrist ring and dorsal spike
      ctx.save();
      ctx.translate(-8,132);
      ctx.scale(1.08,1);
      ctx.fillStyle=armGradient(-28,118,28,150);
      ctx.beginPath();
      ctx.ellipse(0,0,24,10,0,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle=`rgba(255,248,232,${flash?0.96:0.84})`;
      ctx.lineWidth=1.4;
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle=armGradient(-6,120,26,186);
      ctx.beginPath();
      ctx.moveTo(10,138);
      ctx.lineTo(32,152);
      ctx.lineTo(18,116);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,248,230,${flash?0.96:0.84})`;
      ctx.lineWidth=1.2;
      ctx.stroke();

      // hand back spike
      ctx.fillStyle=armGradient(-4,150,30,210);
      ctx.beginPath();
      ctx.moveTo(0,160);
      ctx.lineTo(24,200);
      ctx.lineTo(-6,182);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,246,228,${flash?0.94:0.82})`;
      ctx.lineWidth=1.2;
      ctx.stroke();

      // claws with gleaming edges
      const clawOffsets=[-16,-2,12];
      for(const offset of clawOffsets){
        ctx.save();
        ctx.translate(offset,168);
        ctx.fillStyle=armGradient(-18,-4,18,46);
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.quadraticCurveTo(-16,18,-12,46);
        ctx.lineTo(12,38);
        ctx.lineTo(10,4);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,248,234,${flash?0.96:0.84})`;
        ctx.lineWidth=1.3;
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.84);
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-2,6);
        ctx.lineTo(8,36);
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
    }

    ctx.save();
    ctx.translate(0,-106);
    const neckSegments=4;
    for(let i=0;i<neckSegments;i++){
      const prog=i/(neckSegments-1);
      const segH=26- i*4;
      const segW=34 - prog*8;
      ctx.save();
      ctx.translate(0,i*16);
      ctx.fillStyle=metalGradient(-segW, -segH, segW, segH*1.4);
      ctx.beginPath();
      ctx.moveTo(-segW,-segH*0.4);
      ctx.lineTo(-segW*0.8,segH);
      ctx.lineTo(segW*0.8,segH);
      ctx.lineTo(segW,-segH*0.4);
      ctx.quadraticCurveTo(0,-segH*0.9,-segW,-segH*0.4);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,236,210,${flash?0.9:0.76})`;
      ctx.lineWidth=2;
      ctx.stroke();
      ctx.restore();
    }

    ctx.save();
    ctx.translate(0,-12);
    const headScaleX=0.41;
    const headScaleY=0.38;
    ctx.scale(headScaleX, headScaleY);

    const hornOuterFill=metalGradient(-96,-320,96,-120);
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.fillStyle=hornOuterFill;
      ctx.beginPath();
      ctx.moveTo(22,-188);
      ctx.quadraticCurveTo(88,-246,154,-338);
      ctx.lineTo(136,-356);
      ctx.quadraticCurveTo(90,-350,54,-290);
      ctx.lineTo(28,-188);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=flash?'rgba(255,236,214,0.96)':'rgba(255,214,176,0.82)';
      ctx.lineWidth=2.3;
      ctx.stroke();

      ctx.fillStyle=flash?'rgba(255,250,234,0.9)':'rgba(255,228,188,0.78)';
      ctx.beginPath();
      ctx.moveTo(32,-192);
      ctx.quadraticCurveTo(92,-250,134,-334);
      ctx.lineTo(110,-336);
      ctx.quadraticCurveTo(74,-296,44,-210);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(36,-200);
      ctx.quadraticCurveTo(98,-260,132,-342);
      ctx.stroke();

      ctx.strokeStyle=flash?'rgba(255,210,170,0.88)':'rgba(255,160,100,0.74)';
      ctx.lineWidth=1.1;
      ctx.beginPath();
      ctx.moveTo(50,-214);
      ctx.quadraticCurveTo(104,-274,124,-344);
      ctx.stroke();
      ctx.restore();
    }

    const crownGrad=metalGradient(-70,-188,70,36);
    ctx.fillStyle=crownGrad;
    ctx.beginPath();
    ctx.moveTo(0,-222);
    ctx.lineTo(-44,-198);
    ctx.quadraticCurveTo(-100,-132,-80,-56);
    ctx.quadraticCurveTo(-40,8,-12,40);
    ctx.lineTo(0,56);
    ctx.lineTo(12,40);
    ctx.quadraticCurveTo(40,8,80,-56);
    ctx.quadraticCurveTo(100,-132,44,-198);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,238,214,${flash?0.96:0.82})`;
    ctx.lineWidth=2.2;
    ctx.stroke();

    ctx.strokeStyle=darkMetal(0.92);
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(0,-210);
    ctx.lineTo(0,-34);
    ctx.moveTo(-28,-164);
    ctx.lineTo(-10,-48);
    ctx.moveTo(28,-164);
    ctx.lineTo(10,-48);
    ctx.stroke();

    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.fillStyle=metalGradient(-48,-160,96,-12);
      ctx.beginPath();
      ctx.moveTo(16,-176);
      ctx.lineTo(120,-128);
      ctx.lineTo(94,-62);
      ctx.quadraticCurveTo(46,-8,20,2);
      ctx.lineTo(4,-22);
      ctx.quadraticCurveTo(12,-86,16,-176);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,232,208,${flash?0.94:0.78})`;
      ctx.lineWidth=1.8;
      ctx.stroke();
      ctx.strokeStyle=darkMetal(0.88);
      ctx.lineWidth=1.1;
      ctx.beginPath();
      ctx.moveTo(20,-156);
      ctx.lineTo(78,-66);
      ctx.lineTo(26,-14);
      ctx.stroke();
      ctx.restore();
    }

    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.fillStyle=metalGradient(-36,-36,72,66);
      ctx.beginPath();
      ctx.moveTo(-2,-12);
      ctx.lineTo(46,12);
      ctx.lineTo(62,64);
      ctx.quadraticCurveTo(30,84,6,64);
      ctx.lineTo(-6,20);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,226,${flash?0.96:0.84})`;
      ctx.lineWidth=1.5;
      ctx.stroke();
      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.1;
      ctx.beginPath();
      ctx.moveTo(18,18);
      ctx.lineTo(46,58);
      ctx.stroke();
      ctx.restore();
    }

    ctx.fillStyle=metalGradient(-44,-76,44,52);
    ctx.beginPath();
    ctx.moveTo(-32,-4);
    ctx.lineTo(-68,-46);
    ctx.quadraticCurveTo(-76,-104,-28,-174);
    ctx.quadraticCurveTo(-6,-206,0,-216);
    ctx.quadraticCurveTo(6,-206,28,-174);
    ctx.quadraticCurveTo(76,-104,68,-46);
    ctx.lineTo(32,-4);
    ctx.quadraticCurveTo(0,20,-32,-4);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,240,220,${flash?0.94:0.8})`;
    ctx.lineWidth=2;
    ctx.stroke();

    ctx.strokeStyle=`rgba(255,228,200,${flash?0.9:0.76})`;
    ctx.lineWidth=1.4;
    ctx.beginPath();
    ctx.moveTo(-34,-54);
    ctx.quadraticCurveTo(0,-92,34,-54);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0,-188);
    ctx.quadraticCurveTo(0,-96,0,18);
    ctx.stroke();

    ctx.fillStyle=metalGradient(-32,6,32,78);
    ctx.beginPath();
    ctx.moveTo(-30,12);
    ctx.lineTo(-14,64);
    ctx.quadraticCurveTo(0,88,14,64);
    ctx.lineTo(30,12);
    ctx.lineTo(12,-18);
    ctx.lineTo(-12,-18);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,236,214,${flash?0.92:0.78})`;
    ctx.lineWidth=1.7;
    ctx.stroke();

    ctx.fillStyle='rgba(32,8,6,0.92)';
    ctx.beginPath();
    ctx.moveTo(-26,-6);
    ctx.quadraticCurveTo(0,-34,26,-6);
    ctx.quadraticCurveTo(10,16,0,24);
    ctx.quadraticCurveTo(-10,16,-26,-6);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle=metalGradient(-24,16,24,70);
    ctx.beginPath();
    ctx.moveTo(-20,10);
    ctx.lineTo(-4,56);
    ctx.quadraticCurveTo(0,64,4,56);
    ctx.lineTo(20,10);
    ctx.lineTo(10,-8);
    ctx.lineTo(-10,-8);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,240,224,${flash?0.94:0.82})`;
    ctx.lineWidth=1.3;
    ctx.stroke();

    ctx.fillStyle=flash?'#fffdf0':'#fdf1d2';
    for(const side of [-1,1]){
      for(let i=0;i<3;i++){
        const offset=-12 + i*8;
        ctx.beginPath();
        ctx.moveTo(offset*side,-6);
        ctx.lineTo((offset+3)*side,6);
        ctx.lineTo((offset+1.2)*side,0);
        ctx.closePath();
        ctx.fill();
      }
    }

    ctx.strokeStyle=darkMetal(0.88);
    ctx.lineWidth=1.1;
    ctx.beginPath();
    ctx.moveTo(-18,6);
    ctx.lineTo(-6,48);
    ctx.moveTo(18,6);
    ctx.lineTo(6,48);
    ctx.stroke();

    ctx.save();
    ctx.translate(0,-146);
    const gemGrad=ctx.createRadialGradient(0,0,0,0,0,18);
    gemGrad.addColorStop(0, flash?'#eaffff':'#9effff');
    gemGrad.addColorStop(0.5, flash?'rgba(120,252,255,0.95)':'rgba(60,228,250,0.92)');
    gemGrad.addColorStop(1,'rgba(0,140,180,0)');
    ctx.beginPath();
    ctx.ellipse(0,0,11,16,0,0,Math.PI*2);
    ctx.fillStyle=gemGrad;
    ctx.shadowColor=flash?'rgba(120,252,255,0.86)':'rgba(60,220,240,0.72)';
    ctx.shadowBlur=22;
    ctx.fill();
    ctx.restore();

    ctx.save();
    const eyeGlow=flash?'rgba(255,90,60,0.96)':'rgba(255,36,0,0.92)';

    const drawEyeBase=side=>{
      const isLeft=side<0;
      const tipX=62*side;
      const tipY=-106;
      const innerX=14*side;
      const innerY=-44;
      const lowerX=48*side;
      const lowerY=-18;
      let grad;
      if(isLeft){
        grad=ctx.createLinearGradient(tipX, tipY, innerX, innerY);
        grad.addColorStop(0, flash?'#ff7058':'#ff6a54');
        grad.addColorStop(0.45, flash?'#ff2a00':'#ff2100');
        grad.addColorStop(1, flash?'#a30000':'#450000');
      }else{
        grad=ctx.createLinearGradient(innerX, innerY, tipX, tipY);
        grad.addColorStop(0, flash?'#a30000':'#450000');
        grad.addColorStop(0.55, flash?'#ff2a00':'#ff2100');
        grad.addColorStop(1, flash?'#ff7058':'#ff6a54');
      }
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.moveTo(tipX, tipY);
      ctx.lineTo(innerX, innerY);
      ctx.lineTo(lowerX, lowerY);
      ctx.closePath();
      ctx.shadowColor=eyeGlow;
      ctx.shadowBlur=flash?36:34;
      ctx.fill();
      ctx.strokeStyle=flash?'rgba(255,224,210,0.84)':'rgba(255,120,90,0.66)';
      ctx.lineWidth=1.5;
      ctx.stroke();
      ctx.strokeStyle=flash?'rgba(255,198,184,0.92)':'rgba(255,88,66,0.74)';
      ctx.lineWidth=1.15;
      ctx.beginPath();
      ctx.moveTo(tipX - side*4, tipY+6);
      ctx.lineTo(innerX, innerY-6);
      ctx.stroke();
    };

    const drawEyeHighlights=side=>{
      const isLeft=side<0;
      ctx.shadowBlur=0;
      ctx.fillStyle='rgba(255,255,255,0.42)';
      ctx.beginPath();
      const tipX=62*side;
      const tipY=-106;
      const innerX=14*side;
      const innerY=-44;
      const lowerX=48*side;
      const lowerY=-18;
      const highlightAngle=isLeft?-0.42:0.42;
      const highlightX=tipX - side*10;
      const highlightY=tipY+26;
      ctx.ellipse(highlightX, highlightY, 5.4, 3.4, highlightAngle, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle='rgba(255,255,255,0.28)';
      ctx.beginPath();
      const lowerMidX=(innerX+lowerX)/2;
      const lowerMidY=(innerY+lowerY)/2 + 6;
      const innerHighlightX=innerX + side*6;
      const innerHighlightY=innerY + 8;
      const lowerHighlightX=lowerX + side*4;
      const lowerHighlightY=lowerY + 4;
      ctx.moveTo(lowerMidX, lowerMidY);
      ctx.lineTo(innerHighlightX, innerHighlightY);
      ctx.lineTo(lowerHighlightX, lowerHighlightY);
      ctx.closePath();
      ctx.fill();
    };

    drawEyeBase(-1);
    drawEyeBase(1);
    drawEyeHighlights(-1);
    drawEyeHighlights(1);
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=flash?'rgba(255,132,110,0.35)':'rgba(255,24,0,0.26)';
    ctx.beginPath();
    ctx.ellipse(-30,-46,18,11,-0.32,0,Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(30,-46,18,11,0.32,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.restore();

    ctx.restore();
    ctx.restore();
  }

  function drawDragonAttackVisuals(now){
    if(dragonAttackState && dragonAttackState.type==='deathRay'){
      for(const orb of dragonDeathRayOrbs){
        if(!orb.x || !orb.y) continue;
        const x=orb.x*scaleX;
        const y=orb.y*scaleY;
        const baseR=14*((scaleX+scaleY)/2);
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const grd=ctx.createRadialGradient(x,y,0,x,y,baseR*1.6);
        grd.addColorStop(0,'rgba(255,255,230,0.95)');
        grd.addColorStop(0.4,'rgba(255,236,160,0.85)');
        grd.addColorStop(1,'rgba(255,200,80,0.05)');
        ctx.fillStyle=grd;
        ctx.beginPath();
        ctx.arc(x,y,baseR*1.6,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    for(let i=dragonDeathRayBeams.length-1;i>=0;i--){
      const beam=dragonDeathRayBeams[i];
      if(now>=beam.end){ dragonDeathRayBeams.splice(i,1); continue; }
      const impactAt = beam.impactAt || beam.end;
      const travelSpan = Math.max(1, impactAt - beam.start);
      const travelProg = Math.max(0, Math.min(1, (now - beam.start)/travelSpan));
      const drawX = beam.hit ? beam.x2 : beam.x1 + (beam.x2 - beam.x1)*travelProg;
      const drawY = beam.hit ? beam.y2 : beam.y1 + (beam.y2 - beam.y1)*travelProg;
      const fadeSpan = Math.max(1, beam.end - impactAt);
      const fadeProg = beam.hit ? Math.max(0, Math.min(1, (now - impactAt)/fadeSpan)) : 0;
      const intensity = beam.hit ? 1 - fadeProg : Math.min(1, 0.4 + travelProg*0.6);
      const x1=beam.x1*scaleX, y1=beam.y1*scaleY;
      const x2=drawX*scaleX, y2=drawY*scaleY;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const outer=ctx.createLinearGradient(x1,y1,x2,y2);
      outer.addColorStop(0,'rgba(255,230,150,'+(0.18+0.42*intensity)+')');
      outer.addColorStop(1,'rgba(255,200,120,'+(0.45+0.4*intensity)+')');
      ctx.strokeStyle=outer;
      ctx.lineWidth=10;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      const core=ctx.createLinearGradient(x1,y1,x2,y2);
      core.addColorStop(0,'rgba(255,255,230,'+(0.32+0.52*intensity)+')');
      core.addColorStop(1,'rgba(255,240,180,'+(0.54+0.3*intensity)+')');
      ctx.strokeStyle=core;
      ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      if(!beam.hit){
        const tipR=8*((scaleX+scaleY)/2)*(0.6+travelProg*0.8);
        const tipGrad=ctx.createRadialGradient(x2,y2,0,x2,y2,tipR);
        tipGrad.addColorStop(0,'rgba(255,255,240,'+(0.7+0.3*intensity)+')');
        tipGrad.addColorStop(1,'rgba(255,200,100,0)');
        ctx.fillStyle=tipGrad;
        ctx.beginPath(); ctx.arc(x2,y2,tipR,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
    if(dragonAttackState && dragonAttackState.type==='annihilation'){
      const state=dragonAttackState;
      const L=layout();
      if(state.phase==='challenge'){
        const remain=Math.max(0, state.countdownEnd-now);
        const sec=Math.max(0, Math.ceil(remain/1000));
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.font=`${Math.round(72*((scaleX+scaleY)/2))}px 'Playfair Display',serif`;
        ctx.textAlign='center';
        ctx.textBaseline='top';
        ctx.fillStyle='rgba(255,236,190,0.92)';
        ctx.shadowColor='rgba(255,200,120,0.85)';
        ctx.shadowBlur=24*((scaleX+scaleY)/2);
        let anchorY=Math.max(20, (L.top-60));
        if(dragonMarquee){
          const marqueeHeight=60;
          const marqueeTop=Math.max(16, L.top - marqueeHeight - 14);
          anchorY=Math.max(anchorY, marqueeTop + marqueeHeight + 12, L.top + 12);
        }
        ctx.fillText(String(sec), (1100/2)*scaleX, anchorY*scaleY);
        ctx.restore();
      }else if(state.phase==='detonate'){
        const span=Math.max(1, state.explosionEnd - state.detonateStart);
        const prog=1-Math.max(0, (state.explosionEnd-now)/span);
        const centerX=550*scaleX;
        const L=layout();
        const stageHeight=L.rows*(brickH+L.pad) - L.pad;
        const centerY=(L.top + stageHeight/2)*scaleY;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const maxR=Math.max(canvas.width, canvas.height)*1.2;
        const radial=ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxR);
        radial.addColorStop(0,`rgba(255,255,240,${0.86 - 0.4*prog})`);
        radial.addColorStop(0.35,`rgba(255,240,190,${0.75 - 0.3*prog})`);
        radial.addColorStop(0.7,`rgba(255,210,120,${0.55 - 0.2*prog})`);
        radial.addColorStop(1,'rgba(255,160,60,0)');
        ctx.fillStyle=radial;
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
        ctx.save();
        ctx.globalAlpha=0.32 + 0.22*Math.sin(prog*Math.PI*3);
        ctx.fillStyle='rgba(255,200,120,0.95)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }
    }
  }

  function drawDragonLayer(){
    if(level!==15) return;
    const now=performance.now();
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    if(dragonPhase==='intro' && dragonAnchor){
      const cx=(dragonAnchor.x+dragonAnchor.w/2)*scaleX;
      const cy=(dragonAnchor.y+dragonAnchor.h+80)*scaleY;
      const rad=Math.max(dragonAnchor.w, dragonAnchor.h)*1.3*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      g.addColorStop(0,'rgba(255,220,160,0.18)');
      g.addColorStop(1,'rgba(255,220,160,0)');
      ctx.fillStyle=g;
      ctx.beginPath();
      ctx.arc(cx,cy,rad,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    for(const fx of dragonBursts){
      const life=fx.life||1200;
      const prog=Math.max(0, Math.min(1,(now-fx.t0)/life));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      if(fx.type==='ring'){
        const rad=(fx.r0||0)+((fx.r1||320)-(fx.r0||0))*easeOut(prog);
        ctx.strokeStyle=`rgba(${fx.color||'255,210,140'},${0.4*(1-prog)})`;
        ctx.lineWidth=(fx.width||20)*((scaleX+scaleY)/2)*(1-prog*0.6);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='flare'){
        const rad=(fx.r1||260)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(20, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0,`rgba(${fx.color||'255,215,160'},${0.5*(1-prog)})`);
        grad.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='spark'){
        const rad=(fx.r1||200)*prog*((scaleX+scaleY)/2);
        ctx.strokeStyle=`rgba(${fx.color||'255,210,150'},${0.75*(1-prog)})`;
        ctx.lineWidth=2.6*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.moveTo(fx.x*scaleX-rad, fx.y*scaleY);
        ctx.lineTo(fx.x*scaleX+rad, fx.y*scaleY);
        ctx.moveTo(fx.x*scaleX, fx.y*scaleY-rad*0.6);
        ctx.lineTo(fx.x*scaleX, fx.y*scaleY+rad*0.6);
        ctx.stroke();
      }else if(fx.type==='ember'){
        const size=14*((scaleX+scaleY)/2)*(1-prog);
        ctx.fillStyle=`rgba(255,200,110,${0.7*(1-prog)})`;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, size,0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='halo'){
        const rad=(fx.r0||40)+((fx.r1||320)-(fx.r0||40))*prog;
        ctx.strokeStyle=`rgba(${fx.color||'255,210,140'},${0.25*(1-prog)})`;
        ctx.lineWidth=8*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='mega'){
        const rad=(fx.r1||720)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(40, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0,'rgba(255,250,220,0.95)');
        grad.addColorStop(0.35,'rgba(255,210,140,0.55)');
        grad.addColorStop(1,'rgba(255,180,90,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='apocalypse'){
        const startR=fx.r0||120;
        const endR=fx.r1||900;
        const rad=startR + (endR-startR)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(60, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0,`rgba(255,255,250,${0.96 - prog*0.4})`);
        grad.addColorStop(0.25,`rgba(255,240,200,${0.82 - prog*0.3})`);
        grad.addColorStop(0.6,`rgba(255,214,130,${0.65 - prog*0.25})`);
        grad.addColorStop(1,'rgba(255,180,80,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='shockwave'){
        const startR=fx.r0||0;
        const endR=fx.r1||980;
        const rad=startR + (endR-startR)*easeOut(prog);
        const width=(fx.width||32)*((scaleX+scaleY)/2)*(1-prog*0.5);
        ctx.strokeStyle=`rgba(${fx.color||'255,230,190'},${0.55*(1-prog)})`;
        ctx.lineWidth=width;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='emberRain'){
        if(!fx.particles){
          const count=fx.count||70;
          fx.particles=Array.from({length:count},()=>({
            angle:Math.random()*Math.PI*2,
            radius:30+Math.random()*200,
            speed:220+Math.random()*320,
            size:9+Math.random()*16,
            drift:(Math.random()*0.6-0.3)
          }));
        }
        const flicker=0.5+0.5*Math.sin(prog*Math.PI*4);
        for(const p of fx.particles){
          const dist = p.radius + p.speed*prog;
          const px = fx.x + Math.cos(p.angle + p.drift*prog)*dist;
          const py = fx.y + Math.sin(p.angle + p.drift*prog)*dist*0.65;
          const size=p.size*((1-prog)*0.8+0.2)*((scaleX+scaleY)/2);
          ctx.fillStyle=`rgba(255,${205+Math.round(35*flicker)},${120+Math.round(25*(1-prog))},${0.55*(1-prog)})`;
          ctx.beginPath();
          ctx.arc(px*scaleX, py*scaleY, size,0,Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
    }
    if(dragonBoss && (dragonPhase==='active' || dragonPhase==='dying')){
      renderDragonBody(dragonBoss, now);
    }
    drawDragonAttackVisuals(now);
  }

  function drawDragonMarquee(){
    if(!dragonMarquee) return;
    const now=performance.now();
    const {start, fadeStart, end, text} = dragonMarquee;
    const style=dragonMarquee.style||'alert';
    if(now>=end){ dragonMarquee=null; return; }
    let alpha=1;
    if(style!=='victorySolid' && fadeStart && now>fadeStart){
      alpha=Math.max(0, 1 - (now - fadeStart)/(end - fadeStart||1));
    }
    const areaHeight=60;
    const top=Math.max(16, layout().top - areaHeight - 14);
    const width=Math.min(560, 1100-120);
    const x=(1100-width)/2;
    const radius=20;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, top, width, areaHeight, radius);
    if(style==='victorySolid'){
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(82,52,10,0.96)');
      grad.addColorStop(1,'rgba(48,26,6,0.96)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,220,160,0.85)';
      ctx.lineWidth=2.6;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      ctx.fillStyle='#fff4d4';
      const fontSize=Math.max(24, Math.round(28*((scaleX+scaleY)/2)));
      ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,200,120,0.6)';
      ctx.shadowBlur=18*((scaleX+scaleY)/2);
      ctx.fillText(text, (x+width/2)*scaleX, (top+areaHeight/2)*scaleY);
      ctx.shadowBlur=0;
    }else if(style==='elegant'){
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(48,22,10,0.9)');
      grad.addColorStop(1,'rgba(28,12,6,0.88)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,210,150,0.85)';
      ctx.lineWidth=2.4;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+10;
      const innerY=top+6;
      const innerW=width-20;
      const innerH=areaHeight-12;
      ctx.save();
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      const innerGrad=ctx.createLinearGradient(innerX*scaleX, innerY*scaleY, innerX*scaleX, (innerY+innerH)*scaleY);
      innerGrad.addColorStop(0,'rgba(140,70,30,0.45)');
      innerGrad.addColorStop(1,'rgba(80,34,14,0.35)');
      ctx.fillStyle=innerGrad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,220,180,0.45)';
      ctx.lineWidth=1.4;
      ctx.stroke();
      ctx.restore();
      ctx.save();
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.clip();
      ctx.fillStyle='#ffeedd';
      const fontSize=Math.max(20, Math.round(26*((scaleX+scaleY)/2)));
      ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,150,110,0.55)';
      ctx.shadowBlur=14*((scaleX+scaleY)/2);
      ctx.fillText(text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
      ctx.restore();
    }else{
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(60,32,6,0.95)');
      grad.addColorStop(1,'rgba(32,18,4,0.9)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,210,120,0.75)';
      ctx.lineWidth=2.2;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+12;
      const innerY=top+6;
      const innerW=width-24;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.save();
      ctx.clip();
      ctx.fillStyle='#fff5d8';
      const fontSize=Math.max(18, Math.round(24*((scaleX+scaleY)/2)));
      ctx.font=`${fontSize}px 'Noto Sans TC','Playfair Display',sans-serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,200,120,0.55)';
      ctx.shadowBlur=12*((scaleX+scaleY)/2);
      ctx.fillText(text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawDragonHPBar(){
    if((dragonPhase!=='active' && dragonPhase!=='dying') || !dragonBoss) return;
    const L=layout();
    const barW=32;
    const maxH=700-(L.top+80);
    const barH=Math.max(200, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, dragonBoss.hp/dragonBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(92,58,12,0.96)');
    frameGrad.addColorStop(1,'rgba(46,28,8,0.9)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(255,210,120,0.8)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(28,18,6,0.92)');
    bg.addColorStop(1,'rgba(42,26,8,0.9)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(255,180,90,0.25)');
      fillGrad.addColorStop(0.4,'rgba(255,210,120,0.65)');
      fillGrad.addColorStop(1,'rgba(255,240,200,0.96)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    const segments=10;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - innerH*i/segments)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS 毀滅之龍', dragonBoss.hp, dragonBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(92,58,12,0.95)',
      bgBottom:'rgba(46,28,8,0.9)',
      frame:'rgba(255,210,120,0.78)',
      glow:'rgba(255,200,120,0.55)',
      textPrimary:'#ffeccd',
      textSecondary:'#fff3da'
    });
    ctx.restore();
  }

  function drawDragonHUD(){
    drawDragonMarquee();
    drawDragonHPBar();
  }

  function drawDemonHUD(){
    if(level!==20) return;
    if((demonPhase!=='active' && demonPhase!=='dying') || !demonBoss) return;
    const L=layout();
    const barW=32;
    const maxH=700-(L.top+80);
    const barH=Math.max(200, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, demonBoss.hp/demonBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(70,24,120,0.95)');
    frameGrad.addColorStop(1,'rgba(38,12,80,0.9)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(230,190,255,0.65)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(24,12,40,0.92)');
    bg.addColorStop(1,'rgba(34,16,58,0.9)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(180,110,250,0.22)');
      fillGrad.addColorStop(0.45,'rgba(210,150,255,0.62)');
      fillGrad.addColorStop(1,'rgba(255,230,255,0.96)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    const segments=10;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - innerH*i/segments)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS 魔王埃里赫曼', demonBoss.hp, demonBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(70,24,120,0.95)',
      bgBottom:'rgba(38,12,80,0.9)',
      frame:'rgba(230,190,255,0.7)',
      glow:'rgba(200,150,255,0.55)',
      textPrimary:'#f1e4ff',
      textSecondary:'#f9efff'
    });
    ctx.restore();
  }


  function isSpecialBossActive(){
    return isSpaceBossActive() || isReaperActive() || isDragonActive() || isDemonActive();
  }

  function activeBossCenter(){
    if(isSpaceBossActive()) return {x:spaceBoss.x, y:spaceBoss.y, type:'space'};
    if(isReaperActive() && reaperBoss) return {x:reaperBoss.x, y:reaperBoss.y, type:'reaper'};
    if(isDragonActive() && dragonBoss) return {x:dragonBoss.x, y:dragonBoss.y, type:'dragon'};
    if(isDemonActive() && demonBoss) return {x:demonBoss.x, y:demonBoss.y, type:'demon'};
    return null;
  }

  function getActiveBossBounds(){
    if(isSpaceBossActive()) return getSpaceBossBounds();
    if(isReaperActive()) return getReaperBounds();
    if(isDragonActive()) return getDragonBounds();
    if(isDemonActive()) return getDemonBounds();
    return null;
  }

  function activeBossImpactPoint(fromX, fromY){
    if(isSpaceBossActive()) return spaceBossImpactPoint(fromX, fromY);
    if(isReaperActive()) return reaperImpactPoint(fromX, fromY);
    if(isDragonActive()) return dragonImpactPoint(fromX, fromY);
    if(isDemonActive()) return demonImpactPoint(fromX, fromY);
    return {x:fromX, y:fromY};
  }

  function damageActiveBoss(amount=1, source='generic', impact){
    if(isSpaceBossActive()) return damageSpaceBoss(amount, source, impact);
    if(isReaperActive()) return damageReaperBoss(amount, source, impact);
    if(isDragonActive()) return damageDragonBoss(amount, source, impact);
    if(isDemonActive()) return damageDemonBoss(amount, source, impact);
    return false;
  }

  function circleIntersectsActiveBoss(cx, cy, radius){
    if(isSpaceBossActive()) return circleIntersectsSpaceBoss(cx, cy, radius);
    if(isReaperActive()) return circleIntersectsReaper(cx, cy, radius);
    if(isDragonActive()) return circleIntersectsDragon(cx, cy, radius);
    if(isDemonActive()) return circleIntersectsDemon(cx, cy, radius);
    return false;
  }

  function activeBossClampPoint(x, y){
    if(isDragonActive()) return dragonClampPoint(x, y);
    if(isDemonActive()) return demonClampPoint(x, y);
    const bounds=getActiveBossBounds();
    if(!bounds) return {x, y};
    return {
      x: Math.max(bounds.x, Math.min(x, bounds.x + bounds.w)),
      y: Math.max(bounds.y, Math.min(y, bounds.y + bounds.h))
    };
  }
  // === 修正：格點對齊地揭示底圖，避免黑洞與浮點誤差 ===
  function revealBrickArea(brick){
    if(!brick || brick.fallingTreasure) return;
    const L = layout();
    const cellW = brickW, cellH = brickH;
    // 以格點定位（四捨五入）
    const c0 = Math.max(0, Math.min(GAME_CONFIG.bricks.cols-1, Math.round((brick.x - L.pad) / (cellW + L.pad)) ));
    const r0 = Math.max(0, Math.min(L.rows-1, Math.round((brick.y - L.top) / (cellH + L.pad)) ));
    // 覆蓋的格數（Boss/大磚可能>1）
    const cellsX = Math.max(1, Math.round((brick.w + L.pad) / (cellW + L.pad)));
    const cellsY = Math.max(1, Math.round((brick.h + L.pad) / (cellH + L.pad)));
    for(let rr=0; rr<cellsY; rr++){
      for(let cc=0; cc<cellsX; cc++){
        const c = Math.min(GAME_CONFIG.bricks.cols-1, c0 + cc);
        const r = Math.min(L.rows-1, r0 + rr);
        const rx = L.pad + c*(cellW + L.pad);
        const ry = L.top + r*(cellH + L.pad);
        revealRects.push({x:rx, y:ry, w:cellW, h:cellH});
      }
    }
  }
function generateLevel(lv, L){
    const cols=L.cols, rows=L.rows, pad=L.pad, top=L.top;
    const baseHP = 1 + Math.floor((lv-1)/3);
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // 關卡區段
    const late = lv>=7;
    const later = lv>=11;
    const endgame = lv>=15;

    // Boss每5關
    const isBoss = (lv%5===0);
    if(isBoss){
      if(lv===5){
        const bx = Math.floor(cols/2)-1;
        const by = 0;
        const w = brickW*2 + pad;
        const h = brickH*2 + pad;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:1, colorIdx:0, boss:true, face:'獅', strong:true, unbreakable:true});
        spaceBossPlaceholder = bricks[placeholderIndex];
        if(spaceBossPlaceholder){
          spaceBossPlaceholder.hp=0;
          spaceBossPlaceholder.placeholderBoss=true;
        }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(c>=bx && c<=bx+1 && r>=by && r<=by+1) continue;
            const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
          }
        }
        return;
      }else if(lv===10){
        const bx = Math.floor(cols/2)-1;
        const by = 0;
        const w = brickW*2 + pad;
        const h = brickH*2 + pad;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:1, colorIdx:0, boss:true, face:'影', strong:true, unbreakable:true});
        reaperPlaceholder = bricks[placeholderIndex];
        if(reaperPlaceholder){
          reaperPlaceholder.hp=0;
          reaperPlaceholder.placeholderBoss=true;
        }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(c>=bx && c<=bx+1 && r>=by && r<=by+1) continue;
            const isTopShield = (r===0 && (c%2===0));
            if(isTopShield){
              addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
              continue;
            }
            const moving = (r%3===0 && c%4===0);
            const hpBoost = baseHP + (r%2===0?1:0);
            const explosive = (!moving && Math.random()<GAME_CONFIG.bricks.explosiveChance*0.6);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:hpBoost, colorIdx:(r%4), moving, vx:moving?((Math.random()<0.5?-1:1)*0.7):0, explosive});
          }
        }
        return;
      }
      // 中央大Boss（2x2磚尺寸一塊）
      const bx = Math.floor(cols/2)-1;
      const w = brickW*2 + pad;
      const h = brickH*2 + pad;
      const hpList=[10,20,30,40];
      const bossIdx = Math.floor(lv/5)-1;
      const bossHP = hpList[Math.max(0,Math.min(3,bossIdx))];
      const faces=['獅','騎','目','魔'];
      if(lv===15){
        const by=0;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:bossHP, colorIdx:0, boss:true, face:faces[bossIdx], strong:true, unbreakable:true, cyclops:true, cyclopsRevealed:false});
        dragonPlaceholder = bricks[placeholderIndex];
        if(dragonPlaceholder){ dragonPlaceholder.placeholderBoss=true; }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(r===0) continue;
            if(r===1 && c>=bx && c<=bx+1) continue;
            const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
          }
        }
        return;
      }else if(lv===20){
        const by = 0;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:Infinity, colorIdx:0, boss:true, face:faces[bossIdx], strong:true, unbreakable:true, demonShell:true, hideBossHP:true});
        demonShellBrick = bricks[placeholderIndex];
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(c>=bx && c<=bx+1 && r===by) continue;
            const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
          }
        }
        return;
      }
      const by = Math.max(1, Math.floor(rows/2)-1);
      addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:bossHP, colorIdx:0, boss:true, face:faces[bossIdx], strong:true, unbreakable:true});
      // 周圍護衛磚
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(c>=bx && c<=bx+1 && r>=by && r<=by+1) continue; // 留 Boss 本體
          const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
          addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
        }
      }
      // 加點不可破壞邊框
      for(let c=0;c<cols;c+=2) addBrick(bricks, xAt(c), yAt(0), brickW, brickH, {unbreakable:true});
      return;
    }

    // 非Boss關：設計不同排列
    if(lv<=3){
      // 初學：滿版 + 少量爆炸
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance*0.7;
        addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
      }
    }else if(lv<=6){
      // V 形＋中間走廊
      const mid=Math.floor(cols/2);
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(Math.abs(c-mid)===r%5 && r<rows-1){ // V
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+((r%2)?1:0), colorIdx:r%4});
          }else if(r===Math.floor(rows/2) && (c%3===0)){ // 中線爆炸
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, explosive:true, colorIdx:r%4});
          }
        }
      }
    }else if(lv<=10){
      // 加入不可破壞隔板與少量移動磚
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r%4===0 && c%3===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else{
            const moving = (r%3===0 && c%4===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, moving, vx: moving? ((Math.random()<0.5?-1:1)*0.6) : 0});
          }
        }
      }
    }else if(lv<=14){
      // 交錯棋盤 + 強反彈帶
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if((r+c)%2===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, strong:(r%4===1)});
          }else if(r%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, moving:true, vx: (Math.random()<0.5?-1:1)*0.8});
          }
        }
      }
    }else{
      // 終盤：隧道、移動隊形、強反彈護牆
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r===1 || r===rows-2){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%3===0 && (r%2===0)){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+2, strong:true});
          }else{
            const mv=(r%3===1 && c%2===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, moving:mv, vx: mv?((Math.random()<0.5?-1:1)*1.0):0});
          }
        }
      }
    }
  }


  function canDestroyBrick(b){ const now=performance.now(); if(b.unbreakable) return false; if(b.lockedUntil && now < b.lockedUntil) return false; return true; }
  function damageOrDestroy(i, amount=1){
    const b=bricks[i]; if(!b) return; if(b.unbreakable) return;
    if(b.elite && !b.prompted){ showPrompt('菁英磚'); b.prompted=true; }
    if(b.boss && !b.prompted){ showPrompt('Boss！'); b.prompted=true; }
    const now=performance.now();
    if(b.lockedUntil && now < b.lockedUntil) return;
    b.hp = (b.hp||1) - amount;
    if(b.hp<=0){
      if(b.elite){ stats.eliteKills++; }
      revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); updateHUD();
    }
  }

  function bossKillEffect(b, opts={}){
    const cx=b.x+b.w/2, cy=b.y+b.h/2;
    spawnParticles(cx,cy,'#fff5c0',60,2.5,4.0,4.5);
    spawnParticles(cx,cy,'#ff4d6d',40,2.0,3.5,3.5);
    screenShake=Math.max(screenShake,6);
    playSFX('fireExplosion');
    showComboNotice(`成功擊殺第${level}關Boss!`,5000,3000);
    const dropMode = opts.dropNineCat ?? 'never';
    if(dropMode==='always'){
      spawnPower(cx-12,cy,{forceType:'NINE'});
    } else if(dropMode==='default' || dropMode==='chance'){
      if(Math.random()<0.5){ spawnPower(cx-12,cy,{forceType:'NINE'}); }
    }
  }
  function destroyBrick(i, sfx='default'){
    const b=bricks[i]; if(!b) return; if(!canDestroyBrick(b)) return;
    if(b.elite && !b.prompted){ showPrompt('菁英磚'); b.prompted=true; }
    if(b.boss && !b.prompted){ showPrompt('Boss！'); b.prompted=true; }
    if(b.boss){
      b.hp-=1;
      if(b.hp<=0){
        bossKillEffect(b);
        revealBrickArea(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; updateHUD();
      }
      return;
    }
    if(b.elite){ stats.eliteKills++; }
    const bx=b.x+b.w/2, by=b.y+b.h/2;
    const color=b.treasure?'#ffdf6f':b.boss?'#ff4d6d':b.unbreakable?'#888':b.strong?'#bb7aff':b.moving?'#6ec6ff':b.explosive?getVar('--expl'):brickColor(b.colorIdx);
    spawnParticles(bx,by,color,30,2.0,3.2,3.5);
    if(b.treasure){
      spawnParticles(bx,by,'#ffe8a3',20,2.0,3.2,3.6);
      const rainbowBurst=['#ff6ec7','#ff9f43','#ffe066','#8ce99a','#74c0fc','#b197fc','#ff85f5'];
      for(const col of rainbowBurst){ spawnParticles(bx,by,col,8,1.8,3.0,3.2); }
    }
    if(sfx==='default'){ beep(420,0.06,0.08); setTimeout(()=>beep(620,0.05,0.06),40); }
    else if(sfx!=='none'){ playSFX(sfx); }
    revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); updateHUD();
  }
  function damageBrick(i, dmg, sfx='default'){ for(let k=0;k<dmg;k++){ if(!bricks[i]) break; destroyBrick(i, sfx); } }
  function destroyNeighbors(idx){ const b=bricks[idx]; if(!b) return; const L=layout(); const near=[]; for(let j=bricks.length-1;j>=0;j--){ if(j===idx) continue; const t=bricks[j]; const dx=Math.abs((t.x+t.w/2)-(b.x+b.w/2)); const dy=Math.abs((t.y+t.h/2)-(b.y+b.h/2)); const thx=brickW+L.pad+2, thy=brickH+L.pad+2; if(dx<=thx && dy<=thy){ // 鄰近一格
        if(canDestroyBrick(t)){
          if(t.boss){
            t.hp-=1;
            if(t.hp<=0){
              bossKillEffect(t);
              revealBrickArea(t); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(t)); stats.bossKills++; }
          } else {
            revealBrickArea(t); maybeDropFromBrick(t); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(t)); if(t.elite) stats.eliteKills++;
          }
        }
      }
    }
    updateHUD();
  }

  function explodeAt(cx,cy){
    const radius=Math.max(brickW,brickH)*1.3;
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy);
      if(d<=radius){
        if(b.unbreakable){ continue; }
        // Boss：只扣血，不秒殺
        if(b.boss){
          b.hp -= 1;
          if(b.hp<=0){ bossKillEffect(b); revealBrickArea(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; }
        }else{
          revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++;
        }
        spawnParticles(bx,by,'#ffdd99',14,1.7,2.6,3);
      }
    }
    if(circleIntersectsActiveBoss(cx,cy,radius)){
      const center=activeBossCenter();
      const impact=center?{x:center.x,y:center.y}:{x:cx,y:cy};
      damageActiveBoss(1,'fire',impact);
    }
    spawnParticles(cx,cy,'#ffbb55',24,2.1,3.2,4); updateHUD(); playSFX('explosion');
  }

  function fireExplosionAt(cx,cy,radius){
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy);
      if(d<=radius){
        if(canDestroyBrick(b)){
          if(b.boss){
            b.hp-=1;
            if(b.hp<=0){ bossKillEffect(b); revealBrickArea(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; updateHUD(); }
          }
          else {
            revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++; updateHUD();
          }
        }
        spawnParticles(bx,by,'#ffdd99',20,1.8,2.8,3.5);
      }
    }
    if(circleIntersectsActiveBoss(cx,cy,radius)){
      const center=activeBossCenter();
      const impact=center?{x:center.x,y:center.y}:{x:cx,y:cy};
      damageActiveBoss(1,'fire',impact);
    }
    fireExplosions.push({x:cx,y:cy,r:radius,t0:performance.now(),life:400});
    spawnParticles(cx,cy,'#ff5500',60,2.6,3.8,4.5);
    spawnParticles(cx,cy,'#ffaa33',40,2.8,4.0,3.8);
    spawnParticles(cx,cy,'#fff4cc',20,3.0,4.2,3.0);
    screenShake=Math.max(screenShake,6); updateHUD(); playSFX('fireExplosion');
  }

  function fireCollide(){ if(buffs.FIRE.active){ fireEnergy++; updateFireEnergy(); } }

  // === 掉落道具 ===
  const powerups=[];

  // === 天空隨機增益掉落（第1關每25秒 → 第20關每6秒 線性遞減） ===
  let nextSkyDropAt = 0;
  function skyDropIntervalMs(lv){
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const s = 25*1000 * (1-t) + 6*1000 * t;
    return s;
  }
  function scheduleNextSkyDrop(){ nextSkyDropAt = performance.now() + skyDropIntervalMs(level); }
  function spawnBeneficialAtTop(){
    // 從所有非減益的道具中隨機挑選一種作為隨機掉落增益
    // 若畫面已有特殊道具掉落，暫時排除特殊道具
    const goodTypes = ALL_TYPES.filter(k => GAME_CONFIG.powers[k].type !== 'debuff' && k !== 'NINE');
    let pool = goodTypes;
    if(powerups.some(p=>p.isSpecial)){
      pool = pool.filter(k => {
        const t = GAME_CONFIG.powers[k].type;
        return t !== 'special';
      });
    }
    if(!pool.length) return;
    const type = pool[Math.floor(Math.random()*pool.length)];
    const def = GAME_CONFIG.powers[type];
    if(!def) return;
    const isSpecial = (def.type === 'special');
    // 設定速度：特殊偏慢
    let speed = GAME_CONFIG.powerCapsule.fallVy;
    if(isSpecial) speed *= 0.75;
    // 決定掉落方向
    const horizontal = orientLeft;
    let px, py;
    if(horizontal){
      // 水平掉落：從右側隨機 y 開始
      px = 1100 - 40;
      const L = layout();
      py = L.top + 20 + Math.random() * (700 - 60 - L.top);
    } else {
      // 垂直掉落：從畫面上方隨機 x
      px = 40 + Math.random() * (1100 - 80);
      py = layout().top - 20;
    }
    powerups.push({
      x: px,
      y: py,
      w: GAME_CONFIG.powerCapsule.width,
      h: GAME_CONFIG.powerCapsule.height,
      speed: speed,
      horizontal: horizontal,
      type: type,
      isDebuff: false,
      isSpecial: isSpecial,
      phase: Math.random() * Math.PI * 2
    });
  }

  // 道具掉落率抑制
  let burstStart=0, burstCount=0;
  let pendingGoodDrop=null;
  function activePowerCount(){
    const now=performance.now();
    let cnt=0;
    for(const k in buffs){
      const b=buffs[k];
      if(!b) continue;
      if(Array.isArray(b.stacks)){
        if(b.stacks.some(t=>t>now)) cnt++;
      }else if(b.active && (!b.until || b.until>now)){
        cnt++;
      }
    }
    return cnt;
  }
  function maybeDropFromBrick(b, rateMul=1){
    if(!b || b.unbreakable) return;
    if(b.treasure){
      spawnPower(b.x + b.w/2 - GAME_CONFIG.powerCapsule.width/2, b.y + b.h/2, {forceGood:true});
      return;
    }
    // Boss不會掉落一般增益（保持平衡）
    if(b.boss) return;
    const now=performance.now();
    if(!burstStart || now-burstStart>500){
      burstStart=now; burstCount=1;
    }else{
      burstCount++;
    }
    const actives=activePowerCount();
    if(actives===0){
      if(!pendingGoodDrop){
        const px=b.x+b.w/2-12, py=b.y+b.h/2;
        pendingGoodDrop={x:px,y:py};
        setTimeout(()=>{
          if(pendingGoodDrop && burstCount===1){
            spawnPower(pendingGoodDrop.x, pendingGoodDrop.y, {forceGood:true});
          }
          pendingGoodDrop=null;
        },0);
        return;
      }
      // 已有保底掉落等待確認，後續磚塊走一般掉落計算
    }
    let rate=dropRateForLevel(level);
    if(actives>=5) rate*=0.3;
    if(burstCount>=3){
      let factor;
      if(burstCount===3) factor=0.7;
      else if(burstCount===4) factor=0.4;
      else factor=0.1;
      rate*=factor;
    }
    rate *= rateMul;
    if(Math.random()<rate) spawnPower(b.x + b.w/2 - 12, b.y + b.h/2);
  }

  function dropRateForLevel(lv){
    const diff = getDiff();
    const base = diff.dropRate || 0.5;
    const startBoostAt = 8; // 中期開始提升掉落率
    const incPerLv = 0.02;
    let inc = Math.max(0, (lv - startBoostAt) * incPerLv);
    let max = 0.9;
    const d = (typeof difficultySel!=='undefined') ? difficultySel.value : 'normal';
    if(d==='normal') max = 0.7;
    if(d==='hard') max = 0.5;
    return Math.min(max, base + inc);
  }

  function spawnPower(x,y,opts={}){
    // 隨機挑選一種道具類型（普通或特殊），並根據類型設定掉落速度與顏色標記
    const {forceGood=false, forceType=null} = opts;
    const existingSpecial = powerups.some(p=>p.isSpecial);
    let pool, type;
    if(forceType){
      type = forceType;
    }else{
      if(forceGood){
        pool = ALL_TYPES.filter(k => GAME_CONFIG.powers[k].type !== 'debuff');
        if(existingSpecial){
          pool = pool.filter(k => { const t = GAME_CONFIG.powers[k].type; return t !== 'special'; });
        }
      }else{
        pool = NORMAL_TYPES;
        if(existingSpecial){
          pool = pool.filter(k => { const t = GAME_CONFIG.powers[k].type; return t !== 'special'; });
        }
      }
      pool = pool.filter(k=>k!=='NINE');
      if(!pool.length) return;
      type = pool[Math.floor(Math.random()*pool.length)];
    }
    const def = GAME_CONFIG.powers[type];
    if(!def) return;
    // 判斷是否為特殊（special）或減益
    const isSpecial = (def.type === 'special');
    const isDebuff = (def.type === 'debuff');
    // 設定基礎速度：特殊偏慢，減益偏快
    let speed = GAME_CONFIG.powerCapsule.fallVy;
    if(isSpecial) speed *= 0.75;
    if(isDebuff) speed *= 1.4;
    // 根據當前天地翻轉狀態決定掉落方向與起始位置
    const horizontal = orientLeft;
    let px = x, py = y;
    if(horizontal){
      // 水平掉落：從右側隨機 y 開始往左移動
      px = 1100 - 40;
      const L = layout();
      // 避免靠近上下邊界，預留 40 像素
      py = L.top + 20 + Math.random() * (700 - 60 - L.top);
    }
    powerups.push({
      x: px,
      y: py,
      w: GAME_CONFIG.powerCapsule.width,
      h: GAME_CONFIG.powerCapsule.height,
      speed: speed,
      horizontal: horizontal,
      type: type,
      isDebuff: isDebuff,
      isSpecial: isSpecial,
      phase: Math.random() * Math.PI * 2
    });
  }

  function applyPower(type){
    const _defC=GAME_CONFIG.powers[type]; if(_defC){ if(_defC.type==='debuff') stats.debuffs++; else if(_defC.type) stats.buffs++; }
    const def=GAME_CONFIG.powers[type]; if(!def) return; const now=performance.now();
    const fullLabel = def.label + (def.desc ? `(${def.desc})` : '');
    let promptText='';
    if(def.type==='buff') promptText=`增益：${fullLabel}`;
    else if(def.type==='debuff') promptText=`減益：${fullLabel}`;
    else if(def.type==='special') promptText=`特殊：${fullLabel}`;
    const exist=buffs[type];
    let active=false;
    if(type==='LONG'){ active = exist && exist.stacks && exist.stacks.some(t=>t>now); }
    else active = exist && exist.active && exist.until && exist.until>now;
    if(promptText && !active) showPrompt(promptText);
    // 更新最近取得增益的時間：非減益類型（含特殊）皆視為增益
    if(def.type !== 'debuff'){
      lastBeneficialPickupAt = now;
      nextAutoBeneficialDropAt = now + 10000;
      if(def.type === 'buff') addScore(10);
      else if(def.type === 'special') addScore(50);
      updateHUD();
    }
    // 瞬發特殊增益
    if(def.instant){
      if(type==='PHOENIX'){ // 鳳凰飛過 + 火焰 + 隨機一半消除（Boss只扣1）
        phoenixAnim={x:canvas.width+220,tEnd:now+1200};
        const keep=[]; for(const b of bricks){
          if(Math.random()<0.5){
            if(b.unbreakable){ keep.push(b); continue; }
            if(b.boss){
              b.hp -= 1;
              if(b.hp>0){ keep.push(b);} else { bossKillEffect(b); revealBrickArea(b); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; }
            }
            else {
              revealBrickArea(b); maybeDropFromBrick(b); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++;
            }
            fireBursts.push({x:b.x+b.w/2,y:b.y+b.h/2,life:400+Math.random()*400});
          } else keep.push(b);
        }
        bricks=keep; screenShake=6; playSFX('phoenix'); updateHUD();
        if(isSpecialBossActive()){
          const center=activeBossCenter();
          const impact=center?{x:center.x,y:center.y}:null;
          damageActiveBoss(1,'phoenix',impact);
        }
      } else if(type==='NINE'){ if(nineCatEaten>=2) return; lives=9; nineCatEaten++; updateHUD(); spawnParticles(550,350,'#ffd',40,2.2,3.5,4); beep(880,0.1,0.06); }
      return;
    }
    // 定時類
    if(def.durationMs){ if(type!=='LONG'){ const b=buffs[type]||(buffs[type]={active:false,until:0}); b.active=true; b.until=now+def.durationMs; } }
    if(def.paddleWidthAdd){ buffs.WIDE.active=true; buffs.WIDE.until=now+def.durationMs; }
    if(def.longPerStackAdd){ const act=buffs.LONG.stacks.filter(t=>t>now); const max=def.stacksMax??2; if(act.length<max){ buffs.LONG.stacks.push(now+def.durationMs);} else { const earliest=Math.min(...act); const idx=buffs.LONG.stacks.indexOf(earliest); buffs.LONG.stacks[idx]=now+def.durationMs; } }
    if(def.sticky){ buffs.STICKY.active=true; buffs.STICKY.until=now+def.durationMs; }
    if(def.multiDuplicate){ if(balls.length<3){ const news=[]; for(const b of balls){ const b1={...b}; b1.trail=[]; news.push(b1);} balls=balls.concat(news); const cap=def.maxBalls??4; if(balls.length>cap) balls.length=cap; } }
    if(def.speedMul){ buffs.SLOW.active=true; buffs.SLOW.until=now+def.durationMs; }
    if(def.piercing){ buffs.PIERCE.active=true; buffs.PIERCE.until=now+def.durationMs; for(const b of balls) b.piercing=true; }
    if(def.oneShotShield){ buffs.SHIELD.active=true; }
    if(def.forcePiercing && def.rampageMs){ buffs.RAMPAGE.active=true; buffs.RAMPAGE.until=now+def.durationMs; for(const b of balls){ b.rampageUntil=now+def.rampageMs; b.piercing=true; } }
    if(def.globalSpeedMul){ buffs.FAST.active=true; buffs.FAST.until=now+def.durationMs; if(def.screenShakeOnApply) screenShake=def.screenShakeOnApply; }
    if(def.wavy){ buffs.WAVY.active=true; buffs.WAVY.until=now+def.durationMs; buffs.WAVY.start=now; }
    if(type==='PLASMA'){ buffs.PLASMA.active=true; buffs.PLASMA.until=now+def.durationMs; }
    if(type==='FREEZE'){ buffs.FREEZE.active=true; buffs.FREEZE.until=now+def.durationMs; }
    if(type==='HOLY'){ buffs.HOLY.active=true; buffs.HOLY.until=now+def.durationMs; }
    if(type==='FIRE'){ buffs.FIRE.active=true; buffs.FIRE.until=now+def.durationMs; fireEnergy=0; updateFireEnergy(); }
    if(type==='POISON'){ buffs.POISON.active=true; buffs.POISON.until=now+def.durationMs; }
    if(type==='BLINK'){ buffs.BLINK.active=true; buffs.BLINK.until=now+def.durationMs; }
    if(type==='COMBO'){ buffs.COMBO.active=true; buffs.COMBO.until=now+def.durationMs; }

    if(type==='TRACK'){ buffs.TRACK.active=true; buffs.TRACK.until=now+def.durationMs; }
    if(type==='MISSILE'){ buffs.MISSILE.active=true; buffs.MISSILE.until=now+def.durationMs; }
    if(type==='HELL'){ buffs.HELL.active=true; buffs.HELL.until=now+def.durationMs; }
    if(type==='MEGA'){ if(!buffs.MEGA.active){ for(const ball of balls){ ball.r*=GAME_CONFIG.powers.MEGA.mega.sizeMul; } buffs.MEGA.applied=true; } buffs.MEGA.active=true; buffs.MEGA.until=now+def.durationMs; }
    if(type==='CHAIN'){ buffs.CHAIN.active=true; buffs.CHAIN.until=now+def.durationMs; }
    if(type==='NARROW'){ buffs.NARROW.active=true; buffs.NARROW.until=now+def.durationMs; }
    if(type==='HOLE'){ buffs.HOLE.active=true; buffs.HOLE.until=now+def.durationMs; showComboNotice('注意看! 你破洞啦!',5000,3000); }
    if(type==='PADSPIN'){ buffs.PADSPIN.active=true; buffs.PADSPIN.until=now+def.durationMs; buffs.PADSPIN.start=now; }
    if(type==='PADBOOM'){ buffs.PADBOOM.active=true; buffs.PADBOOM.explodeAt=now+(def.explosion?.flashMs||3000); buffs.PADBOOM.returnAt=buffs.PADBOOM.explodeAt+(def.explosion?.goneMs||3000); buffs.PADBOOM.until=buffs.PADBOOM.returnAt; buffs.PADBOOM.exploded=false; }
    if(type==='GATLING'){ buffs.GATLING.active=true; buffs.GATLING.until=now+def.durationMs; const g=GAME_CONFIG.powers.GATLING.gatling; const pr=paddleRect(); gatling={x:pr.x+pr.w/2,y:pr.y,chargeUntil:now+(g.chargeMs||3000),fireStart:now+(g.chargeMs||3000),fireUntil:now+(g.chargeMs||3000)+(g.fireMs||8000),lastShot:0,angle:0}; }
    if(type==='FLIP'){
      // 天地翻轉：延遲啟用並紀錄起止時間。啟用及結束均由 update 中判斷。
      const delay = 2000;
      // 初始化 FLIP buff 狀態
      if(!buffs.FLIP) buffs.FLIP = {};
      const f = buffs.FLIP;
      f.pending = true;
      f.active = false;
      f.startAt = now + delay;
      f.endAt = f.startAt + def.durationMs;
      // 使用 until 顯示剩餘時間條
      f.until = f.endAt;
      return;
    }
    if(type==='GODSPEED'){ buffs.GODSPEED.active=true; buffs.GODSPEED.until=now+def.durationMs; }
    if(type==='LASER'){ buffs.LASER.active=true; buffs.LASER.until=now+def.durationMs; buffs.LASER.lastShot=0; }
    if(type==='SWORD'){ buffs.SWORD.active=true; buffs.SWORD.until=now+def.durationMs; swordFireStart=0; }
    if(type==='STORM'){ buffs.STORM.active=true; buffs.STORM.until=now+def.durationMs; const pr=paddleRect(); stormTurret={x:pr.x+pr.w/2,y:pr.y,chargeUntil:now+3000,fireAt:now+4000,shots:Math.max(0,21-lives),lastShot:0}; }
    if(type==='BLACKHOLE'){ buffs.BLACKHOLE.active=true; buffs.BLACKHOLE.until=now+def.durationMs; buffs.BLACKHOLE.deaths=0; }
    if(type==='ANNIHIL'){ buffs.ANNIHIL.active=true; buffs.ANNIHIL.start=now; buffs.ANNIHIL.next=now+1000; buffs.ANNIHIL.until=0; }

    updateBuffBadges();
  }

  function drawPower(p){ const base=p.isDebuff?getVar('--debuff'):getVar('--power'); const gold1='#f6d365', gold2='#fda085'; const color = p.isSpecial ? gold1 : base; const x=p.x*scaleX, y=p.y*scaleY, w=p.w*scaleX, h=p.h*scaleY; const wobble=Math.sin(p.phase)*1.5; p.phase+=0.04;
    ctx.save(); ctx.translate(0,wobble); const grd=ctx.createLinearGradient(x,y,x,y+h); grd.addColorStop(0,color); grd.addColorStop(1,p.isSpecial?gold2:(p.isDebuff?'#a33':'#3a56a8')); ctx.fillStyle=grd; roundedRect(x,y,w,h,8); ctx.fill(); ctx.strokeStyle=p.isSpecial?'rgba(255,220,150,.8)':'rgba(255,255,255,.25)'; ctx.stroke();
    ctx.fillStyle=p.isSpecial?'#402a00':'#fff'; ctx.font=`${Math.max(10,Math.round(12*scaleY))}px ui-monospace, monospace`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.type[0], x+w/2, y+h/2+0.5); ctx.restore(); }

  function updateFireEnergy(){
    if(!fireEnergyEl) return;
    if(buffs.FIRE?.active || fireEnergy>0){
      fireEnergyEl.style.display='inline-block';
      fireEnergyEl.textContent=`🔥${fireEnergy}`;
    }else{
      fireEnergyEl.style.display='none';
    }
  }

  function updateHUD(){
    // 更新分數、關卡、生命與愛心顯示
    scoreEl.textContent = Math.max(0 | score, 0);
    // 顯示目前關卡數（level 元素）和總關卡數（totalLevels 元素）
    levelEl.textContent = level;
    if (totalLevelsEl) totalLevelsEl.textContent = GAME_CONFIG.totalLevels;
    if (levelJumpSel){
      levelJumpSel.value = String(level);
      if(typeof refreshLevelJumpVisual==='function') refreshLevelJumpVisual();
    }
    // 更新生命文字與愛心
    livesEl.textContent = lives;
    if (heartsEl) {
      heartsEl.innerHTML = '';
      // 依據生命數量新增愛心圖示
      for (let i = 0; i < lives; i++) {
        const span = document.createElement('span');
        const icon = (window.currentSkin && window.currentSkin.lifeIcon) || '❤️';
        if (typeof icon === 'string' && icon.trim().startsWith('<')) {
          span.innerHTML = icon;
        } else {
          span.textContent = icon;
        }
        span.className = 'life-icon';
        heartsEl.appendChild(span);
      }
      // 過多生命時採用 compact 風格
      heartsEl.classList.toggle('compact', lives > 5);
    }
    if (catsEl) {
      catsEl.innerHTML = '';
      for (let i = 0; i < nineCatEaten; i++) {
        const span = document.createElement('span');
        span.textContent = '🐱';
        span.className = 'cat-icon';
        catsEl.appendChild(span);
      }
      catsEl.style.display = nineCatEaten ? 'flex' : 'none';
    }
    updateFireEnergy();
  }
  window.updateHUD = updateHUD;
  function showCenter(t, txt){
    noteTitle.textContent = t;
    noteText.innerHTML = txt || '';
    centerNote.style.display = 'flex';
  }
  function showGameOver(){
    paused = true; running = false; gameOver = true;
    hideCenter();
    resetCombo();
    const fs2 = document.getElementById('finalScore2'); if(fs2) fs2.textContent = String(Math.max(0|score,0));
    const so  = document.getElementById('statsOver'); if(so)  so.innerHTML = renderStatsHtml();
    gameover?.classList.add('show');
    playSFX('lose');
  }
  function hideCenter(){ centerNote.style.display='none'; }

  function resetGame(load=false){ diff=getDiff(); level=load?level:1; score=load?score:0; lives=load?lives:3; nineCatEaten=load?nineCatEaten:0; scoreUploaded=false; updateHUD(); initBricks(); resetBalls(); paused=true; running=false; resetCombo();
    stats={catches:0,buffs:0,debuffs:0,eliteKills:0,bossKills:0,lifeStart:0,fastestDeath:Infinity,longestLife:0,livesUsed:0,maxCombo:0};
    for(const k of Object.keys(buffs)){
      if(k!=='LONG'){
        buffs[k].active=false;
        buffs[k].until=0;
      }
    }
    // 重置 LONG buff stacks
    buffs.LONG.stacks=[];
    powerups.length=0;
    particles.length=0;
    plasmas.length=0;
    holyFlashes.length=0;
    phoenixAnim=null;
    fireBursts.length=0;
    fireEnergy=0; updateFireEnergy();
    // 回復天地翻轉狀態及暫停計時器
    orientLeft=false;
    pauseStartedAt=null;
    // 初始化增益掉落計時
    lastBeneficialPickupAt = performance.now();
    nextAutoBeneficialDropAt = lastBeneficialPickupAt + 10000;
    updateBuffBadges();
    computePaddleWidth();
    paddle.x = 1100/2 - paddle.w/2;
    // 確保 paddle 在水平方向時位於底部
    paddle.y = 700 - 50;
    showCenter('按 Space 或點畫面開始','用 ←/→ 或 A/D 移動；手指拖曳畫面也可。');
    countdownShow=0;
    scheduleNextSkyDrop();
  }

  // === 存讀檔（含音效/BGM與影像選擇） ===
  function saveProgress(){ try{
      const data={level,score,lives,difficulty:difficultySel.value, imageChoice, soundsOn, bgmOn, bgmVol: parseFloat(bgmVol.value)};
      localStorage.setItem('breakout_save_v_final_cfg', JSON.stringify(data)); alert('已存檔！');
    }catch(e){ alert('存檔失敗：'+e); } }
  function loadProgress(){ try{ const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4'); if(!raw){ alert('沒有存檔'); return; } const data=JSON.parse(raw);
      difficultySel.value=data.difficulty||'normal'; level=data.level||1; score=data.score||0; lives=data.lives||3; if(Array.isArray(data.imageChoice)) imageChoice=data.imageChoice;
      soundsOn=!!data.soundsOn; soundBtn.textContent=`音效：${soundsOn?'開':'關'}`;
      if(typeof data.bgmOn==='boolean'){ bgmOn=data.bgmOn; } if(typeof data.bgmVol==='number'){ bgmVol.value=String(data.bgmVol); if(bgmGain) bgmGain.gain.value=data.bgmVol; localStorage.setItem('bgm_vol', data.bgmVol); }
      resetGame(true); updateHUD(); alert(`已讀檔：等級 ${level}，分數 ${score}，生命 ${lives}`);}catch(e){ alert('讀檔失敗：'+e); } }
  function clearSave(){ localStorage.removeItem('breakout_save_v_final_cfg'); localStorage.removeItem('gallery_unlocks'); localStorage.removeItem('dialog_unlocks'); alert('已清除存檔'); }

  // === 輸入（含觸控） ===
  let keyL=false, keyR=false; let touchActive=false;
  window.addEventListener('keydown',(e)=>{ if(gameOver){ e.preventDefault(); return; }
    if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=true;
    if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=true;
    if(e.code==='Space'){ // 開始 / 暫停 / 倒數
      if(!running){ startGameWithCountdown(); } else { togglePause(); }
      return;
    }
    if((e.code==='ArrowUp' || e.key==='Shift') && !paused && running){
      let released=false;
      for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy = -Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
    if(e.key==='r'||e.key==='R'){ resetGame(); }
    if(e.key==='f'||e.key==='F'){ toggleFullscreen(); }
  });
  window.addEventListener('keyup',(e)=>{ if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=false; if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=false; });
  canvas.addEventListener('mousemove',(e)=>{ const rect=canvas.getBoundingClientRect(); if(performance.now()<=paddleStunUntil) return; if(!orientLeft){ const x=(e.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(e.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } });
  canvas.addEventListener('click',()=>{ if(gameOver){ return; }
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  });
  canvas.addEventListener('touchstart',(e)=>{ if(gameOver){ e.preventDefault(); return; } touchActive=true; 
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  }, {passive:false});
  canvas.addEventListener('touchmove',(e)=>{ if(!touchActive) return; if(performance.now()<=paddleStunUntil) return; const t=e.touches[0]; const rect=canvas.getBoundingClientRect(); if(!orientLeft){ const x=(t.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(t.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } }, {passive:true});
  canvas.addEventListener('touchend',()=>{ touchActive=false; }, {passive:true});
  pauseBtn.addEventListener('click',()=>togglePause()); resetBtn.addEventListener('click',()=>resetGame()); fsBtn.addEventListener('click',()=>toggleFullscreen());
  soundBtn.addEventListener('click',()=>{ soundsOn=!soundsOn; localStorage.setItem('sfx_on', soundsOn?'1':'0'); soundBtn.textContent=`音效：${soundsOn?'開':'關'}`; ensureAudio(); audioCtx?.resume?.(); beep(880,0.06,0.05); });
  difficultySel.addEventListener('change',()=>{ resetGame(); });
  if(ledStyleSel){ ledStyleSel.value = ledStyle; ledStyleSel.addEventListener('change', ()=>{ ledStyle = ledStyleSel.value; localStorage.setItem('led_style', ledStyle); }); }
  saveBtn.addEventListener('click',saveProgress); loadBtn.addEventListener('click',loadProgress); clearSaveBtn.addEventListener('click',clearSave);
  if(levelJumpSel){
    const updateLevelJumpVisual = ()=>{
      const current=levelJumpSel.options[levelJumpSel.selectedIndex]||null;
      const isBoss=!!current && current.classList.contains('boss-level');
      levelJumpSel.classList.toggle('boss-selected', isBoss);
    };
    refreshLevelJumpVisual = updateLevelJumpVisual;
    const populateLevelJumpOptions = ()=>{
      levelJumpSel.innerHTML = '';
      for(let i=1;i<=GAME_CONFIG.totalLevels;i++){
        const option=document.createElement('option');
        const isBoss = i%5===0;
        option.value=String(i);
        option.textContent=isBoss ? `第 ${i} 關 ★ Boss` : `第 ${i} 關`;
        if(isBoss){
          option.classList.add('boss-level');
          option.style.color='#ffb347';
          option.style.fontWeight='800';
          option.style.background='rgba(255,155,74,.22)';
        }
        levelJumpSel.appendChild(option);
      }
      updateLevelJumpVisual();
    };
    populateLevelJumpOptions();
    levelJumpSel.value = String(level);
    updateLevelJumpVisual();
    levelJumpSel.addEventListener('change',()=>{
      updateLevelJumpVisual();
      const target=parseInt(levelJumpSel.value,10);
      if(Number.isNaN(target)) return;
      level = Math.max(1, Math.min(GAME_CONFIG.totalLevels, target));
      gameOver = false;
      gameover?.classList.remove('show');
      paused = true;
      running = false;
      resetCombo();
      initBricks();
      resetBalls();
      applyBGMThemeForLevel();
      updateHUD();
      showCenter(`暫時跳至第 ${level} 關`,`按 Space 或點畫面開始`);
    });
  }
  tutorBtn.addEventListener('click', ()=> toggleHelp('tutor'));
  effectsBtn.addEventListener('click', ()=> toggleHelp('effects'));
  againBtn.addEventListener('click', ()=>{ win.classList.remove('show'); resetGame(); });

  // BGM UI
  bgmBtn.addEventListener('click', ()=>{
    bgmOn=!bgmOn; localStorage.setItem('bgm_on', bgmOn?'1':'0'); bgmBtn.textContent= bgmOn?'開':'關';
    if(bgmOn){ ensureAudio(); startBGM(); } else { stopBGM(); }
  });
  bgmVol.addEventListener('input', ()=>{
    ensureAudio(); const v=parseFloat(bgmVol.value||'0.5'); if(bgmGain) bgmGain.gain.value=v; localStorage.setItem('bgm_vol', v);
  });

  function togglePause(){
    if(!running){ startGameWithCountdown(); return; }
    paused = !paused;
    if(paused){
      // 記錄暫停開始時間，並顯示暫停訊息
      onPauseStart();
      showCenter('已暫停','按 Space / 點畫面繼續');
    } else {
      // 恢復前先調整計時器，再進入倒數
      onResumeFromPause();
      startCountdown();
    }
  }

  function startGameWithCountdown(){
    onResumeFromPause();
    running=true; paused=true; hideCenter();
    if(pendingUnlockNotice){ showComboNotice(pendingUnlockNotice); pendingUnlockNotice=null; }
    ensureAudio(); audioCtx?.resume?.();
    // 音效與BGM設定載入
    // 從 localStorage 載入音效與 BGM 設定
    soundsOn = (localStorage.getItem('sfx_on')||'0') === '1';
    // 同步舊版按鈕與新 UI 複選框
    soundBtn.textContent = `音效：${soundsOn?'開':'關'}`;
    if (sfxOnEl) sfxOnEl.checked = soundsOn;
    bgmOn = (localStorage.getItem('bgm_on')||'0') === '1';
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.7');
    bgmVol.value = String(v);
    ensureAudio(); if (bgmGain) bgmGain.gain.value = v;
    bgmBtn.textContent = bgmOn ? '開' : '關';
    if (bgmOnEl) bgmOnEl.checked = bgmOn;
    if (bgmOn) startBGM(); applyBGMThemeForLevel();
    startCountdown();
  }

  // === 教學/效果說明 ===
  let helpMode=null; // 'tutor' | 'effects' | null
  function toggleHelp(mode){
    if(helpMode===mode){
      // 關閉說明，恢復遊戲
      helpMode=null;
      hideCenter();
      if(menusOpen()) return;
      if(running){
        onResumeFromPause();
        startCountdown();
      } else {
        startGameWithCountdown();
      }
      return;
    }
    helpMode = mode;
    paused = true;
    // 打開說明時開始暫停計時
    onPauseStart();
    if(mode==='tutor'){
      showCenter('教學（按鈕再按一次關閉）', `
        <div class="cols">
          <div>
            <strong>操作</strong><br>
            電腦：<kbd>←</kbd>/<kbd>→</kbd> 或 <kbd>A</kbd>/<kbd>D</kbd> 移動；<kbd>Space</kbd> 開始/暫停。<br>
            釋放黏住的球：<kbd>↑</kbd> 或 <kbd>Shift</kbd>。<br>
            手機：手指拖曳擋板位置即可。<br>
            全螢幕：<kbd>F</kbd>。
          </div>
          <div>
            <strong>目標</strong><br>
            打破所有可破壞磚進入下一關。每 5 關有 Boss（只扣血不會被秒殺）。<br>
            第 1~10 關與 11~20 關會分別顯示同組照片的不同張，20 關結束播放通關畫面。
          </div>
          <div>
            <strong>存讀檔</strong><br>
            可儲存關卡/分數/生命、難度、照片選擇、音效/BGM 設定。
          </div>
        </div>`);
    }else{
      // 效果說明：分類輸出增益、特殊增益、減益與特殊磚
      let html = '<div class="cols">';
      // 增益（buff）
      html += '<div><strong>增益</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'buff'){
          const label = p.label + (p.desc ? `(${p.desc})` : '');
          html += `${badgeIcon(k)} <em>${k}</em>：${label}<br>`;
        }
      }
      html += '</div>';
      // 特殊增益
      html += '<div><strong>特殊增益</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'special'){
          const label = p.label + (p.desc ? `(${p.desc})` : '');
          if(unlockedSpecials.has(k)){
            html += `${badgeIcon(k)} <em>${k}</em>：${label}<br>`;
          }else{
            const req = SPECIAL_UNLOCK_LEVELS[k];
            const hint = req ? `<small class="unlockHint">第${req}關解鎖</small>` : '';
            html += `<span class="sealed">${badgeIcon(k)} <em>${k}</em>：${label}${hint}</span><br>`;
          }
        }
      }
      html += '</div>';
      // 減益（debuff）
      html += '<div><strong>減益</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'debuff'){
          const label = p.label + (p.desc ? `(${p.desc})` : '');
          html += `${badgeIcon(k)} <em>${k}</em>：${label}<br>`;
        }
      }
      html += '</div>';
      // 特殊磚說明
      html += '<div><strong>特殊磚</strong><br>';
      html += '不可破壞磚：只反彈不會壞；<br>';
      html += '移動磚：水平移動；<br>';
      html += '強反彈磚：反彈時加速更強；<br>';
      html += 'Boss磚：大尺寸、只扣血，爆炸/神聖/鳳凰也不會被秒殺。';
      html += '</div>';
      html += '</div>';
      showCenter('效果說明（按鈕再按一次關閉）', html);
    }
  }

  /* ---------------- HUD 互動（移植自 index_skin.html） ---------------- */
  (function(){
    const hud = document.querySelector('.hud');
    const sentinel = document.querySelector('.hud-sentinel');
    const sndBtn = document.getElementById('sndBtn');
    const optBtn = document.getElementById('optBtn');
    const soundMenu = document.getElementById('soundMenu');
    const optMenu = document.getElementById('optMenu');
    let scheduled = false;
    function schedule(){ if(scheduled) return; scheduled = true; requestAnimationFrame(() => { scheduled = false; placeHUD(); }); }
    function placeHUD(){
      const rect = (sentinel || hud).getBoundingClientRect();
      const top = Math.max(0, Math.ceil(rect.top)) + 6;
      document.documentElement.style.setProperty('--hudBottom', top + 'px');
    }
    function toggle(menu, btn){
      const show = !menu.classList.contains('show');
      [soundMenu, optMenu].forEach(m => m.classList.remove('show'));
      document.querySelectorAll('[aria-expanded="true"]').forEach(b => b.setAttribute('aria-expanded', 'false'));
      if(show){
        menu.classList.add('show');
        btn.setAttribute('aria-expanded', 'true');
      }
      // Pause game when any menu is open; resume when none open
      const anyOpen = menusOpen();
      if (typeof window.__setMenuPause === 'function') window.__setMenuPause(anyOpen);
      schedule();
    }
    if(sndBtn) sndBtn.addEventListener('click', (e) => { e.stopPropagation(); toggle(soundMenu, sndBtn); }, {passive:true});
    if(optBtn) optBtn.addEventListener('click', (e) => { e.stopPropagation(); toggle(optMenu, optBtn); }, {passive:true});
    document.addEventListener('click', (e) => {
      if(!e.target.closest('.menu') && !e.target.closest('#optBtn') && !e.target.closest('#sndBtn')){
        const anyOpen = soundMenu.classList.contains('show') || optMenu.classList.contains('show');
        if(anyOpen){
          [soundMenu, optMenu].forEach(m => m.classList.remove('show'));
          if(!menusOpen() && typeof window.__setMenuPause === 'function') window.__setMenuPause(false);
          schedule();
        }
      }
    }, {passive:true});
    ['resize','orientationchange'].forEach(ev => window.addEventListener(ev, schedule, {passive:true}));
    if(document.fonts && document.fonts.ready){ document.fonts.ready.then(schedule); }
    schedule();
  })();

  // === 全螢幕 ===
  async function toggleFullscreen(){
    const elem = document.documentElement;
    try{
      if(!document.fullscreenElement){
        await elem.requestFullscreen();
      }else{
        await document.exitFullscreen();
      }
    }catch(e){
      console.warn('Fullscreen failed:', e);
    }
  }

  // === 擋板寬度 ===
  function desiredPaddleWidth(){
    const now=performance.now();
    buffs.LONG.stacks=buffs.LONG.stacks.filter(t=>t>now);
    const longStacks=Math.min(GAME_CONFIG.powers.LONG.stacksMax, buffs.LONG.stacks.length);
    const addLong=longStacks*(GAME_CONFIG.powers.LONG.longPerStackAdd||0);
    const addWide=(buffs.WIDE.active?(GAME_CONFIG.powers.WIDE.paddleWidthAdd||0):0);
    const base=getDiff().paddleBaseW;
    let width=Math.min(GAME_CONFIG.caps.paddleMaxW, base+addWide+addLong);
    if(buffs.NARROW?.active) width = Math.max(60, width*0.5);
    return width;
  }

  function computePaddleWidth(){
    let desired = desiredPaddleWidth();
    const center=paddle.x+paddle.w/2;
    const reaperCap=Math.max(0, desired - REAPER_PADDLE_MIN_WIDTH);
    if(reaperPaddlePenalty>reaperCap){ reaperPaddlePenalty = reaperCap; }
    let widthAfterReaper=Math.max(REAPER_PADDLE_MIN_WIDTH, desired - reaperPaddlePenalty);
    const penaltyCap=Math.max(0, widthAfterReaper - SPACE_BOSS_PADDLE_MIN_WIDTH);
    if(spaceBossPaddlePenalty>penaltyCap){ spaceBossPaddlePenalty = penaltyCap; }
    let newW=Math.max(SPACE_BOSS_PADDLE_MIN_WIDTH, widthAfterReaper - spaceBossPaddlePenalty);
    paddle.w=newW;
    paddle.x=Math.max(0, Math.min(1100-paddle.w, center - paddle.w/2));
  }

  // 擋板在不同朝向下的實際矩形
  function paddleRect(){
    const now = performance.now();
    if(now < paddleGoneUntil){ return {x:-1000,y:-1000,w:0,h:0}; }
    // 橫向：x,y,w,h；縱向：以 h 為厚度、w 為長度
    if(!orientLeft){
      return {x:paddle.x, y:paddle.y, w:paddle.w, h:paddle.h};
    }else{
      // 左側：固定靠左 40px
      const thick = paddle.h;
      const len = paddle.w;
      const x = 40; // 與牆距
      return {x:x, y:Math.max(0, Math.min(700-len, paddle.y)), w:thick, h:len};
    }
  }
  // === 背景裝飾 & LED 燈條 ===
  function ledColor(){
    if(buffs.GODSPEED.active) return '#ffe066';
    if(buffs.HOLY.active) return '#ffe08a';
    if(buffs.HELL.active) return '#a08cff';
    if(buffs.PLASMA.active) return '#9fe8ff';
    if(buffs.FREEZE.active) return '#cfe9ff';
    if(buffs.RAMPAGE.active || buffs.PIERCE.active || buffs.TRACK.active) return '#7fd8ff';
    if(buffs.FAST.active) return '#ffb37a';
    if(buffs.WAVY.active) return '#ba8fff';
    const led = window.currentSkin && window.currentSkin.canvas && window.currentSkin.canvas.effects && window.currentSkin.canvas.effects.ledStrip;
    if(led){
      const hi = led.hi || window.currentSkin.canvas.hi || [255,255,255];
      const lo = led.lo || window.currentSkin.canvas.base || [92,136,255];
      const period = led.period || window.currentSkin.canvas.period || 2000;
      const t = performance.now();
      const ph = (t % period) / period;
      const blend = 0.5 + 0.5*Math.sin(ph*2*Math.PI);
      const rgb = hi.map((h,i)=>Math.round(h*blend + (lo[i]||0)*(1-blend)));
      return '#' + rgb.map(v=>{const h=v.toString(16);return h.length===1?'0'+h:h;}).join('');
    }
    // Fallback colour when no special buff is active.  If a skin is
    // currently selected and defines a base colour, derive the border
    // colour from it; otherwise revert to the original blue tint.
    if (window.currentSkin && window.currentSkin.canvas && Array.isArray(window.currentSkin.canvas.base)) {
      const arr = window.currentSkin.canvas.base;
      // Convert RGB triplet to a hex string.  Values are clamped to 0–255.
      const hex = '#' + arr.map((v) => {
        const n = Math.max(0, Math.min(255, Math.round(v)));
        const h = n.toString(16);
        return h.length === 1 ? '0' + h : h;
      }).join('');
      return hex;
    }
    return '#8fb3ff';
  }

  function drawBGDecor(){ const w=canvas.width,h=canvas.height; bgTime+=0.003;
    const isCyborg = window.currentSkin && window.currentSkin.cssSkin === '科技．賽博格綠';
    const isPhantom = window.currentSkin && window.currentSkin.cssSkin === '科技．魅影幻彩';
    if(isCyborg){
      ctx.save();
      const bg=ctx.createLinearGradient(0,0,0,h); bg.addColorStop(0,'#00140a'); bg.addColorStop(1,'#000b08'); ctx.fillStyle=bg; ctx.fillRect(0,0,w,h);
      const step=40; const offX=(bgTime*20)%step, offY=(bgTime*15)%step; ctx.strokeStyle='rgba(0,255,150,0.15)'; ctx.lineWidth=1;
      for(let x=-step;x<w+step;x+=step){ const xx=x+offX; ctx.beginPath(); ctx.moveTo(xx,0); ctx.lineTo(xx,h); ctx.stroke(); }
      for(let y=-step;y<h+step;y+=step){ const yy=y+offY; ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(w,yy); ctx.stroke(); }
      ctx.fillStyle='rgba(0,255,150,0.15)';
      for(let x=-step;x<w+step;x+=step){ const xx=x+offX; for(let y=-step;y<h+step;y+=step){ const yy=y+offY; ctx.beginPath(); ctx.arc(xx,yy,1.2,0,Math.PI*2); ctx.fill(); } }
      const glow=ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h)*0.7); glow.addColorStop(0,'rgba(0,255,150,0.12)'); glow.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=glow; ctx.fillRect(0,0,w,h);
      ctx.restore();
      if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    } else if(isPhantom){
      ctx.save();
      const grad=ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h));
      const shift=(Math.sin(bgTime*0.4)+1)/2;
      grad.addColorStop(0,`rgba(60,0,90,${0.55+0.25*shift})`);
      grad.addColorStop(1,'#000');
      ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
      ctx.globalCompositeOperation='lighter';
      const cols=['#ff66ff','#ffb366','#fff466','#66ffb3','#66d1ff','#6666ff','#cc66ff'];
      for(let i=0;i<cols.length;i++){
        ctx.save();
        const ang=i/cols.length*Math.PI*2+bgTime*0.2;
        const x=w/2+Math.cos(ang)*w;
        const y=h/2+Math.sin(ang)*h;
        const beam=ctx.createLinearGradient(w/2,h/2,x,y);
        beam.addColorStop(0,'rgba(0,0,0,0)');
        beam.addColorStop(1,cols[i]);
        ctx.strokeStyle=beam; ctx.globalAlpha=0.25; ctx.lineWidth=60;
        ctx.beginPath(); ctx.moveTo(w/2,h/2); ctx.lineTo(x,y); ctx.stroke();
        ctx.restore();
      }
      ctx.globalCompositeOperation='source-over';
      ctx.restore();
      if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    } else {
      ctx.save(); ctx.globalAlpha=0.12; ctx.translate(Math.sin(bgTime)*8, Math.cos(bgTime*0.7)*6); const step=40;

      for(let x=0;x<w;x+=step){ ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(x,0,1,h);} for(let y=0;y<h;y+=step){ ctx.fillStyle='rgba(255,255,255,.025)'; ctx.fillRect(0,y,w,1);} ctx.restore();
      const grad=ctx.createRadialGradient(w/2,h*0.2,0,w/2,h*0.5,Math.max(w,h)); grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
      if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    }

    // 鳳凰火焰殘留
    for(let i=fireBursts.length-1;i>=0;i--){ const f=fireBursts[i]; f.life-=16; if(f.life<=0){ fireBursts.splice(i,1); continue; } const a=Math.min(1, f.life/600); const rx= (f.x*scaleX), ry=(f.y*scaleY); const r=60*((scaleX+scaleY)/2); const g=ctx.createRadialGradient(rx,ry,1,rx,ry,r); g.addColorStop(0,`rgba(255,180,0,${0.6*a})`); g.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(rx,ry,r,0,Math.PI*2); ctx.fill(); }

    // 火焰球爆炸範圍特效
    for(let i=fireExplosions.length-1;i>=0;i--){
      const ex = fireExplosions[i];
      const age = performance.now() - ex.t0;
      const prog = age / ex.life;
      if(prog>=1){ fireExplosions.splice(i,1); continue; }
      const alpha = 1 - prog;
      const x = ex.x * scaleX;
      const y = ex.y * scaleY;
      const r = ex.r * ((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = `rgba(255,80,0,${0.25*alpha})`;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = `rgba(255,200,50,${alpha})`;
      ctx.lineWidth = 4 + 6*(1-prog);
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }


    // LED 燈條框（多風格，落球區域無燈條）
    const c=ledColor();
    let spAvg=0; for(const b of balls){ spAvg += Math.hypot(b.vx,b.vy); } spAvg = balls.length? spAvg/balls.length : 8;
    const nowT = performance.now();
    // For the classic LED breathing effect, prefer the period defined by the
    // current skin (if available).  When a skin is selected its period
    // defines the full cycle (in ms).  Otherwise fall back to the original
    // behaviour based on ball speed.
    let __periodClassic;
    if (window.currentSkin && window.currentSkin.canvas && typeof window.currentSkin.canvas.period === 'number') {
      __periodClassic = window.currentSkin.canvas.period;
    } else {
      // Preserve the old dynamic period based on average ball speed (spAvg).
      __periodClassic = (180 - Math.min(120, spAvg * 6));
    }
    // Compute a phase between 0 and 1, wrapping around __periodClassic.
    const __phaseClassic = ((__periodClassic > 0) ? ((nowT % __periodClassic) / __periodClassic) : 0);
    const breathClassic = (Math.sin(__phaseClassic * Math.PI * 2) + 1) / 2;
    const breath5 = (Math.sin(nowT / (5000 / (2*Math.PI)))+1)/2;  // 5s
    const breath3 = (Math.sin(nowT / (3000 / (2*Math.PI)))+1)/2;  // 3s
    const breath8 = (Math.sin(nowT / (8000 / (2*Math.PI)))+1)/2;  // 8s

    function pathThreeSides(){
      ctx.beginPath();
      if(!orientLeft){
        ctx.moveTo(3,3); ctx.lineTo(w-3,3);
        ctx.moveTo(3,3); ctx.lineTo(3,h-3);
        ctx.moveTo(w-3,3); ctx.lineTo(w-3,h-3);
      }else{
        ctx.moveTo(3,3); ctx.lineTo(w-3,3);
        ctx.moveTo(w-3,3); ctx.lineTo(w-3,h-3);
        ctx.moveTo(3,h-3); ctx.lineTo(w-3,h-3);
      }
    }

    ctx.save();
    if(isPhantom){
      const rainbow=['#ff66ff','#ffb366','#fff466','#66ffb3','#66d1ff','#6666ff','#cc66ff'];
      const periodColor=(window.currentSkin&&window.currentSkin.canvas&&window.currentSkin.canvas.period)||2400;
      const step=Math.floor(nowT/periodColor)%rainbow.length;
      const c1=rainbow[step];
      const c2=rainbow[(step+1)%rainbow.length];
      const grad=ctx.createLinearGradient(0,0,w,0);
      grad.addColorStop(0,c1);
      grad.addColorStop(1,c2);
      ctx.globalAlpha=0.55+0.35*breathClassic;
      ctx.strokeStyle=grad; ctx.lineWidth=6;
      ctx.shadowColor=c2; ctx.shadowBlur=24+12*breathClassic;
      pathThreeSides(); ctx.stroke();
      ctx.restore();
    } else switch(ledStyle){
      case 'tech': {
        ctx.globalAlpha = 0.55 + 0.35*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=8; ctx.shadowColor=c; ctx.shadowBlur=28 + 10*breath5;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'arc': {
        ctx.globalAlpha = 0.5 + 0.25*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=5; ctx.shadowColor=c; ctx.shadowBlur=16 + 6*breath5;
        pathThreeSides(); ctx.setLineDash([14,10]); ctx.lineDashOffset = -(nowT/20); ctx.stroke();
        ctx.setLineDash([]); ctx.globalAlpha = 0.3 + 0.2*breath8; ctx.lineWidth=2.5; ctx.shadowBlur=0;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'steel': {
        ctx.globalAlpha = 0.65 + 0.25*breath5;
        const g = ctx.createLinearGradient(0,0,w,0);
        g.addColorStop(0, 'rgba(220,230,255,0.85)');
        g.addColorStop(0.5, 'rgba(120,140,180,0.85)');
        g.addColorStop(1, 'rgba(200,210,240,0.85)');
        ctx.strokeStyle=g; ctx.lineWidth=7.5; ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=12;
        pathThreeSides(); ctx.stroke();
        ctx.shadowBlur=0; ctx.fillStyle=c;
        const ends = !orientLeft ? [[3,3],[w-3,3]] : [[w-3,3],[w-3,h-3]];
        for(const [ex,ey] of ends){ ctx.beginPath(); ctx.arc(ex,ey,6 + 2*breath5, 0, Math.PI*2); ctx.fill(); }
        break;
      }
      case 'vivid': {
        ctx.globalAlpha = 0.5 + 0.5*breath3;
        const grad = ctx.createLinearGradient(0,0,w,0);
        grad.addColorStop(0, 'rgba(255,255,255,0.85)');
        grad.addColorStop(1, c);
        ctx.strokeStyle=grad; ctx.lineWidth=4.5;
        for(const off of [-4,0,4]){ ctx.save(); ctx.translate(0,off); pathThreeSides(); ctx.stroke(); ctx.restore(); }
        break;
      }
      default: {
        ctx.globalAlpha = 0.6 + 0.3*breathClassic;
        if(window.currentSkin && window.currentSkin.cssSkin === '科技．賽博格綠'){
          const g = ctx.createLinearGradient(0,0,w,0);
          g.addColorStop(0,'#00ff99');
          g.addColorStop(1,'#00cc66');
          ctx.strokeStyle=g; ctx.lineWidth=6;
          ctx.shadowColor='#00ff99'; ctx.shadowBlur=20 + 10*breathClassic; pathThreeSides(); ctx.stroke();
        }else{
          ctx.strokeStyle=c; ctx.lineWidth=6; ctx.shadowColor=c; ctx.shadowBlur=20 + 10*breathClassic; pathThreeSides(); ctx.stroke();
        }
        break;
      }
    }
    ctx.restore();}

  // 只在磚塊區域揭示圖片切片（依本關影像）
  function drawRevealTiles(){
    const img=getLevelImage(level);
    if(!img || !(img.naturalWidth>0 && img.naturalHeight>0)) return;
    const L=layout();
    const area={x:L.pad,y:L.top,w:1100-L.pad*2,h:L.rows*(brickH+L.pad)-L.pad};
    const rImg=img.naturalWidth/img.naturalHeight;
    const rArea=area.w/area.h;
    let dw,dh;
    if(rImg>rArea){ dh=area.h; dw=dh*rImg; } else { dw=area.w; dh=dw/rImg; }
    const dx=area.x+(area.w-dw)/2;
    const dy=area.y+(area.h-dh)/2;
    ctx.save();
    ctx.scale(scaleX,scaleY);
    for(const r of revealRects){
      let sx=(r.x-dx)/dw*img.naturalWidth;
      let sy=(r.y-dy)/dh*img.naturalHeight;
      let sw=r.w/dw*img.naturalWidth;
      let sh=r.h/dh*img.naturalHeight;
      const sx0=Math.max(0, Math.min(img.naturalWidth, sx));
      const sy0=Math.max(0, Math.min(img.naturalHeight, sy));
      const sw0=Math.max(0, Math.min(img.naturalWidth - sx0, sw));
      const sh0=Math.max(0, Math.min(img.naturalHeight - sy0, sh));
      if(sw0>0 && sh0>0){
        ctx.drawImage(img, sx0,sy0,sw0,sh0, r.x, r.y, r.w, r.h);
      }
    }
    ctx.restore();
  }

  function drawPlasmas(){ const now=performance.now(); ctx.save(); for(let i=plasmas.length-1;i>=0;i--){ const P=plasmas[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.995; P.vy*=0.995; P.phase=(P.phase||0)+0.2; if(now>P.until){ plasmas.splice(i,1); continue; }
      const x=P.x*scaleX, y=P.y*scaleY, r=P.radius*((scaleX+scaleY)/2); const grd=ctx.createRadialGradient(x,y,0,x,y,r); grd.addColorStop(0,'rgba(200,255,255,0.9)'); grd.addColorStop(0.3,'rgba(150,200,255,0.6)'); grd.addColorStop(0.6,'rgba(120,150,255,0.3)'); grd.addColorStop(1,'rgba(120,150,255,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.save(); ctx.globalCompositeOperation='lighter'; for(let k=0;k<3;k++){ const a=P.phase+k*Math.PI*2/3; ctx.strokeStyle='rgba(180,240,255,0.6)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,r*0.8,a,a+Math.PI/3); ctx.stroke(); } ctx.restore();
      // 沿途清除磚塊（Boss/不可破壞豁免）
      for(let j=bricks.length-1;j>=0;j--){ const b=bricks[j]; const bx=b.x+b.w/2, by=b.y+b.h/2; if(Math.hypot(P.x-bx,P.y-by)<=P.radius){
          if(b.unbreakable) continue;
          if(b.boss){
            b.hp-=1;
            if(b.hp<=0){ bossKillEffect(b); revealBrickArea(b); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; updateHUD(); }
          }
          else {
            revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++; updateHUD(); playSFX('plasmaHit');
          }
        }
      }
      if(circleIntersectsActiveBoss(P.x,P.y,P.radius)){
        const impact=activeBossClampPoint(P.x, P.y);
        damageActiveBoss(1,'plasma',impact);
      }
    } ctx.restore(); }

  function drawHoly(){ const now=performance.now(); for(let i=holyFlashes.length-1;i>=0;i--){ const H=holyFlashes[i]; if(now>H.until){ holyFlashes.splice(i,1); continue; } const a=Math.max(0, (H.until-now)/300); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle=`rgba(255,240,180,${0.6*a})`; ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(0, H.y*scaleY); ctx.lineTo(canvas.width, H.y*scaleY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(H.x*scaleX, 0); ctx.lineTo(H.x*scaleX, canvas.height); ctx.stroke(); ctx.restore(); } }

  function drawPhoenix(){ if(!phoenixAnim) return; const now=performance.now(); const t=phoenixAnim; const prog=1-Math.max(0,(t.tEnd-now)/1200); const logicW=1100; const xLogic=(1-prog)*(logicW+200)-200; const x=xLogic*scaleX;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    // 身形光羽
    const grad=ctx.createLinearGradient((x+120),220*scaleY,x,260*scaleY); grad.addColorStop(0,'rgba(255,180,0,0.9)'); grad.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=grad;
    ctx.beginPath(); ctx.moveTo((x+180), 220*scaleY); ctx.quadraticCurveTo((x+60), 180*scaleY, (x), 230*scaleY); ctx.quadraticCurveTo((x-40), 260*scaleY, (x+120), 260*scaleY); ctx.closePath(); ctx.fill();
    // 羽毛粒子
    for(let i=0;i<3;i++){ fireBursts.push({x:(x-40)+Math.random()*120,y:220+Math.random()*60,life:300+Math.random()*400}); }
    ctx.restore(); if(now>=t.tEnd) phoenixAnim=null; }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(screenShake>0){ const s=screenShake*0.6; ctx.save(); ctx.translate((Math.random()-0.5)*s,(Math.random()-0.5)*s); screenShake*=0.9; }
    const now=performance.now();
    drawBGDecor();
    drawDemonWave(now);
    if(buffs.ANNIHIL.active){ if(Math.random()<0.5) annihilSparks.push({x:Math.random()*1100,y:0,v:1+Math.random()*1.5}); for(let i=annihilSparks.length-1;i>=0;i--){ const sp=annihilSparks[i]; sp.y+=sp.v; ctx.fillStyle='rgba(255,220,150,0.8)'; ctx.fillRect(sp.x*scaleX, sp.y*scaleY,2*scaleX,2*scaleY); if(sp.y>700) annihilSparks.splice(i,1); } }
    drawRevealTiles();

    // 磚塊
    for(const b of bricks){
      // 移動磚更新
      if(b.moving){
        b.x += b.vx;
        if(b.x<8){ b.x=8; b.vx=Math.abs(b.vx); }
        if(b.x+b.w>1100-8){ b.x=1100-8-b.w; b.vx=-Math.abs(b.vx); }
      }
      // 繪製
      let fillStyle;
      if(b.treasure){
        const gold=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
        gold.addColorStop(0,'#fff5d6');
        gold.addColorStop(0.18,'#ffe38a');
        gold.addColorStop(0.45,'#ffd042');
        gold.addColorStop(0.78,'#d9a326');
        gold.addColorStop(1,'#9f7012');
        fillStyle=gold;
      }else{
        let base = b.boss ? '#ff4d6d' : b.unbreakable ? '#888' : b.strong ? '#bb7aff' : b.moving ? '#6ec6ff' : b.explosive ? getVar('--expl') : brickColor(b.colorIdx);
        const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
        g.addColorStop(0,base);
        g.addColorStop(1,'#1a1f3a');
        fillStyle=g;
      }
      ctx.fillStyle=fillStyle;
      drawRoundedRect(b.x,b.y,b.w,b.h,6);
      ctx.fill();
      if(b.treasure){
        const now=performance.now();
        const sheenPos=(now%1400)/1400;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const sheen=ctx.createLinearGradient((b.x-12)*scaleX,(b.y-12)*scaleY,(b.x+b.w+12)*scaleX,(b.y+b.h+12)*scaleY);
        const start=Math.max(0,sheenPos-0.2);
        const peak=sheenPos;
        const end=Math.min(1,sheenPos+0.2);
        sheen.addColorStop(0,'rgba(255,255,255,0)');
        sheen.addColorStop(start,'rgba(255,255,255,0)');
        sheen.addColorStop(peak,'rgba(255,255,255,0.85)');
        sheen.addColorStop(end,'rgba(255,255,255,0)');
        sheen.addColorStop(1,'rgba(255,255,255,0)');
        ctx.globalAlpha=0.55;
        ctx.fillStyle=sheen;
        drawRoundedRect(b.x-4,b.y-4,b.w+8,b.h+8,9);
        ctx.fill();

        const glowPulse=0.65+0.35*Math.sin(now/320);
        const rainbow=ctx.createLinearGradient((b.x-10)*scaleX,(b.y-10)*scaleY,(b.x+b.w+10)*scaleX,(b.y+b.h+10)*scaleY);
        const rainbowColors=['#ff6ec7','#ff9f43','#ffe066','#8ce99a','#74c0fc','#b197fc','#ff85f5'];
        rainbowColors.forEach((col,i)=>rainbow.addColorStop(i/(rainbowColors.length-1),col));
        ctx.globalAlpha=0.8+0.2*Math.sin(now/360);
        ctx.strokeStyle=rainbow;
        ctx.lineWidth=3.5+1.5*glowPulse;
        ctx.shadowBlur=20;
        ctx.shadowColor=`rgba(255,210,120,${0.3+0.25*glowPulse})`;
        drawRoundedRect(b.x-5,b.y-5,b.w+10,b.h+10,10);
        ctx.stroke();
        ctx.restore();
      }
      if(b.placeholderBoss){
        const pulse=0.5+0.5*Math.sin(performance.now()/200);
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle=`rgba(255,210,150,${0.35+0.35*pulse})`;
        ctx.lineWidth=6;
        drawRoundedRect(b.x-6,b.y-6,b.w+12,b.h+12,10);
        ctx.stroke();
        ctx.restore();
      }
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.shadowColor='rgba(120,220,255,0.7)'; ctx.shadowBlur=15; const eg=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x+b.w)*scaleX,(b.y+b.h)*scaleY); eg.addColorStop(0,'rgba(0,255,255,0.9)'); eg.addColorStop(1,'rgba(120,180,255,0.2)'); ctx.strokeStyle=eg; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.shadowBlur=0; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); }
      if(b.poisonUntil && performance.now()<b.poisonUntil){ ctx.fillStyle='rgba(0,255,0,0.25)'; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill(); }
      // 鎖鏈覆蓋
      if(b.lockedUntil && performance.now() < b.lockedUntil){ ctx.fillStyle='rgba(90,0,120,0.35)'; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill();
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.shadowColor='rgba(120,220,255,0.7)'; ctx.shadowBlur=15; const eg=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x+b.w)*scaleX,(b.y+b.h)*scaleY); eg.addColorStop(0,'rgba(0,255,255,0.9)'); eg.addColorStop(1,'rgba(120,180,255,0.2)'); ctx.strokeStyle=eg; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.shadowBlur=0; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); } }
      // 菁英聚氣光
      if(b.elite && b.eliteChargeUntil && performance.now()<b.eliteChargeUntil){ const a=0.5+0.5*Math.sin(performance.now()/80); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,220,255,'+(0.6*a)+')'; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.restore(); }
      // 血條 / 面孔
      if(b.boss){
        drawBossEmblem(b);
        if(!b.cyclops && !b.hideBossHP){
          // 血條
          ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*scaleX,6*scaleY);
          const ratio=Math.max(0, b.hp/40);
          const hpGrad=ctx.createLinearGradient((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.x+b.w-8)*scaleX,(b.y+b.h-8)*scaleY);
          hpGrad.addColorStop(0,'rgba(255,150,150,.95)'); hpGrad.addColorStop(1,'rgba(255,240,240,.95)');
          ctx.fillStyle=hpGrad; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*ratio*scaleX,6*scaleY);
        }
      }else if(b.hp>1 && b.hp<99 && b.hp<Infinity){
        ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*scaleX,4*scaleY);
        ctx.fillStyle='rgba(255,255,255,.75)'; const ratio=Math.max(0,(b.hp-1))/3; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*ratio*scaleX,4*scaleY);
      }
    }

    for(const d of demonFallingDebris){
      ctx.save();
      const cx=(d.x + d.w/2)*scaleX;
      const cy=(d.y + d.h/2)*scaleY;
      ctx.translate(cx, cy);
      ctx.rotate(d.angle);
      const w=d.w*scaleX;
      const h=d.h*scaleY;
      const grad=ctx.createLinearGradient(0,-h/2,0,h/2);
      grad.addColorStop(0,d.color||'#ffffff');
      grad.addColorStop(1,'rgba(26,31,58,0.85)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.moveTo(-w/2,-h/2);
      ctx.lineTo(w/2,-h/2);
      ctx.lineTo(w/2,h/2);
      ctx.lineTo(-w/2,h/2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    drawSpaceBossLayer();
    drawReaperLayer();
    drawDragonLayer();
    drawDemonLayer(now);
    drawDemonCloakWraps(now,'behind');
    drawPlasmas(); drawHoly(); drawPhoenix(); drawSwords();

      // Boss wind-up glow
      if(bossChargeUntil && performance.now()<bossChargeUntil){
      const nowCharge = performance.now();
      const a = 0.5 + 0.5*Math.sin(nowCharge/80);
      const dragonCharging = isDragonActive() && dragonBoss && dragonBoss.petrifyCharge && nowCharge < dragonBoss.petrifyCharge.end;
      for(const b of bricks){ if(b.boss){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba('+bossChargeColor+','+(0.6*a)+')'; ctx.lineWidth=4; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke(); ctx.restore(); } }
      if(isDragonActive() && dragonBoss){ const bounds=getDragonBounds(); if(bounds && !dragonCharging){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba('+bossChargeColor+','+(0.6*a)+')'; ctx.lineWidth=4; drawRoundedRect(bounds.x, bounds.y, bounds.w, bounds.h, 18); ctx.stroke(); ctx.restore(); } }
    }


    // 擋板
    const pr=paddleRect();
    const nowPad=performance.now();
    if(nowPad>=paddleGoneUntil){
      const padGlow=buffs.STICKY.active?'rgba(120,230,220,.6)':((buffs.WIDE.active||buffs.LONG.stacks.length)?'rgba(120,170,255,.6)':'rgba(200,210,255,.4)');
      ctx.shadowColor=padGlow; ctx.shadowBlur=20;
      const padW=pr.w*scaleX, padH=pr.h*scaleY;
      ctx.save();
      ctx.translate((pr.x+pr.w/2)*scaleX,(pr.y+pr.h/2)*scaleY);
      let ang=0;
      if(buffs.PADSPIN.active){ const period=GAME_CONFIG.powers.PADSPIN.spin.periodMs||8000; ang=((nowPad-(buffs.PADSPIN.start||nowPad))%period)/period*2*Math.PI; }
      ctx.rotate(ang);
      ctx.fillStyle='#9aaeff';
      if(buffs.PADBOOM.active && !buffs.PADBOOM.exploded){ ctx.globalAlpha=0.5+0.5*Math.sin(nowPad/100); }
      const r=8*Math.min(scaleX,scaleY);
      ctx.beginPath();
      ctx.moveTo(-padW/2 + r, -padH/2);
      ctx.arcTo(padW/2, -padH/2, padW/2, padH/2, r);
      ctx.arcTo(padW/2, padH/2, -padW/2, padH/2, r);
      ctx.arcTo(-padW/2, padH/2, -padW/2, -padH/2, r);
      ctx.arcTo(-padW/2, -padH/2, padW/2, -padH/2, r);
      ctx.closePath();
      ctx.fill();
      if(buffs.HOLE.active){
        if(!orientLeft){ const gapW=padW/3; ctx.clearRect(-padW/2+padW/3, -padH/2, gapW, padH); }
        else { const gapH=padH/3; ctx.clearRect(-padW/2, -padH/2+padH/3, padW, gapH); }
      }
      ctx.restore();
      ctx.shadowBlur=0;
      if(buffs.SHIELD.active && !orientLeft){ const g=ctx.createLinearGradient(0,(700-10)*scaleY,0,700*scaleY); g.addColorStop(0,'rgba(120,220,255,0.35)'); g.addColorStop(1,'rgba(120,220,255,0.05)'); ctx.fillStyle=g; ctx.fillRect(0,(700-10)*scaleY,canvas.width,10*scaleY); }
      if(nowPad<=paddleStunUntil){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(255,230,160,0.35)'; drawRoundedRect(pr.x,pr.y,pr.w,pr.h,8); ctx.fill(); ctx.restore(); }
    }
    // 雷射砲展示
    if(buffs.LASER.active){ ctx.fillStyle='rgba(120,255,120,0.8)'; if(!orientLeft){ ctx.fillRect((pr.x-6)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); ctx.fillRect((pr.x+pr.w+2)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); } else { ctx.fillRect((pr.x-4)*scaleX, (pr.y-6)*scaleY, (pr.w+8)*scaleX, 4*scaleY); ctx.fillRect((pr.x-4)*scaleX, (pr.y+pr.h+2)*scaleY, (pr.w+8)*scaleX, 4*scaleY); } }
    if(stormTurret){ const t=stormTurret; ctx.save(); ctx.fillStyle='rgba(200,255,200,0.8)'; ctx.fillRect((t.x-10)*scaleX,(t.y-20)*scaleY,20*scaleX,20*scaleY); if(performance.now()<t.chargeUntil){ const prog=1-(t.chargeUntil-performance.now())/3000; ctx.globalCompositeOperation='lighter'; ctx.fillStyle=`rgba(120,255,200,${0.3+0.7*prog})`; ctx.beginPath(); ctx.arc(t.x*scaleX,(t.y-20)*scaleY,30*prog*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); } ctx.restore(); }
    if(gatling){
      const t=gatling;
      ctx.save();
      const grad=ctx.createLinearGradient((t.x-8)*scaleX,(t.y-20)*scaleY,(t.x+8)*scaleX,t.y*scaleY);
      grad.addColorStop(0,'#444');
      grad.addColorStop(0.5,'#bbb');
      grad.addColorStop(1,'#444');
      ctx.fillStyle=grad;
      ctx.fillRect((t.x-8)*scaleX,(t.y-20)*scaleY,16*scaleX,20*scaleY);
      ctx.fillStyle='#333';
      ctx.fillRect((t.x-3)*scaleX,(t.y-24)*scaleY,6*scaleX,4*scaleY);
      if(performance.now()<t.chargeUntil){
        const prog=1-(t.chargeUntil-performance.now())/(GAME_CONFIG.powers.GATLING.gatling.chargeMs||3000);
        ctx.globalCompositeOperation='lighter';
        ctx.fillStyle=`rgba(255,200,100,${0.3+0.7*prog})`;
        ctx.beginPath();
        ctx.arc(t.x*scaleX,(t.y-24)*scaleY,20*prog*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    // 球與拖尾
    const nowT=performance.now();
    for(const b of balls){
      b.trail.push({x:b.x,y:b.y,t:nowT}); while(b.trail.length>12) b.trail.shift();
      for(let i=b.trail.length-1;i>=0;i--){ const p=b.trail[i]; const age=(nowT-p.t)/200; if(age>1) continue; const alpha=(1-age)*0.6;
        let color=( (b.rampageUntil&&nowT<b.rampageUntil)||b.piercing )?`rgba(120,220,255,${alpha})`:(buffs.FAST.active?`rgba(255,140,90,${alpha})`:`rgba(255,255,255,${alpha*0.6})`);
        if(buffs.PLASMA.active) color=`rgba(160,240,255,${alpha})`; if(buffs.FREEZE.active) color=`rgba(200,230,255,${alpha})`; if(buffs.HOLY.active) color=`rgba(255,240,180,${alpha})`; if(buffs.FIRE.active) color=`rgba(255,150,50,${alpha})`; if(buffs.POISON.active) color=`rgba(120,255,120,${alpha})`; if(buffs.BLINK.active) color=`rgba(180,200,255,${alpha})`; if(buffs.SWORD.active) color=`rgba(${150+100*Math.sin(nowT/80)},${120+60*Math.sin(nowT/60)},255,${alpha})`; if(buffs.BLACKHOLE.active) color=`rgba(80,80,120,${alpha})`; if(buffs.ANNIHIL.active) color=`rgba(255,200,80,${alpha})`;
        if(buffs.TRACK.active) color=`rgba(${Math.floor(128+127*Math.sin(nowT/80))},${Math.floor(128+127*Math.sin(nowT/95+2))},${Math.floor(128+127*Math.sin(nowT/110+4))},${alpha})`;
        if(buffs.GODSPEED.active) color=`rgba(255,224,102,${alpha})`;
        ctx.fillStyle=color; ctx.beginPath(); ctx.arc(p.x*scaleX,p.y*scaleY,(b.r*0.7)*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill();
      }
      const bx=b.x*scaleX, by=b.y*scaleY, br=b.r*((scaleX+scaleY)/2); const grad=ctx.createRadialGradient(bx-3,by-4,2,bx,by,br);
      let edge=(b.piercing||(b.rampageUntil&&nowT<b.rampageUntil))?'#9ff':(buffs.FAST.active?'#ff9a66':'#cbd4ff');
      if(buffs.PLASMA.active) edge='#aff'; if(buffs.FREEZE.active) edge='#e8f8ff'; if(buffs.HOLY.active) edge='#fff0a0'; if(buffs.FIRE.active) edge='#ff6600'; if(buffs.POISON.active) edge='#55ff55'; if(buffs.BLINK.active) edge='#a0b0ff'; if(buffs.GODSPEED.active) edge='#ffe066'; if(buffs.SWORD.active) edge='#d0bbff'; if(buffs.BLACKHOLE.active) edge='#444'; if(buffs.ANNIHIL.active) edge='#ffb347';
      if(b.demonCloakState==='captured') edge='#ff758b';
      grad.addColorStop(0,'#fff'); grad.addColorStop(1, edge); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();
      if(buffs.WAVY.active){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; const r1=br+2+2*Math.sin((nowT/100)+b.x*0.02); ctx.beginPath(); ctx.arc(bx,by,r1,0,Math.PI*2); ctx.stroke(); }
      if(b.stuck && !orientLeft){ ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect((paddle.x+paddle.w/2-12)*scaleX,(paddle.y-6)*scaleY,24*scaleX,4*scaleY); }
    }
    drawDemonCloakWraps(nowT,'front');

    // 黑洞特效
    for(let i=blackHoles.length-1;i>=0;i--){
      const h=blackHoles[i];
      const nowH=performance.now();
      if(nowH>h.until){ blackHoles.splice(i,1); continue; }
      if(h.spinPhase==null){ h.spinPhase=Math.random()*Math.PI*2; }
      const baseR=h.r||40;
      const start=h.start!=null?h.start:(h.until-600);
      const life=Math.max(1, h.until-start);
      const age=Math.max(0, Math.min(1, (nowH-start)/life));
      const spinDir=h.spinDir||1;
      const scaleAvg=(scaleX+scaleY)/2;
      const pulse=0.82+0.18*Math.sin(nowH/150 + h.spinPhase);
      const x=h.x*scaleX, y=h.y*scaleY;
      const coreR=baseR*scaleAvg*pulse;
      const coronaR=coreR*1.5;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createRadialGradient(x,y,0,x,y,coronaR);
      grad.addColorStop(0,'rgba(5,0,10,0.96)');
      grad.addColorStop(0.32,`rgba(50,0,80,${0.92-0.25*age})`);
      grad.addColorStop(0.6,`rgba(140,70,220,${0.65-0.28*age})`);
      grad.addColorStop(0.86,'rgba(220,180,255,0.22)');
      grad.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(x,y,coronaR,0,Math.PI*2);
      ctx.fill();
      const horizonR=coreR*1.18;
      ctx.strokeStyle=`rgba(220,190,255,${0.22+0.22*Math.sin(nowH/210 + age*Math.PI)})`;
      ctx.lineWidth=4*scaleAvg*(1-age*0.5);
      ctx.beginPath();
      ctx.arc(x,y,horizonR,0,Math.PI*2);
      ctx.stroke();
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate((nowH/240 + h.spinPhase)*spinDir);
      const swirlLayers=4;
      for(let layer=0; layer<swirlLayers; layer++){
        const theta=layer*(Math.PI/2);
        const rr=coreR*(0.46 + layer*0.12);
        ctx.beginPath();
        ctx.strokeStyle=`rgba(255,230,255,${0.14*(1-layer*0.18)})`;
        ctx.lineWidth=(1.6+layer*0.7)*scaleAvg;
        ctx.arc(0,0,rr,theta,theta+Math.PI*0.65);
        ctx.stroke();
      }
      ctx.restore();
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate((-nowH/320 + h.spinPhase*1.4)*spinDir);
      ctx.strokeStyle=`rgba(160,110,255,${0.2*(1-age)})`;
      ctx.lineWidth=3.6*scaleAvg;
      ctx.beginPath();
      ctx.arc(0,0,coreR*1.32,-Math.PI*0.35,Math.PI*0.35);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    
    // 雷射光束（強化質感）
    for(let i=laserBeams.length-1;i>=0;i--){
      const b=laserBeams[i];
      const nowP=performance.now();
      if(nowP>b.until){ laserBeams.splice(i,1); continue; }
      const x1=b.x1*scaleX, y1=b.y1*scaleY, x2=b.x2*scaleX, y2=b.y2*scaleY;
      const t = Math.max(0, Math.min(1, (b.until-nowP)/200));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      // Outer glow
      ctx.strokeStyle='rgba(120,255,180,'+(0.25*t)+')';
      ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Mid beam
      const grd = ctx.createLinearGradient(x1,y1,x2,y2);
      grd.addColorStop(0,'rgba(160,255,220,'+(0.7*t)+')');
      grd.addColorStop(1,'rgba(255,255,255,'+(0.9*t)+')');
      ctx.strokeStyle=grd; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Core
      ctx.strokeStyle='rgba(255,255,255,'+(1*t)+')'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    }
    // Boss 投射物
    drawAndStepBossProjectiles();

    // 雷射命中散開特效
    for(let i=laserImpacts.length-1;i>=0;i--){
      const it=laserImpacts[i]; const nowI=performance.now();
      if(nowI>it.tEnd){ laserImpacts.splice(i,1); continue; }
      const prog = 1 - Math.max(0, (it.tEnd - nowI)/ (it.tEnd - it.t0));
      const x = it.x*scaleX, y = it.y*scaleY;
      // expanding ring
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='rgba(160,255,200,'+(0.8*(1-prog))+')';
      ctx.lineWidth = 2 + 6*prog;
      ctx.beginPath(); ctx.arc(x,y, 6 + 26*prog, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
      // sparks
      for(let s=0;s<6;s++){
        const ang = (s/6)*Math.PI*2;
        const len = 8 + prog*24;
        ctx.save(); ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle='rgba(180,255,220,'+(0.7*(1-prog))+')';
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(x,y);
        ctx.lineTo(x+Math.cos(ang)*len, y+Math.sin(ang)*len);
        ctx.stroke(); ctx.restore();
      }
    }
    // 火力壓制子彈
    for(const b of gatlingBullets){
      ctx.save();
      const r=4*((scaleX+scaleY)/2);
      const g=ctx.createRadialGradient(b.x*scaleX,b.y*scaleY,0,b.x*scaleX,b.y*scaleY,r);
      g.addColorStop(0,'#fff');
      g.addColorStop(0.3,'#ffec99');
      g.addColorStop(1,'#ff8800');
      ctx.fillStyle=g;
      ctx.shadowBlur=8*((scaleX+scaleY)/2);
      ctx.shadowColor='#ffb347';
      ctx.beginPath(); ctx.arc(b.x*scaleX,b.y*scaleY,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    // 飛彈
    for(const m of missiles){ for(const tr of (m.trail||[])){ const a=Math.max(0,1-(performance.now()-tr.t)/300); ctx.fillStyle=`rgba(255,180,90,${0.6*a})`; ctx.beginPath(); ctx.arc(tr.x*scaleX,tr.y*scaleY,2*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); } ctx.fillStyle='#ddd'; ctx.beginPath(); ctx.arc(m.x*scaleX,m.y*scaleY,4*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    // 掉落道具

    for(const p of powerups) drawPower(p);

    // 鎖定框
    drawLockBoxes();

    // 粒子
    for(let i=particles.length-1;i>=0;i--){ const P=particles[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.98; P.vy*=0.98; P.life-=16; if(P.life<=0){ particles.splice(i,1); continue; }
      const a=Math.max(0, Math.min(1, P.life/500)); ctx.fillStyle=P.color||`rgba(255,220,180,${a*0.6})`; ctx.beginPath(); ctx.arc(P.x*scaleX,P.y*scaleY,P.size*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    drawSpaceBossHUD();
    drawReaperHUD();
    drawDragonHUD();
    drawDemonHUD();
    drawDemonMarquee(now);

    // 倒數提示
    if(countdownShow>0){
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.font=`${Math.round(96*((scaleX+scaleY)/2))}px system-ui, sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(countdownShow), canvas.width/2, canvas.height/2);
      ctx.restore();
    }

    // 天地翻轉提示：啟動前 2 秒與結束前 2 秒顯示旋轉符號，不遮擋球/方塊/平台
    {
      const f = buffs.FLIP;
      const nowT = performance.now();
      let showFlip = false;
      if(f){
        if(f.pending && f.startAt && nowT >= f.startAt - 2000 && nowT < f.startAt){ showFlip = true; }
        if(f.active && f.endAt && nowT >= f.endAt - 2000 && nowT < f.endAt){ showFlip = true; }
      }
      if(showFlip){
        ctx.save();
        // 遮罩輕微暗化背景
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        // 畫旋轉符號（使用 Unicode 符號 ↻）
        ctx.fillStyle = '#aaffaa';
        ctx.font = `${Math.round(80*((scaleX+scaleY)/2))}px system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('↻', canvas.width/2, canvas.height/2);
        ctx.restore();
      }
    }

    if(screenShake>0){ ctx.restore(); }
  }

  function drawSwords(){ const now=performance.now(); const pr=paddleRect(); for(let i=swords.length-1;i>=0;i--){ const s=swords[i]; if(s.state==='wander'){ s.x+=s.vx; s.y+=s.vy; if(s.x<20||s.x>1080) s.vx*=-1; if(s.y<500||s.y>680) s.vy*=-1; if(!buffs.SWORD.active){ s.state='gather'; s.t0=now; s.tx=pr.x+pr.w/2+ (i-swords.length/2)*20; s.ty=pr.y-40; } } else if(s.state==='gather'){ const prog=Math.min(1,(now-s.t0)/2000); s.x += (s.tx-s.x)*0.15; s.y += (s.ty-s.y)*0.15; if(prog>=1){ s.state='ready'; } } else if(s.state==='fire'){ s.x+=s.vx; s.y+=s.vy; const idx=s.target; if(idx==='boss'){ const bounds=getActiveBossBounds(); if(!isSpecialBossActive() || !bounds){ swords.splice(i,1); continue; } if(s.x>bounds.x && s.x<bounds.x+bounds.w && s.y>bounds.y && s.y<bounds.y+bounds.h){ playSFX('sword'); damageActiveBoss(1,'sword',{x:s.x,y:s.y}); swords.splice(i,1); continue; } } else { const bk=bricks[idx]; if(bk && s.x>bk.x && s.x<bk.x+bk.w && s.y>bk.y && s.y<bk.y+bk.h){ playSFX('sword'); damageBrick(idx,3,'none'); swords.splice(i,1); continue; } } if(s.x<0||s.x>1100||s.y<0||s.y>700){ swords.splice(i,1); continue; } }
      ctx.save();
      ctx.translate(s.x*scaleX, s.y*scaleY);
      ctx.rotate(Math.atan2(s.vy||0.1, s.vx||0.1));
      const bladeGrad = ctx.createLinearGradient(-12, 0, 14, 0);
      bladeGrad.addColorStop(0, '#fdfbff');
      bladeGrad.addColorStop(1, '#c8a8ff');
      ctx.fillStyle = bladeGrad;
      ctx.beginPath();
      ctx.moveTo(-12, -2);
      ctx.lineTo(14, 0);
      ctx.lineTo(-12, 2);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#b090ff';
      ctx.fillRect(-14, -3, 4, 6); // guard
      ctx.fillStyle = '#6c4bb3';
      ctx.fillRect(-18, -1, 4, 2); // handle
      ctx.restore(); }
    if(!buffs.SWORD.active && swords.length && !swordFireStart){ swordFireStart=now+2000; nextSwordFire=swordFireStart; }
    if(swordFireStart && now>=swordFireStart){
      if(now>=nextSwordFire){
        const s=swords.find(z=>z.state==='ready');
        if(s){
          const idx=randomBrick(true);
          if(idx!=null){
            let tx=null, ty=null;
            if(idx==='boss'){
              if(isSpecialBossActive()){
                const center=activeBossCenter();
                if(center){ tx=center.x; ty=center.y; }
                highlightSpaceBossTarget();
              }
            }else{
              const t=bricks[idx];
              if(t){ tx=t.x+t.w/2; ty=t.y+t.h/2; }
            }
            if(tx!=null && ty!=null){
              const ang=Math.atan2(ty-s.y,tx-s.x);
              s.vx=Math.cos(ang)*8;
              s.vy=Math.sin(ang)*8;
              s.state='fire';
              s.target=idx;
            }
          }
        }
        nextSwordFire=now+300;
        if(!swords.some(z=>z.state==='ready')) swordFireStart=0;
      }
    }
  }

  function randomBrick(includeBoss=false){
    const arr=bricks.map((b,i)=>({b,i})).filter(x=>canDestroyBrick(x.b));
    if(includeBoss && isSpecialBossActive()){ arr.push({boss:true}); }
    if(!arr.length) return null;
    const r=arr[Math.floor(Math.random()*arr.length)];
    return r.boss ? 'boss' : r.i;
  }

  
  function speedForLevel(lv){
    // 更平滑的球速曲線：從 baseSpeed 緩慢增長到 +~3.2
    const base = getDiff().baseSpeed;
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const ease = t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2; // easeInOutQuad
    const extra = 0.6 + 2.6 * ease; // 0.6 -> 3.2
    return base + extra;
  }

  function paddleHitSpeedMul(lv){
    const maxLevel=20;
    const l=Math.min(Math.max(lv,1),maxLevel);
    const t=(l-1)/(maxLevel-1);
    return 1.04 + 0.02 * t; // 1.04 -> 1.06
  }

  function resetBalls(center=true){ balls=[makeBall(false)]; const base=getDiff().baseSpeed; const speed=speedForLevel(level); const angle=(-60-Math.random()*60)*Math.PI/180;
    balls[0].x=center?1100/2:paddle.x+paddle.w/2; balls[0].y=700-70; balls[0].vx=Math.cos(angle)*speed; balls[0].vy=Math.sin(angle)*speed; balls[0].piercing=buffs.PIERCE.active; }

  function startCountdown(restart=true){
    // 清除先前的倒數計時以避免在選單開啟時仍繼續倒數
    if(countdownTimer){ clearTimeout(countdownTimer); countdownTimer=null; }
    paused=true;
    if(restart || countdownShow<=0){ countdownShow=3; }
    showCenter('', ''); centerNote.style.display='none'; // 用畫面倒數
    resumePending=true;
    const tick=()=>{
      if(countdownShow<=0){
        resumePending=false; paused=false; stats.lifeStart=performance.now(); countdownTimer=null; return;
      }
      beep(600 + (3-countdownShow)*100, 0.07, 0.05);
      countdownTimer = setTimeout(()=>{ countdownShow--; tick(); }, 450);
    };
    tick();
  }


  function update(){
    const now=performance.now();
    if(cyclopsShakeUntil && now<cyclopsShakeUntil){ screenShake=Math.max(screenShake,6); }
    if(comboEl) comboEl.classList.toggle('star', buffs.COMBO.active);
    if(combo>0){
      const elapsed=now-comboLastTime;
      const mul=buffs.COMBO.active?GAME_CONFIG.powers.COMBO.combo.timeMul:1;
      const fadeStart=3000*mul, resetTime=5000*mul;
      if(elapsed>fadeStart && elapsed<resetTime){ comboEl.style.opacity=1-((elapsed-fadeStart)/(resetTime-fadeStart)); }
      else if(elapsed>=resetTime){ resetCombo(); }
      else { comboEl.style.opacity=1; }
    }
    // Buff 過期
    for(const key of Object.keys(GAME_CONFIG.powers)){
      if(key==='LONG' || key==='FLIP') continue;
      const b=buffs[key];
      if(b?.active && b.until && now>b.until){
        if(key==='BLACKHOLE') continue;
        b.active=false;
        if(key==='GODSPEED'){
          for(const ball of balls){
            const ang=Math.atan2(ball.vy,ball.vx);
            const sp=ball.speedCap*0.5;
            ball.vx=Math.cos(ang)*sp;
            ball.vy=Math.sin(ang)*sp;
          }
        }
        if(key==='PIERCE'){ for(const ball of balls) ball.piercing=false; }
        if(key==='STICKY'){ for(const ball of balls){ if(ball.stuck){ ball.stuck=false; ball.vy = -Math.abs(ball.vy||6); } } }
        if(key==='MEGA' && buffs.MEGA.applied){ for(const ball of balls){ ball.r/=GAME_CONFIG.powers.MEGA.mega.sizeMul; } buffs.MEGA.applied=false; }
        if(key==='FIRE'){
          if(fireEnergy>0 && balls.length){
            const b0=balls[0];
            const e=fireEnergy;
            const radius = e<=3?100:e<=8?150:e<=14?200:300;
            fireExplosionAt(b0.x,b0.y,radius);
          }
          fireEnergy=0; updateFireEnergy();
        }
        if(key==='COMBO' && comboEl){ comboEl.classList.remove('star'); }
        if(key==='GATLING'){ gatling=null; gatlingBullets.length=0; }
      }
    }
    computePaddleWidth(); updateBuffBadges();
    updateSpaceBoss();
    updateReaperBoss();
    updateDragonBoss();
    updateDemonEvent(now);
    updateDemonBoss();

    if(isTrueBossFightActive()){
      if(!nextTreasureBrickAt){
        scheduleNextTreasureBrick(now);
      }else if(now>=nextTreasureBrickAt){
        spawnBossTreasureBrick();
        scheduleNextTreasureBrick(now);
      }
    }else{
      nextTreasureBrickAt=0;
    }

    let treasureRemoved=false;
    for(let i=bricks.length-1;i>=0;i--){
      const bk=bricks[i];
      if(!bk?.fallingTreasure) continue;
      const vy=bk.vy || GAME_CONFIG.powerCapsule.fallVy || 2.2;
      bk.y += vy;
      if(bk.y>710){ bricks.splice(i,1); treasureRemoved=true; }
    }
    if(treasureRemoved){ updateHUD(); }

    for(let i=demonFallingDebris.length-1;i>=0;i--){
      const d=demonFallingDebris[i];
      d.vy += d.gravity;
      d.y += d.vy;
      if(d.vx){ d.x += d.vx; d.vx*=0.99; }
      d.angle += d.spin;
      if(d.y>720){ demonFallingDebris.splice(i,1); }
    }

    // 劇毒磚持續扣血
    for(let i=bricks.length-1;i>=0;i--){
      const bk=bricks[i];
      if(!bk.poisonUntil) continue;
      if(now>=bk.poisonUntil){ delete bk.poisonUntil; delete bk.poisonTick; continue; }
      if(!bk.poisonTick) bk.poisonTick = now + (GAME_CONFIG.powers.POISON.poison.tickMs||2000);
      if(now >= bk.poisonTick){
        bk.poisonTick += (GAME_CONFIG.powers.POISON.poison.tickMs||2000);
        if(canDestroyBrick(bk)){
          if(bk.boss){
            bk.hp-=1;
            if(bk.hp<=0){ bossKillEffect(bk); revealBrickArea(bk); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(bk)); stats.bossKills++; updateHUD(); }
          }
          else {
            bk.hp=(bk.hp||1)-1;
            if(bk.hp<=0){ revealBrickArea(bk); maybeDropFromBrick(bk); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(bk)); if(bk.elite) stats.eliteKills++; updateHUD(); }
          }
          spawnParticles(bk.x+bk.w/2,bk.y+bk.h/2,'rgba(120,255,120,0.9)',10,1.5,2.4,2);
        }
      }
    }

    // === 天地翻轉狀態處理 ===
    if(buffs.FLIP){
      const f = buffs.FLIP;
      // 啟動翻轉：pending 狀態進入 active
      if(f.pending && f.startAt && now >= f.startAt){
        f.pending = false;
        f.active = true;
        // 更新 until 供 HUD 顯示
        if(f.endAt) f.until = f.endAt;
        // 切換為左側模式
        orientLeft = true;
        // 將擋板置於畫面中央（垂直模式）
        paddle.y = (700 - paddle.w) / 2;
        paddle.x = 0;
        // 將現有掉落道具改為水平移動
        for(const p of powerups){ p.horizontal = true; }
        // 重新鎖定所有球以瞄準擋板中心
        const pr = paddleRect();
        const tx = pr.x + pr.w/2;
        const ty = pr.y + pr.h/2;
        for(const b of balls){
          const sp = Math.max(6, Math.hypot(b.vx, b.vy));
          const ang = Math.atan2(ty - b.y, tx - b.x);
          b.vx = Math.cos(ang) * sp;
          b.vy = Math.sin(ang) * sp;
        }
        // 加入鎖定框提示擋板位置
        pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
      }
      // 結束翻轉：active 狀態到期後恢復正常
      if(f.active && f.endAt && now >= f.endAt){
        f.active = false;
        // 重置 until
        f.until = 0;
        // 恢復水平方向
        orientLeft = false;
        // 擋板置於底部中央
        paddle.y = 700 - 50;
        paddle.x = 1100/2 - paddle.w/2;
        // 將現有掉落道具改為垂直移動
        for(const p of powerups){ p.horizontal = false; }
        // 球重新瞄準擋板中心
        const pr2 = paddleRect();
        const tx2 = pr2.x + pr2.w/2;
        const ty2 = pr2.y + pr2.h/2;
        for(const b of balls){
          const sp = Math.max(6, Math.hypot(b.vx, b.vy));
          const ang = Math.atan2(ty2 - b.y, tx2 - b.x);
          b.vx = Math.cos(ang) * sp;
          b.vy = Math.sin(ang) * sp;
        }
        // 顯示鎖定框
        pushLockBox(pr2.x, pr2.y, pr2.w, pr2.h, 'paddle');
      }
    }


    if(buffs.PADBOOM.active){
      if(!buffs.PADBOOM.exploded && now >= buffs.PADBOOM.explodeAt){
        const pr = paddleRect();
        const cx = pr.x+pr.w/2, cy = pr.y+pr.h/2;
        spawnParticles(cx, cy, '#ffdd99', 80, 3.5, 5.0, 5);
        spawnParticles(cx, cy, '#ffeeaa', 60, 3.8, 4.8, 4.5);
        spawnParticles(cx, cy, '#ffffff', 40, 3.2, 4.2, 3.5);
        screenShake = Math.max(screenShake,10);
        playSFX('explosion');
        showComboNotice('哈哈你爆掉啦? 道具不能亂吃呀!',5000,3000);
        paddleGoneUntil = buffs.PADBOOM.returnAt;
        buffs.PADBOOM.exploded = true;
      }
      if(buffs.PADBOOM.exploded && now >= buffs.PADBOOM.returnAt){
        buffs.PADBOOM.active = false;
        buffs.PADBOOM.until = 0;
        paddleGoneUntil = 0;
      }
    }

    // 菁英磚技能：每30秒發射，發射前聚氣2秒
    for(const b of bricks){ if(!b.elite) continue; if(b.eliteChargeUntil && now<b.eliteChargeUntil){ /* charging */ } else { if(!b.eliteNext) b.eliteNext = now+30000; if(now>=b.eliteNext){ b.eliteChargeUntil = now+2000; b.eliteNext = now+30000; setTimeout(()=>{ const idx = bricks.indexOf(b); if(idx!==-1){ spawnLionBeamFrom(b.x+b.w/2, b.y+b.h/2); } }, 2000); } } }
// 鍵盤移動：天地翻轉時改為上下移動（仍使用左右鍵）
    if(!orientLeft){ if(performance.now()>paddleStunUntil){ if(keyL) paddle.x-=paddle.speed; if(keyR) paddle.x+=paddle.speed; } paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x)); }
    else{ if(performance.now()>paddleStunUntil){ if(keyL) paddle.y-=paddle.speed; if(keyR) paddle.y+=paddle.speed; } paddle.y=Math.max(0, Math.min(700-paddle.w, paddle.y)); }

    // 雷射發射
    if(buffs.LASER.active){
      const interval = GAME_CONFIG.powers.LASER.laser.intervalMs;
      if(!buffs.LASER.lastShot || now - buffs.LASER.lastShot >= interval){
        buffs.LASER.lastShot = now;
        const pr=paddleRect();
        const barrels = !orientLeft ? [{x:pr.x, y:pr.y+pr.h/2},{x:pr.x+pr.w, y:pr.y+pr.h/2}] : [{x:pr.x+pr.w/2, y:pr.y},{x:pr.x+pr.w/2, y:pr.y+pr.h}];
        for(const s of barrels){
          let target=null;
          let best=-1;
          for(let i=0;i<bricks.length;i++){
            const bk=bricks[i];
            if(!canDestroyBrick(bk)) continue;
            const dx=(bk.x+bk.w/2)-s.x;
            const dy=(bk.y+bk.h/2)-s.y;
            const d=dx*dx+dy*dy;
            if(d>best){ best=d; target={type:'brick', idx:i, x:bk.x+bk.w/2, y:bk.y+bk.h/2}; }
          }
          const bossCenter = isSpecialBossActive() ? activeBossCenter() : null;
          if(bossCenter){
            const dx=bossCenter.x - s.x;
            const dy=bossCenter.y - s.y;
            const d=dx*dx+dy*dy;
            if(d>best){
              best=d;
              target={type:'boss', x:bossCenter.x, y:bossCenter.y};
              highlightSpaceBossTarget();
            }
          }
          if(target){
            const impact = target.type==='boss' ? activeBossImpactPoint(s.x,s.y) : {x:target.x, y:target.y};
            laserBeams.push({x1:s.x,y1:s.y,x2:impact.x,y2:impact.y,until:now+200});
            laserImpacts.push({x:impact.x, y:impact.y, t0:now, tEnd:now+320});
            spawnParticles(impact.x,impact.y,'rgba(160,255,200,0.9)',10,1.8,2.2,2.6);
            if(target.type==='boss'){
              damageActiveBoss(1,'laser',impact);
            }else{
              destroyBrick(target.idx,'laser');
            }
          }
        }
      }
    }

    if(gatling){
      const pr=paddleRect();
      gatling.x=pr.x+pr.w/2; gatling.y=pr.y;
      if(now>=gatling.fireStart){
        if(now>=gatling.fireUntil){ gatling=null; buffs.GATLING.active=false; }
        else if(now-gatling.lastShot>=(GAME_CONFIG.powers.GATLING.gatling.intervalMs||100)){
          gatling.lastShot=now;
          gatling.angle=(gatling.angle||0)+0.3;
          const cfg=GAME_CONFIG.powers.GATLING.gatling;
          const x=gatling.x+Math.cos(gatling.angle)*5;
          const vx=Math.cos(gatling.angle)*0.5;
          gatlingBullets.push({x:x,y:gatling.y-10,vx:vx,vy:-(cfg.bulletSpeed||10)});
          spawnParticles(x, gatling.y-10, '#ffbb55', 8, 1.2, 2.5, 2);
          playSFX('gatlingShoot');
        }
      }
    }
    for(let i=gatlingBullets.length-1;i>=0;i--){
      const bl=gatlingBullets[i];
      bl.x+=bl.vx; bl.y+=bl.vy;
      if(bl.y<0){ gatlingBullets.splice(i,1); continue; }
      let removed=false;
      for(let j=bricks.length-1;j>=0;j--){
        const bk=bricks[j];
        if(bl.x>bk.x && bl.x<bk.x+bk.w && bl.y>bk.y && bl.y<bk.y+bk.h){
          spawnParticles(bl.x, bl.y, '#ffdd77', 8, 1.6, 3.2, 2.5);
          playSFX('gatlingHit');
          if(canDestroyBrick(bk) && !(bk.lockedUntil && now<bk.lockedUntil)){
            bk.hp=(bk.hp||1)-1; incrementCombo();
            if(bk.hp<=0){
              addScore(scoreForBrick(bk)); updateHUD();
              const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
              revealBrickArea(bk); maybeDropFromBrick(bk);
              spawnParticles(cx, cy, '#eeeeee', 24, 2.4, 4.0, 3.5);
              if(bk.explosive){ explodeAt(cx,cy); } else { bricks.splice(j,1); }
            } else updateHUD();
          }
          gatlingBullets.splice(i,1);
          removed=true;
          break;
        }
      }
      if(!removed && isSpecialBossActive()){
        const bounds=getActiveBossBounds();
        if(bounds && bl.x>bounds.x && bl.x<bounds.x+bounds.w && bl.y>bounds.y && bl.y<bounds.y+bounds.h){
          spawnParticles(bl.x, bl.y, '#ffdd77', 8, 1.6, 3.2, 2.5);
          playSFX('gatlingHit');
          damageActiveBoss(1,'gatling',{x:bl.x,y:bl.y});
          gatlingBullets.splice(i,1);
        }
      }
    }

    if(stormTurret){ if(now>=stormTurret.fireAt){ if(stormTurret.shots<=0){ stormTurret=null; buffs.STORM.active=false; } else if(now-stormTurret.lastShot>=200){ const idx=randomBrick(true); if(idx!=null){ if(idx==='boss' && isSpecialBossActive()){ const impact=activeBossImpactPoint(stormTurret.x,stormTurret.y); highlightSpaceBossTarget(); laserBeams.push({x1:stormTurret.x,y1:stormTurret.y,x2:impact.x,y2:impact.y,until:now+200}); laserImpacts.push({x:impact.x,y:impact.y,t0:now,tEnd:now+320}); damageActiveBoss(1,'laser',impact); } else { const t=bricks[idx]; if(t){ const tx=t.x+t.w/2, ty=t.y+t.h/2; laserBeams.push({x1:stormTurret.x,y1:stormTurret.y,x2:tx,y2:ty,until:now+200}); laserImpacts.push({x:tx,y:ty,t0:now,tEnd:now+320}); destroyBrick(idx,'laser'); } } stormTurret.shots--; stormTurret.lastShot=now; } } } }

    if(buffs.BLACKHOLE.active && now>buffs.BLACKHOLE.until){ const d=Math.min(8,buffs.BLACKHOLE.deaths||0); const dmg=1+(d/8)*(40-1); const rad=200+(d/8)*(800-200); const pr=paddleRect(); const cx=pr.x+pr.w/2, cy=pr.y-rad; const spinDir=(Math.random()>0.5?1:-1); blackHoles.push({x:cx,y:cy,r:rad,until:now+3000,start:now,spinDir}); for(let i=bricks.length-1;i>=0;i--){ const bk=bricks[i]; const bx=bk.x+bk.w/2, by=bk.y+bk.h/2; if(Math.hypot(bx-cx,by-cy)<=rad){ damageBrick(i,dmg,'none'); } } if(circleIntersectsActiveBoss(cx,cy,rad)){ const impact=activeBossCenter(); damageActiveBoss(1,'blackhole',impact?{x:impact.x,y:impact.y}:{x:cx,y:cy}); } playSFX('blackhole'); buffs.BLACKHOLE.active=false; }

    if(buffs.ANNIHIL.active && now>=buffs.ANNIHIL.next){ let cand=bricks.filter(b=>canDestroyBrick(b)&&!b.boss); if(!cand.length) cand=bricks.filter(b=>canDestroyBrick(b)); if(cand.length){ const target=cand[Math.floor(Math.random()*cand.length)]; const idx=bricks.indexOf(target); destroyBrick(idx,'annihil'); } else if(isSpecialBossActive()){ const center=activeBossCenter(); damageActiveBoss(1,'annihil',center?{x:center.x,y:center.y}:null); } buffs.ANNIHIL.next+=1000; }

    // 全局速度倍率（GODSPEED 時忽略其它）
    function effectiveMul(){
      if(buffs.GODSPEED.active) return 1.0;
      let mul=1.0;
      if(buffs.SLOW.active){ mul*=(GAME_CONFIG.powers.SLOW.speedMul??1.0); }
      if(buffs.FAST.active){ mul*=(GAME_CONFIG.powers.FAST.globalSpeedMul??1.0); }
      if(buffs.WAVY.active){ const w=GAME_CONFIG.powers.WAVY.wavy||{amp:0.6,base:1.2,periodMs:200}; const phase=(now-(buffs.WAVY.start||now))/(w.periodMs); mul*=(w.base+w.amp*Math.sin(phase)); }
      if(buffs.HELL.active){ mul*=(GAME_CONFIG.powers.HELL.hell.speedMul); }
      if(buffs.MEGA.active){ mul*=(GAME_CONFIG.powers.MEGA.mega.speedMul); }
      if(buffs.ANNIHIL.active){
        const t=Math.min(1,(now-buffs.ANNIHIL.start)/10000);
        const maxMul=GAME_CONFIG.powers.ANNIHIL.annihil.speedMul||3;
        mul*=1+t*(maxMul-1);
      }

      // 天地翻轉：啟動前 2 秒與結束前 2 秒期間略微減速（降低不適感）
      const f = buffs.FLIP;
      if(f){
        // 前延遲
        if(f.pending && f.startAt && now >= f.startAt - 2000 && now < f.startAt){
          mul *= 0.8;
        }
        // 結束前
        if(f.active && f.endAt && now >= f.endAt - 2000 && now < f.endAt){
          mul *= 0.8;
        }
      }
      return mul;
    }

    const mulGlobal=effectiveMul();

    // Boss 能力排程
    updateBossAbilities();
    updateCyclopsEvent();
    for(const b of balls){
      if(b.rampageUntil && now>b.rampageUntil){ b.rampageUntil=0; if(!buffs.PIERCE.active) b.piercing=false; }

      // FREEZE 狀態
      if(b.freeze.state==='delay'){
        if(now - b.freeze.t0 >= b.freeze.delay){
          b.freeze.state = 'stopped';
          b.freeze.until = now + b.freeze.stop;
          b.vx = 0; b.vy = 0;
          spawnParticles(b.x,b.y,'rgba(230,247,255,0.9)',16,1.2,1.0,2.5);
        }
      }
      if(b.freeze.state==='stopped'){
        if(now < b.freeze.until){
          continue;
        }else{
          b.freeze.state = 'idle';
          let vx = b.freeze.oldVX, vy = b.freeze.oldVY;
          const tiny = Math.abs(vx)+Math.abs(vy) < 0.2;
          if(tiny){ vx = (Math.random()<0.5?-1:1) * 4; vy = -Math.max(4, speedForLevel(level)*0.8); }
          const sp = Math.max(4, Math.hypot(vx, vy));
          const ang = Math.atan2(vy, vx);
          b.vx = Math.cos(ang)*sp;
          b.vy = Math.sin(ang)*sp;
        }
      }

      if(handleDemonCloakState(b, now)){
        continue;
      }

      if(b.blinkAt && now>=b.blinkAt){
        spawnParticles(b.x,b.y,'rgba(180,200,255,0.8)',20,1.8,2.6,2.5);
        b.y=b.r+0.1; b.vy=Math.abs(b.vy)||Math.abs(speedForLevel(level));
        spawnParticles(b.x,b.y,'rgba(180,200,255,0.8)',20,1.8,2.6,2.5);
        b.blinkAt=0;
      }

      if(b.stuck){ if(!orientLeft){ b.x=paddle.x+paddle.w/2+b.offsetX; b.y=paddle.y-b.r-0.1; } else { const pr=paddleRect(); b.x=pr.x+pr.w+b.r+0.1; b.y=pr.y+pr.h/2; } continue; }
      // 移動
      let speedMul = mulGlobal;
      b.x+=b.vx*speedMul; b.y+=b.vy*speedMul;

      // GODSPEED：速度鎖定到上限
      if(buffs.GODSPEED.active){
        const sp=Math.hypot(b.vx,b.vy); const cap=b.speedCap;
        if(sp<cap*0.98){ const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*cap; b.vy=Math.sin(ang)*cap; }
      }

      // 牆壁
      const r=b.r;
      if(!orientLeft){
        if(b.x-r<0){ b.x=r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
        if(b.y-r<0){ b.y=r; b.vy*=-1; beep(700,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); fireCollide(); noteCeilingBounce(b, now); noteBounce(b,b.x,b.y,'y',now); }
        if(b.y-r>700){
          // 底部：GODSPEED 不落地 / SHIELD 擋一次
          if(buffs.GODSPEED.active){ b.y=700-r; b.vy=-Math.abs(b.vy); noteBounce(b,b.x,b.y,'y',now); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.y=700-r-1; b.vy=-Math.abs(b.vy); noteBounce(b,b.x,b.y,'y',now); }
          else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; }
        }
      }else{
        // 左側模式：上下為牆，左側為落點；GODSPEED 無落地
        if(b.y-r<0){ b.y=r; b.vy*=-1; fireCollide(); noteCeilingBounce(b, now); noteBounce(b,b.x,b.y,'y',now); }
        if(b.y+r>700){ b.y=700-r; b.vy*=-1; fireCollide(); noteBounce(b,b.x,b.y,'y',now); }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
        if(b.x-r<0){
          if(buffs.GODSPEED.active){ b.x=r; b.vx=Math.abs(b.vx); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.x=r+1; b.vx=Math.abs(b.vx); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
          else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; }
        }
      }

      // 擋板碰撞
      const pr=paddleRect();
      // 擋板有空洞：拆成兩段
      let hitPaddle=false;
      if(!orientLeft){
        const gap = buffs.HOLE.active ? pr.w/3 : 0;
        const l1=pr.x, r1=pr.x+pr.w*(gap?1/3:1);
        const l2=pr.x+pr.w*(gap?2/3:1), r2=pr.x+pr.w;
        const inSeg1 = (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l1 && b.x<=r1);
        const inSeg2 = gap? (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l2 && b.x<=r2):false;
        hitPaddle = inSeg1 || inSeg2;
      }else{
        const gap = buffs.HOLE.active ? pr.h/3 : 0;
        const t1=pr.y, b1=pr.y+pr.h*(gap?1/3:1);
        const t2=pr.y+pr.h*(gap?2/3:1), b2=pr.y+pr.h;
        const inSeg1 = (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t1 && b.y<=b1);
        const inSeg2 = gap? (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t2 && b.y<=b2):false;
        hitPaddle = inSeg1 || inSeg2;
      }
      if(hitPaddle){ stats.catches++;
        const baseSpeed=Math.hypot(b.vx,b.vy);
        const speedMul = isSpeedSuppressed(b, now) ? 1 : paddleHitSpeedMul(level);
        const sp=Math.min(baseSpeed*speedMul, b.speedCap);
        if(!orientLeft){
          const hitPos=(b.x-(pr.x+pr.w/2))/(pr.w/2); const angle=hitPos*(Math.PI/3);
          b.vx=Math.sin(angle)*sp; b.vy=-Math.cos(angle)*sp; b.y=pr.y-b.r-0.1;
          noteBounce(b,b.x,b.y,'y',now);
        }else{
          const hitPos=(b.y-(pr.y+pr.h/2))/(pr.h/2); const angle=hitPos*(Math.PI/3);
          b.vx=Math.cos(angle)*sp; b.vy=Math.sin(angle)*sp; b.x=pr.x+pr.w+b.r+0.1;
          noteBounce(b,b.x,b.y,'x',now);
        }
        if(b.demonCloakState==='launched'){
          const restore=Math.min(b.demonCloakStoredSpeed||Math.hypot(b.vx,b.vy), b.speedCap);
          const ang=Math.atan2(b.vy,b.vx);
          b.vx=Math.cos(ang)*restore;
          b.vy=Math.sin(ang)*restore;
          b.demonCloakState=null;
          b.demonCloakStoredSpeed=0;
          b.demonCloakAnchor=null;
          b.demonCloakStayStart=0;
        }
        beep(880,0.03); spawnParticles(b.x,b.y,'#caddff',8,1.3,1.5,2.5); fireCollide();
        screenShake=Math.max(screenShake, orientLeft?4:3);
        if(buffs.STICKY.active){ b.stuck=true; b.offsetX= (!orientLeft) ? (b.x-(paddle.x+paddle.w/2)) : 0; }
        if(buffs.BLINK.active){ b.blinkAt=performance.now()+ (GAME_CONFIG.powers.BLINK.blink.delayMs||1000); }

        // MISSILE：擋板彈出時發射三枚
        if(buffs.MISSILE.active){
          // 取最近/中距離/最遠
          const src={x:b.x,y:b.y};
          const candidates = bricks.map((bk,idx)=>({idx, type:'brick', d: (bk.x+bk.w/2-src.x)**2 + (bk.y+bk.h/2-src.y)**2 })).sort((a,b)=>a.d-b.d);
          const bossCenter = isSpecialBossActive() ? activeBossCenter() : null;
          if(bossCenter){
            const d = (bossCenter.x-src.x)**2 + (bossCenter.y-src.y)**2;
            candidates.push({idx:'boss', type:'boss', d});
            candidates.sort((a,b)=>a.d-b.d);
          }
          const pickIdxs = [0, Math.floor(candidates.length/2), candidates.length-1].filter(i=>i>=0 && i<candidates.length);
          for(const i of pickIdxs){
            const entry = candidates[i];
            if(!entry) continue;
            const ang=Math.random()*Math.PI*2;
            missiles.push({x:src.x,y:src.y,vx:Math.cos(ang)*2,vy:Math.sin(ang)*2,targetId:entry.idx,targetType:entry.type||'brick',lifeUntil:now+GAME_CONFIG.powers.MISSILE.missile.lifeMs,trail:[]});
            if(entry.type==='boss'){ highlightSpaceBossTarget(); }
            else {
              const ttt = bricks[entry.idx];
              if(ttt){ pushLockBox(ttt.x, ttt.y, ttt.w, ttt.h, 'target'); }
            }
          }
        }

        // 追蹤球：擋板彈出後瞄準目標磚（獨立優先）
        if(buffs.TRACK.active){
          function neighborCount(t){
            let cnt=0; const L=layout(); for(const o of bricks){ if(o===t) continue; const dx=Math.abs((o.x+o.w/2)-(t.x+t.w/2)); const dy=Math.abs((o.y+o.h/2)-(t.y+t.h/2)); const thx=brickW+L.pad+2, thy=brickH+L.pad+2; if(dx<=thx && dy<=thy) cnt++; } return cnt;
          }
          let best=null;
          for(const t of bricks){ if(t.unbreakable) continue; const iso=neighborCount(t); const d=Math.hypot((t.x+t.w/2)-b.x,(t.y+t.h/2)-b.y); const score=iso*1000 + d; if(best==null || score<best.score) best={t,score,type:'brick'}; }
          const bossTarget = isSpecialBossActive() ? activeBossCenter() : null;
          if(!best && bossTarget){
            best={type:'boss', score:-Infinity};
          }
          const targetX = best? (best.type==='boss'? (bossTarget?bossTarget.x:1100/2) : best.t.x+best.t.w/2) : (1100/2);
          const targetY = best? (best.type==='boss'? (bossTarget?bossTarget.y:layout().top) : best.t.y+best.t.h/2) : (layout().top);
          const sp=Math.hypot(b.vx,b.vy); const ang=Math.atan2(targetY-b.y, targetX-b.x); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;

          if(best){
            if(best.type==='boss'){ highlightSpaceBossTarget(); }
            else { pushLockBox(best.t.x, best.t.y, best.t.w, best.t.h, 'target'); }
          }
        }
        if(buffs.SWORD.active){ swords.push({x:Math.random()*1100,y:650,vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*0.5,state:'wander'}); }
      }

      // 碰磚
      const inRampage = !!(b.rampageUntil && now<b.rampageUntil);
      let collidedWithBrick=false;
      let hit=-1; for(let i=0;i<bricks.length;i++){ const bk=bricks[i]; if(b.x+r>bk.x && b.x-r<bk.x+bk.w && b.y+r>bk.y && b.y-r<bk.y+bk.h){ hit=i; break; } }
      if(hit>=0){
        const bk=bricks[hit];
        collidedWithBrick=true;
        fireCollide();
        if((inRampage || b.piercing) && bk.unbreakable){
          if(b.loopBrick===bk){ b.loopHits++; } else { b.loopBrick=bk; b.loopHits=1; }
          if(b.loopHits>=20){
            const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
            const dx=b.x-cx, dy=b.y-cy;
            const len=Math.hypot(dx,dy)||1;
            const pushDist=Math.max(bk.w,bk.h)/2 + b.r + 4;
            b.x=cx + (dx/len)*pushDist;
            b.y=cy + (dy/len)*pushDist;
            const sp=Math.max(4, Math.hypot(b.vx,b.vy));
            const jitter=(Math.random()>0.5?1:-1)*(Math.PI/12);
            const ang=Math.atan2(b.vy,b.vx)+jitter;
            b.vx=Math.cos(ang)*sp || (Math.random()>0.5?4:-4);
            b.vy=Math.sin(ang)*sp || (Math.random()>0.5?4:-4);
            b.loopBrick=null;
            b.loopHits=0;
          }
        }else{ b.loopBrick=null; b.loopHits=0; }
        let suppressBrickAccel=false;
        let shouldSuppressSpeedBoost=false;
        if(bk.id!=null){
          const prevId=b.lastBrickId;
          const prevTime=b.lastBrickHitTime||0;
          if(prevId===bk.id && now-prevTime<=1000){
            b.sameBrickHits=(b.sameBrickHits||1)+1;
            if(b.sameBrickHits>=2){ suppressBrickAccel=true; shouldSuppressSpeedBoost=true; }
          }else{
            b.sameBrickHits=1;
          }
          b.lastBrickId=bk.id;
          b.lastBrickHitTime=now;
        }else{
          b.sameBrickHits=0;
          b.lastBrickId=null;
          b.lastBrickHitTime=0;
        }
        if(b.loopBrick===bk && b.loopHits>=3){ suppressBrickAccel=true; shouldSuppressSpeedBoost=true; }
        if(shouldSuppressSpeedBoost){ suppressSpeedBoost(b, now); }
        // 反彈
        let bounceAxis=null;
        const oL=(b.x+r)-bk.x, oR=(bk.x+bk.w)-(b.x-r), oT=(b.y+r)-bk.y, oB=(bk.y+bk.h)-(b.y-r); const m=Math.min(oL,oR,oT,oB);
        if(!inRampage && !b.piercing){
          if(m===oL){ b.x=bk.x-r; b.vx=-Math.abs(b.vx); bounceAxis='x'; } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=Math.abs(b.vx); bounceAxis='x'; } else if(m===oT){ b.y=bk.y-r; b.vy=-Math.abs(b.vy); bounceAxis='y'; } else { b.y=bk.y+bk.h+r; b.vy=Math.abs(b.vy); bounceAxis='y'; }
        }else{
          if(m===oL){ b.x=bk.x-r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; } else if(m===oT){ b.y=bk.y-r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; } else { b.y=bk.y+bk.h+r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
          b.piercing=true;
        }
        if(bounceAxis){ noteBounce(b,b.x,b.y,bounceAxis,now); }

        // 強反彈加速
        if(bk.strong){ const skipAccel = suppressBrickAccel || isSpeedSuppressed(b, now); if(!skipAccel){ const sp=Math.min(Math.hypot(b.vx,b.vy)*1.08, b.speedCap); const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp; } screenShake=Math.max(screenShake,3); }

        // 特效觸發
        if(buffs.PLASMA.active){ const cfg=GAME_CONFIG.powers.PLASMA.plasma; const ang=Math.random()*Math.PI*2; plasmas.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,vx:Math.cos(ang)*cfg.drift,vy:Math.sin(ang)*cfg.drift,until:now+cfg.lifeMs,radius:cfg.radius,phase:Math.random()*Math.PI*2}); playSFX('plasma'); }
        if(buffs.FREEZE.active && (b.freeze.state==='idle' || !b.freeze.state)){ const f=GAME_CONFIG.powers.FREEZE.freeze; b.freeze.state = 'delay'; b.freeze.t0 = now; b.freeze.delay = f.delayMs; b.freeze.stop = f.stopMs; b.freeze.oldVX = b.vx; b.freeze.oldVY = b.vy; }
        if(buffs.HOLY.active){ playSFX('holy'); holyFlashes.push({x:bk.x+bk.w/2, y:bk.y+bk.h/2, until:now+350}); for(let i=bricks.length-1;i>=0;i--){ const t=bricks[i]; const sameRow=Math.abs(t.y-bk.y)<1; const sameCol=Math.abs(t.x-bk.x)<1; if(sameRow||sameCol){ destroyBrick(i,'none'); } } if(isSpecialBossActive()){ const bounds=getActiveBossBounds(); const rowY=bk.y+bk.h/2; const colX=bk.x+bk.w/2; let bossHit=false; if(bounds && rowY>=bounds.y && rowY<=bounds.y+bounds.h){ const cx=bounds.x+bounds.w/2; damageActiveBoss(1,'holy',{x:cx,y:rowY}); bossHit=true; } if(bounds && !bossHit && colX>=bounds.x && colX<=bounds.x+bounds.w){ const cy=bounds.y+bounds.h/2; damageActiveBoss(1,'holy',{x:colX,y:cy}); } } screenShake=Math.max(screenShake,4); }
        if(buffs.CHAIN.active){ bk.lockedUntil = now + GAME_CONFIG.powers.CHAIN.chain.lockMs; }
        if(buffs.HELL.active){ const holeSpin=(Math.random()>0.5?1:-1); blackHoles.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,r:40,until:now+GAME_CONFIG.powers.HELL.hell.haloMs,start:performance.now(),spinDir:holeSpin}); playSFX('blackhole'); destroyNeighbors(hit); destroyBrick(hit,'none'); }
        if(buffs.POISON.active){ bk.poisonUntil = now + (GAME_CONFIG.powers.POISON.durationMs||12000); bk.poisonTick = now + (GAME_CONFIG.powers.POISON.poison?.tickMs||2000); }

        // 當前磚扣血（若已在上面被處理則略過）
        if(!buffs.HELL.active && !buffs.HOLY.active){
          // 不可破壞／鎖鏈狀態下不扣血
          if(bk.unbreakable || (bk.lockedUntil && now<bk.lockedUntil)){
            if(bk.boss){ updateHUD(); }
          }else{
            bk.hp=(bk.hp||1)-1; incrementCombo();
            if(bk.hp<=0){
              const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
              if(!bk.explosive){
                if(bk.boss){ bossKillEffect(bk); stats.bossKills++; addScore(scoreForBrick(bk)); }
                else { if(bk.elite) stats.eliteKills++; addScore(scoreForBrick(bk)); }
              } else {
                addScore(scoreForBrick(bk));
              }
              revealBrickArea(bk);
              if(inRampage || b.piercing) playSFX('pierce');
              if(!bk.boss) maybeDropFromBrick(bk);
              if(bk.explosive){ explodeAt(cx,cy); }
              else { bricks.splice(hit,1); updateHUD(); }
            } else updateHUD();
          }
        }

        // 追蹤球：撞磚後瞄準擋板中心
        if(buffs.TRACK.active){
          const pr=paddleRect(); const tx = pr.x + (orientLeft? (pr.w + 60) : pr.w/2); const ty = pr.y + pr.h/2;
          const sp=Math.hypot(b.vx,b.vy); const ang=Math.atan2(ty-b.y, tx-b.x); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        
          pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
}

        beep(520+Math.random()*200,0.03,0.05);
      }

      if(!collidedWithBrick && isSpecialBossActive()){
        if(isDragonActive() && dragonBoss){
          const result=resolveDragonBallCollision(b, r, inRampage);
          if(result){
            fireCollide();
            if(result.bounceAxis){ noteBounce(b,b.x,b.y,result.bounceAxis,now); }
            spawnParticles(result.impactX, result.impactY, '#b8d6ff', 20, 1.4, 2.4, 2.2);
            triggerBallBuffEffectsOnBossHit(b, result.impactX, result.impactY, now);
            damageActiveBoss(1,'ball',{x:result.impactX,y:result.impactY});
            if(buffs.TRACK.active){
              const pr=paddleRect();
              const tx = pr.x + (orientLeft? (pr.w + 60) : pr.w/2);
              const ty = pr.y + pr.h/2;
              const sp=Math.hypot(b.vx,b.vy);
              const ang=Math.atan2(ty-b.y, tx-b.x);
              b.vx=Math.cos(ang)*sp;
              b.vy=Math.sin(ang)*sp;
              pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
            }
            beep(520+Math.random()*200,0.03,0.05);
            collidedWithBrick=true;
          }
        }else if(isDemonActive() && demonBoss){
          const result=resolveDemonBallCollision(b, r);
          if(result){
            const zone=result.zone;
            let bounceAxis=null;
            if(!inRampage && !b.piercing){
              if(result.penetration===result.oL){ b.x=zone.x-r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
              else if(result.penetration===result.oR){ b.x=zone.x+zone.w+r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
              else if(result.penetration===result.oT){ b.y=zone.y-r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
              else { b.y=zone.y+zone.h+r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
            }else{
              if(result.penetration===result.oL){ b.x=zone.x-r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
              else if(result.penetration===result.oR){ b.x=zone.x+zone.w+r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
              else if(result.penetration===result.oT){ b.y=zone.y-r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
              else { b.y=zone.y+zone.h+r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
              b.piercing=true;
            }
            if(bounceAxis){ noteBounce(b,b.x,b.y,bounceAxis,now); }
            const impactX=Math.max(zone.x, Math.min(b.x, zone.x+zone.w));
            const impactY=Math.max(zone.y, Math.min(b.y, zone.y+zone.h));
            spawnParticles(impactX, impactY, '#dcb6ff', 20, 1.6, 2.6, 2.4);
            fireCollide();
            damageActiveBoss(1,'ball',{x:impactX,y:impactY});
            collidedWithBrick=true;
          }
        }else{
          const bounds=getActiveBossBounds();
          if(bounds){
            const rx=bounds.x, ry=bounds.y, rw=bounds.w, rh=bounds.h;
            if(b.x+r>rx && b.x-r<rx+rw && b.y+r>ry && b.y-r<ry+rh){
              const oL=(b.x+r)-rx, oR=(rx+rw)-(b.x-r), oT=(b.y+r)-ry, oB=(ry+rh)-(b.y-r);
              const m=Math.min(oL,oR,oT,oB);
              let bounceAxis=null;
              if(!inRampage && !b.piercing){
                if(m===oL){ b.x=rx-r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
                else if(m===oR){ b.x=rx+rw+r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
                else if(m===oT){ b.y=ry-r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
                else { b.y=ry+rh+r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
              }else{
                if(m===oL){ b.x=rx-r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
                else if(m===oR){ b.x=rx+rw+r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
                else if(m===oT){ b.y=ry-r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
                else { b.y=ry+rh+r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
                b.piercing=true;
              }
              if(bounceAxis){ noteBounce(b,b.x,b.y,bounceAxis,now); }
              const impactX = Math.max(rx, Math.min(b.x, rx+rw));
              const impactY = Math.max(ry, Math.min(b.y, ry+rh));
              spawnParticles(impactX, impactY, '#b8d6ff', 20, 1.4, 2.4, 2.2);
              fireCollide();
              damageActiveBoss(1,'ball',{x:impactX,y:impactY});
              collidedWithBrick=true;
            }
          }
        }
      }

      // 安全保底速度
      const sp2 = Math.hypot(b.vx,b.vy);
      if(sp2 < 0.2 && !b.stuck && b.freeze.state==='idle'){
        b.vx = (Math.random()<0.5?-1:1) * 4;
        b.vy = -Math.max(4, speedForLevel(level)*0.8);
      }
    }

    // 飛彈更新
    for(let i=missiles.length-1;i>=0;i--){
      const m=missiles[i];
      if(now>m.lifeUntil){ missiles.splice(i,1); continue; }
      let tx,ty, rect=null;
      if(m.targetType==='boss'){
        if(!isSpecialBossActive()){ missiles.splice(i,1); continue; }
        const bounds=getActiveBossBounds();
        const center=activeBossCenter();
        if(!bounds || !center){ missiles.splice(i,1); continue; }
        rect=bounds;
        tx=center.x; ty=center.y;
      }else{
        const t=bricks[m.targetId];
        if(!t){ missiles.splice(i,1); continue; }
        tx=t.x+t.w/2; ty=t.y+t.h/2;
        rect={x:t.x,y:t.y,w:t.w,h:t.h};
      }
      const ang=Math.atan2(ty-m.y, tx-m.x);
      const sp=GAME_CONFIG.powers.MISSILE.missile.speed;
      // 轉向
      const curAng=Math.atan2(m.vy, m.vx);
      let diff=ang-curAng; while(diff>Math.PI) diff-=2*Math.PI; while(diff<-Math.PI) diff+=2*Math.PI;
      const maxTurn=GAME_CONFIG.powers.MISSILE.missile.turn;
      const newAng = curAng + Math.max(-maxTurn, Math.min(maxTurn, diff));
      m.vx=Math.cos(newAng)*sp; m.vy=Math.sin(newAng)*sp;
      m.x+=m.vx; m.y+=m.vy;
      (m.trail||(m.trail=[])).push({x:m.x,y:m.y,t:now}); if(m.trail.length>20) m.trail.shift();
      // 命中判定
      if(rect && m.x>rect.x && m.x<rect.x+rect.w && m.y>rect.y && m.y<rect.y+rect.h){
        if(m.targetType==='boss'){ damageActiveBoss(1,'missile',{x:m.x,y:m.y}); }
        else { destroyBrick(m.targetId,'missile'); }
        missiles.splice(i,1); spawnParticles(m.x,m.y,'#ffbb66',12,1.8,2.2,3);
      }
    }

    // 球全沒了
    if(balls.length===0){
      const nowL=performance.now();
      if(nowL<=spaceBossSuppressLifeLossUntil){
        // skip automatic life loss triggered by Space Boss abilities
      }else{
        if(stats.lifeStart){ const dur=(nowL-stats.lifeStart)/1000; if(dur<stats.fastestDeath) stats.fastestDeath=dur; if(dur>stats.longestLife) stats.longestLife=dur; }
        stats.livesUsed++;
      if(buffs.BLACKHOLE.active){ buffs.BLACKHOLE.deaths=Math.min(8,(buffs.BLACKHOLE.deaths||0)+1); }
      if(buffs.ANNIHIL.active){ buffs.ANNIHIL.active=false; }
      lives--; updateHUD();
      if(lives<=0){ running=false; paused=true; showGameOver(); return; }
      else { resetBalls(false); startCountdown(); return; }
      }
    }

    // 掉落道具移動/撿取
    for(let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      // 根據方向更新位置
      if(p.horizontal){
        p.x -= p.speed;
      } else {
        p.y += p.speed;
      }
      const pr = paddleRect();
      // 命中檢查：根據擋板方向檢查碰撞
      const hit = (!orientLeft)
        ? (p.y + p.h >= pr.y && p.x + p.w >= pr.x && p.x <= pr.x + pr.w && p.y <= pr.y + pr.h)
        : (p.x + p.w >= pr.x && p.x <= pr.x + pr.w && p.y + p.h >= pr.y && p.y <= pr.y + pr.h);
      if(hit){
        applyPower(p.type);
        // 撿到增益/特殊增益時更新最後拾取時間，以便自動掉落計時
        const def = GAME_CONFIG.powers[p.type];
        if(def && def.type !== 'debuff'){
          lastBeneficialPickupAt = performance.now();
          nextAutoBeneficialDropAt = lastBeneficialPickupAt + 10000;
        }
        powerups.splice(i,1);
        continue;
      }
      // 超出畫面則移除
      if(p.horizontal){
        if(p.x + p.w < 0){ powerups.splice(i,1); }
      } else {
        if(p.y > 710){ powerups.splice(i,1); }
      }
    }

    {
      const prNow = paddleRect();
      spaceBossPrevPaddleCenter = spaceBossLastPaddleCenter;
      spaceBossLastPaddleCenter = prNow.x + prNow.w/2;
    }

        // 天空定時掉落
    if(performance.now() >= nextSkyDropAt){ spawnBeneficialAtTop(); scheduleNextSkyDrop(); }
    // 若距上次取得增益已逾 10 秒，則自動從天空掉落一個增益
    if(running && !paused && !resumePending && !gameOver){
      const nowAuto = performance.now();
      if(nowAuto >= nextAutoBeneficialDropAt){
        spawnBeneficialAtTop();
        lastBeneficialPickupAt = nowAuto;
        nextAutoBeneficialDropAt = lastBeneficialPickupAt + 10000;
      }
    }

    // 清關（進入畫廊或通關）
    if(!hasBreakables()){
      unlockSpecials(level);
      const idx=((level-1)%10);
      const type = (level<=10 ? (imageChoice[idx]===0?'bg':'cg') : (imageChoice[idx]===0?'cg':'bg'));
      markImageUnlocked(type, idx);
      paused=true; running=false; onPauseStart();
      if(level>=GAME_CONFIG.totalLevels){
        finalScore.textContent=String(score);
          const el=document.getElementById('statsWin'); if(el) el.innerHTML = renderStatsHtml();
        ring.innerHTML='';
        for(let i=1;i<=GAME_CONFIG.totalLevels;i++){
          const im=getLevelImage(i);
          const th=document.createElement('img'); th.src=im.src; ring.appendChild(th);
        }
        win.classList.add('show');
        playSFX('win');
        resetCombo();
      }else{
        const key = getLevelImageKey(level);
        galleryImg.src=getLevelImage(level).src;
        galleryDialog.style.display='none';
        if(galleryHint) galleryHint.textContent='點一下顯示台詞 ▶';
        gallery.style.display='flex'; requestAnimationFrame(()=>gallery.classList.add('show'));
        const proceed=()=>{ gallery.classList.remove('show'); setTimeout(()=>{ gallery.style.display='none'; gallery.removeEventListener('click',proceed); },200); galleryDialog.style.display='none'; level++; updateHUD(); initBricks(); resetBalls(); paused=true; running=false; applyBGMThemeForLevel(); showCenter(`進入關卡 ${level}`,'按 Space 或點畫面開始'); };
        const showLine=()=>{ const dlg=getRandomDialog(key); unlockDialog(key, dlg.idx); galleryDialog.textContent=dlg.text; galleryDialog.style.display='block'; if(galleryHint) galleryHint.textContent='點一下進入下一關 ▶'; gallery.removeEventListener('click',showLine); gallery.addEventListener('click',proceed,{once:true}); };
        gallery.addEventListener('click',showLine); return;
      }
    }
  }


  function loop(){ if(!paused && running) update(); draw(); requestAnimationFrame(loop); }
  
  // 菜單暫停控制：當音效或選項菜單開啟時停住遊戲，關閉時恢復（不影響 Game Over / 倒數邏輯）
  (function(){
    let menuPaused = false;
    window.__setMenuPause = function(flag){
      menuPaused = !!flag;
      if(menuPaused){
        // 開啟選單：立即暫停遊戲並記錄暫停開始時間
        paused = true;
        // 若正在倒數，停止計時以免在選單開啟期間自動恢復
        if(countdownTimer){ clearTimeout(countdownTimer); countdownTimer=null; }
        onPauseStart();
      } else {
        // 關閉選單：只要遊戲尚在進行且未 Game Over，立即修正計時並重新倒數
        if(running && !gameOver){
          // 確保即便先前已有倒數排程也能正確恢復
          resumePending = false;
          onResumeFromPause();
          // 繼續先前的倒數而非重置
          startCountdown(false);
        }
      }
    };
    // 保護性：若 UI 在小尺寸下重排導致狀態不同步，定時校正
    setInterval(()=>{
      const anyOpen = menusOpen();
      if(anyOpen !== menuPaused){ window.__setMenuPause(anyOpen); }
    }, 400);
  })();
function boot(){
    resetGame(); updateHUD(); loop();
    // 自動讀取音效/BGM偏好
    soundsOn = (localStorage.getItem('sfx_on')||'0')==='1'; soundBtn.textContent=`音效：${soundsOn?'開':'關'}`;
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.7'); bgmVol.value=String(v);
    bgmOn = (localStorage.getItem('bgm_on')||'0')==='1'; bgmBtn.textContent = bgmOn?'開':'關';
    // 若有存檔給提示
    const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4');
    if(raw){ setTimeout(()=>{ if(confirm('偵測到存檔，要讀取進度嗎？')) loadProgress(); }, 400); }
  }
  boot();
  // Ensure audio context unlock on first user gesture (mobile safe)
  try{ document.addEventListener('pointerdown', function(){ try{ ensureAudio(); }catch(e){} }, { once:true, passive:true}); }catch(_e){}
})();
</script>


<script>
(function(){
  const $ = sel => document.querySelector(sel);
  const skinSel = $('#skinSel');
  const skinTitle = $('#skinTitle');
  const skinDesc = $('#skinDesc');

  function populateSkinOptions(){
    if (!skinSel || !window.SKINS) return;
    while (skinSel.firstChild) skinSel.removeChild(skinSel.firstChild);
    const order = Object.keys(window.SKINS);
    for (const key of order){
      const def = window.SKINS[key];
      if (!def) continue;
      const opt = document.createElement('option');
      opt.value = key;
      opt.textContent = def.selectLabel || def.label || key;
      skinSel.appendChild(opt);
    }
  }

  window.updateSkinUI = function(skin){
    if (skinTitle) skinTitle.textContent = skin.label || skin.selectLabel || '經典風格';
    if (skinDesc) skinDesc.textContent = skin.desc || '';
  };

  function restoreAndApply(){
    let key = 'classic';
    try {
      const saved = localStorage.getItem('selected_skin');
      if (saved && window.SKINS && window.SKINS[saved]) key = saved;
    } catch(e){}
    if (skinSel) skinSel.value = key;
    if (typeof window.applySkin === 'function') window.applySkin(key);
  }

  function init(){
    if (!window.SKINS) { console.warn('[skin] SKINS not ready yet.'); return; }
    populateSkinOptions();
    restoreAndApply();
  }

  // 監聽選擇
  if (skinSel) {
    skinSel.addEventListener('change', function(){
      const key = skinSel.value;
      if (typeof window.applySkin === 'function') window.applySkin(key);
    }, { passive: true });
  }

  // 若 skin.js 較晚載入，這裡用 DOMContentLoaded 後再 init，多次呼叫也安全
  document.addEventListener('DOMContentLoaded', init, { once:true });
  // 如果已過 DOMContentLoaded，直接 init
  if (document.readyState === 'interactive' || document.readyState === 'complete') { init(); }
})();
</script>


<script>
// === Prism / Rainbow FX 引擎 ===
(function(){
  let rafId = 0, ctx = null, cvs = null;
  let t0 = 0, prevTs = 0;
  let stars=[], snows=[], clouds=[], embers=[], sparks=[], shards=[], slicers=[], flames=[], gears=[], balloons=[];
  let hexagram=null, scriptRing=null, pulse=null, sunOpt=null, flameOpt=null, ruins=[], webOpt=null, balloonOpt=null;
  let nukeAt=0, nukeEnd=0, diffusePhase=0;

  function resize(){
    if (!cvs) return;
    const parent = cvs.parentElement;
    const rect = parent.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    cvs.width  = Math.max(1, Math.floor(rect.width  * ratio));
    cvs.height = Math.max(1, Math.floor((parent.querySelector('#game')?.getBoundingClientRect().height || rect.width*0.56) * ratio));
    cvs.style.height = (cvs.height/ratio)+'px';
  }

  function drawRainbowWash(w, h, time){
    const g = ctx.createLinearGradient(0,0,w,0);
    const hueShift = (time*0.02)%360;
    for(let i=0;i<=6;i++){
      const hue = (hueShift + i*60)%360;
      g.addColorStop(i/6, `hsla(${hue},80%,60%,0.035)`);
    }
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
  }

  function initEffects(eff){
    const w=cvs.width, h=cvs.height;
    stars=[]; snows=[]; clouds=[]; embers=[]; sparks=[]; shards=[]; slicers=[]; flames=[]; balloons=[]; ruins=[]; gears=[];
    hexagram=scriptRing=pulse=null; sunOpt=null; flameOpt=null; balloonOpt=null; nukeAt=0; nukeEnd=0; diffusePhase=0; webOpt=null;
    if(!eff) return;
    if(eff.web) webOpt=eff.web;
    if(eff.stars){
      const count = Math.round( (eff.stars.countScale||1) * 140 );
      for(let i=0;i<count;i++) stars.push({x:Math.random()*w,y:Math.random()*h,r:(eff.stars.sizeMin||1)+Math.random()*((eff.stars.sizeMax||3)-(eff.stars.sizeMin||1)),ph:Math.random()*Math.PI*2});
    }
    if(eff.snow){
      const count = eff.snow.countScale||100;
      for(let i=0;i<count;i++) snows.push({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*0.3,vy:(eff.snow.speed||0.3)+Math.random()*((eff.snow.speedMax||0.8)-(eff.snow.speed||0.3)),ph:Math.random()*Math.PI*2});
    }
    if(eff.clouds){
      for(let i=0;i<eff.clouds.count;i++) clouds.push({x:Math.random()*w,y:Math.random()*h,sz:eff.clouds.sizePx||200,ph:Math.random()*Math.PI*2});
    }
    if(eff.balloons){
      balloonOpt = Object.assign({intervalMs:10000, lifeMs:40000, colors:['#ff8aa0','#ffd966','#9ad0f5','#cfa0ff','#ffe599'], last:0}, eff.balloons);
    }
    if(eff.embers){
      const N = eff.embers.count||200;
      for(let i=0;i<N;i++) embers.push({x:Math.random()*w,y:Math.random()*h,ph:Math.random()*Math.PI*2});
    }
    if(eff.shards){
      for(let i=0;i<eff.shards.count;i++) shards.push({x:Math.random()*w,y:Math.random()*h,ang:(eff.shards.angleDeg||-28)*Math.PI/180});
    }
    if(eff.sparks){
      for(let i=0;i<eff.sparks.count;i++) sparks.push({x:Math.random()*w,y:Math.random()*h});
    }
    if(eff.flames){
      flameOpt=eff.flames;
      const N=flameOpt.count||40;
      for(let i=0;i<N;i++){
        flames.push({
          x:Math.random()*w,
          y:h*(flameOpt.baseY||0.8)+Math.random()*h*0.2,
          size:(flameOpt.sizeMin||2)+Math.random()*((flameOpt.sizeMax||6)-(flameOpt.sizeMin||2)),
          alpha:0.5+Math.random()*0.5,
          speed:(flameOpt.speedMin||0.3)+Math.random()*((flameOpt.speedMax||0.8)-(flameOpt.speedMin||0.3)),
          ph:Math.random()*Math.PI*2
        });
      }
    }
    if(eff.gears){
      const period=eff.gears.rotationMs||30000;
      if(eff.gears.layout){
        const minDim=Math.min(w,h);
        gears=eff.gears.layout.map((g,i)=>{
          const r=g.r*minDim;
          const x=g.x*w;
          const y=g.y*h;
          const inner=g.inner||0.6;
          const dir=g.dir!=null?g.dir:(i%2? -1:1);
          const teeth=g.teeth||12;
          return {x,y,r,teeth,inner,rot:0,omega:dir*2*Math.PI/period};
        });
      }else{
        for(let i=0;i<eff.gears.count;i++){
          const r=(eff.gears.sizeMin||40)+Math.random()*((eff.gears.sizeMax||120)-(eff.gears.sizeMin||40));
          const omega=(Math.random()<0.5?-1:1)*2*Math.PI/period;
          const x=Math.random()*w;
          const y=h*0.55 + Math.random()*h*0.45; // avoid upper brick area
          const inner=0.55+Math.random()*0.2;
          gears.push({x,y,r,teeth:8+Math.floor(Math.random()*5),inner,rot:Math.random()*Math.PI*2,omega});
        }
      }
    }
    if(eff.sun) sunOpt=eff.sun;
    if(eff.hexagram) hexagram=eff.hexagram;
    if(eff.scriptRing) scriptRing=eff.scriptRing;
    if(eff.pulse) pulse=eff.pulse;
    if(eff.ruins){
      for(let i=0;i<eff.ruins.layers;i++) ruins.push({off:Math.random()*w});
    }
    if(eff.nuke) nukeAt=performance.now()+ (eff.nuke.intervalMs||12000);
    if(eff.slicer){
      // start immediately
      slicers.push({t:0});
    }
  }

  function drawPrismBeams(w,h,time,opt){
    const beams=opt.beams||6;const speed=opt.speed||0.0005;const alpha=opt.alpha||0.1;const spread=opt.spread||0.85;const hueShift=opt.hueShift||40;
    const cx=w*0.5,cy=h*0.2;const r=Math.hypot(w,h);const base=time*speed*2*Math.PI;
    for(let i=0;i<beams;i++){
      const a=base+i*(2*Math.PI/beams);const hue=(hueShift+i*(360/beams))%360;const x2=cx+Math.cos(a)*r;const y2=cy+Math.sin(a)*r;
      const grad=ctx.createLinearGradient(cx,cy,x2,y2);
      grad.addColorStop(0,`hsla(${hue},95%,65%,0)`);grad.addColorStop(0.15,`hsla(${hue},95%,65%,${alpha})`);grad.addColorStop(spread,`hsla(${hue},95%,65%,0)`);
      ctx.strokeStyle=grad;ctx.lineWidth=Math.max(1,r*0.012);ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(x2,y2);ctx.stroke();
    }
  }

  function drawCobweb(w,h,time,opt){
    const period = opt.period || 30000;
    const phase = (time % period) / period;
    const rMax = Math.hypot(w,h)*0.6;
    const r = phase * rMax;
    const flash = Math.pow(Math.sin(time*0.0002), 8);
    const shimmer = 0.1 + 0.9*flash;
    const alpha = (opt.alpha || 0.05) * shimmer * (1 - phase);
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.strokeStyle = opt.color || '#e0e0e0';
    ctx.globalAlpha = alpha;
    ctx.lineWidth = opt.lineWidth || 1.2;
    const radials = opt.radials || 12;
    for(let i=0;i<radials;i++){
      const ang = i*(2*Math.PI/radials);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
      ctx.stroke();
    }
    const rings = opt.rings || 6;
    for(let j=1;j<=rings;j++){
      const rr = r*(j/rings);
      ctx.beginPath();
      ctx.arc(0,0,rr,0,Math.PI*2);
      ctx.stroke();
    }
    if(opt.dew){
      const count = opt.dew.count || 20;
      const radius = opt.dew.radius || 2;
      const dewColor = opt.dew.color || '#ffffff';
      const spin = opt.dew.spin || 0.0004;
      for(let i=0;i<count;i++){
        const ang = i*(2*Math.PI/count) + time*spin;
        const rr = r*((i%rings)+1)/(rings+1);
        ctx.save();
        const a = (0.4+0.6*Math.sin(time*0.002+i))*(opt.dew.alpha||0.8)*(1-phase);
        ctx.globalAlpha = a;
        ctx.fillStyle = dewColor;
        ctx.beginPath();
        ctx.arc(Math.cos(ang)*rr, Math.sin(ang)*rr, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    ctx.restore();
  }

  function drawSun(w,h,time,opt){
    const rot=(time%(opt.rotationPeriodMs||30000))/(opt.rotationPeriodMs||30000)*2*Math.PI;
    const scalePeriod=opt.scalePeriodMs||120000;
    const frac=(time%scalePeriod)/scalePeriod;
    const prog=frac<0.5?frac*2:(1-frac)*2;
    const r=Math.min(w,h)*((opt.sizeMin||0.05)+prog*((opt.sizeMax||0.3)-(opt.sizeMin||0.05)));
    const cx=w/2,cy=h*(opt.centerY||0.55);
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(rot);

    if(opt.scatter){
      const count = opt.scatter.count || 16;
      const far = Math.hypot(w,h);
      const near = r;
      const wNear = near * (opt.scatter.widthNear || 0.02);
      const wFar = far * (opt.scatter.widthFar || 0.1);
      const alpha = opt.scatter.alpha || 0.05;
      ctx.globalAlpha = alpha;
      for(let i=0;i<count;i++){
        const ang = i * (2*Math.PI/count);
        const angNear = wNear/near;
        const angFar = wFar/far;
        ctx.beginPath();
        ctx.moveTo(Math.cos(ang-angNear/2)*near, Math.sin(ang-angNear/2)*near);
        ctx.lineTo(Math.cos(ang-angFar/2)*far, Math.sin(ang-angFar/2)*far);
        ctx.lineTo(Math.cos(ang+angFar/2)*far, Math.sin(ang+angFar/2)*far);
        ctx.lineTo(Math.cos(ang+angNear/2)*near, Math.sin(ang+angNear/2)*near);
        ctx.closePath();
        const grad = ctx.createLinearGradient(
          Math.cos(ang)*near, Math.sin(ang)*near,
          Math.cos(ang)*far, Math.sin(ang)*far
        );
        grad.addColorStop(0,'rgba(255,240,200,0)');
        grad.addColorStop(0.2,'rgba(255,240,200,1)');
        grad.addColorStop(1,'rgba(255,240,200,0)');
        ctx.fillStyle = grad;
        ctx.fill();
      }
    }

    ctx.globalAlpha=opt.alpha||0.4;

    const rayCount=opt.rayCount||20;
    const inner=r*0.6;
    const outerLong=r;
    const outerShort=r*0.8;
    ctx.fillStyle='rgba(255,200,80,0.35)';
    ctx.beginPath();
    for(let i=0;i<rayCount*2;i++){
      const ang=i*Math.PI/rayCount;
      let rad;
      if(i%2===0){
        rad = i%4===0?outerLong:outerShort;
      }else{
        rad = inner;
      }
      const x=Math.cos(ang)*rad;
      const y=Math.sin(ang)*rad;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();

    const g=ctx.createRadialGradient(0,0,0,0,0,inner);
    g.addColorStop(0,'rgba(255,255,220,0.9)');
    g.addColorStop(0.7,'rgba(255,180,40,0.4)');
    g.addColorStop(1,'rgba(255,140,0,0)');
    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.arc(0,0,inner,0,Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function loop(ts){
    if(!ctx||!cvs)return;
    if(!t0){ t0=ts; prevTs=ts; }
    const t=ts-t0;
    const dt=ts-prevTs; prevTs=ts;
    const w=cvs.width,h=cvs.height; ctx.clearRect(0,0,w,h);
    const eff=window.currentSkin&&window.currentSkin.canvas&&window.currentSkin.canvas.effects;
    drawRainbowWash(w,h,t);
    if(eff){
      ctx.globalCompositeOperation='screen';
      if(webOpt) drawCobweb(w,h,t,webOpt);
      if(eff.prism) drawPrismBeams(w,h,t,eff.prism);
      if(stars.length){for(const s of stars){const tw=eff.stars&&eff.stars.twinkle?0.5+0.5*Math.sin(t*0.002+s.ph):1;ctx.fillStyle=`rgba(255,255,255,${0.6*tw})`;ctx.beginPath();ctx.arc(s.x,s.y,s.r,0,Math.PI*2);ctx.fill();}}
      if(snows.length){for(const f of snows){f.y+=f.vy;f.x+=f.vx;f.x+=Math.sin(f.ph+t*0.001)*(eff.snow.sway||0.5);if(f.y>h)f.y=-10;if(f.x>w)f.x=0;if(f.x<0)f.x=w;ctx.fillStyle='rgba(255,255,255,0.8)';ctx.beginPath();ctx.arc(f.x,f.y,2,0,Math.PI*2);ctx.fill();}}
      if(clouds.length){
        ctx.globalAlpha = eff.clouds.alpha || 0.25;
        for(const c of clouds){
          c.x += Math.sin(t*0.00005 + c.ph) * (eff.clouds.speed || 0.002) * 50;
          if(c.x > w + c.sz) c.x = -c.sz;
          const grad = ctx.createRadialGradient(c.x, c.y, c.sz*0.2, c.x, c.y, c.sz);
          grad.addColorStop(0,'#ffffff');
          grad.addColorStop(1,'#ffe6f5');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(c.x - c.sz*0.4, c.y, c.sz*0.6, 0, Math.PI*2);
          ctx.arc(c.x, c.y - c.sz*0.2, c.sz*0.7, 0, Math.PI*2);
          ctx.arc(c.x + c.sz*0.4, c.y, c.sz*0.6, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
        if(balloonOpt){
          const interval = balloonOpt.intervalMs || 10000;
          if(t - balloonOpt.last >= interval){
            balloonOpt.last = t;
            const cols = balloonOpt.colors || ['#ff8aa0','#ffd966','#9ad0f5','#cfa0ff','#ffe599'];
            const col = cols[Math.floor(Math.random()*cols.length)];
            balloons.push({x:Math.random()*w,y:h+30,color:col});
          }
          for(let i=balloons.length-1;i>=0;i--){
            const b=balloons[i];
            const life=balloonOpt.lifeMs||40000;
            b.y -= h*dt/life;
            ctx.fillStyle=b.color;
            ctx.beginPath();
            ctx.ellipse(b.x,b.y,20,26,0,0,Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(b.x,b.y+26);
            ctx.lineTo(b.x,b.y+40);
            ctx.strokeStyle='rgba(0,0,0,0.15)';
            ctx.lineWidth=2;
            ctx.stroke();
            if(b.y<-30) balloons.splice(i,1);
          }
        }
      if(embers.length){const cx=w*(eff.embers.center?eff.embers.center[0]:0.5), cy=h*(eff.embers.center?eff.embers.center[1]:0.5);for(const p of embers){p.ph+=eff.embers.omega||0.002;const r=Math.hypot(p.x-cx,p.y-cy);const ang=Math.atan2(p.y-cy,p.x-cx)+ (eff.embers.omega||0.002);p.x=cx+Math.cos(ang)*r; p.y=cy+Math.sin(ang)*r; ctx.fillStyle='rgba(255,120,40,0.8)';ctx.beginPath();ctx.arc(p.x,p.y,2,0,Math.PI*2);ctx.fill();}}
      if(gears.length){
        for(const g of gears){
          g.rot+=g.omega*dt;
          ctx.save();
          ctx.translate(g.x,g.y);
          ctx.rotate(g.rot);
          ctx.globalAlpha=0.6;
          const step=2*Math.PI/g.teeth;
          // 讓齒槽寬度與輪齒寬度一致，因此每齒佔一半角度
          const tooth=step*0.5;
          const root=g.r*0.75;
          ctx.beginPath();
          ctx.moveTo(root,0);
          for(let i=0;i<g.teeth;i++){
            const a=i*step;
            ctx.lineTo(root*Math.cos(a), root*Math.sin(a));
            ctx.lineTo(g.r*Math.cos(a), g.r*Math.sin(a));
            ctx.lineTo(g.r*Math.cos(a+tooth), g.r*Math.sin(a+tooth));
            ctx.lineTo(root*Math.cos(a+tooth), root*Math.sin(a+tooth));
          }
          ctx.closePath();
          const grad=ctx.createRadialGradient(0,0,g.r*0.2,0,0,g.r);
          grad.addColorStop(0,'rgba(255,240,220,0.1)');
          grad.addColorStop(0.6,'rgba(200,170,120,0.05)');
          grad.addColorStop(1,'rgba(90,70,50,0.03)');
          ctx.fillStyle=grad;
          ctx.fill();
          ctx.lineWidth=g.r*0.04;
          ctx.strokeStyle='rgba(255,220,170,0.15)';
          ctx.stroke();
          ctx.globalCompositeOperation='destination-out';
          ctx.beginPath();
          ctx.arc(0,0,g.r*0.4,0,Math.PI*2);
          ctx.fill();
          ctx.globalCompositeOperation='source-over';
          ctx.beginPath();
          ctx.arc(0,0,g.r*0.4,0,Math.PI*2);
          ctx.lineWidth=g.r*0.025;
          ctx.strokeStyle='rgba(255,220,170,0.1)';
          ctx.stroke();
          ctx.restore();
        }
      }
      if(sparks.length){for(const sp of sparks){ctx.fillStyle='rgba(255,210,122,0.8)';ctx.fillRect(sp.x,sp.y,2,2);}}
      if(flames.length){for(const f of flames){f.y-=f.speed;f.x+=Math.sin(t*0.002+f.ph)*(flameOpt?.drift||0.3);f.alpha-=0.004;f.size*=0.98;if(f.alpha<=0||f.y<h*(flameOpt?.dieY||0.55)){f.x=Math.random()*w;f.y=h*(flameOpt?.baseY||0.8)+Math.random()*h*0.2;f.size=(flameOpt?.sizeMin||2)+Math.random()*((flameOpt?.sizeMax||6)-(flameOpt?.sizeMin||2));f.alpha=0.5+Math.random()*0.5;f.speed=(flameOpt?.speedMin||0.3)+Math.random()*((flameOpt?.speedMax||0.8)-(flameOpt?.speedMin||0.3));f.ph=Math.random()*Math.PI*2;}ctx.fillStyle=`rgba(255,220,150,${f.alpha})`;ctx.beginPath();ctx.arc(f.x,f.y,f.size,0,Math.PI*2);ctx.fill();}}
      if(sunOpt) drawSun(w,h,t,sunOpt);
      if(hexagram){const R=Math.min(w,h)*(hexagram.radiusMul||0.44);const rot=(t%(hexagram.rotationPeriodMs||24000))/(hexagram.rotationPeriodMs||24000)*2*Math.PI;ctx.save();ctx.translate(w/2,h*0.48);ctx.rotate(rot);ctx.strokeStyle=hexagram.color||'#FFD27A';ctx.lineWidth=(hexagram.strokePx||2);ctx.beginPath();for(let i=0;i<6;i++){const a=i*Math.PI/3;ctx.lineTo(Math.cos(a)*R,Math.sin(a)*R);}ctx.closePath();ctx.stroke();ctx.restore();}
      if(scriptRing){const R=Math.min(w,h)*(scriptRing.radiusMul||0.58);const rot=-(t%(scriptRing.rotationPeriodMs||24000))/(scriptRing.rotationPeriodMs||24000)*2*Math.PI;ctx.save();ctx.translate(w/2,h*0.48);ctx.rotate(rot);ctx.strokeStyle=scriptRing.strokeColor||'#FFD27A';ctx.lineWidth=(scriptRing.strokePx||1.6);ctx.globalAlpha=scriptRing.alpha||0.7;ctx.beginPath();ctx.arc(0,0,R,0,Math.PI*2);ctx.stroke();ctx.restore();}
      if(pulse){const cx=w/2,cy=h*0.48;const r=(t%(pulse.intervalMul?skin.canvas.period*(pulse.intervalMul):skin.canvas.period))/ (skin.canvas.period||2000);const rad=r*Math.min(w,h);ctx.strokeStyle=`rgba(${pulse.color.join(',')},0.3)`;ctx.lineWidth=pulse.thickness||4;ctx.beginPath();ctx.arc(cx,cy,rad,0,Math.PI*2);ctx.stroke();}
      if(ruins.length){ctx.fillStyle='rgba(0,0,0,'+(eff.ruins.haze||0.2)+')';for(const r0 of ruins){ctx.fillRect((r0.off+t*0.01)%w - w,h*0.6,w,h*0.4);}}
      if(eff.nuke){const now=performance.now(); if(now>nukeAt){nukeEnd=now+(eff.nuke.flashMs||200); nukeAt=now+(eff.nuke.intervalMs||12000);} if(now<nukeEnd){ctx.fillStyle='rgba(255,255,255,0.3)';ctx.fillRect(0,0,w,h);} }
      if(eff.diffuse){
        diffusePhase=(diffusePhase+0.001)%1;
        const rr=Math.max(w,h)*diffusePhase;
        const col=eff.diffuse.color||[255,69,0];
        const alpha=eff.diffuse.alpha||0.05;
        const g=ctx.createRadialGradient(w/2,h/2,rr*0.2,w/2,h/2,rr);
        g.addColorStop(0,`rgba(${col[0]},${col[1]},${col[2]},${alpha})`);
        g.addColorStop(1,`rgba(${col[0]},${col[1]},${col[2]},0)`);
        ctx.fillStyle=g;
        ctx.fillRect(0,0,w,h);
      }
      if(eff.slicer){const now=performance.now(); if(!slicers.length||now-slicers[slicers.length-1].t>(eff.slicer.intervalMs||3000)){slicers.push({t:now,x:Math.random()*w});}
        ctx.strokeStyle=eff.slicer.color||'rgba(190,0,30,0.35)';ctx.lineWidth=(eff.slicer.widthMul||0.3)*10; for(let i=slicers.length-1;i>=0;i--){const s=slicers[i]; const age=now-s.t; if(age>(eff.slicer.lifeMs||500)){slicers.splice(i,1);continue;} const y=age*0.5; ctx.beginPath(); ctx.moveTo(s.x,y); ctx.lineTo(s.x+w,y+h); ctx.stroke();}}
      ctx.globalCompositeOperation='source-over';
    }
    rafId=requestAnimationFrame(loop);
  }

  function start(skin){
    if(!cvs){cvs=document.getElementById('fx'); if(!cvs) return; ctx=cvs.getContext('2d',{alpha:true}); window.addEventListener('resize',resize);} resize(); cancelAnimationFrame(rafId); t0=0; initEffects(skin.canvas&&skin.canvas.effects); rafId=requestAnimationFrame(loop);
  }
  function stop(){ cancelAnimationFrame(rafId); if(ctx&&cvs){ctx.clearRect(0,0,cvs.width,cvs.height);} }
  window.fxStart=start; window.fxStop=stop;
})();
</script>

</body>
</html>
