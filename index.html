<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>打磚塊 Breakout（最終合併版 · Config 化）</title>
  <style>
    :root {
      --bg:#0b1022; --bg2:#0a0f1e; --fg:#e9ecf1; --accent:#66b2ff;
      --brick1:#ff6b6b; --brick2:#ffd166; --brick3:#06d6a0; --brick4:#4cc9f0;
      --expl:#ff8c00; --power:#7aa2ff; --debuff:#ff6aa3;
      --glass: rgba(255,255,255,.06); --glass-stroke: rgba(255,255,255,.12);
      --btn:#1a2448; --btn-stroke:#2a3974; --pill:#121a36;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 800px at 50% -10%, #152040, #0a0f1e 60%); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;}
    .wrap{display:flex; gap:16px; align-items:center; justify-content:center; flex-direction:column; padding:20px}
    h1{margin:6px 0 0 0; font-weight:800; letter-spacing:.3px; text-shadow:0 2px 20px #0008}
    .hud{
      position:sticky; top:0; z-index:3;
      display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; font-weight:650;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--glass-stroke); border-radius:14px; padding:10px 12px;
      box-shadow: 0 6px 24px rgba(0,0,0,.25); backdrop-filter: blur(6px);
    }
    .pill{padding:8px 12px; background:var(--pill); border:1px solid var(--glass-stroke); border-radius:999px}
    .btn{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg);
      border:1px solid var(--btn-stroke); border-radius:10px; padding:8px 12px; cursor:pointer; user-select:none}
    .btn:active{transform:translateY(1px)}
    select{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg); border:1px solid var(--btn-stroke); border-radius:8px; padding:6px 10px}
    canvas{background:linear-gradient(180deg, #0d1126, #0b1022 55%, #091022);
      border:1px solid #1a2348; border-radius:14px; max-width:min(1120px, 96vw); width: min(1120px, 96vw); height: auto; display:block;
      box-shadow: 0 30px 80px rgba(0,0,0,.35), inset 0 0 120px rgba(255,255,255,.02);}
    .overlay{position:relative}
    .center-note{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:2}
    .note-box{background:linear-gradient(180deg, rgba(8,12,28,.9), rgba(8,12,28,.85));
      border:1px solid var(--glass-stroke); padding:18px 22px; border-radius:14px; text-align:center; max-width:min(90vw,820px);
      box-shadow: 0 12px 60px rgba(0,0,0,.5);}
    .note-box h2{margin:0 0 8px 0}
    .note-box p{margin:6px 0; line-height:1.6}
    kbd{background:#0e1836; border:1px solid #2a356a; border-radius:6px; padding:2px 6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:90%}
    .badges{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center}
    .badge{background:linear-gradient(180deg, rgba(18,32,68,.9), rgba(10,20,48,.9));
      border:1px solid var(--glass-stroke); padding:4px 10px; border-radius:999px; font-size:12px; display:flex; gap:6px; align-items:center}
    .legend{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center; font-size:13px}
    .legend .box{width:14px; height:14px; display:inline-block; border-radius:3px; margin-right:4px; vertical-align:middle}
    .legend .item{padding:4px 8px; border-radius:10px; background:rgba(255,255,255,.05); border:1px solid var(--glass-stroke)}

    /* 關卡過關後的大圖展示 overlay */ 
    .gallery{position:absolute; inset:0; display:none; align-items:center; justify-content:center; flex-direction:column; z-index:4;}
    .gallery .backdrop{position:absolute; inset:0; background:rgba(0,0,0,.75); opacity:0; transition:opacity .6s;}
    .gallery img{max-width:min(92vw,1040px); max-height:min(88vh,680px); border-radius:16px; box-shadow:0 30px 120px rgba(0,0,0,.6); opacity:0; transform:translateY(12px) scale(.98); transition:opacity .6s, transform .6s;}
    .gallery .hint{position:absolute; bottom:24px; color:#fff; font-size:18px; opacity:0; text-shadow:0 2px 10px rgba(0,0,0,.6);}
    .gallery.show .backdrop{opacity:1;}
    .gallery.show img{opacity:1; transform:translateY(0) scale(1);}
    .gallery.show .hint{opacity:.9;}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>打磚塊 Breakout（最終合併版 · Config 化）</h1>
    <div class="hud">
      <div class="pill">分數 <span id="score">0</span></div>
      <div class="pill">關卡 <span id="level">1</span></div>
      <div class="pill">生命 <span id="lives">3</span></div>
      <label>難度
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </label>
      <button class="btn" id="pauseBtn">開始 / 暫停 (<kbd>Space</kbd>)</button>
      <button class="btn" id="resetBtn">重開 (<kbd>R</kbd>)</button>
      <button class="btn" id="fsBtn">全螢幕 (<kbd>F</kbd>)</button>
      <button class="btn" id="soundBtn">音效：關</button>
      <button class="btn" id="saveBtn">存檔</button>
      <button class="btn" id="loadBtn">讀檔</button>
      <button class="btn" id="clearSaveBtn">清除存檔</button>
    </div>

    <div class="legend">
      <span class="item"><span class="box" style="background:var(--expl)"></span>爆炸磚</span>
      <span class="item"><span class="box" style="background:var(--brick2)"></span>一般磚</span>
      <span class="item"><span class="box" style="background:var(--power)"></span>增益道具</span>
      <span class="item"><span class="box" style="background:var(--debuff)"></span>減益道具</span>
    </div>
    <div class="badges" id="activeBuffs"></div>

    <div class="overlay">
      <div class="gallery" id="gallery">
        <div class="backdrop"></div>
        <img id="galleryImg" src="" alt="關卡大圖" />
        <div class="hint">點一下進入下一關 ▶</div>
      </div>

      <canvas id="game" width="1100" height="700"></canvas>
      <div class="center-note" id="centerNote">
        <div class="note-box">
          <h2 id="noteTitle">按 <kbd>Space</kbd> 或點畫面開始</h2>
          <p id="noteText">
            本版已整合：背景逐步揭示 + 清關畫廊、增益減益（Config 控制）、爆炸磚、音效、難度、存讀檔。<br>
            操作：<kbd>←</kbd>/<kbd>→</kbd> 或 <kbd>A</kbd>/<kbd>D</kbd>；滑鼠左右移動也可。Space 暫停/開始，R 重開，F 全螢幕。
          </p>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // === 全域設定：難度 / 磚塊 / 道具 / 上限 ===
  const GAME_CONFIG = {
    difficulty: {
      easy:   { paddleBaseW: 220, baseSpeed: 4, rowsBase: 6, dropRate: 0.42 },
      normal: { paddleBaseW: 180, baseSpeed: 5, rowsBase: 7, dropRate: 0.32 },
      hard:   { paddleBaseW: 140, baseSpeed: 6, rowsBase: 8, dropRate: 0.22 },
    },
    bricks: {
      explosiveChance: 0.20,
      brickHeight: 30,
      padding: 9,
      topOffset: 60,
      cols: 12
    },
    powers: {
      WIDE:   { label:'平台變寬',   type:'buff',   durationMs:30000, paddleWidthAdd:50,  badge:'↔️' },
      LONG:   { label:'平台變長',   type:'buff',   durationMs:30000, longPerStackAdd:40, stacksMax:2, badge:'📏' },
      STICKY: { label:'黏性平台',   type:'buff',   durationMs:5000, sticky:true,        badge:'🧲' },
      MULTI:  { label:'多球',       type:'buff',   multiDuplicate:true, maxBalls:4,      badge:'✨' },
      SLOW:   { label:'全局慢速',   type:'buff',   durationMs:15000,   speedMul:0.6,     badge:'🐢' },
      PIERCE: { label:'穿透球',     type:'buff',   durationMs:12000,   piercing:true,     badge:'🎯' },
      SHIELD: { label:'護盾',       type:'buff',   oneShotShield:true,                  badge:'🛡' },
      RAMPAGE:{ label:'暴走球',     type:'buff',   durationMs:5000,   forcePiercing:true, rampageMs:5000, badge:'🔥' },
      FAST:   { label:'快速球',     type:'debuff', durationMs:5000,  globalSpeedMul:2.0, screenShakeOnApply:6, badge:'⚡' },
      WAVY:   { label:'變速球',     type:'debuff', durationMs:5000,  wavy:{amp:0.6, base:1.2, periodMs:200}, badge:'〰️' }
    },
    powerCapsule: { width:24, height:16, fallVy:2.2 },
    caps: { paddleMaxW:300, ballSpeedMax:16 }
  };

  // ==== 背景圖片（固定順序） ====
  const BG_SRCS = [
    'images/bg1.png','images/bg2.png','images/bg3.png','images/bg4.png','images/bg5.png',
    'images/bg6.png','images/bg7.png','images/bg8.png','images/bg9.png','images/bg10.png',
  ];
  const BG_IMGS = BG_SRCS.map(src => { const i=new Image(); i.src=src; i.decoding='async'; i.loading='eager'; return i; });

  // Canvas / HUD refs
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const livesEl = document.getElementById('lives');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const fsBtn = document.getElementById('fsBtn');
  const soundBtn = document.getElementById('soundBtn');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const clearSaveBtn = document.getElementById('clearSaveBtn');
  const centerNote = document.getElementById('centerNote');
  const noteTitle = document.getElementById('noteTitle');
  const noteText = document.getElementById('noteText');
  const difficultySel = document.getElementById('difficulty');
  const activeBuffsEl = document.getElementById('activeBuffs');

  // Gallery overlay
  const gallery = document.getElementById('gallery');
  const galleryImg = document.getElementById('galleryImg');

  // DPR scaling
  function resizeCanvasDPR() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const cssW = canvas.clientWidth;
    const cssH = Math.round(cssW * (700/1100));
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    scaleX = canvas.width / 1100;
    scaleY = canvas.height / 700;
  }
  let scaleX=1, scaleY=1;
  window.addEventListener('resize', resizeCanvasDPR);
  resizeCanvasDPR();

  // Game state
  let running = false;
  let paused = true;
  let level = 1;
  let score = 0;
  let lives = 3;
  let soundsOn = false;

  // Background style
  let bgTime = 0;

  // Particles
  const particles = []; // {x,y,vx,vy,life,color,size}
  function spawnParticles(x,y,color,count=10,spread=1.6,speed=3,size=3){
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const v = speed*(.4 + Math.random());
      particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:400+Math.random()*300,color,size:size*(.6+Math.random()*0.8)});
    }
  }

  // Helpers
  function getDiff(){ return GAME_CONFIG.difficulty[difficultySel.value]; }
  function brickColor(idx){ return [getVar('--brick1'), getVar('--brick2'), getVar('--brick3'), getVar('--brick4')][idx%4]; }
  function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawRoundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo((x+r)*scaleX, y*scaleY);
    ctx.arcTo((x+w)*scaleX, y*scaleY, (x+w)*scaleX, (y+h)*scaleY, r*scaleX);
    ctx.arcTo((x+w)*scaleX, (y+h)*scaleY, x*scaleX, (y+h)*scaleY, r*scaleX);
    ctx.arcTo(x*scaleX, (y+h)*scaleY, x*scaleX, y*scaleY, r*scaleX);
    ctx.arcTo(x*scaleX, y*scaleY, (x+w)*scaleX, y*scaleY, r*scaleX);
    ctx.closePath();
  }

  // Badge / Buff UI
  function badgeIcon(k){
    const def = GAME_CONFIG.powers[k];
    return def?.badge || '●';
  }
  function updateBuffBadges(){
    activeBuffsEl.innerHTML = '';
    const now = performance.now();
    for (const key of Object.keys(GAME_CONFIG.powers)){
      if (key === 'LONG'){
        const lefts = buffs.LONG.stacks.filter(t=>t>now).map(t=>((t-now)/1000));
        if (lefts.length === 0) continue;
        const span = document.createElement('span');
        span.className = 'badge';
        span.textContent = `${badgeIcon('LONG')} LONG×${lefts.length} ${Math.max(0,Math.max(...lefts)).toFixed(1)}s`;
        activeBuffsEl.appendChild(span);
      }else{
        const b = buffs[key];
        if (!b?.active) continue;
        const left = b.until && b.until>now ? ((b.until-now)/1000).toFixed(1)+'s' : '';
        const span = document.createElement('span');
        span.className = 'badge';
        span.textContent = `${badgeIcon(key)} ${key}${left?' '+left:''}`;
        activeBuffsEl.appendChild(span);
      }
    }
  }

  // Buff state (kept same keys to preserve logic)
  const buffs = {
    WIDE:{active:false, until:0},
    STICKY:{active:false, until:0},
    MULTI:{active:false, until:0},
    SLOW:{active:false, until:0},
    PIERCE:{active:false, until:0},
    SHIELD:{active:false, until:0},
    RAMPAGE:{active:false, until:0},
    FAST:{active:false, until:0},
    WAVY:{active:false, until:0, start:0},
    LONG:{active:false, until:0, stacks:[]}
  };

  // Difficulty snapshot
  let diff = getDiff();

  // Paddle
  const paddle = { w: diff.paddleBaseW, h: 18, x: 1100/2 - diff.paddleBaseW/2, y: 700 - 50, speed: 12 };

  // Balls
  let balls = [];
  function makeBall(stuck=false, x=null){
    const b = { x: x??(1100/2), y: 700/2, r: 10, vx: 5, vy: -5, speedCap: GAME_CONFIG.caps.ballSpeedMax, piercing:false, stuck:stuck, offsetX:0, rampageUntil:0, trail:[] };
    return b;
  }

  // Audio
  const audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
  function beep(freq=600, dur=0.05, vol=0.06){
    if (!soundsOn || !audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square'; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); }, Math.max(10, dur*1000));
  }

  // Bricks + reveal
  let bricks = [];
  let brickW = 0, brickH = GAME_CONFIG.bricks.brickHeight;
  let revealRects = []; // [{x,y,w,h}]

  function layout(){
    return {
      rows: getDiff().rowsBase + Math.floor((level-1)%3),
      cols: GAME_CONFIG.bricks.cols,
      pad:  GAME_CONFIG.bricks.padding,
      top:  GAME_CONFIG.bricks.topOffset,
      h:    GAME_CONFIG.bricks.brickHeight
    };
  }

  function initBricks() {
    const L = layout();
    const totalPad = (L.cols+1) * L.pad;
    brickW = Math.floor((1100 - totalPad) / L.cols);
    brickH = L.h;
    bricks = [];
    revealRects = [];
    for (let r=0;r<L.rows;r++){
      for (let c=0;c<L.cols;c++){
        const x = L.pad + c*(brickW + L.pad);
        const y = L.top + r*(brickH + L.pad);
        const hp = 1 + Math.floor((level-1)/3);
        const explosive = Math.random() < GAME_CONFIG.bricks.explosiveChance;
        bricks.push({x,y,w:brickW,h:brickH,hp:explosive ? 1 : hp,colorIdx:(r%4), explosive});
      }
    }
  }

  function explodeAt(cx, cy){
    const radius = Math.max(brickW, brickH) * 1.3;
    for (let i=bricks.length-1; i>=0; i--){
      const b = bricks[i];
      const bx = b.x + b.w/2, by = b.y + b.h/2;
      const d = Math.hypot(bx - cx, by - cy);
      if (d <= radius){
        revealRects.push({x:b.x, y:b.y, w:b.w, h:b.h});
        bricks.splice(i,1);
        score += 10;
        spawnParticles(bx,by,'#ffdd99', 14, 1.7, 2.6, 3);
      }
    }
    spawnParticles(cx,cy,'#ffbb55', 24, 2.1, 3.2, 4);
    updateHUD();
    beep(200,0.08,0.08);
  }

  // Power-ups
  const powerups = []; // {x,y,w,h,vy,type,isDebuff,phase}
  const POWER_TYPES = Object.keys(GAME_CONFIG.powers);
  function spawnPower(x,y){
    const type = POWER_TYPES[Math.floor(Math.random()*POWER_TYPES.length)];
    const def = GAME_CONFIG.powers[type];
    powerups.push({
      x:x, y:y,
      w:GAME_CONFIG.powerCapsule.width,
      h:GAME_CONFIG.powerCapsule.height,
      vy:GAME_CONFIG.powerCapsule.fallVy,
      type,
      isDebuff:(def.type === 'debuff'),
      phase:Math.random()*Math.PI*2
    });
  }

  function applyPower(type){
    const def = GAME_CONFIG.powers[type];
    if (!def) return;
    const now = performance.now();

    // 設定持續時間（一次性道具不會設置 until）
    if (def.durationMs){
      if (type !== 'LONG'){ // LONG 由 stacks 管理
        const b = buffs[type];
        if (b){ b.active = true; b.until = now + def.durationMs; }
      }
    }

    // 專屬效果
    if (def.paddleWidthAdd){
      // 只標記 WIDE 啟用，實際寬度交給 computePaddleWidth
      buffs.WIDE.active = true; buffs.WIDE.until = now + def.durationMs;
    }
    if (def.longPerStackAdd){
      const actives = buffs.LONG.stacks.filter(t=>t>now);
      const max = def.stacksMax ?? 2;
      if (actives.length < max){
        buffs.LONG.stacks.push(now + def.durationMs);
      }else{
        const earliest = Math.min(...actives);
        const idx = buffs.LONG.stacks.indexOf(earliest);
        buffs.LONG.stacks[idx] = now + def.durationMs;
      }
    }
    if (def.sticky){
      buffs.STICKY.active = true; buffs.STICKY.until = now + def.durationMs;
    }
    if (def.multiDuplicate){
      // 保留原行為：只有在 balls.length < 3 時複製每顆球 → 1->2, 2->4
      if (balls.length < 3){
        const news = [];
        for (const b of balls){ const b1 = {...b}; b1.trail = []; news.push(b1); }
        balls = balls.concat(news);
        // 保護上限（避免極端狀況）
        const cap = def.maxBalls ?? 4;
        if (balls.length > cap) balls.length = cap;
      }
    }
    if (def.speedMul){
      buffs.SLOW.active = true; buffs.SLOW.until = now + def.durationMs;
    }
    if (def.piercing){
      buffs.PIERCE.active = true; buffs.PIERCE.until = now + def.durationMs;
      for (const b of balls) b.piercing = true;
    }
    if (def.oneShotShield){
      buffs.SHIELD.active = true;
    }
    if (def.forcePiercing && def.rampageMs){
      buffs.RAMPAGE.active = true; buffs.RAMPAGE.until = now + def.durationMs;
      for (const b of balls){ b.rampageUntil = now + def.rampageMs; b.piercing = true; }
    }
    if (def.globalSpeedMul){
      buffs.FAST.active = true; buffs.FAST.until = now + def.durationMs;
      if (def.screenShakeOnApply) screenShake = def.screenShakeOnApply;
    }
    if (def.wavy){
      buffs.WAVY.active = true; buffs.WAVY.until = now + def.durationMs; buffs.WAVY.start = now;
    }

    updateBuffBadges();
  }

  function drawPower(p){
    const color = p.isDebuff ? getVar('--debuff') : getVar('--power');
    const x = p.x*scaleX, y = p.y*scaleY, w = p.w*scaleX, h = p.h*scaleY;
    const wobble = Math.sin(p.phase)*1.5; p.phase += 0.04;
    ctx.save(); ctx.translate(0, wobble);
    const grd = ctx.createLinearGradient(x, y, x, y+h); grd.addColorStop(0, color); grd.addColorStop(1, p.isDebuff ? '#a33' : '#3a56a8');
    ctx.fillStyle = grd; roundedRect(x, y, w, h, 8); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,.25)'; ctx.stroke();
    ctx.fillStyle = '#fff'; ctx.font = `${Math.max(10, Math.round(12*scaleY))}px ui-monospace, monospace`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.type[0], x+w/2, y+h/2+0.5);
    ctx.restore();
  }

  function updateHUD(){ scoreEl.textContent = score; levelEl.textContent = level; livesEl.textContent = lives; }

  function showCenter(title, text){ noteTitle.textContent = title; noteText.innerHTML = text; centerNote.style.display = 'flex'; }
  function hideCenter(){ centerNote.style.display = 'none'; }

  function resetGame(load=false){
    diff = getDiff();
    level = load ? level : 1; score = load ? score : 0; lives = load ? lives : 3;
    updateHUD();
    initBricks(); resetBalls();
    paused = true; running = false;
    for (const k of Object.keys(buffs)){ if (k!=='LONG'){ buffs[k].active=false; buffs[k].until=0; } }
    buffs.LONG.stacks = []; powerups.length = 0; particles.length = 0; updateBuffBadges();
    computePaddleWidth(); paddle.x = 1100/2 - paddle.w/2;
    showCenter('按 Space 或點畫面開始', '用 ←/→ 或 A/D 移動；滑鼠左右移動也可。');
  }

  // Save / Load
  function saveProgress(){ try{ const data = { level, score, lives, difficulty: difficultySel.value }; localStorage.setItem('breakout_save_v_final_cfg', JSON.stringify(data)); alert('已存檔！'); }catch(e){ alert('存檔失敗：' + e); } }
  function loadProgress(){
    try{
      const raw = localStorage.getItem('breakout_save_v_final_cfg') || localStorage.getItem('breakout_save_v_final') || localStorage.getItem('breakout_save_v4');
      if (!raw){ alert('沒有存檔'); return; }
      const data = JSON.parse(raw);
      difficultySel.value = data.difficulty || 'normal';
      level = data.level||1; score = data.score||0; lives = data.lives||3;
      resetGame(true); updateHUD(); alert(`已讀檔：等級 ${level}，分數 ${score}，生命 ${lives}`);
    }catch(e){ alert('讀檔失敗：' + e); }
  }
  function clearSave(){ localStorage.removeItem('breakout_save_v_final_cfg'); alert('已清除存檔'); }

  // Input
  let keyL=false, keyR=false;
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keyL = true;
    if (e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') keyR = true;
    if (e.code === 'Space'){ togglePause(); }
    if (e.key === 'r' || e.key === 'R'){ resetGame(); }
    if (e.key === 'f' || e.key === 'F'){ toggleFullscreen(); }
    if (e.key === ' ' && buffs.STICKY.active){ for (const b of balls){ if (b.stuck){ b.stuck=false; b.vy = -Math.abs(b.vy||6); } } }
  });
  window.addEventListener('keyup', (e)=>{
    if (e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keyL = false;
    if (e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') keyR = false;
  });
  canvas.addEventListener('mousemove', (e)=>{ const rect = canvas.getBoundingClientRect(); const x = (e.clientX - rect.left) * (1100 / rect.width); paddle.x = Math.max(0, Math.min(1100 - paddle.w, x - paddle.w/2)); });
  canvas.addEventListener('click', ()=>{ if (!running || paused) { running = true; paused = false; hideCenter(); if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } });
  pauseBtn.addEventListener('click', ()=>togglePause());
  resetBtn.addEventListener('click', ()=>resetGame());
  fsBtn.addEventListener('click', ()=>toggleFullscreen());
  soundBtn.addEventListener('click', ()=>{ soundsOn = !soundsOn; soundBtn.textContent = `音效：${soundsOn ? '開' : '關'}`; if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); beep(880,0.06,0.05); });
  difficultySel.addEventListener('change', ()=>{ resetGame(); });
  saveBtn.addEventListener('click', saveProgress);
  loadBtn.addEventListener('click', loadProgress);
  clearSaveBtn.addEventListener('click', clearSave);

  function togglePause(){ if (!running){ running = true; paused = false; hideCenter(); return; } paused = !paused; if (paused) showCenter('已暫停', '按 Space 或點畫面繼續'); else hideCenter(); }
  async function toggleFullscreen(){ const elem = document.documentElement; try{ if (!document.fullscreenElement){ await elem.requestFullscreen(); } else { await document.exitFullscreen(); } }catch(e){ console.warn('Fullscreen failed:', e); } }

  // Compute paddle width by config
  function computePaddleWidth(){
    const now = performance.now();
    buffs.LONG.stacks = buffs.LONG.stacks.filter(t=>t>now);
    const longStacks = Math.min(GAME_CONFIG.powers.LONG.stacksMax, buffs.LONG.stacks.length);
    const addLong = longStacks * (GAME_CONFIG.powers.LONG.longPerStackAdd || 0);
    const addWide = (buffs.WIDE.active ? (GAME_CONFIG.powers.WIDE.paddleWidthAdd || 0) : 0);
    const base = getDiff().paddleBaseW;
    const newW = Math.min(GAME_CONFIG.caps.paddleMaxW, base + addWide + addLong);
    const center = paddle.x + paddle.w/2;
    paddle.w = newW;
    paddle.x = Math.max(0, Math.min(1100 - paddle.w, center - paddle.w/2));
  }

  // Global speed multiplier by config
  function speedMultiplier(now){
    let mul = 1.0;
    if (buffs.SLOW.active){
      mul *= (GAME_CONFIG.powers.SLOW.speedMul ?? 1.0);
    }
    if (buffs.FAST.active){
      mul *= (GAME_CONFIG.powers.FAST.globalSpeedMul ?? 1.0);
    }
    if (buffs.WAVY.active){
      const w = GAME_CONFIG.powers.WAVY.wavy || { amp:0.6, base:1.2, periodMs:200 };
      const phase = (now - (buffs.WAVY.start||now)) / (w.periodMs);
      mul *= (w.base + w.amp*Math.sin(phase));
    }
    return mul;
  }

  // Screen shake
  let screenShake = 0;

  function drawBGDecor(){
    const w = canvas.width, h = canvas.height;
    bgTime += 0.003;
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.translate(Math.sin(bgTime)*8, Math.cos(bgTime*0.7)*6);
    const step = 40;
    for (let x=0;x<w;x+=step){
      ctx.fillStyle = 'rgba(255,255,255,.03)';
      ctx.fillRect(x, 0, 1, h);
    }
    for (let y=0;y<h;y+=step){
      ctx.fillStyle = 'rgba(255,255,255,.025)';
      ctx.fillRect(0, y, w, 1);
    }
    ctx.restore();
    const grad = ctx.createRadialGradient(w/2,h*0.2,0,w/2,h*0.5,Math.max(w,h));
    grad.addColorStop(0,'rgba(0,0,0,0)');
    grad.addColorStop(1,'rgba(0,0,0,0.35)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);
    if (buffs.SLOW.active){
      ctx.fillStyle = 'rgba(80,140,255,0.08)';
      ctx.fillRect(0,0,w,h);
    }
  }

  // === 背景揭示：只在「磚塊區域」繪製圖片切片 ===
  function drawRevealTiles(){
    const img = BG_IMGS[(level-1) % BG_IMGS.length];
    if (!img || !img.complete) return;
    const L = layout();
    const area = {
      x: L.pad,
      y: L.top,
      w: 1100 - L.pad*2,
      h: L.rows * (brickH + L.pad) - L.pad
    };
    const rImg = img.naturalWidth / img.naturalHeight;
    const rArea = area.w / area.h;
    let dw, dh;
    if (rImg > rArea){ dh = area.h; dw = dh * rImg; } else { dw = area.w; dh = dw / rImg; }
    const dx = area.x + (area.w - dw)/2;
    const dy = area.y + (area.h - dh)/2;

    for (const r of revealRects){
      const rx1 = r.x, ry1 = r.y, rw = r.w, rh = r.h;
      const sx = (rx1 - dx) / dw * img.naturalWidth;
      const sy = (ry1 - dy) / dh * img.naturalHeight;
      const sw = rw / dw * img.naturalWidth;
      const sh = rh / dh * img.naturalHeight;
      const x = rx1 * scaleX, y = ry1 * scaleY, w = rw * scaleX, h = rh * scaleY;
      try{ ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h); }catch(e){}
    }
  }

  function draw(){
    if (screenShake > 0){ const s = screenShake * 0.6; ctx.save(); ctx.translate((Math.random()-0.5)*s, (Math.random()-0.5)*s); screenShake *= 0.9; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBGDecor();

    // 已揭示的圖片片段
    drawRevealTiles();

    // 磚塊
    for (const b of bricks){
      const base = b.explosive ? getVar('--expl') : brickColor(b.colorIdx);
      const g = ctx.createLinearGradient((b.x)*scaleX, (b.y)*scaleY, (b.x)*scaleX, (b.y+b.h)*scaleY);
      g.addColorStop(0, base); g.addColorStop(1, '#1a1f3a');
      ctx.fillStyle = g; drawRoundedRect(b.x, b.y, b.w, b.h, 6); ctx.fill();
      if (b.hp > 1){
        ctx.fillStyle = 'rgba(0,0,0,.25)';
        ctx.fillRect((b.x+4)*scaleX, (b.y+b.h-6)*scaleY, (b.w-8)*scaleX, 4*scaleY);
        ctx.fillStyle = 'rgba(255,255,255,.75)';
        const ratio = Math.max(0,(b.hp-1))/3;
        ctx.fillRect((b.x+4)*scaleX, (b.y+b.h-6)*scaleY, (b.w-8)*ratio*scaleX, 4*scaleY);
      }
    }

    // 擋板
    const padGlow = buffs.STICKY.active ? 'rgba(120,230,220,.6)' : ( (buffs.WIDE.active || buffs.LONG.stacks.length) ? 'rgba(120,170,255,.6)' : 'rgba(200,210,255,.4)');
    ctx.shadowColor = padGlow; ctx.shadowBlur = 20;
    ctx.fillStyle = '#9aaeff'; drawRoundedRect(paddle.x, paddle.y, paddle.w, paddle.h, 8); ctx.fill(); ctx.shadowBlur = 0;
    if (buffs.SHIELD.active){ const g = ctx.createLinearGradient(0,(700-10)*scaleY,0,700*scaleY); g.addColorStop(0,'rgba(120,220,255,0.35)'); g.addColorStop(1,'rgba(120,220,255,0.05)'); ctx.fillStyle = g; ctx.fillRect(0, (700-10)*scaleY, canvas.width, 10*scaleY); }

    // 球 + 拖尾
    const nowT = performance.now();
    for (const b of balls){
      b.trail.push({x:b.x, y:b.y, t:nowT}); while (b.trail.length > 12) b.trail.shift();
      for (let i=b.trail.length-1;i>=0;i--){
        const p = b.trail[i]; const age = (nowT - p.t)/200; if (age>1) continue;
        const alpha = (1-age) * 0.6;
        const color = ( (b.rampageUntil && nowT < b.rampageUntil) || b.piercing ) ? `rgba(120,220,255,${alpha})` : (buffs.FAST.active ? `rgba(255,140,90,${alpha})` : `rgba(255,255,255,${alpha*0.6})`);
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(p.x*scaleX, p.y*scaleY, (b.r*0.7)*((scaleX+scaleY)/2), 0, Math.PI*2); ctx.fill();
      }
      const bx = b.x * scaleX, by = b.y * scaleY, br = b.r * (scaleX+scaleY)/2;
      const grad = ctx.createRadialGradient(bx-3, by-4, 2, bx, by, br);
      const tail = (b.rampageUntil && nowT < b.rampageUntil);
      grad.addColorStop(0, '#fff'); grad.addColorStop(1, (b.piercing||tail) ? '#9ff' : (buffs.FAST.active ? '#ff9a66' : '#cbd4ff'));
      ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI*2); ctx.fill();
      if (buffs.WAVY.active){ ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1; const r1 = br + 2 + 2*Math.sin((nowT/100)+b.x*0.02); ctx.beginPath(); ctx.arc(bx, by, r1, 0, Math.PI*2); ctx.stroke(); }
      if (b.stuck){ ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.fillRect((paddle.x + paddle.w/2 - 12)*scaleX, (paddle.y-6)*scaleY, 24*scaleX, 4*scaleY); }
    }

    // 道具
    for (const p of powerups) drawPower(p);

    // 粒子
    for (let i=particles.length-1;i>=0;i--){
      const P = particles[i];
      P.x += P.vx; P.y += P.vy; P.vx *= 0.98; P.vy *= 0.98; P.life -= 16;
      if (P.life<=0){ particles.splice(i,1); continue; }
      const a = Math.max(0, Math.min(1, P.life/500));
      ctx.fillStyle = `rgba(255,220,180,${a*0.6})`;
      ctx.beginPath(); ctx.arc(P.x*scaleX, P.y*scaleY, P.size*((scaleX+scaleY)/2), 0, Math.PI*2); ctx.fill();
    }

    if (screenShake > 0){ ctx.restore(); }
  }

  function resetBalls(center=true) {
    balls = [makeBall(false)];
    const base = getDiff().baseSpeed;
    const speed = base + Math.min(level*0.5, 4);
    const angle = (-60 - Math.random()*60) * Math.PI/180;
    balls[0].x = center ? 1100/2 : paddle.x + paddle.w/2;
    balls[0].y = 700 - 70;
    balls[0].vx = Math.cos(angle)*speed;
    balls[0].vy = Math.sin(angle)*speed;
    balls[0].piercing = buffs.PIERCE.active;
  }

  function update(){
    const now = performance.now();
    // Buff timers
    for (const key of Object.keys(GAME_CONFIG.powers)){
      if (key === 'LONG') continue;
      const b = buffs[key];
      if (b?.active && b.until && now > b.until){
        b.active = false;
        if (key === 'PIERCE'){ for (const ball of balls) ball.piercing = false; }
      }
    }
    computePaddleWidth(); updateBuffBadges();

    if (keyL) paddle.x -= paddle.speed;
    if (keyR) paddle.x += paddle.speed;
    paddle.x = Math.max(0, Math.min(1100 - paddle.w, paddle.x));

    // Move balls
    const mulGlobal = speedMultiplier(now);
    for (const b of balls){
      if (b.rampageUntil && now > b.rampageUntil){ b.rampageUntil = 0; if (!buffs.PIERCE.active) b.piercing = false; }
      if (b.stuck){ b.x = paddle.x + paddle.w/2 + b.offsetX; b.y = paddle.y - b.r - 0.1; continue; }
      b.x += b.vx * mulGlobal; b.y += b.vy * mulGlobal;

      // Walls
      if (b.x - b.r < 0){ b.x = b.r; b.vx *= -1; beep(780,0.03); spawnParticles(b.x,b.y,'#99bbff',5,1.2,1.2,2); }
      if (b.x + b.r > 1100){ b.x = 1100 - b.r; b.vx *= -1; beep(780,0.03); spawnParticles(b.x,b.y,'#99bbff',5,1.2,1.2,2); }
      if (b.y - b.r < 0){ b.y = b.r; b.vy *= -1; beep(700,0.03); spawnParticles(b.x,b.y,'#99bbff',5,1.2,1.2,2); }

      // Bottom
      if (b.y - b.r > 700){
        if (buffs.SHIELD.active){
          buffs.SHIELD.active = false; b.y = 700 - b.r - 1; b.vy = -Math.abs(b.vy);
        }else{
          const idx = balls.indexOf(b); if (idx>=0) balls.splice(idx,1);
          break;
        }
      }

      // Paddle collision
      if (b.y + b.r >= paddle.y && b.y + b.r <= paddle.y + paddle.h &&
          b.x >= paddle.x && b.x <= paddle.x + paddle.w && b.vy > 0){
        const hitPos = (b.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
        const speed = Math.min(Math.hypot(b.vx, b.vy) * 1.02, b.speedCap);
        const angle = hitPos * (Math.PI/3);
        b.vx = Math.sin(angle) * speed; b.vy = -Math.cos(angle) * speed;
        b.y = paddle.y - b.r - 0.1;
        beep(880,0.03); spawnParticles(b.x, b.y, '#caddff', 8, 1.3, 1.5, 2.5);
        if (buffs.STICKY.active){ b.stuck = true; b.offsetX = b.x - (paddle.x + paddle.w/2); }
      }

      // Brick collisions
      let hit = -1;
      for (let i=0;i<bricks.length;i++){
        const bk = bricks[i];
        if (b.x + b.r > bk.x && b.x - b.r < bk.x + bk.w && b.y + b.r > bk.y && b.y - b.r < bk.y + bk.h){ hit = i; break; }
      }
      if (hit >= 0){
        const bk = bricks[hit];
        const inRampage = b.rampageUntil && now < b.rampageUntil;
        if (!inRampage && !b.piercing){
          const overlapL = (b.x + b.r) - bk.x;
          const overlapR = (bk.x + bk.w) - (b.x - b.r);
          const overlapT = (b.y + b.r) - bk.y;
          const overlapB = (bk.y + bk.h) - (b.y - b.r);
          const minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);
          if (minOverlap === overlapL) { b.x = bk.x - b.r; b.vx = -Math.abs(b.vx); }
          else if (minOverlap === overlapR) { b.x = bk.x + bk.w + b.r; b.vx = Math.abs(b.vx); }
          else if (minOverlap === overlapT) { b.y = bk.y - b.r; b.vy = -Math.abs(b.vy); }
          else { b.y = bk.y + bk.h + b.r; b.vy = Math.abs(b.vy); }
        } else if (inRampage){
          const overlapL = (b.x + b.r) - bk.x;
          const overlapR = (bk.x + bk.w) - (b.x - b.r);
          const overlapT = (b.y + b.r) - bk.y;
          const overlapB = (bk.y + bk.h) - (b.y - b.r);
          const minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);
          if (minOverlap === overlapL) { b.x = bk.x - b.r; b.vx = Math.abs(b.vx)||4; }
          else if (minOverlap === overlapR) { b.x = bk.x + bk.w + b.r; b.vx = -Math.abs(b.vx)||-4; }
          else if (minOverlap === overlapT) { b.y = bk.y - b.r; b.vy = Math.abs(b.vy)||4; }
          else { b.y = bk.y + bk.h + b.r; b.vy = -Math.abs(b.vy)||-4; }
          b.piercing = true;
        }
        bk.hp = (bk.hp||1) - 1; score += 10; updateHUD();
        if (bk.hp <= 0){
          const cx = bk.x + bk.w/2, cy = bk.y + bk.h/2;
          revealRects.push({x:bk.x, y:bk.y, w:bk.w, h:bk.h});
          if (Math.random() < getDiff().dropRate) spawnPower(cx-12, cy);
          if (bk.explosive) explodeAt(cx, cy);
          bricks.splice(hit,1);
        }
        beep(520 + Math.random()*200, 0.03, 0.05);
      }
    }

    // No balls left
    if (balls.length === 0){
      lives--; updateHUD();
      if (lives <= 0){
        running = false; paused = true; showCenter('遊戲結束', `分數：${score}<br>按 Space 或點畫面再來一局，或按 R 重開。`); return;
      } else { resetBalls(false); paused = true; showCenter('失去一條命', '按 Space 或點畫面繼續'); return; }
    }

    // Power-ups falling
    for (let i=powerups.length-1; i>=0; i--){
      const p = powerups[i];
      p.y += p.vy;
      if (p.y + p.h >= paddle.y && p.x + p.w >= paddle.x && p.x <= paddle.x + paddle.w && p.y <= paddle.y + paddle.h){
        applyPower(p.type);
        powerups.splice(i,1);
        continue;
      }
      if (p.y > 710) powerups.splice(i,1);
    }

    // Level clear -> gallery
    if (bricks.length === 0){
      paused = true; running = false;
      galleryImg.src = BG_SRCS[(level-1) % BG_SRCS.length];
      gallery.style.display = 'flex';
      requestAnimationFrame(() => gallery.classList.add('show'));
      const proceed = () => {
        gallery.classList.remove('show');
        setTimeout(()=>{ gallery.style.display = 'none'; gallery.removeEventListener('click', proceed); }, 200);
        level++; updateHUD(); initBricks(); resetBalls(); paused = true; running = false;
        showCenter(`進入關卡 ${level}`, '按 Space 或點畫面開始');
      };
      gallery.addEventListener('click', proceed, { once:true });
      return;
    }
  }

  function loop(){ if (!paused && running) update(); draw(); requestAnimationFrame(loop); }

  function boot(){
    resetGame(); updateHUD(); loop();
    const raw = localStorage.getItem('breakout_save_v_final_cfg') || localStorage.getItem('breakout_save_v_final') || localStorage.getItem('breakout_save_v4');
    if (raw){ setTimeout(()=>{ if (confirm('偵測到存檔，要讀取進度嗎？')) loadProgress(); }, 400); }
  }
  boot();
})();
</script>
</body>
</html>
