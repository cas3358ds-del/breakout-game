<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rock打磚塊 Breakout（擴充改良版）</title>
  <style>
    :root {
      --bg:#0b1022; --bg2:#0a0f1e; --fg:#e9ecf1; --accent:#66b2ff;
      --brick1:#ff6b6b; --brick2:#ffd166; --brick3:#06d6a0; --brick4:#4cc9f0;
      --expl:#ff8c00; --power:#7aa2ff; --debuff:#ff6aa3;
      --glass: rgba(255,255,255,.06); --glass-stroke: rgba(255,255,255,.12);
      --btn:#1a2448; --btn-stroke:#2a3974; --pill:#121a36;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 800px at 50% -10%, #152040, #0a0f1e 60%); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;}
    body{min-height:100svh; display:flex; align-items:flex-start; justify-content:center;}
    .wrap{display:flex; gap:12px; align-items:center; justify-content:center; flex-direction:column; padding:12px; width:100%; max-width:1200px}
    h1{margin:4px 0 2px 0; font-weight:800; letter-spacing:.3px; text-shadow:0 2px 20px #0008;
       font-size:clamp(16px,3.2vw,28px)}
    .hud{
      position:sticky; top:0; z-index:3;
      display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; font-weight:650;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--glass-stroke); border-radius:14px; padding:8px 10px;
      box-shadow: 0 6px 24px rgba(0,0,0,.25); backdrop-filter: blur(6px);
    }
    .pill{padding:6px 10px; background:var(--pill); border:1px solid var(--glass-stroke); border-radius:999px; font-size:14px}
    .btn{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg);
      border:1px solid var(--btn-stroke); border-radius:10px; padding:6px 10px; cursor:pointer; user-select:none; font-size:14px}
    .btn:active{transform:translateY(1px)}
    select{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg); border:1px solid var(--btn-stroke); border-radius:8px; padding:6px 10px}
    canvas{background:linear-gradient(180deg, #0d1126, #0b1022 55%, #091022);
      border:1px solid #1a2348; border-radius:14px; max-width:min(1120px, 98vw); width: min(1120px, 98vw); height: auto; display:block;
      box-shadow: 0 30px 80px rgba(0,0,0,.35), inset 0 0 120px rgba(255,255,255,.02); touch-action:none;}
    .overlay{position:relative}
    .center-note{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:2}
    .note-box{background:linear-gradient(180deg, rgba(8,12,28,.9), rgba(8,12,28,.85));
      border:1px solid var(--glass-stroke); padding:16px 18px; border-radius:14px; text-align:center; max-width:min(90vw,820px);
      box-shadow: 0 12px 60px rgba(0,0,0,.5); font-size:14px}
    .note-box h2{margin:0 0 8px 0; font-size:18px}
    .note-box p{margin:6px 0; line-height:1.6}
    kbd{background:#0e1836; border:1px solid #2a356a; border-radius:6px; padding:2px 6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:90%}
    .badges{display:flex; gap:6px; flex-wrap:wrap; align-items:center; justify-content:center}
    .badge{background:linear-gradient(180deg, rgba(18,32,68,.9), rgba(10,20,48,.9));
      border:1px solid var(--glass-stroke); padding:4px 8px; border-radius:999px; font-size:12px; display:flex; gap:6px; align-items:center}
    .legend{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; font-size:12px}
    .legend .box{width:14px; height:14px; display:inline-block; border-radius:3px; margin-right:4px; vertical-align:middle}
    .legend .item{padding:4px 8px; border-radius:10px; background:rgba(255,255,255,.05); border:1px solid var(--glass-stroke)}

    /* 清關畫廊 overlay */ 
    .gallery{position:absolute; inset:0; display:none; align-items:center; justify-content:center; flex-direction:column; z-index:4;}
    .gallery .backdrop{position:absolute; inset:0; background:rgba(0,0,0,.75); opacity:0; transition:opacity .6s;}
    .gallery img{max-width:min(94vw,1040px); max-height:min(88vh,680px); border-radius:16px; box-shadow:0 30px 120px rgba(0,0,0,.6); opacity:0; transform:translateY(12px) scale(.98); transition:opacity .6s, transform .6s;}
    .gallery .hint{position:absolute; bottom:24px; color:#fff; font-size:16px; opacity:0; text-shadow:0 2px 10px rgba(0,0,0,.6);}
    .gallery.show .backdrop{opacity:1;}
    .gallery.show img{opacity:1; transform:translateY(0) scale(1);} 
    .gallery.show .hint{opacity:.9;}

    @media (max-width: 768px){
      .wrap{padding:8px}
      .pill,.btn{font-size:12px; padding:5px 8px}
      .legend{display:none}
      .hud{gap:6px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Rock打磚塊 Breakout（擴充改良版）</h1>
    <div class="hud">
      <div class="pill">分數 <span id="score">0</span></div>
      <div class="pill">關卡 <span id="level">1</span></div>
      <div class="pill">生命 <span id="lives">3</span></div>
      <label>難度
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </label>
      <button class="btn" id="pauseBtn">開始 / 暫停 (<kbd>Space</kbd>)</button>
      <button class="btn" id="resetBtn">重開 (<kbd>R</kbd>)</button>
      <button class="btn" id="fsBtn">全螢幕 (<kbd>F</kbd>)</button>
      <button class="btn" id="soundBtn">音效：關</button>
      <button class="btn" id="saveBtn">存檔</button>
      <button class="btn" id="loadBtn">讀檔</button>
      <button class="btn" id="clearSaveBtn">清除存檔</button>
    </div>

    <div class="legend">
      <span class="item"><span class="box" style="background:var(--expl)"></span>爆炸磚</span>
      <span class="item"><span class="box" style="background:var(--brick2)"></span>一般磚</span>
      <span class="item"><span class="box" style="background:var(--power)"></span>增益道具</span>
      <span class="item"><span class="box" style="background:var(--debuff)"></span>減益道具</span>
    </div>
    <div class="badges" id="activeBuffs"></div>

    <div class="overlay">
      <div class="gallery" id="gallery">
        <div class="backdrop"></div>
        <img id="galleryImg" src="" alt="關卡大圖" />
        <div class="hint">點一下進入下一關 ▶</div>
      </div>

      <canvas id="game" width="1100" height="700"></canvas>
      <div class="center-note" id="centerNote">
        <div class="note-box">
          <h2 id="noteTitle">按 <kbd>Space</kbd> 或點畫面開始</h2>
          <p id="noteText">
            操作：<kbd>←</kbd>/<kbd>→</kbd> 或 <kbd>A</kbd>/<kbd>D</kbd>；手指拖曳畫面也可移動平台。<br>
            已整合：背景逐步揭示 + 清關畫廊、增益/減益（含電漿球/凍結球/神聖球/鳳凰審判/9命怪貓）、爆炸磚、音效、難度、存讀檔。
          </p>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // === 設定（沿用你最新檔案為基礎，加入新增益與手機優化） ===
  const GAME_CONFIG = {
    difficulty: {
      easy:   { paddleBaseW: 220, baseSpeed: 4, rowsBase: 6, dropRate: 0.72 },
      normal: { paddleBaseW: 180, baseSpeed: 4, rowsBase: 7, dropRate: 0.52 },
      hard:   { paddleBaseW: 140, baseSpeed: 6, rowsBase: 8, dropRate: 0.32 },
    },
    bricks: { explosiveChance: 0.20, brickHeight: 30, padding: 9, topOffset: 60, cols: 12 },
    powers: {
      // 既有
      WIDE:{label:'平台變寬',type:'buff',durationMs:30000,paddleWidthAdd:50,badge:'↔️'},
      LONG:{label:'平台變長',type:'buff',durationMs:30000,longPerStackAdd:40,stacksMax:2,badge:'📏'},
      STICKY:{label:'黏性平台',type:'buff',durationMs:5000,sticky:true,badge:'🧲'},
      MULTI:{label:'多球',type:'buff',multiDuplicate:true,maxBalls:4,badge:'✨'},
      SLOW:{label:'全局慢速',type:'buff',durationMs:15000,speedMul:0.6,badge:'🐢'},
      PIERCE:{label:'穿透球',type:'buff',durationMs:12000,piercing:true,badge:'🎯'},
      SHIELD:{label:'護盾',type:'buff',oneShotShield:true,badge:'🛡'},
      RAMPAGE:{label:'暴走球',type:'buff',durationMs:5000,forcePiercing:true,rampageMs:5000,badge:'🔥'},
      FAST:{label:'快速球',type:'debuff',durationMs:5000,globalSpeedMul:2.0,screenShakeOnApply:6,badge:'⚡'},
      WAVY:{label:'變速球',type:'debuff',durationMs:5000,wavy:{amp:0.6,base:1.2,periodMs:200},badge:'〰️'},
      // 新增
      PLASMA:{label:'電漿球',type:'buff',durationMs:10000,plasma:{drift:1.2,radius:38,lifeMs:3000},badge:'⚡️'},
      FREEZE:{label:'凍結球',type:'buff',durationMs:10000,freeze:{delayMs:300,stopMs:2000},badge:'❄️'},
      HOLY:{label:'神聖球',type:'buff',durationMs:5000,holy:{},badge:'✝️'},
      PHOENIX:{label:'鳳凰審判',type:'rare',rareFactor:0.1,instant:true,badge:'🪽'},
      NINE:{label:'9命怪貓',type:'rare',rareFactor:0.1,instant:true,badge:'🐱'}
    },
    powerCapsule:{width:24,height:16,fallVy:2.2},
    caps:{paddleMaxW:300,ballSpeedMax:16}
  };

  // 背景圖（固定順序）
  const BG_SRCS=['images/bg1.png','images/bg2.png','images/bg3.png','images/bg4.png','images/bg5.png','images/bg6.png','images/bg7.png','images/bg8.png','images/bg9.png','images/bg10.png'];
  const BG_IMGS=BG_SRCS.map(src=>{const i=new Image(); i.src=src; i.decoding='async'; i.loading='eager'; return i;});

  // 參考 DOM
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const scoreEl=document.getElementById('score'), levelEl=document.getElementById('level'), livesEl=document.getElementById('lives');
  const pauseBtn=document.getElementById('pauseBtn'), resetBtn=document.getElementById('resetBtn'), fsBtn=document.getElementById('fsBtn');
  const soundBtn=document.getElementById('soundBtn'), saveBtn=document.getElementById('saveBtn'), loadBtn=document.getElementById('loadBtn'), clearSaveBtn=document.getElementById('clearSaveBtn');
  const centerNote=document.getElementById('centerNote'), noteTitle=document.getElementById('noteTitle'), noteText=document.getElementById('noteText');
  const difficultySel=document.getElementById('difficulty'), activeBuffsEl=document.getElementById('activeBuffs');
  const gallery=document.getElementById('gallery'), galleryImg=document.getElementById('galleryImg');

  // DPR 縮放
  function resizeCanvasDPR(){ const dpr=Math.min(window.devicePixelRatio||1,2); const cssW=canvas.clientWidth; const cssH=Math.round(cssW*(700/1100)); canvas.style.height=cssH+'px'; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); scaleX=canvas.width/1100; scaleY=canvas.height/700; }
  let scaleX=1, scaleY=1; window.addEventListener('resize', resizeCanvasDPR, {passive:true}); resizeCanvasDPR();

  // 狀態
  let running=false, paused=true, level=1, score=0, lives=3, soundsOn=false;
  let bgTime=0; let screenShake=0;

  // 粒子 / 特效容器
  const particles=[]; // {x,y,vx,vy,life,size}
  const plasmas=[];   // {x,y,vx,vy,until,radius}
  const holyFlashes=[]; // {x,y,until}
  let phoenixAnim=null; // {x, tEnd}
  const fireBursts=[];  // 火焰片段 {x,y,life}

  function spawnParticles(x,y,color,count=10,spread=1.6,speed=3,size=3){
    for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const v=speed*(.4+Math.random()); particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:400+Math.random()*300,size:size*(.6+Math.random()*0.8),color}); }
  }

  // 工具
  function getDiff(){ return GAME_CONFIG.difficulty[difficultySel.value]; }
  function brickColor(i){ return [getVar('--brick1'),getVar('--brick2'),getVar('--brick3'),getVar('--brick4')][i%4]; }
  function getVar(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo((x+r)*scaleX,y*scaleY); ctx.arcTo((x+w)*scaleX,y*scaleY,(x+w)*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo((x+w)*scaleX,(y+h)*scaleY,x*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo(x*scaleX,(y+h)*scaleY,x*scaleX,y*scaleY,r*scaleX); ctx.arcTo(x*scaleX,y*scaleY,(x+w)*scaleX,y*scaleY,r*scaleX); ctx.closePath(); }

  // Buff/De-buff 顯示
  function badgeIcon(k){ return (GAME_CONFIG.powers[k]?.badge)||'●'; }
  function updateBuffBadges(){ activeBuffsEl.innerHTML=''; const now=performance.now();
    // LONG 堆疊
    const longAct=buffs.LONG.stacks.filter(t=>t>now); if(longAct.length){ const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon('LONG')} LONG×${longAct.length} ${Math.max(0,Math.max(...longAct)-now).toFixed(0)}ms`; activeBuffsEl.appendChild(s); }
    // 其它
    for(const key of Object.keys(GAME_CONFIG.powers)){ if(key==='LONG') continue; const b=buffs[key]; if(!b?.active) continue; const left=b.until&&b.until>now?((b.until-now)/1000).toFixed(1)+'s':''; const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon(key)} ${key}${left?' '+left:''}`; activeBuffsEl.appendChild(s); }
  }

  // Buff 狀態
  const buffs={WIDE:{active:false,until:0},STICKY:{active:false,until:0},MULTI:{active:false,until:0},SLOW:{active:false,until:0},PIERCE:{active:false,until:0},SHIELD:{active:false,until:0},RAMPAGE:{active:false,until:0},FAST:{active:false,until:0},WAVY:{active:false,until:0,start:0},LONG:{active:false,until:0,stacks:[]},PLASMA:{active:false,until:0},FREEZE:{active:false,until:0},HOLY:{active:false,until:0}};

  // 擋板 & 球
  let diff=getDiff(); const paddle={w:diff.paddleBaseW,h:18,x:1100/2-diff.paddleBaseW/2,y:700-50,speed:12};
  let balls=[]; function makeBall(stuck=false,x=null){ return {x:x??(1100/2),y:700/2,r:10,vx:5,vy:-5,speedCap:GAME_CONFIG.caps.ballSpeedMax,piercing:false,stuck:stuck,offsetX:0,rampageUntil:0,trail:[],freeze:{until:0,oldVX:0,oldVY:0,pending:false}}; }

  // 聲音
  const audioCtx=(window.AudioContext||window.webkitAudioContext)?new (window.AudioContext||window.webkitAudioContext)():null;
  function beep(freq=600,dur=0.05,vol=0.06){ if(!soundsOn||!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.stop(); }, Math.max(10, dur*1000)); }

  // 磚塊與揭示
  let bricks=[]; let brickW=0, brickH=GAME_CONFIG.bricks.brickHeight; let revealRects=[];
  function layout(){ return {rows:getDiff().rowsBase+Math.floor((level-1)%3), cols:GAME_CONFIG.bricks.cols, pad:GAME_CONFIG.bricks.padding, top:GAME_CONFIG.bricks.topOffset, h:GAME_CONFIG.bricks.brickHeight}; }
  function initBricks(){ const L=layout(); const totalPad=(L.cols+1)*L.pad; brickW=Math.floor((1100-totalPad)/L.cols); brickH=L.h; bricks=[]; revealRects=[];
    for(let r=0;r<L.rows;r++){ for(let c=0;c<L.cols;c++){ const x=L.pad+c*(brickW+L.pad); const y=L.top+r*(brickH+L.pad); const hp=1+Math.floor((level-1)/3); const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance; bricks.push({x,y,w:brickW,h:brickH,hp:explosive?1:hp,colorIdx:(r%4), explosive}); } } }
  function explodeAt(cx,cy){ const radius=Math.max(brickW,brickH)*1.3; for(let i=bricks.length-1;i>=0;i--){ const b=bricks[i]; const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy); if(d<=radius){ revealRects.push({x:b.x,y:b.y,w:b.w,h:b.h}); bricks.splice(i,1); score+=10; spawnParticles(bx,by,'#ffdd99',14,1.7,2.6,3);} } spawnParticles(cx,cy,'#ffbb55',24,2.1,3.2,4); updateHUD(); beep(200,0.08,0.08); }

  // 掉落道具
  const powerups=[]; const ALL_TYPES=Object.keys(GAME_CONFIG.powers); const NORMAL_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='rare'); const RARE_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type==='rare');
  function spawnPower(x,y){ const rareChance=(GAME_CONFIG.powers.PHOENIX?.rareFactor)||0.1; const pickRare=RARE_TYPES.length && Math.random()<rareChance; const pool=pickRare?RARE_TYPES:NORMAL_TYPES; const type=pool[Math.floor(Math.random()*pool.length)]; const def=GAME_CONFIG.powers[type];
    powerups.push({x,y,w:GAME_CONFIG.powerCapsule.width,h:GAME_CONFIG.powerCapsule.height,vy:GAME_CONFIG.powerCapsule.fallVy,type,isDebuff:(def.type==='debuff'),phase:Math.random()*Math.PI*2}); }

  function applyPower(type){
    const def=GAME_CONFIG.powers[type]; if(!def) return; const now=performance.now();
    if(def.instant && def.type==='rare'){
      if(type==='PHOENIX'){ // 鳳凰飛過 + 火焰 + 隨機一半消除
        phoenixAnim={x:canvas.width+220,tEnd:now+1200};
        const keep=[]; for(const b of bricks){ if(Math.random()<0.5){ revealRects.push({x:b.x,y:b.y,w:b.w,h:b.h}); score+=10; fireBursts.push({x:b.x+b.w/2,y:b.y+b.h/2,life:400+Math.random()*400}); } else keep.push(b); }
        bricks=keep; screenShake=6; beep(180,0.12,0.1);
      } else if(type==='NINE'){ lives=9; updateHUD(); spawnParticles(550,350,'#ffd',40,2.2,3.5,4); beep(880,0.1,0.06); }
      return;
    }
    // 定時類
    if(def.durationMs){ if(type!=='LONG'){ const b=buffs[type]||(buffs[type]={active:false,until:0}); b.active=true; b.until=now+def.durationMs; } }
    if(def.paddleWidthAdd){ buffs.WIDE.active=true; buffs.WIDE.until=now+def.durationMs; }
    if(def.longPerStackAdd){ const act=buffs.LONG.stacks.filter(t=>t>now); const max=def.stacksMax??2; if(act.length<max){ buffs.LONG.stacks.push(now+def.durationMs);} else { const earliest=Math.min(...act); const idx=buffs.LONG.stacks.indexOf(earliest); buffs.LONG.stacks[idx]=now+def.durationMs; } }
    if(def.sticky){ buffs.STICKY.active=true; buffs.STICKY.until=now+def.durationMs; }
    if(def.multiDuplicate){ if(balls.length<3){ const news=[]; for(const b of balls){ const b1={...b}; b1.trail=[]; b1.freeze={...b.freeze}; news.push(b1);} balls=balls.concat(news); const cap=def.maxBalls??4; if(balls.length>cap) balls.length=cap; } }
    if(def.speedMul){ buffs.SLOW.active=true; buffs.SLOW.until=now+def.durationMs; }
    if(def.piercing){ buffs.PIERCE.active=true; buffs.PIERCE.until=now+def.durationMs; for(const b of balls) b.piercing=true; }
    if(def.oneShotShield){ buffs.SHIELD.active=true; }
    if(def.forcePiercing && def.rampageMs){ buffs.RAMPAGE.active=true; buffs.RAMPAGE.until=now+def.durationMs; for(const b of balls){ b.rampageUntil=now+def.rampageMs; b.piercing=true; } }
    if(def.globalSpeedMul){ buffs.FAST.active=true; buffs.FAST.until=now+def.durationMs; if(def.screenShakeOnApply) screenShake=def.screenShakeOnApply; }
    if(def.wavy){ buffs.WAVY.active=true; buffs.WAVY.until=now+def.durationMs; buffs.WAVY.start=now; }
    if(type==='PLASMA'){ buffs.PLASMA.active=true; buffs.PLASMA.until=now+def.durationMs; }
    if(type==='FREEZE'){ buffs.FREEZE.active=true; buffs.FREEZE.until=now+def.durationMs; }
    if(type==='HOLY'){ buffs.HOLY.active=true; buffs.HOLY.until=now+def.durationMs; }
    updateBuffBadges();
  }

  function drawPower(p){ const color=p.isDebuff?getVar('--debuff'):getVar('--power'); const x=p.x*scaleX, y=p.y*scaleY, w=p.w*scaleX, h=p.h*scaleY; const wobble=Math.sin(p.phase)*1.5; p.phase+=0.04;
    ctx.save(); ctx.translate(0,wobble); const grd=ctx.createLinearGradient(x,y,x,y+h); grd.addColorStop(0,color); grd.addColorStop(1,p.isDebuff?'#a33':'#3a56a8'); ctx.fillStyle=grd; roundedRect(x,y,w,h,8); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.stroke();
    ctx.fillStyle='#fff'; ctx.font=`${Math.max(10,Math.round(12*scaleY))}px ui-monospace, monospace`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.type[0], x+w/2, y+h/2+0.5); ctx.restore(); }

  function updateHUD(){ scoreEl.textContent=score; levelEl.textContent=level; livesEl.textContent=lives; }
  function showCenter(t,txt){ noteTitle.textContent=t; noteText.innerHTML=txt||''; centerNote.style.display='flex'; }
  function hideCenter(){ centerNote.style.display='none'; }

  function resetGame(load=false){ diff=getDiff(); level=load?level:1; score=load?score:0; lives=load?lives:3; updateHUD(); initBricks(); resetBalls(); paused=true; running=false;
    for(const k of Object.keys(buffs)){ if(k!=='LONG'){ buffs[k].active=false; buffs[k].until=0; } } buffs.LONG.stacks=[]; powerups.length=0; particles.length=0; plasmas.length=0; holyFlashes.length=0; phoenixAnim=null; fireBursts.length=0;
    updateBuffBadges(); computePaddleWidth(); paddle.x=1100/2-paddle.w/2; showCenter('按 Space 或點畫面開始','用 ←/→ 或 A/D 移動；手指拖曳畫面也可。'); }

  // 存讀檔（延續你的鍵值）
  function saveProgress(){ try{ const data={level,score,lives,difficulty:difficultySel.value}; localStorage.setItem('breakout_save_v_final_cfg', JSON.stringify(data)); alert('已存檔！'); }catch(e){ alert('存檔失敗：'+e); } }
  function loadProgress(){ try{ const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4'); if(!raw){ alert('沒有存檔'); return; } const data=JSON.parse(raw);
      difficultySel.value=data.difficulty||'normal'; level=data.level||1; score=data.score||0; lives=data.lives||3; resetGame(true); updateHUD(); alert(`已讀檔：等級 ${level}，分數 ${score}，生命 ${lives}`);}catch(e){ alert('讀檔失敗：'+e); } }
  function clearSave(){ localStorage.removeItem('breakout_save_v_final_cfg'); alert('已清除存檔'); }

  // 輸入（含觸控）
  let keyL=false, keyR=false; let touchActive=false;
  window.addEventListener('keydown',(e)=>{
  if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=true;
  if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=true;
  // Space: only pause/resume
  if(e.code==='Space'){ togglePause(); return; }
  // Release sticky ball: ArrowUp or Shift, only when running
  if((e.code==='ArrowUp' || e.key==='Shift') && !paused && running){
    let released=false;
    for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy = -Math.abs(b.vy||6); released=true; } }
    if(released) return;
  }
  if(e.key==='r'||e.key==='R'){ resetGame(); }
  if(e.key==='f'||e.key==='F'){ toggleFullscreen(); }
});
  window.addEventListener('keyup',(e)=>{ if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=false; if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=false; });
  canvas.addEventListener('mousemove',(e)=>{ const rect=canvas.getBoundingClientRect(); const x=(e.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); });
  canvas.addEventListener('click',()=>{
  // running 狀態下，如有黏著球則釋放
  if(running && !paused){
    let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
    if(released) return;
  }
  if(!running||paused){ running=true; paused=false; hideCenter(); if(audioCtx&&audioCtx.state==='suspended') audioCtx.resume(); }
});
  canvas.addEventListener('touchstart',(e)=>{ touchActive=true; 
  if(running && !paused){
    let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
    if(released) return; // 已釋放就不進入開始/暫停切換
  }
  if(!running||paused){ running=true; paused=false; hideCenter(); if(audioCtx&&audioCtx.state==='suspended') audioCtx.resume(); }
}, {passive:true});
  canvas.addEventListener('touchmove',(e)=>{ if(!touchActive) return; const t=e.touches[0]; const rect=canvas.getBoundingClientRect(); const x=(t.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); }, {passive:true});
  canvas.addEventListener('touchend',()=>{ touchActive=false; }, {passive:true});
  pauseBtn.addEventListener('click',()=>togglePause()); resetBtn.addEventListener('click',()=>resetGame()); fsBtn.addEventListener('click',()=>toggleFullscreen());
  soundBtn.addEventListener('click',()=>{ soundsOn=!soundsOn; soundBtn.textContent=`音效：${soundsOn?'開':'關'}`; if(audioCtx&&audioCtx.state==='suspended') audioCtx.resume(); beep(880,0.06,0.05); });
  difficultySel.addEventListener('change',()=>{ resetGame(); });
  saveBtn.addEventListener('click',saveProgress); loadBtn.addEventListener('click',loadProgress); clearSaveBtn.addEventListener('click',clearSave);
  function togglePause(){ if(!running){ running=true; paused=false; hideCenter(); return; } paused=!paused; if(paused) showCenter('已暫停','按 Space / 點畫面繼續'); else hideCenter(); }
  async function toggleFullscreen(){ const elem=document.documentElement; try{ if(!document.fullscreenElement){ await elem.requestFullscreen(); } else { await document.exitFullscreen(); } }catch(e){ console.warn('Fullscreen failed:', e); } }

  function computePaddleWidth(){ const now=performance.now(); buffs.LONG.stacks=buffs.LONG.stacks.filter(t=>t>now); const longStacks=Math.min(GAME_CONFIG.powers.LONG.stacksMax, buffs.LONG.stacks.length);
    const addLong=longStacks*(GAME_CONFIG.powers.LONG.longPerStackAdd||0); const addWide=(buffs.WIDE.active?(GAME_CONFIG.powers.WIDE.paddleWidthAdd||0):0); const base=getDiff().paddleBaseW;
    const newW=Math.min(GAME_CONFIG.caps.paddleMaxW, base+addWide+addLong); const center=paddle.x+paddle.w/2; paddle.w=newW; paddle.x=Math.max(0, Math.min(1100-paddle.w, center - paddle.w/2)); }

  function speedMultiplier(now){ let mul=1.0; if(buffs.SLOW.active){ mul*=(GAME_CONFIG.powers.SLOW.speedMul??1.0);} if(buffs.FAST.active){ mul*=(GAME_CONFIG.powers.FAST.globalSpeedMul??1.0);} if(buffs.WAVY.active){ const w=GAME_CONFIG.powers.WAVY.wavy||{amp:0.6,base:1.2,periodMs:200}; const phase=(now-(buffs.WAVY.start||now))/(w.periodMs); mul*=(w.base+w.amp*Math.sin(phase)); } return mul; }

  function drawBGDecor(){ const w=canvas.width,h=canvas.height; bgTime+=0.003; ctx.save(); ctx.globalAlpha=0.12; ctx.translate(Math.sin(bgTime)*8, Math.cos(bgTime*0.7)*6); const step=40;
    for(let x=0;x<w;x+=step){ ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(x,0,1,h);} for(let y=0;y<h;y+=step){ ctx.fillStyle='rgba(255,255,255,.025)'; ctx.fillRect(0,y,w,1);} ctx.restore();
    const grad=ctx.createRadialGradient(w/2,h*0.2,0,w/2,h*0.5,Math.max(w,h)); grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
    if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    // 鳳凰火焰殘留
    for(let i=fireBursts.length-1;i>=0;i--){ const f=fireBursts[i]; f.life-=16; if(f.life<=0){ fireBursts.splice(i,1); continue; } const a=Math.min(1, f.life/600); const rx= (f.x*scaleX), ry=(f.y*scaleY); const r=60*((scaleX+scaleY)/2); const g=ctx.createRadialGradient(rx,ry,1,rx,ry,r); g.addColorStop(0,`rgba(255,180,0,${0.6*a})`); g.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(rx,ry,r,0,Math.PI*2); ctx.fill(); }
  }

  // 只在磚塊區域揭示圖片切片
  function drawRevealTiles(){
  const img = BG_IMGS[(level-1)%BG_IMGS.length];
  if (!img || !img.complete || !img.naturalWidth) return;
  const L = layout();
  const area = { x: L.pad, y: L.top, w: 1100 - L.pad*2, h: L.rows*(brickH+L.pad) - L.pad };
  const rImg = img.naturalWidth / img.naturalHeight;
  const rArea = area.w / area.h;
  let dw, dh;
  if (rImg > rArea) { dh = area.h; dw = dh * rImg; } else { dw = area.w; dh = dw / rImg; }
  const dx = area.x + (area.w - dw)/2;
  const dy = area.y + (area.h - dh)/2;

  for (const r of revealRects){
    let sx = (r.x - dx) / dw * img.naturalWidth;
    let sy = (r.y - dy) / dh * img.naturalHeight;
    let sw =  r.w / dw * img.naturalWidth;
    let sh =  r.h / dh * img.naturalHeight;

    // clamp to natural image bounds
    const sx0 = Math.max(0, Math.min(img.naturalWidth,  sx));
    const sy0 = Math.max(0, Math.min(img.naturalHeight, sy));
    let   sw0 = Math.max(0, Math.min(img.naturalWidth  - sx0, sw));
    let   sh0 = Math.max(0, Math.min(img.naturalHeight - sy0, sh));

    const dxPix = r.x*scaleX, dyPix = r.y*scaleY, dwPix = r.w*scaleX, dhPix = r.h*scaleY;

    if (sw0 > 0 && sh0 > 0 && Number.isFinite(sx0) && Number.isFinite(sy0)){
      // normal sub-rect draw
      ctx.drawImage(img, sx0, sy0, sw0, sh0, dxPix, dyPix, dwPix, dhPix);
    } else {
      // Fallback (iOS/WebKit sub-rect rounding bug): clip tile rect, then draw fitted whole image
      ctx.save();
      ctx.beginPath();
      ctx.rect(dxPix, dyPix, dwPix, dhPix);
      ctx.clip();
      ctx.drawImage(img, dx*scaleX, dy*scaleY, dw*scaleX, dh*scaleY);
      ctx.restore();
    }
  }
}
    } }

  function drawPlasmas(){ const now=performance.now(); ctx.save(); for(let i=plasmas.length-1;i>=0;i--){ const P=plasmas[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.995; P.vy*=0.995; if(now>P.until){ plasmas.splice(i,1); continue; }
      const x=P.x*scaleX, y=P.y*scaleY, r=P.radius*((scaleX+scaleY)/2); const grd=ctx.createRadialGradient(x,y,2,x,y,r); grd.addColorStop(0,'rgba(150,230,255,0.9)'); grd.addColorStop(0.4,'rgba(120,200,255,0.35)'); grd.addColorStop(1,'rgba(120,200,255,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(180,240,255,0.5)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,r*0.7,0,Math.PI*2); ctx.stroke();
      // 沿途清除磚塊
      for(let j=bricks.length-1;j>=0;j--){ const b=bricks[j]; const bx=b.x+b.w/2, by=b.y+b.h/2; if(Math.hypot(P.x-bx,P.y-by)<=P.radius){ revealRects.push({x:b.x,y:b.y,w:b.w,h:b.h}); bricks.splice(j,1); score+=10; } }
    } ctx.restore(); }

  function drawHoly(){ const now=performance.now(); for(let i=holyFlashes.length-1;i>=0;i--){ const H=holyFlashes[i]; if(now>H.until){ holyFlashes.splice(i,1); continue; } const a=Math.max(0, (H.until-now)/300); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle=`rgba(255,240,180,${0.6*a})`; ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(0, H.y*scaleY); ctx.lineTo(canvas.width, H.y*scaleY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(H.x*scaleX, 0); ctx.lineTo(H.x*scaleX, canvas.height); ctx.stroke(); ctx.restore(); } }

  function drawPhoenix(){ if(!phoenixAnim) return; const now=performance.now(); const t=phoenixAnim; const prog=1-Math.max(0,(t.tEnd-now)/1200); const logicW=1100; const xLogic=(1-prog)*(logicW+200)-200; const x=xLogic*scaleX;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    // 身形光羽
    const grad=ctx.createLinearGradient((x+120),220*scaleY,x,260*scaleY); grad.addColorStop(0,'rgba(255,180,0,0.9)'); grad.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=grad;
    ctx.beginPath(); ctx.moveTo((x+180), 220*scaleY); ctx.quadraticCurveTo((x+60), 180*scaleY, (x), 230*scaleY); ctx.quadraticCurveTo((x-40), 260*scaleY, (x+120), 260*scaleY); ctx.closePath(); ctx.fill();
    // 羽毛粒子
    for(let i=0;i<3;i++){ fireBursts.push({x:(x-40)+Math.random()*120,y:220+Math.random()*60,life:300+Math.random()*400}); }
    ctx.restore(); if(now>=t.tEnd) phoenixAnim=null; }

  function draw(){
    if(screenShake>0){ const s=screenShake*0.6; ctx.save(); ctx.translate((Math.random()-0.5)*s,(Math.random()-0.5)*s); screenShake*=0.9; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBGDecor();
    drawRevealTiles();

    // 磚塊
    for(const b of bricks){ const base=b.explosive?getVar('--expl'):brickColor(b.colorIdx); const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY); g.addColorStop(0,base); g.addColorStop(1,'#1a1f3a'); ctx.fillStyle=g; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill();
      if(b.hp>1){ ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*scaleX,4*scaleY); ctx.fillStyle='rgba(255,255,255,.75)'; const ratio=Math.max(0,(b.hp-1))/3; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*ratio*scaleX,4*scaleY);} }

    drawPlasmas(); drawHoly(); drawPhoenix();

    // 擋板
    const padGlow=buffs.STICKY.active?'rgba(120,230,220,.6)':((buffs.WIDE.active||buffs.LONG.stacks.length)?'rgba(120,170,255,.6)':'rgba(200,210,255,.4)'); ctx.shadowColor=padGlow; ctx.shadowBlur=20;
    ctx.fillStyle='#9aaeff'; drawRoundedRect(paddle.x,paddle.y,paddle.w,paddle.h,8); ctx.fill(); ctx.shadowBlur=0;
    if(buffs.SHIELD.active){ const g=ctx.createLinearGradient(0,(700-10)*scaleY,0,700*scaleY); g.addColorStop(0,'rgba(120,220,255,0.35)'); g.addColorStop(1,'rgba(120,220,255,0.05)'); ctx.fillStyle=g; ctx.fillRect(0,(700-10)*scaleY,canvas.width,10*scaleY); }

    // 球與拖尾（根據 buff 變色）
    const nowT=performance.now();
    for(const b of balls){
      b.trail.push({x:b.x,y:b.y,t:nowT}); while(b.trail.length>12) b.trail.shift();
      for(let i=b.trail.length-1;i>=0;i--){ const p=b.trail[i]; const age=(nowT-p.t)/200; if(age>1) continue; const alpha=(1-age)*0.6;
        let color=( (b.rampageUntil&&nowT<b.rampageUntil)||b.piercing )?`rgba(120,220,255,${alpha})`:(buffs.FAST.active?`rgba(255,140,90,${alpha})`:`rgba(255,255,255,${alpha*0.6})`);
        if(buffs.PLASMA.active) color=`rgba(160,240,255,${alpha})`; if(buffs.FREEZE.active) color=`rgba(200,230,255,${alpha})`; if(buffs.HOLY.active) color=`rgba(255,240,180,${alpha})`;
        ctx.fillStyle=color; ctx.beginPath(); ctx.arc(p.x*scaleX,p.y*scaleY,(b.r*0.7)*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill();
      }
      const bx=b.x*scaleX, by=b.y*scaleY, br=b.r*((scaleX+scaleY)/2); const grad=ctx.createRadialGradient(bx-3,by-4,2,bx,by,br);
      let edge=(b.piercing||(b.rampageUntil&&nowT<b.rampageUntil))?'#9ff':(buffs.FAST.active?'#ff9a66':'#cbd4ff'); if(buffs.PLASMA.active) edge='#aff'; if(buffs.FREEZE.active) edge='#e8f8ff'; if(buffs.HOLY.active) edge='#fff0a0';
      grad.addColorStop(0,'#fff'); grad.addColorStop(1, edge); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();
      if(buffs.WAVY.active){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; const r1=br+2+2*Math.sin((nowT/100)+b.x*0.02); ctx.beginPath(); ctx.arc(bx,by,r1,0,Math.PI*2); ctx.stroke(); }
      if(b.stuck){ ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect((paddle.x+paddle.w/2-12)*scaleX,(paddle.y-6)*scaleY,24*scaleX,4*scaleY); }
    }

    // 掉落道具
    for(const p of powerups) drawPower(p);

    // 粒子
    for(let i=particles.length-1;i>=0;i--){ const P=particles[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.98; P.vy*=0.98; P.life-=16; if(P.life<=0){ particles.splice(i,1); continue; }
      const a=Math.max(0, Math.min(1, P.life/500)); ctx.fillStyle=P.color||`rgba(255,220,180,${a*0.6})`; ctx.beginPath(); ctx.arc(P.x*scaleX,P.y*scaleY,P.size*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    if(screenShake>0){ ctx.restore(); }
  }

  function resetBalls(center=true){ balls=[makeBall(false)]; const base=getDiff().baseSpeed; const speed=base+Math.min(level*0.5,4); const angle=(-60-Math.random()*60)*Math.PI/180;
    balls[0].x=center?1100/2:paddle.x+paddle.w/2; balls[0].y=700-70; balls[0].vx=Math.cos(angle)*speed; balls[0].vy=Math.sin(angle)*speed; balls[0].piercing=buffs.PIERCE.active; }

  function update(){
    const now=performance.now();
    // Buff 過期
    for(const key of Object.keys(GAME_CONFIG.powers)){
      if(key==='LONG') continue; 
      const b=buffs[key];
      if(b?.active && b.until && now>b.until){
        b.active=false;
        if(key==='PIERCE'){ for(const ball of balls) ball.piercing=false; }
        if(key==='STICKY'){
          // 若黏性效果到期而球仍黏著，立刻溫和釋放
          for(const ball of balls){ if(ball.stuck){ ball.stuck=false; ball.vy = -Math.abs(ball.vy||6); } }
        }
      }
    }
    computePaddleWidth(); updateBuffBadges();

    if(keyL) paddle.x-=paddle.speed; if(keyR) paddle.x+=paddle.speed; paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x));

    const mulGlobal=speedMultiplier(now);
    for(const b of balls){
      // 凍結狀態
      if(b.freeze.until && now<b.freeze.until){ continue; }
      if(b.freeze.until && now>=b.freeze.until){ b.vx=b.freeze.oldVX; b.vy=b.freeze.oldVY; b.freeze.until=0; }

      if(b.rampageUntil && now>b.rampageUntil){ b.rampageUntil=0; if(!buffs.PIERCE.active) b.piercing=false; }
      if(b.stuck){ b.x=paddle.x+paddle.w/2+b.offsetX; b.y=paddle.y-b.r-0.1; continue; }
      b.x+=b.vx*mulGlobal; b.y+=b.vy*mulGlobal;

      // 邊界
      if(b.x-b.r<0){ b.x=b.r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
      if(b.x+b.r>1100){ b.x=1100-b.r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
      if(b.y-b.r<0){ b.y=b.r; b.vy*=-1; beep(700,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
      if(b.y-b.r>700){ if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.y=700-b.r-1; b.vy=-Math.abs(b.vy); } else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; } }

      // 擋板
      if(b.y+b.r>=paddle.y && b.y+b.r<=paddle.y+paddle.h && b.x>=paddle.x && b.x<=paddle.x+paddle.w && b.vy>0){
        const hitPos=(b.x-(paddle.x+paddle.w/2))/(paddle.w/2); const speed=Math.min(Math.hypot(b.vx,b.vy)*1.02, b.speedCap); const angle=hitPos*(Math.PI/3);
        b.vx=Math.sin(angle)*speed; b.vy=-Math.cos(angle)*speed; b.y=paddle.y-b.r-0.1; beep(880,0.03); spawnParticles(b.x,b.y,'#caddff',8,1.3,1.5,2.5);
        if(buffs.STICKY.active){ b.stuck=true; b.offsetX=b.x-(paddle.x+paddle.w/2); }
      }

      // 碰磚
      let hit=-1; for(let i=0;i<bricks.length;i++){ const bk=bricks[i]; if(b.x+b.r>bk.x && b.x-b.r<bk.x+bk.w && b.y+b.r>bk.y && b.y-b.r<bk.y+bk.h){ hit=i; break; } }
      if(hit>=0){
        const bk=bricks[hit]; const inRampage=b.rampageUntil && now<b.rampageUntil;
        let reflected=false;
        if(!inRampage && !b.piercing){
          const oL=(b.x+b.r)-bk.x, oR=(bk.x+bk.w)-(b.x-b.r), oT=(b.y+b.r)-bk.y, oB=(bk.y+bk.h)-(b.y-b.r); const m=Math.min(oL,oR,oT,oB);
          if(m===oL){ b.x=bk.x-b.r; b.vx=-Math.abs(b.vx); } else if(m===oR){ b.x=bk.x+bk.w+b.r; b.vx=Math.abs(b.vx); } else if(m===oT){ b.y=bk.y-b.r; b.vy=-Math.abs(b.vy); } else { b.y=bk.y+bk.h+b.r; b.vy=Math.abs(b.vy); }
        reflected=true;
        } else if(inRampage){
          const oL=(b.x+b.r)-bk.x, oR=(bk.x+bk.w)-(b.x-b.r), oT=(b.y+b.r)-bk.y, oB=(bk.y+bk.h)-(b.y-b.r); const m=Math.min(oL,oR,oT,oB);
          if(m===oL){ b.x=bk.x-b.r; b.vx=Math.abs(b.vx)||4; } else if(m===oR){ b.x=bk.x+bk.w+b.r; b.vx=-Math.abs(b.vx)||-4; } else if(m===oT){ b.y=bk.y-b.r; b.vy=Math.abs(b.vy)||4; } else { b.y=bk.y+bk.h+b.r; b.vy=-Math.abs(b.vy)||-4; }
          b.piercing=true;
        }

        // 扣血 + 分數
        bk.hp=(bk.hp||1)-1; score+=10; updateHUD();

        // 新增增益的命中效果
        if(buffs.PLASMA.active){ const cfg=GAME_CONFIG.powers.PLASMA.plasma; const ang=Math.random()*Math.PI*2; plasmas.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,vx:Math.cos(ang)*cfg.drift,vy:Math.sin(ang)*cfg.drift,until:now+cfg.lifeMs,radius:cfg.radius}); }
        if(buffs.FREEZE.active && reflected && !b.freeze.pending){
          const f=GAME_CONFIG.powers.FREEZE.freeze;
          b.freeze.pending = true;
          setTimeout(()=>{
            if(!buffs.FREEZE.active){ b.freeze.pending=false; return; }
            b.freeze.oldVX=b.vx; b.freeze.oldVY=b.vy;
            b.freeze.until=performance.now()+f.stopMs;
            b.vx=0; b.vy=0;
            b.freeze.pending=false;
            spawnParticles(b.x,b.y,'rgba(230,247,255,0.9)',16,1.2,1.0,2.5);
          }, f.delayMs);
        }
        if(buffs.HOLY.active){ holyFlashes.push({x:bk.x+bk.w/2, y:bk.y+bk.h/2, until:now+350}); for(let i=bricks.length-1;i>=0;i--){ const t=bricks[i]; const sameRow=Math.abs(t.y-bk.y)<1; const sameCol=Math.abs(t.x-bk.x)<1; if(sameRow||sameCol){ revealRects.push({x:t.x,y:t.y,w:t.w,h:t.h}); bricks.splice(i,1); score+=10; } } screenShake=Math.max(screenShake,4); }

        // 磚塊壞掉 → 揭示與掉落
        if(bk.hp<=0){
          const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
          revealRects.push({x:bk.x,y:bk.y,w:bk.w,h:bk.h});
          if(Math.random()<getDiff().dropRate) spawnPower(cx-12,cy);
          if(bk.explosive){ explodeAt(cx,cy); } else { bricks.splice(hit,1); }
        }
        beep(520+Math.random()*200,0.03,0.05);
      }
    }

    // Watchdog：若所有球都處於凍結或黏住，且 FREEZE 已過期，則自動釋放一顆避免軟鎖
    (function(){
      if (balls.length === 0) return;
      const nowT = performance.now();
      const freezeActive = !!(buffs.FREEZE.active && buffs.FREEZE.until && nowT < buffs.FREEZE.until);
      const allImmobile = balls.every(bb => (bb.stuck === true) || (bb.freeze && bb.freeze.until && nowT < bb.freeze.until));
      if (!freezeActive && allImmobile){
        // 優先釋放一顆凍結球
        for (const bb of balls){
          if (bb.freeze && bb.freeze.until && nowT < bb.freeze.until){
            const vx = bb.freeze.oldVX || ((Math.random()<0.5?-1:1) * 4);
            const vy = bb.freeze.oldVY || -6;
            bb.freeze.until = 0;
            bb.vx = vx; bb.vy = vy;
            return;
          }
        }
        // 否則釋放一顆黏住的球
        for (const bb of balls){
          if (bb.stuck){
            bb.stuck = false;
            bb.vy = -Math.abs(bb.vy || 6);
            return;
          }
        }
      }
    })();



    // 球全沒了
    if(balls.length===0){ lives--; updateHUD(); if(lives<=0){ running=false; paused=true; showCenter('遊戲結束', `分數：${score}<br>按 Space 或點畫面再來一局，或按 R 重開。`); return; } else { resetBalls(false); paused=true; showCenter('失去一條命','按 Space 或點畫面繼續'); return; } }

    // 掉落道具移動/撿取
    for(let i=powerups.length-1;i>=0;i--){ const p=powerups[i]; p.y+=p.vy; if(p.y+p.h>=paddle.y && p.x+p.w>=paddle.x && p.x<=paddle.x+paddle.w && p.y<=paddle.y+paddle.h){ applyPower(p.type); powerups.splice(i,1); continue; } if(p.y>710) powerups.splice(i,1); }

    // 清關 → 畫廊
    if(bricks.length===0){
      paused=true; running=false; galleryImg.src=BG_SRCS[(level-1)%BG_SRCS.length]; gallery.style.display='flex'; requestAnimationFrame(()=>gallery.classList.add('show'));
      const proceed=()=>{ gallery.classList.remove('show'); setTimeout(()=>{ gallery.style.display='none'; gallery.removeEventListener('click',proceed); },200); level++; updateHUD(); initBricks(); resetBalls(); paused=true; running=false; showCenter(`進入關卡 ${level}`,'按 Space 或點畫面開始'); };
      gallery.addEventListener('click',proceed,{once:true}); return;
    }
  }

  function loop(){ if(!paused && running) update(); draw(); requestAnimationFrame(loop); }
  function boot(){ resetGame(); updateHUD(); loop(); const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4'); if(raw){ setTimeout(()=>{ if(confirm('偵測到存檔，要讀取進度嗎？')) loadProgress(); }, 400); } }
  boot();
})();
</script>
</body>
</html>
