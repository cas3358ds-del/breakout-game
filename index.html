<!DOCTYPE html>

<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<title>Rockæ‰“ç£šå¡Š Breakoutï¼ˆæœ€çµ‚å¢å¼·ç‰ˆï¼‰</title><style>
    :root {
      --bg:#0b1022; --bg2:#0a0f1e; --fg:#e9ecf1; --accent:#66b2ff;
      --brick1:#ff6b6b; --brick2:#ffd166; --brick3:#06d6a0; --brick4:#4cc9f0;
      --expl:#ff8c00; --power:#7aa2ff; --debuff:#ff6aa3;
      --glass: rgba(255,255,255,.06); --glass-stroke: rgba(255,255,255,.12);
      --btn:#1a2448; --btn-stroke:#2a3974; --pill:#121a36;
      --led:#8fb3ff;
    }
    html,body{height:100%; margin:0; overscroll-behavior-y:contain; background:radial-gradient(1200px 800px at 50% -10%, #152040, #0a0f1e 60%); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;}
    body{min-height:100svh; display:flex; align-items:flex-start; justify-content:center;}
    .wrap{display:flex; gap:12px; align-items:center; justify-content:center; flex-direction:column; padding:12px; width:100%; max-width:1200px}
    h1{margin:4px 0 2px 0; font-weight:800; letter-spacing:.3px; text-shadow:0 2px 20px #0008;
       font-size:clamp(16px,3.2vw,28px)}
    .hud{
      position:sticky; top:0; z-index:5;
      display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; font-weight:650;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--glass-stroke); border-radius:14px; padding:8px 10px;
      box-shadow: 0 6px 24px rgba(0,0,0,.25); backdrop-filter: blur(6px);
    }
    .pill{padding:6px 10px; background:var(--pill); border:1px solid var(--glass-stroke); border-radius:999px; font-size:14px}
    .btn{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg);
      border:1px solid var(--btn-stroke); border-radius:10px; padding:6px 10px; cursor:pointer; user-select:none; font-size:14px}
    .btn:active{transform:translateY(1px)}
    select,input[type="range"]{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg); border:1px solid var(--btn-stroke); border-radius:8px; padding:6px 10px}
    .range{display:flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid var(--glass-stroke); border-radius:999px; background:var(--pill); font-size:12px}
    canvas{background:linear-gradient(180deg, #0d1126, #0b1022 55%, #091022);
      border:1px solid #1a2348; border-radius:16px; max-width:min(1120px, 96vw); width: min(1120px, 96vw); height: auto; display:block;
      box-shadow: 0 30px 80px rgba(0,0,0,.35), inset 0 0 120px rgba(255,255,255,.02); touch-action:none;}
    .overlay{position:relative; display:inline-block; vertical-align:top;}
    .center-note{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:9999}
    .note-box{background:linear-gradient(180deg, rgba(8,12,28,.9), rgba(8,12,28,.85));
      border:1px solid var(--glass-stroke); padding:16px 18px; border-radius:14px; text-align:center; max-width:min(90vw,860px);
      box-shadow: 0 12px 60px rgba(0,0,0,.5); font-size:14px}
    .note-box h2{margin:0 0 8px 0; font-size:18px}
    .note-box p{margin:6px 0; line-height:1.6}
    .note-box .cols{display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:10px; text-align:left}
    kbd{background:#0e1836; border:1px solid #2a356a; border-radius:6px; padding:2px 6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:90%}

    .badges{display:flex; gap:6px; flex-wrap:wrap; align-items:center; justify-content:center}
    .badge{background:linear-gradient(180deg, rgba(18,32,68,.9), rgba(10,20,48,.9));
      border:1px solid var(--glass-stroke); padding:4px 8px; border-radius:999px; font-size:12px; display:flex; gap:6px; align-items:center}
    .legend{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; font-size:12px}
    .legend .box{width:14px; height:14px; display:inline-block; border-radius:3px; margin-right:4px; vertical-align:middle}
    .legend .item{padding:4px 8px; border-radius:10px; background:rgba(255,255,255,.05); border:1px solid var(--glass-stroke)}

    /* æ¸…é—œç•«å»Š overlay */ 
    .gallery{position:absolute; inset:0; display:none; align-items:center; justify-content:center; flex-direction:column; z-index:4;}
    .gallery .backdrop{position:absolute; inset:0; background:rgba(0,0,0,.75); opacity:0; transition:opacity .6s;}
    .gallery img{max-width:min(94vw,1040px); max-height:min(88vh,680px); border-radius:16px; box-shadow:0 30px 120px rgba(0,0,0,.6); opacity:0; transform:translateY(12px) scale(.98); transition:opacity .6s, transform .6s;}
    .gallery .hint{position:absolute; bottom:24px; color:#fff; font-size:16px; opacity:0; text-shadow:0 2px 10px rgba(0,0,0,.6);}
    .gallery.show .backdrop{opacity:1;}
    .gallery.show img{opacity:1; transform:translateY(0) scale(1);} 
    .gallery.show .hint{opacity:.9;}

    /* å‹åˆ©ç•«é¢ */
    .win{position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:6;}
    .win.show{display:flex;}
    .gameover{position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:8;}
    .gameover.show{display:flex;}
    .gameover .backdrop{position:absolute; inset:0; background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .gameover .center{position:relative; z-index:2; text-align:center; background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75)); padding:18px 22px; border:1px solid var(--glass-stroke); border-radius:16px; box-shadow:0 20px 90px rgba(0,0,0,.5)}
    
    .win .backdrop{position:absolute; inset:0; background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .thumb-ring{position:absolute; inset:16px; pointer-events:auto; display:grid; grid-template-columns:repeat(10,1fr); gap:6px; opacity:.95}
    .thumb-ring img{width:100%; height:100%; object-fit:cover; border-radius:10px; box-shadow:0 8px 30px rgba(0,0,0,.5);}
    .win .center{position:relative; z-index:2; text-align:center; background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75)); padding:18px 22px; border:1px solid var(--glass-stroke); border-radius:16px; box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .win h2{margin:4px 0 6px; font-size:28px; letter-spacing:2px}
    .win .small{opacity:.8; font-size:12px; margin-top:6px}
    .win .again{margin-top:10px}

    @media (max-width: 768px){
      .wrap{padding:8px}
      .pill,.btn{font-size:12px; padding:5px 8px}
      .legend{display:none}
      .hud{gap:6px}
      .thumb-ring{grid-template-columns:repeat(5,1fr)}
    }

    /* === UI ç¾å­¸å¼·åŒ– === */
    .pill.life { 
      background: linear-gradient(180deg, #1d274f, #0f1733);
      border: 1px solid #3a4ea3;
      box-shadow: inset 0 0 16px rgba(140,170,255,.15), 0 6px 24px rgba(0,0,0,.2);
    }
    .pill.life #lives {
      font-size: 20px; font-weight: 800; letter-spacing: .5px; color:#fff;
      text-shadow: 0 2px 10px rgba(100,140,255,.5);
    }
    .btn.info, .btn.info:focus {
      background: linear-gradient(180deg, #283a7a, #192450);
      border-color: #3c56a8;
    }
    /* æ•™å­¸/æ•ˆæœèªªæ˜è¦–çª—çš„å‰å‰é—œé–‰éˆ• */
    .note-box { position: relative; }
    .note-close {
      position:absolute; top:8px; right:8px; width:28px; height:28px; border-radius:999px;
      display:grid; place-items:center; cursor:pointer; user-select:none;
      border:1px solid var(--glass-stroke);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), rgba(255,255,255,.02));
      box-shadow: 0 6px 16px rgba(0,0,0,.25);
      color:#d7dcff; font-weight:800; line-height:1;
    }
    .note-close:hover { filter:brightness(1.1); }
    .note-close:active { transform: translateY(1px); }

    /* é–å®šæ¡†ï¼ˆçµ±ä¸€ 1sï¼‰ */
    .lockbox { /* canvas-rendered; this is for reference */ }

    /* æç¤ºå¡æ¨£å¼ */
    .prompts {
      position:absolute; left: 16px; top: 160px;
      display:flex; flex-direction:column; gap:8px; pointer-events:none;
      z-index:7;
    }
    .prompt-card {
      padding:8px 12px;
      border-radius:10px;
      max-width:180px;
      font-size:12px;
      box-shadow:0 4px 12px rgba(0,0,0,0.4);
      opacity:0.0;
      transform:translateX(-20px);
      transition:opacity .4s, transform .4s;
    }
    .prompt-card.show {
      opacity:0.96;
      transform:translateX(0);
    }
    .prompt-card.fade {
      opacity:0;
    }
    .prompt-info  { background:rgba(30,40,80,0.85); border:1px solid rgba(255,255,255,0.15); color:#cce; }
    .prompt-buff  { background:rgba(70,100,180,0.85); border:1px solid rgba(160,190,255,0.4); color:#fff; }
    .prompt-debuff{ background:rgba(150,60,90,0.85); border:1px solid rgba(255,150,200,0.4); color:#fff; }
    .prompt-special{background:rgba(210,180,80,0.85); border:1px solid rgba(255,220,160,0.5); color:#111;}
    .prompt-boss { background:rgba(120,40,120,0.85); border:1px solid rgba(220,160,220,0.4); color:#fff; }

  
    .note-box{max-height:60vh; overflow:auto;}
</style>
</head>
<body>
<div class="wrap">
<h1>Rockæ‰“ç£šå¡Š Breakoutï¼ˆæœ€çµ‚å¢å¼·ç‰ˆï¼‰</h1>
<div class="hud">
<div class="pill">åˆ†æ•¸ <span id="score">0</span></div>
<div class="pill">é—œå¡ <span id="level">1</span>/20</div>
<div class="pill life">ç”Ÿå‘½ <span id="lives">3</span></div>
<label>é›£åº¦
        <select id="difficulty">
<option value="easy">Easy</option>
<option selected="" value="normal">Normal</option>
<option value="hard">Hard</option>
</select>
</label>
<button class="btn" id="pauseBtn">é–‹å§‹ / æš«åœ (<kbd>Space</kbd>)</button>
<label>Skiné¢¨æ ¼
        <select id="ledStyle">
<option selected="" value="classic">ç¶“å…¸é¢¨æ ¼</option>
<option value="tech">ç§‘æŠ€é¢¨æ ¼</option>
<option value="arc">é›»å¼§é¢¨æ ¼</option>
<option value="ice">å†°é›ªé¢¨æ ¼</option>
<option value="vivid">çµ¢éº—é¢¨æ ¼</option>
<option value="reaper">æ­»ç¥é¢¨æ ¼</option>
<option value="flame">çƒˆç„°é¢¨æ ¼</option>
<option value="demon">é­”ç‹é¢¨æ ¼</option>
</select>
</label>
<button class="btn" id="resetBtn">é‡é–‹ (<kbd>R</kbd>)</button>
<button class="btn" id="fsBtn">å…¨è¢å¹• (<kbd>F</kbd>)</button>
<button class="btn info" id="tutorBtn">æ•™å­¸</button>
<button class="btn info" id="effectsBtn">æ•ˆæœèªªæ˜</button>
<button class="btn" id="soundBtn">éŸ³æ•ˆï¼šé—œ</button>
<span class="range">BGM
        <button class="btn" id="bgmBtn">é—œ</button>
<input id="bgmVol" max="1" min="0" step="0.01" style="width:120px" type="range" value="0.85"/>
</span>
<button class="btn" id="saveBtn">å­˜æª”</button>
<button class="btn" id="loadBtn">è®€æª”</button>
<button class="btn" id="clearSaveBtn">æ¸…é™¤å­˜æª”</button>
</div>
<div class="legend">
<span class="item"><span class="box" style="background:var(--expl)"></span>çˆ†ç‚¸ç£š</span>
<span class="item"><span class="box" style="background:var(--brick2)"></span>ä¸€èˆ¬ç£š</span>
<span class="item"><span class="box" style="background:#888"></span>ä¸å¯ç ´å£ç£š</span>
<span class="item"><span class="box" style="background:#bb7aff"></span>å¼·åå½ˆç£š</span>
<span class="item"><span class="box" style="background:#6ec6ff"></span>ç§»å‹•ç£š</span>
<span class="item"><span class="box" style="background:#ff4d6d"></span>Bossç£š</span>
<span class="item"><span class="box" style="background:var(--power)"></span>å¢ç›Šé“å…·</span>
<span class="item"><span class="box" style="background:var(--debuff)"></span>æ¸›ç›Šé“å…·</span>
</div>
<div class="badges" id="activeBuffs"></div>
<div class="overlay">
<div class="gallery" id="gallery">
<div class="backdrop"></div>
<img alt="é—œå¡å¤§åœ–" id="galleryImg" src=""/>
<div class="hint">é»ä¸€ä¸‹é€²å…¥ä¸‹ä¸€é—œ â–¶</div>
</div>
<div class="win" id="win">
<div class="backdrop"></div>
<div class="thumb-ring" id="ring"></div>
<div class="center">
<h2>æ­å–œéé—œï¼</h2>
<div style="font-size:28px;margin:6px 0;">ç¸½åˆ†æ•¸ï¼š<span id="finalScore">0</span></div>
<div id="statsWin" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:360px"></div>
<div class="small">ä½œè€…ï¼š ChatGPTã€€ï¼ã€€æŒ‡å°è€…ï¼š Rock</div>
<div class="again"><button class="btn" id="againBtn">å†ç©ä¸€æ¬¡</button></div>
</div>
</div>
<canvas height="700" id="game" width="1100"></canvas>
        <!-- æç¤ºå¡å®¹å™¨ï¼šé¡¯ç¤ºå¢ç›Š/æ¸›ç›Š/Boss/èè‹±æç¤º -->
        <div id="prompts" class="prompts"></div>
<div class="gameover" id="gameover">
<div class="backdrop"></div>
<div class="center">
<h2>éŠæˆ²çµæŸ</h2>
<div style="font-size:28px;margin:6px 0;">æœ€çµ‚åˆ†æ•¸ï¼š<span id="finalScore2">0</span></div>
<div id="statsOver" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:320px"></div>
<div class="again"><button class="btn" id="retryBtn">å†æ¬¡éŠæˆ²</button></div>
</div>
</div>
<div class="center-note" id="centerNote">
<div class="note-box" id="noteBox"><button aria-label="é—œé–‰" class="note-close" id="noteClose">Ã—</button>
<h2 id="noteTitle">æŒ‰ <kbd>Space</kbd> æˆ–é»ç•«é¢é–‹å§‹</h2>
<p id="noteText">
            æ“ä½œï¼š<kbd>â†</kbd>/<kbd>â†’</kbd> æˆ– <kbd>A</kbd>/<kbd>D</kbd>ï¼›æ‰‹æŒ‡æ‹–æ›³ç•«é¢ä¹Ÿå¯ç§»å‹•å¹³å°ã€‚<br/>
            å·²æ•´åˆï¼šèƒŒæ™¯é€æ­¥æ­ç¤º + æ¸…é—œç•«å»Šã€å¢ç›Š/æ¸›ç›Šï¼ˆå«é›»æ¼¿çƒ/å‡çµçƒ/ç¥è–çƒ/é³³å‡°å¯©åˆ¤/9å‘½æ€ªè²“ï¼‰ã€çˆ†ç‚¸ç£šã€éŸ³æ•ˆã€é›£åº¦ã€å­˜è®€æª”ã€BGMã€æ•™å­¸/æ•ˆæœèªªæ˜ã€Bossèˆ‡é€²éšç£šã€‚
          </p>
</div>
</div>
</div>
</div>
<script>
(() => {
  /* __MOBILE_BOOT_FIX__ */
  function __ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  __ready(() => {
    const canvas = document.getElementById('game');
    const skinFX = document.getElementById('skinFX');
    const centerNote = document.getElementById('centerNote');
    const pauseBtn = document.getElementById('pauseBtn');
    const noteClose = document.getElementById('noteClose');

    // Keep skinFX overlay exactly matching canvas size
    const sync = () => {
      if(!canvas || !skinFX) return;
      const rect = canvas.getBoundingClientRect();
      skinFX.style.width = rect.width + 'px';
      skinFX.style.height = rect.height + 'px';
    };
    new ResizeObserver(sync).observe(document.body);
    window.addEventListener('orientationchange', () => setTimeout(sync, 200));
    window.addEventListener('resize', () => setTimeout(sync, 50));
    setTimeout(sync, 0);

    // One-tap start
    let booted = false;
    function bootStart(){
      if(booted) return; booted = true;
      if(centerNote) centerNote.style.display = 'none';
      try {
        if (window.resetGame) window.resetGame();
        if (window.startGameWithCountdown) window.startGameWithCountdown();
        if (window.Howler && Howler.ctx && Howler.ctx.state==='suspended') Howler.ctx.resume().catch(()=>{});
      } catch(e){ console && console.warn('[bootStart]', e); }
    }
    document.addEventListener('click', bootStart, {passive:true});
    document.addEventListener('touchend', bootStart, {passive:true});
    document.addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.key===' '){ e.preventDefault(); bootStart(); }});
    if (pauseBtn) pauseBtn.addEventListener('click', bootStart);
    if (noteClose) noteClose.addEventListener('click', bootStart);
    if (centerNote) centerNote.addEventListener('click', (e)=>{ if(e.target===centerNote) bootStart(); });
  });
  // === è¨­å®š ===
  const GAME_CONFIG = {
    totalLevels: 20,
    difficulty: {
      easy:   { paddleBaseW: 220, baseSpeed: 4, rowsBase: 6, dropRate: 0.72 },
      normal: { paddleBaseW: 180, baseSpeed: 4.5, rowsBase: 7, dropRate: 0.52 },
      hard:   { paddleBaseW: 140, baseSpeed: 6, rowsBase: 8, dropRate: 0.32 },
    },
    bricks: { explosiveChance: 0.18, brickHeight: 30, padding: 9, topOffset: 60, cols: 12 },
    powers: {
      // æ—¢æœ‰
      WIDE:{label:'å¹³å°è®Šå¯¬',type:'buff',durationMs:30000,paddleWidthAdd:50,badge:'â†”ï¸'},
      LONG:{label:'å¹³å°è®Šé•·(å¯ç–Š)',type:'buff',durationMs:30000,longPerStackAdd:40,stacksMax:2,badge:'ğŸ“'},
      STICKY:{label:'é»æ€§å¹³å°(ä¸Šå½ˆå¯æš«é»)',type:'buff',durationMs:5000,sticky:true,badge:'ğŸ§²'},
      MULTI:{label:'å¤šçƒ',type:'buff',multiDuplicate:true,maxBalls:4,badge:'âœ¨'},
      SLOW:{label:'å…¨å±€æ…¢é€Ÿ',type:'buff',durationMs:15000,speedMul:0.6,badge:'ğŸ¢'},
      PIERCE:{label:'ç©¿é€çƒ',type:'buff',durationMs:12000,piercing:true,badge:'ğŸ¯'},
      SHIELD:{label:'è­·ç›¾(æ‰çƒæ“‹ä¸€æ¬¡)',type:'buff',oneShotShield:true,badge:'ğŸ›¡'},
      RAMPAGE:{label:'æš´èµ°çƒ(çŸ­æš«å¼·ç©¿)',type:'buff',durationMs:5000,forcePiercing:true,rampageMs:5000,badge:'ğŸ”¥'},
      FAST:{label:'å¿«é€Ÿçƒ',type:'debuff',durationMs:5000,globalSpeedMul:1.5,screenShakeOnApply:6,badge:'âš¡'},
      WAVY:{label:'è®Šé€Ÿçƒ',type:'debuff',durationMs:5000,wavy:{amp:0.6,base:1.2,periodMs:200},badge:'ã€°ï¸'},
      // æ–°å¢
      PLASMA:{label:'é›»æ¼¿çƒ(æ“Šä¸­æ”¾å‡ºé›»æ¼¿åœˆæ¸…åˆ—)',type:'buff',durationMs:10000,plasma:{drift:1.2,radius:38,lifeMs:3000},badge:'âš¡ï¸'},
      FREEZE:{label:'å‡çµçƒ(å»¶é²åœé “ä¸€ä¸‹)',type:'buff',durationMs:10000,freeze:{delayMs:300,stopMs:2000},badge:'â„ï¸'},
      HOLY:{label:'ç¥è–çƒ(åå­—æ¸…ç·š)',type:'buff',durationMs:5000,holy:{},badge:'âœï¸'},
      PHOENIX:{label:'é³³å‡°å¯©åˆ¤(æ¶ˆåŠå ´/ä¸ç§’æ®ºBoss)',type:'rare',rareFactor:0.08,instant:true,badge:'ğŸª½'},
      NINE:{label:'9å‘½æ€ªè²“(ç”Ÿå‘½è®Š9)',type:'rare',rareFactor:0.08,instant:true,badge:'ğŸ±'}
      ,TRACK:{label:'è¿½è¹¤çƒ(è‡ªå‹•ä¿®æ­£è»Œè·¡)',type:'buff',durationMs:10000,track:{},badge:'ğŸ§­'}
      ,MISSILE:{label:'é£›å½ˆçƒ(æ“‹æ¿åå½ˆæ™‚ç™¼å°„3æš)',type:'buff',durationMs:5000,missile:{speed:7,turn:0.08,lifeMs:4000},badge:'ğŸš€'}
      ,HELL:{label:'åœ°ç„çƒ',type:'none'}
      ,MEGA:{label:'ç‰¹å¤§çƒ',type:'none'}
      ,CHAIN:{label:'é–éˆçƒ(å‘½ä¸­ç£šé–10ç§’)',type:'debuff',durationMs:5000,chain:{lockMs:10000},badge:'â›“ï¸'}
      ,NARROW:{label:'å¹³å°ç¸®å°(å¯¬åº¦æ¸›åŠ)',type:'debuff',durationMs:5000,narrow:true,badge:'ğŸ“‰'}
      ,HOLE:{label:'å¹³å°ç©ºæ´(ä¸­é–“1/3ç„¡æ•ˆ)',type:'debuff',durationMs:5000,hole:true,badge:'ğŸ•³'}
      ,FLIP:{label:'å¤©åœ°ç¿»è½‰(æ”¹ç‚ºå·¦å´æ“‹æ¿)',type:'special',durationMs:15000,specialWeight:0.1,badge:'ğŸ”„'}
      ,GODSPEED:{label:'ç¥é€Ÿæµè½‰(ä¸è½åœ°/å¿½ç•¥æ•ˆæœ/æ»¿é€Ÿ)',type:'special',durationMs:10000,specialWeight:0.1,badge:'â˜„ï¸'}
      ,LASER:{label:'è‡ªå‹•é›·å°„(æ¯2ç§’å…©ç«¯ç™¼å°„)',type:'special',durationMs:10000,specialWeight:0.1,laser:{intervalMs:2000},badge:'ğŸ”«'}

      /* æ–°å¢å¢ç›Šé“å…· */
      ,FIREBALL:{label:'ç«ç„°çƒ',type:'buff',durationMs:10000,badge:'ğŸ”¥'}
      ,POISON:{label:'åŠ‡æ¯’çƒ',type:'buff',durationMs:12000,badge:'â˜ ï¸'}
      ,TELEPORT:{label:'ç¬ç§»çƒ',type:'buff',durationMs:10000,badge:'ğŸŒ€'}
      /* æ–°å¢ç‰¹æ®Šå¢ç›Šé“å…· */
      ,SWORD:{label:'åŠèŠ’è£‚ç©º',type:'special',durationMs:20000,specialWeight:0.1,minLevel:5,badge:'ğŸ—¡ï¸'}
      ,LASERSTORM:{label:'é›·å°„é¢¨æš´',type:'special',durationMs:20000,specialWeight:0.1,minLevel:10,badge:'ğŸ’¥'}
      ,BLACKHOLE:{label:'é»‘æ´åå™¬',type:'special',durationMs:20000,specialWeight:0.1,minLevel:15,badge:'ğŸ•³ï¸'}
      ,ANNIHILATION:{label:'è¬ç‰©éŠ·æ¯€',type:'special',durationMs:0,specialWeight:0.1,minLevel:15,badge:'ğŸ’£'}
      /* æ–°å¢æ¸›ç›Šé“å…· */
      ,ROTATE:{label:'å¹³å°ç¿»è½‰',type:'debuff',durationMs:8000,badge:'ğŸ”'}

    },
    powerCapsule:{width:24,height:16,fallVy:2.2},
    caps:{paddleMaxW:300,ballSpeedMax:19.5}
  };

  // === å½±åƒè¼‰å…¥ï¼ˆæ”¯æ´ .png / .jpgï¼‰ ===
  const IMG_PAIRS = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.png`, cg:`images/cg${i}.png`}));
  // æº–å‚™ jpg å¾Œå‚™
  const IMG_PAIRS_FALLBACK = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.jpg`, cg:`images/cg${i}.jpg`}));

  function makeImg(src, fallback){
    const im = new Image(); im.decoding='async'; im.loading='lazy'; im.src=src;
    if(fallback){
      im.onerror=()=>{ if(im.src!==fallback) im.src=fallback; };
    }
    return im;
  }
  const IMG_MAP = []; // 0..9: {bg:Image, cg:Image}
  for(let i=0;i<10;i++){
    IMG_MAP[i] = {
      bg: makeImg(IMG_PAIRS[i].bg, IMG_PAIRS_FALLBACK[i].bg),
      cg: makeImg(IMG_PAIRS[i].cg, IMG_PAIRS_FALLBACK[i].cg),
    };
  }

  // === åƒè€ƒ DOM ===
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const scoreEl=document.getElementById('score'), levelEl=document.getElementById('level'), livesEl=document.getElementById('lives');
  const pauseBtn=document.getElementById('pauseBtn'), resetBtn=document.getElementById('resetBtn'), fsBtn=document.getElementById('fsBtn');
  const soundBtn=document.getElementById('soundBtn'), saveBtn=document.getElementById('saveBtn'), loadBtn=document.getElementById('loadBtn'), clearSaveBtn=document.getElementById('clearSaveBtn');
  const tutorBtn=document.getElementById('tutorBtn'), effectsBtn=document.getElementById('effectsBtn');
  const centerNote=document.getElementById('centerNote'), noteTitle=document.getElementById('noteTitle'), noteText=document.getElementById('noteText'), noteBox=document.getElementById('noteBox');
  const difficultySel=document.getElementById('difficulty'), activeBuffsEl=document.getElementById('activeBuffs');
  const ledStyleSel=document.getElementById('ledStyle');
  const gallery=document.getElementById('gallery'), galleryImg=document.getElementById('galleryImg');
  const win=document.getElementById('win'), ring=document.getElementById('ring'), finalScore=document.getElementById('finalScore'), againBtn=document.getElementById('againBtn');
  (function(){var el=document.getElementById('retryBtn');if(el) el.addEventListener('click', ()=>{ const go=document.getElementById('gameover'); if(go) go.classList.remove('show'); gameOver=false; resetGame(); startGameWithCountdown(); });})();
  const bgmBtn=document.getElementById('bgmBtn'), bgmVol=document.getElementById('bgmVol');
  const gameover=document.getElementById('gameover'), finalScore2=document.getElementById('finalScore2');
  const retryBtn=document.getElementById('retryBtn');

  // ==== æç¤ºå¡æ©Ÿåˆ¶ ====
  // æç¤ºå¡å®¹å™¨èˆ‡è¨˜éŒ„ï¼Œç”¨æ–¼åœ¨é¦–æ¬¡å–å¾—å¢ç›Š/ç‰¹æ®Šå¢ç›Š/æ¸›ç›Šã€é‡åˆ°èè‹±æˆ–Bossæ™‚é¡¯ç¤ºæç¤º
  const promptsEl = document.getElementById('prompts');
  const promptSeen = {};
  /**
   * é¡¯ç¤ºæç¤ºå¡
   * @param {string} key ç”¨æ–¼å»é‡çš„é¡å‹æ¨™è­˜
   * @param {string} text è¦é¡¯ç¤ºçš„æ–‡å­—å…§å®¹ï¼ˆå¯ä»¥åŒ…å« HTMLï¼‰
   * @param {string} category åˆ†é¡: 'info' | 'buff' | 'debuff' | 'special' | 'boss'
   */
  function showPrompt(key, text, category='info'){
    if(promptSeen[key]) return;
    promptSeen[key] = true;
    if(!promptsEl) return;
    const div = document.createElement('div');
    div.className = `prompt-card prompt-${category}`;
    div.innerHTML = text;
    promptsEl.prepend(div);
    while(promptsEl.children.length > 3){
      promptsEl.removeChild(promptsEl.lastElementChild);
    }
    requestAnimationFrame(()=> div.classList.add('show'));
    setTimeout(()=>{
      div.classList.add('fade');
      setTimeout(()=>{ if(div.parentElement) div.parentElement.removeChild(div); }, 800);
    }, 5000);
  }

  // 9å‘½æ€ªè²“ä½¿ç”¨æ¬¡æ•¸é™åˆ¶
  let nineUsed = 0;
  // è¨˜éŒ„æœ€è¿‘æ¶ˆé™¤ç£šå¡Šçš„æ™‚é–“æˆ³ï¼Œç”¨æ–¼æ‰è½ç‡æŠ‘åˆ¶
  const recentBrickClears = [];


  // é—œé–‰è¦–çª—æŒ‰éˆ•ï¼ˆé—œé–‰å¾Œç«‹å³å€’æ•¸ã€ç¹¼çºŒéŠæˆ²ï¼‰
  const noteClose = document.getElementById('noteClose');
  function closeNoteAndResume(){
    hideCenter();
    if(running){ startCountdown(); } else { startGameWithCountdown(); }
  }
  noteClose.addEventListener('click', (e)=>{ e.stopPropagation();
  // å…è¨±é»æ“Šæ•´å€‹æ•™å­¸/èªªæ˜è¦†è“‹å±¤å³å¯é–‹å§‹æˆ–ç¹¼çºŒï¼ˆé¿å…è¡Œå‹•è£ç½®èª¤è§¸ç„¡æ³•å•Ÿå‹•ï¼‰
  centerNote.addEventListener('click', (e)=>{ e.stopPropagation(); closeNoteAndResume();
  noteBox.addEventListener('click', (e)=>{ e.stopPropagation(); /* è®“é»æ“Šå€å¡Šä¸ç©¿é€ */ });
  // ä»»ä½•åœ°æ–¹é»æ“Šï¼ˆä¾‹å¦‚ HUDï¼‰ä¹Ÿèƒ½è§¸ç™¼é¦–æ¬¡å•Ÿå‹•ï¼Œå¼·åŒ–å®¹éŒ¯
  document.addEventListener('click', ()=>{ if(!running && !gameOver) { startGameWithCountdown(); } });
 closeNoteAndResume();


  // === DPR ç¸®æ”¾ ===
  function resizeCanvasDPR(){ const dpr=Math.min(window.devicePixelRatio||1,2); const cssW=canvas.clientWidth; const cssH=Math.round(cssW*(700/1100)); canvas.style.height=cssH+'px'; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); scaleX=canvas.width/1100; scaleY=canvas.height/700; }
  let scaleX=1, scaleY=1; window.addEventListener('resize', resizeCanvasDPR, {passive:true}); resizeCanvasDPR();

  // === ç‹€æ…‹ ===
  let running=false, paused=true, level=1, score=0, lives=3, soundsOn=false;
  let gameOver=false;
  let stats={catches:0,buffs:0,debuffs:0,eliteKills:0,bossKills:0,lifeStart:0,fastestDeath:Infinity,longestLife:0,livesUsed:0};
  let ledStyle = (localStorage.getItem('led_style')||'classic');
  // èˆŠç‰ˆ steel å°æ‡‰ç‚º ice
  if(ledStyle === 'steel') ledStyle = 'ice';
  function renderStatsHtml(){
    const fd = (stats.fastestDeath===Infinity)? '-' : stats.fastestDeath.toFixed(2);
    const ld = (stats.longestLife===0)? '-' : stats.longestLife.toFixed(2);
    return `<div class="grid">
      <div>æ¶ˆè€—ç”Ÿå‘½ï¼š<strong>${stats.livesUsed}</strong></div>
      <div>æ¥çƒæ¬¡æ•¸ï¼š<strong>${stats.catches}</strong></div>
      <div>å¢ç›Šæ¬¡æ•¸ï¼š<strong>${stats.buffs}</strong></div>
      <div>æ¸›ç›Šæ¬¡æ•¸ï¼š<strong>${stats.debuffs}</strong></div>
      <div>æ®ºèè‹±æ•¸ï¼š<strong>${stats.eliteKills}</strong></div>
      <div>æ®ºBossæ•¸ï¼š<strong>${stats.bossKills}</strong></div>
      <div>æœ€å¿«æ­»äº¡ï¼š<strong>${fd}</strong> s</div>
      <div>æœ€ä¹…å­˜æ´»ï¼š<strong>${ld}</strong> s</div>
    </div>`;
  }

  let bgTime=0; let screenShake=0;
  let countdownTimer=null, countdownShow=0, resumePending=false;
  // å½±åƒé¸æ“‡ï¼š1~10 éš¨æ©Ÿ bg/cgï¼Œ11~20 ç”¨å°æ‡‰æœªç”¨è€…
  let imageChoice = new Array(10).fill(-1); // 0=bg,1=cg; -1: æœªæ±º
  // BGM
  let audioCtx=null, bgmGain=null, bgmOn=false, bgmStarted=false;
  let bgmNodes=[]; // ä¾¿æ–¼åœæ’­

  // ç²’å­ / ç‰¹æ•ˆå®¹å™¨
  const particles=[]; // {x,y,vx,vy,life,size,color}
  const plasmas=[];   // {x,y,vx,vy,until,radius}
  const holyFlashes=[]; // {x,y,until}
  let phoenixAnim=null; // {x, tEnd}
  const fireBursts=[];  // ç«ç„°ç‰‡æ®µ {x,y,life}

  // æ–°å¢å®¹å™¨ï¼šé£›å½ˆã€é»‘æ´ç‰¹æ•ˆã€é›·å°„å…‰æŸ
  const missiles=[]; // {x,y,vx,vy,targetId,lifeUntil,trail:[]}
  const blackHoles=[]; // {x,y,until}
  const laserBeams=[]; // {x1,y1,x2,y2,until}
  const laserImpacts=[]; // {x,y,t0,tEnd}
  const lockBoxes=[]; // {x,y,w,h,until,kind}

  // === Boss æŠ•å°„ç‰© ===
  const hostileBeams=[]; // ç·šæ€§å…‰æŸå½ˆ {x,y,vx,vy,color,hit,onHit}
  const hostileArcs=[];  // å¼§å½¢åŠæ°£ {x,y,vx,vy,phase,amp,color,onHit}
  const hostileColumns=[]; // ç›´ä¸‹çŸ³åŒ–å…‰æŸ {x,w,tStart,tEnd,color,applied}
  const hazardClouds=[]; // çƒé›² {x,y,tEnd,spawned}

  function bossCenter(){ for(const b of bricks){ if(b.boss) return {b, x:b.x+b.w/2, y:b.y+b.h/2}; } return null; }

  function spawnLionBeamFrom(x,y){ const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2; const ang=Math.atan2(ty-y, tx-x); const speed=6.0; hostileBeams.push({x:x, y:y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); }}); }
  function spawnLionBeam(){
    const bc=bossCenter(); if(!bc) return;
    const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
    const ang=Math.atan2(ty-bc.y, tx-bc.x);
    const speed=6.0;
    hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); }});
  }
  function spawnKnightArc(){
    const bc=bossCenter(); if(!bc) return;
    const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
    const ang=Math.atan2(ty-bc.y, tx-bc.x);
    const speed=3.8;
    hostileArcs.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, phase:0, amp:32, color:'silver', onHit:()=>{ lives=Math.max(0, lives-1); updateHUD(); }});
  }
  function spawnCyclopsColumn(){
    const bc=bossCenter(); if(!bc) return;
    // é¢¨upï¼šåœ¨ boss ä¸Šæ–¹ç™¼å…‰ 2 ç§’
    cyclopsChargeUntil = performance.now() + 2000;
    setTimeout(()=>{
      hostileColumns.push({x:bc.x, w:150, tStart:performance.now(), tEnd:performance.now()+1000, color:'#eedc9a', applied:false});
    },2000);
  }
  function spawnDemonBeam(){
    const bc=bossCenter(); if(!bc) return;
    const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
    const ang=Math.atan2(ty-bc.y, tx-bc.x);
    const speed=7.2;
    hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'#ff3355', hit:false, onHit:()=>{ lives=Math.max(0, lives-1); updateHUD(); }});
  }
  function spawnDemonClouds(){
    const picks = Array.from({length:5}, ()=> 40 + Math.random()*(1100-80));
    const y = layout().top - 10;
    const tEnd = performance.now() + 1000;
    for(const x of picks){ hazardClouds.push({x,y,tEnd,spawned:false}); }
  }
  let nextBossAtkA=0, nextBossAtkB=0, cyclopsChargeUntil=0;

  function updateBossAbilities(){
    const bossLv = (level%5===0)? level : 0;
    if(!bossLv) return;
    const now=performance.now();
    if(bossLv===5){ if(now>=nextBossAtkA){ spawnLionBeam(); nextBossAtkA = now + 10000; } }
    else if(bossLv===10){ if(now>=nextBossAtkA){ spawnKnightArc(); nextBossAtkA = now + 15000; } }
    else if(bossLv===15){ if(now>=nextBossAtkA){ spawnCyclopsColumn(); nextBossAtkA = now + 20000; } }
    else if(bossLv===20){ if(now>=nextBossAtkA){ spawnDemonBeam(); nextBossAtkA = now + 10000; } if(now>=nextBossAtkB){ spawnDemonClouds(); nextBossAtkB = now + 30000; } }
  }

  function drawAndStepBossProjectiles(){
    const pr=paddleRect();
    // é‡‘/ç´…é›·å°„
    for(let i=hostileBeams.length-1;i>=0;i--){
      const b = hostileBeams[i];
      b.x += b.vx; b.y += b.vy;
      // render
      const x1 = (b.x - b.vx*2)*scaleX, y1=(b.y - b.vy*2)*scaleY;
      const x2 = b.x*scaleX, y2=b.y*scaleY;
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const col = b.color==='gold' ? 'rgba(255,220,120,' : (b.color+' ,');
      ctx.strokeStyle = (b.color==='gold') ? 'rgba(255,220,120,0.8)' : 'rgba(255,80,120,0.8)';
      ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
      // hit check
      if(!b.hit && x2>=pr.x*scaleX && x2<= (pr.x+pr.w)*scaleX && y2>=pr.y*scaleY && y2<= (pr.y+pr.h)*scaleY){
        b.hit=true; b.onHit&&b.onHit(pr); spawnParticles(b.x,b.y,'#ffd',12,1.6,2.2,2.5);
      }
      // out of bounds
      if(b.x<0||b.x>1100||b.y<0||b.y>700){ hostileBeams.splice(i,1); }
    }
    // å¼§å½¢åŠæ°£
    for(let i=hostileArcs.length-1;i>=0;i--){
      const a = hostileArcs[i];
      a.phase += 0.15;
      a.x += a.vx + Math.sin(a.phase)*0.9;
      a.y += a.vy + Math.cos(a.phase)*0.4;
      // render
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='rgba(220,220,255,0.9)'; ctx.lineWidth=3;
      ctx.beginPath(); 
      ctx.arc(a.x*scaleX, a.y*scaleY, 22*((scaleX+scaleY)/2), Math.PI*0.2, Math.PI*1.2);
      ctx.stroke();
      // ç²’å­
      for(let k=0;k<3;k++){ particles.push({x:a.x, y:a.y, vx:(Math.random()-0.5)*0.8, vy:(Math.random()-0.5)*0.8, life:220, size:1.6, color:'rgba(220,220,255,0.7)'}); }
      ctx.restore();
      // hit
      if(a.x>=pr.x && a.x<=pr.x+pr.w && a.y>=pr.y && a.y<=pr.y+pr.h){
        a.onHit&&a.onHit(); hostileArcs.splice(i,1);
      }
      if(a.x<0||a.x>1100||a.y>700||a.y<0){ hostileArcs.splice(i,1); }
    }
    // çŸ³åŒ–æŸ±
    for(let i=hostileColumns.length-1;i>=0;i--){
      const c = hostileColumns[i];
      const now=performance.now();
      if(now>c.tEnd){ hostileColumns.splice(i,1); continue; }
      const x = (c.x - c.w/2)*scaleX, y = (layout().top)*scaleY;
      const w = c.w*scaleX, h = (700 - layout().top)*scaleY;
      const alpha = 0.5 + 0.5*Math.sin(now/80);
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const grd = ctx.createLinearGradient(c.x*scaleX, layout().top*scaleY, c.x*scaleX, 700*scaleY);
      grd.addColorStop(0, 'rgba(245,228,150,0.85)'); grd.addColorStop(1, 'rgba(240,210,120,0.35)');
      ctx.fillStyle = grd; ctx.fillRect(x, y, w, h);
      ctx.restore();
      // å‘½ä¸­å¹³å°ï¼šåƒµç›´3ç§’
      const pr = paddleRect();
      if(!c.applied){
        const inter = !( pr.x+pr.w < (c.x - c.w/2) || pr.x > (c.x + c.w/2) );
        if(inter){ paddleStunUntil = Math.max(paddleStunUntil, performance.now()+3000); c.applied=true; }
      }
    }
    // çƒé›²
    for(let i=hazardClouds.length-1;i>=0;i--){
      const cl = hazardClouds[i];
      const now=performance.now();
      // draw cloud
      ctx.save();
      const x = cl.x*scaleX, y=cl.y*scaleY;
      ctx.globalAlpha = 0.9 * Math.max(0, (cl.tEnd - now)/1000);
      ctx.fillStyle='rgba(60,60,80,0.9)';
      ctx.beginPath(); ctx.arc(x-20,y,14,0,Math.PI*2); ctx.arc(x,y-6,18,0,Math.PI*2); ctx.arc(x+18,y,16,0,Math.PI*2); ctx.fill();
      ctx.restore();
      if(now>=cl.tEnd && !cl.spawned){
        // æ‰è½æ¸›ç›Šé“å…·
        const debuffs = ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type==='debuff');
        const type = debuffs[Math.floor(Math.random()*debuffs.length)] || 'FAST';
        powerups.push({x:cl.x-12, y:cl.y, w:GAME_CONFIG.powerCapsule.width, h:GAME_CONFIG.powerCapsule.height, vy:GAME_CONFIG.powerCapsule.fallVy, type, isDebuff:true, phase:Math.random()*Math.PI*2});
        cl.spawned=true;
      }
      if(now > cl.tEnd + 2000){ hazardClouds.splice(i,1); }
    }
  }

  // å¤©åœ°ç¿»è½‰ç‹€æ…‹
  let orientLeft=false; // true æ™‚æ”¹ç‚ºå·¦å´æ“‹æ¿æ¨¡å¼
  let paddleStunUntil=0;


  function spawnParticles(x,y,color,count=10,spread=1.6,speed=3,size=3){
    for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const v=speed*(.4+Math.random()); particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:400+Math.random()*300,size:size*(.6+Math.random()*0.8),color}); }
  }

  // === å·¥å…· ===
  function getDiff(){ return GAME_CONFIG.difficulty[difficultySel.value]; }
  function brickColor(i){ return [getVar('--brick1'),getVar('--brick2'),getVar('--brick3'),getVar('--brick4')][i%4]; }
  function getVar(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }
  function clampHP(h){ return Math.max(1, Math.min(4, (h|0))); }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo((x+r)*scaleX,y*scaleY); ctx.arcTo((x+w)*scaleX,y*scaleY,(x+w)*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo((x+w)*scaleX,(y+h)*scaleY,x*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo(x*scaleX,(y+h)*scaleY,x*scaleX,y*scaleY,r*scaleX); ctx.arcTo(x*scaleX,y*scaleY,(x+w)*scaleX,y*scaleY,r*scaleX); ctx.closePath(); }

  // === çµ±ä¸€é–å®šæ¡†ï¼ˆé¡¯ç¤º 1 ç§’ï¼‰ ===
  function pushLockBox(x,y,w,h,kind='target'){ lockBoxes.push({x,y,w,h,until:performance.now()+1000,kind}); }
  function drawLockBoxes(){
    const now=performance.now();
    for(let i=lockBoxes.length-1;i>=0;i--){
      const b=lockBoxes[i];
      if(now>b.until){ lockBoxes.splice(i,1); continue; }
      const t = 1 - Math.max(0, (b.until-now)/1000);
      const pulse = 0.7 + 0.3*Math.sin(now/100);
      let col = b.kind==='paddle' ? 'rgba(120,220,255,'+(0.6*pulse)+')' : 'rgba(255,220,140,'+(0.6*pulse)+')';
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle = col;
      ctx.lineWidth = 2 + 2*pulse;
      drawRoundedRect(b.x, b.y, b.w, b.h, 10);
      ctx.stroke();
      ctx.restore();
    }
  }


  
  function drawBossEmblem(b){
    const cx = (b.x + b.w/2)*scaleX, cy = (b.y + b.h/2)*scaleY;
    const t = performance.now()/600;
    // è£ç”²å±¤
    ctx.save();
    const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
    g.addColorStop(0,'#5f0d2a'); g.addColorStop(1,'#130812');
    ctx.fillStyle = g; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.fill();
    // å¤–æ¡†å‘¼å¸
    const glow = 0.5 + 0.5*Math.sin(t*2);
    ctx.strokeStyle = 'rgba(255,90,120,'+(0.6*glow)+')'; ctx.lineWidth = 3 + 2*glow;
    drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke();
    // Emblem
    ctx.translate(cx, cy);
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,230,230,0.9)';
    const idx = ['ç…','é¨','ç›®','é­”'].indexOf(b.face);
    if(idx===0){
      // ç…ï¼šé¬ƒæ¯›åœ“ç’° + ç‰™
      ctx.beginPath(); ctx.arc(0,0, Math.min(b.w,b.h)*0.22*scaleX, 0, Math.PI*2); ctx.stroke();
      for(let i=0;i<6;i++){ const a = i*Math.PI/3; ctx.beginPath(); ctx.moveTo(Math.cos(a)*18, Math.sin(a)*18); ctx.lineTo(Math.cos(a)*30, Math.sin(a)*30); ctx.stroke(); }
      ctx.beginPath(); ctx.moveTo(-14,8); ctx.lineTo(-6,14); ctx.moveTo(14,8); ctx.lineTo(6,14); ctx.stroke();
    }else if(idx===1){
      // é¨å£«ï¼šé ­ç›” + ç¾½é£¾
      ctx.beginPath(); ctx.arc(0,0,22,Math.PI*0.15, Math.PI*0.85); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-14,0); ctx.lineTo(14,0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-10,-10); ctx.lineTo(0,-22); ctx.lineTo(10,-10); ctx.stroke();
    }else if(idx===2){
      // ç¨çœ¼ï¼šå·¨çœ¼ + çœ¼ç¼
      ctx.beginPath(); ctx.ellipse(0,0,26,18,0,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,0); ctx.lineTo(26,0); ctx.stroke();
    }else{
      // é­”ç‹ï¼šäº”èŠ’æ˜Ÿ + è§’
      ctx.beginPath();
      for(let i=0;i<5;i++){ const a = -Math.PI/2 + i*2*Math.PI/5; const x = Math.cos(a)*22, y=Math.sin(a)*22;
        const a2 = -Math.PI/2 + ((i*2+2)%10)*Math.PI/5; const x2=Math.cos(a2)*9, y2=Math.sin(a2)*9;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); ctx.lineTo(x2,y2);
      } ctx.closePath(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,-18); ctx.lineTo(-10,-30); ctx.moveTo(26,-18); ctx.lineTo(10,-30); ctx.stroke();
    }
    ctx.restore();
  }

  // === Buff/De-buff é¡¯ç¤º ===
  function badgeIcon(k){ return ((GAME_CONFIG.powers[k] && GAME_CONFIG.powers[k].badge))||'â—'; }
  function updateBuffBadges(){ activeBuffsEl.innerHTML=''; const now=performance.now();
    // LONG å †ç–Š
    const longAct=buffs.LONG.stacks.filter(t=>t>now); if(longAct.length){ const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon('LONG')} LONGÃ—${longAct.length} ${Math.max(0,Math.max(...longAct)-now|0)}ms`; activeBuffsEl.appendChild(s); }
    // å…¶å®ƒ
    for(const key of Object.keys(GAME_CONFIG.powers)){ if(key==='LONG') continue; const b=buffs[key]; if(! (b && b.active)) continue; const left=b.until&&b.until>now?((b.until-now)/1000).toFixed(1)+'s':''; const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon(key)} ${key}${left?' '+left:''}`; activeBuffsEl.appendChild(s); }
  }

  // === Buff ç‹€æ…‹ ===
  const buffs={
    WIDE:{active:false,until:0},
    STICKY:{active:false,until:0},
    MULTI:{active:false,until:0},
    SLOW:{active:false,until:0},
    PIERCE:{active:false,until:0},
    SHIELD:{active:false,until:0},
    RAMPAGE:{active:false,until:0},
    FAST:{active:false,until:0},
    WAVY:{active:false,until:0,start:0},
    LONG:{active:false,until:0,stacks:[]},
    PLASMA:{active:false,until:0},
    FREEZE:{active:false,until:0},
    HOLY:{active:false,until:0},
    TRACK:{active:false,until:0},
    MISSILE:{active:false,until:0},
    HELL:{active:false,until:0},
    MEGA:{active:false,until:0,applied:false},
    CHAIN:{active:false,until:0},
    NARROW:{active:false,until:0},
    HOLE:{active:false,until:0},
    FLIP:{active:false,until:0},
    GODSPEED:{active:false,until:0},
    LASER:{active:false,until:0,lastShot:0},
    FIREBALL:{active:false,until:0,energy:0},
    POISON:{active:false,until:0},
    TELEPORT:{active:false,until:0,nextTeleport:0},
    SWORD:{active:false,until:0,count:0,released:false},
    LASERSTORM:{active:false,until:0,started:false,startAt:0,nextShot:0,targetCount:0},
    BLACKHOLE:{active:false,until:0,deaths:0},
    ANNIHILATION:{active:false,until:0,speeding:false,nextSmash:0},
    ROTATE:{active:false,until:0}
  };

  // === æ“‹æ¿ & çƒ ===
  let diff=getDiff(); const paddle={w:diff.paddleBaseW,h:18,x:1100/2-diff.paddleBaseW/2,y:700-50,speed:12};
  let balls=[];
  // Helper to construct a new ball. Fix incorrect object literal syntax that prevented the game from loading.
  // We want to return an object describing the ball with sensible defaults.  If an explicit x-coordinate
  // is provided we use that, otherwise we default to the horizontal centre of the playfield (1100/2).
  function makeBall(stuck = false, x = null) {
    return {
      x: x != null ? x : (1100 / 2),
      y: 700 / 2,
      r: 10,
      vx: 5,
      vy: -5,
      speedCap: GAME_CONFIG.caps.ballSpeedMax,
      piercing: false,
      stuck: stuck,
      offsetX: 0,
      rampageUntil: 0,
      trail: [],
      freeze: {
        state: 'idle',
        t0: 0,
        until: 0,
        oldVX: 0,
        oldVY: 0,
        delay: 0,
        stop: 0
      }
    };
  }

  // === è²éŸ³èˆ‡BGM ===

  // === BGM ä¸»é¡Œä¾é—œå¡æ®µè½ ===
  
function bgmThemeForLevel(lv){
    // ä¾éœ€æ±‚é‡æ–°è¨­è¨ˆ 8 æ®µé¢¨æ ¼
    // 1~4 è‰åŸé‡ç¸é«˜é€Ÿã€5 ç…å­ç‹æ±ºæˆ°ã€6~9 æ”»å…¥åŸå ¡ã€10 é¨å£«å°æ±ºã€11~14 å·¨äººå±±è°·ã€15 æ±ºæˆ°å·¨äººã€16~19 æƒ¡é­”åŸã€20 é­”ç‹æœ€çµ‚
    if(lv<=4) return 'beast';
    if(lv===5) return 'lion';
    if(lv<=9) return 'castle';
    if(lv===10) return 'knight_duel';
    if(lv<=14) return 'giant_valley';
    if(lv===15) return 'giant_final';
    if(lv<=19) return 'demon_castle';
    return 'final_boss';
}

  let currentBGMTheme = null;
  
function startBGMTheme(theme){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || !bgmOn) return;
    stopBGM();
    bgmStarted=true;
    currentBGMTheme = theme;
    const now=audioCtx.currentTime;

    // è®“æ•´é«”æ›´å¤§è²ä¸€é»ï¼ˆåŒæ™‚ç”± UI æ»‘æ¡¿æ§åˆ¶ç¸½éŸ³é‡ï¼‰
    function tone(freq, type, start, dur, gain=0.075){
      const o=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value=0;
      o.connect(g); g.connect(bgmGain);
      o.start(now+start);
      g.gain.setTargetAtTime(gain, now+start, 0.015);
      g.gain.setTargetAtTime(0.0001, now+start+dur-0.03, 0.02);
      o.stop(now+start+dur+0.1);
      bgmNodes.push(o,g);
    }

    // ä¾çƒé€ŸåŠ å¿«å‘¼å¸ï¼ˆæœ€å¤š 2 å€ï¼‰
    function speedFactor(){
      let spAvg=0; for(const b of balls){ spAvg += Math.hypot(b.vx,b.vy); }
      spAvg = balls.length? spAvg/balls.length : 8;
      const f = 1 + Math.min(1, Math.max(0,(spAvg-8)/8)); // 8~16 ç·šæ€§ 1~2 å€
      return f;
    }

    let step=0; // ç”¨æ–¼ 8 å°ç¯€è®Šå¥
    function scheduleLoop(){
      if(!bgmOn || !bgmStarted) return;
      const f = speedFactor();

      // æ¯ç¨®ä¸»é¡Œæº–å‚™è‡³å°‘ 4 ç¨®è®Šå¥ï¼Œä¾ step(æ¯ 8 å°ç¯€) è¼ªæ›
      const varIdx = (Math.floor(step/8)) % 4;

      // é‡å°ä¸åŒä¸»é¡Œè¨­å®š
      bgmNodes=[];
      if(theme==='beast'){ // è‰åŸé‡ç¸ï¼šé«˜é€Ÿæ„Ÿ
        const tempo = (150/60) * f;
        const kits = [
          {bass:[110,123.47,146.83,164.81], lead:[329.63,349.23,392.00,440.00]},
          {bass:[146.83,164.81,146.83,123.47], lead:[392.00,440.00,392.00,349.23]},
          {bass:[98,110,123.47,110], lead:[293.66,329.63,349.23,392.00]},
          {bass:[130.81,146.83,164.81,146.83], lead:[392.00,440.00,493.88,440.00]},
        ];
        const k = kits[varIdx];
        k.bass.forEach((f0,i)=> tone(f0,'sawtooth', i*0.5/tempo, 0.45/tempo, 0.08));
        k.lead.forEach((f0,i)=> tone(f0,'square', 1 + i*0.25/tempo, 0.20/tempo, 0.07));
        setTimeout(scheduleLoop, Math.round(4000/f));
      }else if(theme==='lion'){ // ç…å­ç‹æ±ºæˆ°ï¼šé©šéšªè¬åˆ†
        const tempo = (132/60) * f;
        const stabs = [
          [220.00,246.94,293.66,261.63],
          [246.94,293.66,329.63,293.66],
          [261.63,246.94,220.00,196.00],
          [293.66,329.63,369.99,329.63],
        ][varIdx];
        stabs.forEach((f0,i)=> tone(f0,'square', i*0.5/tempo, 0.35/tempo, 0.085));
        for(let i=0;i<8;i++) tone(98,'sine', i*0.25/tempo, 0.24/tempo, 0.06);
        setTimeout(scheduleLoop, Math.round(3200/f));
      }else if(theme==='castle'){ // æ”»å…¥åŸå ¡ï¼šæ­¥æ­¥ç‚ºç‡Ÿ
        const tempo = (104/60) * f;
        const arp = [
          [261.63,329.63,392.00,523.25],
          [293.66,369.99,440.00,587.33],
          [246.94,329.63,392.00,493.88],
          [329.63,392.00,493.88,659.25],
        ][varIdx];
        arp.forEach((f0,i)=> tone(f0,'triangle', i*0.5/tempo, 0.46/tempo, 0.07));
        setTimeout(scheduleLoop, Math.round(3600/f));
      }else if(theme==='knight_duel'){ // é¨å£«å°æ±ºï¼šå„ªé›…
        const tempo = (126/60) * f;
        const riff = [
          [196.00,246.94,293.66,246.94],
          [220.00,261.63,329.63,261.63],
          [246.94,293.66,369.99,293.66],
          [261.63,329.63,392.00,329.63],
        ][varIdx];
        riff.forEach((f0,i)=> tone(f0,'sawtooth', i*0.5/tempo, 0.40/tempo, 0.075));
        setTimeout(scheduleLoop, Math.round(3400/f));
      }else if(theme==='giant_valley'){ // å·¨äººå±±è°·ï¼šç†±è¡€
        const tempo = (114/60) * f;
        const drums = [98,82.41,73.42,87.31][varIdx];
        for(let i=0;i<8;i++) tone(drums,'sine', i*0.25/tempo, 0.22/tempo, 0.085);
        const shout=[392,440,392,349.23][varIdx];
        tone(shout,'square', 1.0, 0.3/tempo, 0.09);
        setTimeout(scheduleLoop, Math.round(3600/f));
      }else if(theme==='giant_final'){ // æ±ºæˆ°å·¨äººï¼šå£¯çƒˆ
        const tempo = (92/60) * f;
        const bass=[65.41,73.42,82.41,98.00][varIdx];
        for(let i=0;i<8;i++) tone(bass,'sine', i*0.5/tempo, 0.40/tempo, 0.1);
        const hits=[196,174.61,196,220][varIdx];
        tone(hits,'square', 1.2, 0.28/tempo, 0.09);
        setTimeout(scheduleLoop, Math.round(4200/f));
      }else if(theme==='demon_castle'){ // æƒ¡é­”åŸï¼šç¾¤é­”äº‚èˆ
        const tempo = (140/60) * f;
        const osts = [
          [293.66,277.18,261.63,246.94],
          [246.94,261.63,277.18,293.66],
          [233.08,246.94,261.63,277.18],
          [261.63,246.94,233.08,246.94],
        ][varIdx];
        osts.forEach((f0,i)=> tone(f0,'sawtooth', i*0.25/tempo, 0.22/tempo, 0.08));
        setTimeout(scheduleLoop, Math.round(3000/f));
      }else{ // final_bossï¼šå…‰èˆ‡æš—çš„æœ€å¾Œå»æ®º
        const tempo = (148/60) * f;
        const ost=[293.66,277.18,261.63,246.94,233.08,246.94,261.63,277.18];
        ost.forEach((f0,i)=> tone(f0,'sawtooth', i*0.22/tempo, 0.20/tempo, 0.09));
        const stab=[587.33,554.37,523.25,493.88];
        stab.forEach((f0,i)=> tone(f0,'square', 1.3 + i*0.4/tempo, 0.22/tempo, 0.095));
        setTimeout(scheduleLoop, Math.round(2800/f));
      }
      step++;
    }
    scheduleLoop();
  }
  function applyBGMThemeForLevel(){

    const theme = bgmThemeForLevel(level);
    if(theme!==currentBGMTheme){ startBGMTheme(theme); }
  }

  function ensureAudio(){ if(!audioCtx){ const AC=(window.AudioContext||window.webkitAudioContext); if(AC){ audioCtx=new AC(); } } if(audioCtx && !bgmGain){ bgmGain=audioCtx.createGain(); bgmGain.gain.value=parseFloat(localStorage.getItem('bgm_vol')||'0.85'); bgmGain.connect(audioCtx.destination); } }
  function beep(freq=600,dur=0.05,vol=0.06){ if(!soundsOn||!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.stop(); }, Math.max(10, dur*1000)); }

  function startBGM(){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || bgmStarted) return; if(audioCtx && audioCtx.resume) audioCtx.resume(); bgmStarted=true; applyBGMThemeForLevel();
  }
  function stopBGM(){ bgmStarted=false; bgmNodes.forEach(n=>{try{(n && n.disconnect && n.disconnect())}catch{} }); bgmNodes.length=0; }

  // === ç£šå¡Šèˆ‡æ­ç¤º ===
  let bricks=[]; let brickW=0, brickH=GAME_CONFIG.bricks.brickHeight; let revealRects=[];
  function layout(){ return {rows:getDiff().rowsBase+Math.floor((level-1)%3), cols:GAME_CONFIG.bricks.cols, pad:GAME_CONFIG.bricks.padding, top:GAME_CONFIG.bricks.topOffset, h:GAME_CONFIG.bricks.brickHeight}; }

  // å–å¾—æœ¬é—œé¡¯ç¤ºå½±åƒï¼ˆ1~10éš¨æ©ŸBG/CGï¼›11~20ç”¨å¦ä¸€å¼µï¼‰
  function getLevelImage(levelNum){
    const idx=((levelNum-1)%10);
    if(levelNum<=10){
      if(imageChoice[idx]<0){ imageChoice[idx]= Math.random()<0.5 ? 0:1; }
      return imageChoice[idx]===0? IMG_MAP[idx].bg : IMG_MAP[idx].cg;
    }else{
      if(imageChoice[idx]<0){ imageChoice[idx]=0; } // ä¿åº•
      return imageChoice[idx]===0? IMG_MAP[idx].cg : IMG_MAP[idx].bg;
    }
  }

  // ç‰¹æ®Šç£šæ¨¡æ¿
  function addBrick(list, x,y,w,h, opts={}){
    list.push(Object.assign({x,y,w,h,hp:opts.unbreakable?Infinity:(opts.hp||1), colorIdx:0, explosive:false, unbreakable:false, strong:false, moving:false, vx:0, vy:0, boss:false, face:''}, opts));
  }

  
  function postAdjustAndDensify(L){
    // å°‡ä¸€èˆ¬ç£šè¡€é‡å¹³æ»‘ä¸Šé™ç‚º 4ï¼Œä¸¦è£œç£šè‡³ >= 2/3 é¢ç©
    const rows=L.rows, cols=L.cols, pad=L.pad;
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // ä½”ç”¨ç¶²æ ¼
    const occ = Array.from({length:rows}, ()=> Array(cols).fill(false));
    function markRect(x,y,w,h){
      const cellW = brickW, cellH = brickH;
      const c0 = Math.max(0, Math.min(cols-1, Math.round((x - L.pad) / (cellW + L.pad)) ));
      const r0 = Math.max(0, Math.min(rows-1, Math.round((y - L.top) / (cellH + L.pad)) ));
      const cellsX = Math.max(1, Math.round((w + L.pad) / (cellW + L.pad)));
      const cellsY = Math.max(1, Math.round((h + L.pad) / (cellH + L.pad)));
      for(let rr=0; rr<cellsY; rr++){
        for(let cc=0; cc<cellsX; cc++){
          const c = Math.min(cols-1, c0 + cc);
          const r = Math.min(rows-1, r0 + rr);
          occ[r][c] = true;
        }
      }
    }
    // å…ˆå¤¾è¡€é‡ + æ¨™è¨˜æ—¢æœ‰ä½”ç”¨
    for(const b of bricks){
      if(!b.unbreakable && !b.boss){
        b.hp = clampHP(b.hp||1);
      }
      markRect(b.x,b.y,b.w,b.h);
    }
    // è¨ˆç®—è¦†è“‹åº¦
    let filled = 0;
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(occ[r][c]) filled++;
    const target = Math.ceil(rows*cols * (2/3));
    if(filled >= target) return;

    // ç”±ä¸­å¿ƒå¾€å¤–è£œç£šï¼Œç¶­æŒç¾æ„Ÿ
    const midC = (cols-1)/2, midR = (rows-1)/2;
    const empties = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(!occ[r][c]){
          const score = (c-midC)**2 + (r-midR)**2;
          empties.push({r,c,score});
        }
      }
    }
    

    empties.sort((a,b)=> a.score - b.score);
    const baseHP = Math.min(1 + Math.floor((level-1)/5), 3);
    let idx=0;
    while(filled < target && idx<empties.length){
      const {r,c} = empties[idx++];
      if(occ[r][c]) continue;
      let hp = baseHP + ((level>=13 && r>rows/2)?1:0);
      hp = clampHP(hp);
      const moving = (Math.random()<0.08) && (r%2===0);
      const vx = moving ? ((Math.random()<0.5?-1:1)*0.6) : 0;
      addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp, colorIdx:(r%4), moving, vx});
      occ[r][c] = true  
      filled += 1;
    }
  }

  function initBricks(){
    applyBGMThemeForLevel();
    const L=layout();
    const totalPad=(L.cols+1)*L.pad; brickW=Math.floor((1100-totalPad)/L.cols); brickH=L.h; bricks=[]; revealRects=[];
    // ä¾é—œå¡è¨­è¨ˆé—œå¡å¸ƒå±€
    generateLevel(level, L);
    postAdjustAndDensify(L);
    // æ”¾ç½®èè‹±ç£šï¼ˆç¬¬6é—œä»¥å¾Œï¼Œæœ€å¤š2å€‹ï¼‰
    if(level>=6){ let placed=0; const candidates=bricks.filter(b=>!b.unbreakable && !b.boss);
      const cx=1100/2, cy=(layout().top + (layout().rows* (brickH+layout().pad) - layout().pad))/2;
      candidates.sort((a,b)=> (Math.hypot((a.x+a.w/2)-cx,(a.y+a.h/2)-cy) - Math.hypot((b.x+b.w/2)-cx,(b.y+b.h/2)-cy)) );
      for(const b of candidates){ if(placed>=2) break; b.elite=true; b.hp=Math.min(5, Math.max(3, b.hp||3)); placed++; }
    }
    // é‡ç½® Boss è¨ˆæ™‚
    nextBossAtkA = nextBossAtkB = cyclopsChargeUntil = 0;

    // é¦–æ¬¡é‡åˆ°èè‹±æˆ– Boss æç¤º
    try{
      if(bricks.some(b=>b.boss)){
        showPrompt('boss', 'Bosså‡ºç¾ï¼å°å¿ƒæ‡‰æˆ°ï¼', 'boss');
      } else if(bricks.some(b=>b.elite)){
        showPrompt('elite', 'èè‹±ç£šå‡ºç¾ï¼Œæ‰“å€’å¯ç²é«˜åˆ†ï¼', 'info');
      }
    }catch(e){}
  }

  
  
  // === ä¿®æ­£ï¼šéé—œåˆ¤å®šæ”¹ç‚ºåªçœ‹ã€Œå¯ç ´å£ç£šã€æ˜¯å¦æ¸…ç©º ===
  function hasBreakables(){
    // åªè¦å ´ä¸Šé‚„æœ‰ä¸æ˜¯ä¸å¯ç ´å£çš„ç£šï¼ˆåŒ…å« Boss ä»å­˜æ´»ï¼‰ï¼Œå°±å°šæœªæ¸…é—œ
    return bricks.some(b => !b.unbreakable);
  }

  // === ä¿®æ­£ï¼šæ ¼é»å°é½Šåœ°æ­ç¤ºåº•åœ–ï¼Œé¿å…é»‘æ´èˆ‡æµ®é»èª¤å·® ===
  function revealBrickArea(brick){
    const L = layout();
    const cellW = brickW, cellH = brickH;
    // ä»¥æ ¼é»å®šä½ï¼ˆå››æ¨äº”å…¥ï¼‰
    const c0 = Math.max(0, Math.min(GAME_CONFIG.bricks.cols-1, Math.round((brick.x - L.pad) / (cellW + L.pad)) ));
    const r0 = Math.max(0, Math.min(L.rows-1, Math.round((brick.y - L.top) / (cellH + L.pad)) ));
    // è¦†è“‹çš„æ ¼æ•¸ï¼ˆBoss/å¤§ç£šå¯èƒ½>1ï¼‰
    const cellsX = Math.max(1, Math.round((brick.w + L.pad) / (cellW + L.pad)));
    const cellsY = Math.max(1, Math.round((brick.h + L.pad) / (cellH + L.pad)));
    for(let rr=0; rr<cellsY; rr++){
      for(let cc=0; cc<cellsX; cc++){
        const c = Math.min(GAME_CONFIG.bricks.cols-1, c0 + cc);
        const r = Math.min(L.rows-1, r0 + rr);
        const rx = L.pad + c*(cellW + L.pad);
        const ry = L.top + r*(cellH + L.pad);
        revealRects.push({x:rx, y:ry, w:cellW, h:cellH});
      }
    }
  }
function generateLevel(lv, L){
    const cols=L.cols, rows=L.rows, pad=L.pad, top=L.top;
    const baseHP = 1 + Math.floor((lv-1)/3);
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // é—œå¡å€æ®µ
    const late = lv>=7;
    const later = lv>=11;
    const endgame = lv>=15;

    // Bossæ¯5é—œ
    const isBoss = (lv%5===0);
    if(isBoss){
      // ä¸­å¤®å¤§Bossï¼ˆ2x2ç£šå°ºå¯¸ä¸€å¡Šï¼‰
      const bx = Math.floor(cols/2)-1;
      const by = Math.max(1, Math.floor(rows/2)-1);
      const w = brickW*2 + pad;
      const h = brickH*2 + pad;
      const hpList=[10,20,30,40];
      const bossIdx = Math.floor(lv/5)-1;
      const bossHP = hpList[Math.max(0,Math.min(3,bossIdx))];
      const faces=['ç…','é¨','ç›®','é­”'];
      addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:bossHP, colorIdx:0, boss:true, face:faces[bossIdx], strong:true});
      // å‘¨åœè­·è¡›ç£š
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(c>=bx-2 && c<=bx+3 && r>=by-2 && r<=by+3) continue; // ç•™ Boss å€åŸŸ
          const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
          addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
        }
      }
      // åŠ é»ä¸å¯ç ´å£é‚Šæ¡†
      for(let c=0;c<cols;c+=2) addBrick(bricks, xAt(c), yAt(0), brickW, brickH, {unbreakable:true});
      return;
    }

    // éBossé—œï¼šè¨­è¨ˆä¸åŒæ’åˆ—
    if(lv<=3){
      // åˆå­¸ï¼šæ»¿ç‰ˆ + å°‘é‡çˆ†ç‚¸
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance*0.7;
        addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
      }
    }else if(lv<=6){
      // V å½¢ï¼‹ä¸­é–“èµ°å»Š
      const mid=Math.floor(cols/2);
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(Math.abs(c-mid)===r%5 && r<rows-1){ // V
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+((r%2)?1:0), colorIdx:r%4});
          }else if(r===Math.floor(rows/2) && (c%3===0)){ // ä¸­ç·šçˆ†ç‚¸
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, explosive:true, colorIdx:r%4});
          }
        }
      }
    }else if(lv<=10){
      // åŠ å…¥ä¸å¯ç ´å£éš”æ¿èˆ‡å°‘é‡ç§»å‹•ç£š
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r%4===0 && c%3===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else{
            const moving = (r%3===0 && c%4===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, moving, vx: moving? ((Math.random()<0.5?-1:1)*0.6) : 0});
          }
        }
      }
    }else if(lv<=14){
      // äº¤éŒ¯æ£‹ç›¤ + å¼·åå½ˆå¸¶
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if((r+c)%2===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, strong:(r%4===1)});
          }else if(r%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, moving:true, vx: (Math.random()<0.5?-1:1)*0.8});
          }
        }
      }
    }else{
      // çµ‚ç›¤ï¼šéš§é“ã€ç§»å‹•éšŠå½¢ã€å¼·åå½ˆè­·ç‰†
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r===1 || r===rows-2){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%3===0 && (r%2===0)){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+2, strong:true});
          }else{
            const mv=(r%3===1 && c%2===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, moving:mv, vx: mv?((Math.random()<0.5?-1:1)*1.0):0});
          }
        }
      }
    }
  }


  function canDestroyBrick(b){ const now=performance.now(); if(b.unbreakable) return false; if(b.lockedUntil && now < b.lockedUntil) return false; return true; }
  function damageOrDestroy(i, amount=1){ const b=bricks[i]; if(!b) return; if(b.unbreakable) return; const now=performance.now(); if(b.lockedUntil && now < b.lockedUntil) return; b.hp = (b.hp||1) - amount; if(b.hp<=0){ if(b.elite){ stats.eliteKills++; } revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); score+=10; updateHUD(); } }
  function destroyBrick(i){ const b=bricks[i]; if(!b) return; if(!canDestroyBrick(b)) return; if(b.boss){ b.hp-=1; if(b.hp<=0){ revealBrickArea(b); bricks.splice(i,1); score+=50; stats.bossKills++; updateHUD(); } return; } if(b.elite){ stats.eliteKills++; } revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); score+=10; updateHUD(); }
  function destroyNeighbors(idx){ const b=bricks[idx]; if(!b) return; const L=layout(); const near=[]; for(let j=bricks.length-1;j>=0;j--){ if(j===idx) continue; const t=bricks[j]; const dx=Math.abs((t.x+t.w/2)-(b.x+b.w/2)); const dy=Math.abs((t.y+t.h/2)-(b.y+b.h/2)); const thx=brickW+L.pad+2, thy=brickH+L.pad+2; if(dx<=thx && dy<=thy){ // é„°è¿‘ä¸€æ ¼
        if(canDestroyBrick(t)){ if(t.boss){ t.hp-=1; if(t.hp<=0){ revealBrickArea(t); maybeDropFromBrick(t); bricks.splice(j,1); score+=50; } } else { revealBrickArea(t); maybeDropFromBrick(t); bricks.splice(j,1); score+=10; } }
      }
    }
    updateHUD();
  }

  function explodeAt(cx,cy){
    const radius=Math.max(brickW,brickH)*1.3;
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy);
      if(d<=radius){
        if(b.unbreakable){ continue; }
        // Bossï¼šåªæ‰£è¡€ï¼Œä¸ç§’æ®º
        if(b.boss){
          b.hp -= 1;
          if(b.hp<=0){ revealBrickArea(b); bricks.splice(i,1); score+=50; }
        }else{
          revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); score+=10;
        }
        spawnParticles(bx,by,'#ffdd99',14,1.7,2.6,3);
      }
    }
    spawnParticles(cx,cy,'#ffbb55',24,2.1,3.2,4); updateHUD(); beep(200,0.08,0.08);
  }

  // === æ‰è½é“å…· ===
  const powerups=[]; const ALL_TYPES=Object.keys(GAME_CONFIG.powers); const NORMAL_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='rare'); const RARE_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type==='rare');

  // 10 ç§’æœªå–å¾—ä»»ä½•å¢ç›Š â†’ å¤©ç©ºéš¨æ©Ÿæ‰ 1 å€‹å¢ç›Š
  let lastGainPickupAt = performance.now();
  let nextForcedDropAt = lastGainPickupAt + 10000;

  // === å¤©ç©ºéš¨æ©Ÿå¢ç›Šæ‰è½ï¼ˆç¬¬1é—œæ¯25ç§’ â†’ ç¬¬20é—œæ¯6ç§’ ç·šæ€§éæ¸›ï¼‰ ===
  let nextSkyDropAt = 0;
  function skyDropIntervalMs(lv){
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const s = 25*1000 * (1-t) + 6*1000 * t;
    return s;
  }
  function scheduleNextSkyDrop(){ nextSkyDropAt = performance.now() + skyDropIntervalMs(level); }
  function spawnBeneficialAtTop(){
    const x = 40 + Math.random()*(1100-80);
    const y = layout().top - 20;
    // æŠ½éæ¸›ç›Šé“å…·ï¼ˆå«ç¨€æœ‰ï¼Œä½†æ©Ÿç‡è¼ƒä½ï¼‰
    const goodTypes = ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='debuff');
    let type = goodTypes[Math.floor(Math.random()*goodTypes.length)];
    powerups.push({x, y, w:GAME_CONFIG.powerCapsule.width, h:GAME_CONFIG.powerCapsule.height, vy:GAME_CONFIG.powerCapsule.fallVy, type, isDebuff:false, isSpecial:(GAME_CONFIG.powers[type] && GAME_CONFIG.powers[type].type==='rare'), phase:Math.random()*Math.PI*2});
  }

  

  function maybeDropFromBrick(b){
    if(!b || b.unbreakable) return;
    // Bossä¸æœƒæ‰è½ä¸€èˆ¬å¢ç›Šï¼ˆä¿æŒå¹³è¡¡ï¼‰
    if(b.boss) return;
    // æ‰è½ç‡æŠ‘åˆ¶ï¼šçŸ­æ™‚é–“å¤§é‡æ¶ˆç£šé™ä½æ‰è½
    const nowT = performance.now();
    recentBrickClears.push(nowT);
    while(recentBrickClears.length && nowT - recentBrickClears[0] > 500){ recentBrickClears.shift(); }
    const count = recentBrickClears.length;
    let chance = dropRateForLevel(level);
    if(count >= 3){
      const factors=[0.8,0.6,0.4,0.2];
      const idx=Math.min(count - 3, factors.length - 1);
      chance *= factors[idx];
    }
    if(Math.random() < chance) spawnPower(b.x + b.w/2 - 12, b.y + b.h/2);
  }

  function dropRateForLevel(lv){
    const diff = getDiff();
    const base = diff.dropRate || 0.5;
    const startBoostAt = 8; // ä¸­æœŸé–‹å§‹æå‡æ‰è½ç‡
    const incPerLv = 0.02;
    let inc = Math.max(0, (lv - startBoostAt) * incPerLv);
    let max = 0.9;
    const d = (typeof difficultySel!=='undefined') ? difficultySel.value : 'normal';
    if(d==='normal') max = 0.7;
    if(d==='hard') max = 0.5;
    return Math.min(max, base + inc);
  }

  
function spawnPower(x,y){
  const defs = GAME_CONFIG.powers;
  // éæ¿¾æ‰ä¸è©²æ‰è½çš„é¡å‹ï¼šNONEã€9å‘½ä½¿ç”¨ä¸Šé™ã€æœªé”ç­‰ç´šçš„ç‰¹æ®Šå¢ç›Š
  const allKeys = Object.keys(defs).filter(k => {
    const d = defs[k];
    if(d.type === 'none') return false;
    if(k === 'NINE' && nineUsed >= 2) return false;
    if(d.minLevel && level < d.minLevel) return false;
    return true;
  });
  const normals = allKeys.filter(k=>defs[k].type==='buff');
  const specials = allKeys.filter(k=>defs[k].type==='special' || defs[k].type==='rare');
  const debuffs  = allKeys.filter(k=>defs[k].type==='debuff');

  // æ§‹å»ºæ¬Šé‡ï¼šä¸€èˆ¬å¢ç›Š = 1ï¼Œç‰¹æ®Šå¢ç›Š = 0.1ï¼Œæ¸›ç›Š = 0.6ï¼ˆç¶­æŒäº›è¨±å¨è„…ï¼‰
  const weighted = [];
  // æ™®é€šå¢ç›Š 1.0 æ¬Šé‡ï¼š10 å€‹æ¨£æœ¬
  for (const k of normals) {
    for (let i = 0; i < 10; i++) weighted.push(k);
  }
  // ç‰¹æ®Šå¢ç›Š/ç¨€æœ‰å¢ç›Š 0.1 æ¬Šé‡ï¼š1 å€‹æ¨£æœ¬
  for (const k of specials) {
    weighted.push(k);
  }
  // æ¸›ç›Š 0.6 æ¬Šé‡ï¼š6 å€‹æ¨£æœ¬
  for (const k of debuffs) {
    for (let i = 0; i < 6; i++) weighted.push(k);
  }

  // éš¨æ©Ÿé¸å–é¡å‹
  const type = weighted[Math.floor(Math.random() * weighted.length)];
  const def = defs[type];

  // èª¿æ•´ä¸‹è½é€Ÿåº¦ï¼šæ¸›ç›Šç¨å¿«ï¼Œç‰¹æ®Š/ç¨€æœ‰ç¨æ…¢
  let vy = GAME_CONFIG.powerCapsule.fallVy;
  if (def.type === 'debuff') vy *= 1.18;
  else if (def.type === 'special' || def.type === 'rare') vy *= 0.88;

  powerups.push({
    x: x,
    y: y,
    w: GAME_CONFIG.powerCapsule.width,
    h: GAME_CONFIG.powerCapsule.height,
    vy: vy,
    type: type,
    isDebuff: def.type === 'debuff',
    isSpecial: def.type === 'special' || def.type === 'rare',
    phase: Math.random() * Math.PI * 2,
  });
}

  // === è‡ªè¨‚ç‰¹æ•ˆ ===
  /**
   * é‡‹æ”¾åŠèŠ’ï¼šæ–¼å»¶é²å¾Œä¾åºé‡å°éš¨æ©Ÿç£šå¡Šé€ æˆ 3 é»å‚·å®³
   * @param {number} count é£›åŠæ•¸é‡
   */
  function releaseSwords(count){
    for(let i=0;i<count;i++){
      setTimeout(()=>{
        // é¸æ“‡ä¸€å€‹å¯ç ´å£ç£šå¡Šï¼ˆéš¨æ©Ÿï¼‰
        const targets = bricks.filter(b=>!b.unbreakable);
        if(targets.length===0) return;
        const t = targets[Math.floor(Math.random()*targets.length)];
        // é–å®šä¸¦æ‰£è¡€3
        const idx = bricks.indexOf(t);
        if(idx>=0){
          if(t.boss){ t.hp -= 3; if(t.hp<=0){ revealBrickArea(t); bricks.splice(idx,1); score+=50; } }
          else {
            t.hp = (t.hp||1) - 3;
            if(t.hp<=0){ revealBrickArea(t); maybeDropFromBrick(t); bricks.splice(idx,1); score+=10; }
          }
          spawnParticles(t.x + t.w/2, t.y + t.h/2, '#cfcfff', 16, 1.8, 2.4, 3);
        }
      }, i * 300);
    }
  }

  /**
   * ç«ç„°çƒçˆ†ç‚¸ï¼šæ ¹æ“šç´¯ç©èƒ½é‡æ±ºå®šçˆ†ç‚¸åŠå¾‘ï¼Œå°ç¯„åœå…§ç£šå¡Šé€ æˆç ´å£
   * @param {number} cx ä¸­å¿ƒ x åæ¨™
   * @param {number} cy ä¸­å¿ƒ y åæ¨™
   * @param {number} energy ç´¯ç©èƒ½é‡é»æ•¸
   */
  function fireballExplosionAt(cx, cy, energy){
    // èƒ½é‡é»æ•¸å°æ‡‰åŠå¾‘ï¼š<=5 =>60, <=10 =>100, <=20 =>150, >20 =>250
    let rad = 60;
    if(energy <= 5) rad = 60;
    else if(energy <= 10) rad = 100;
    else if(energy <= 20) rad = 150;
    else rad = 250;
    // å°æ–¼æ¯å€‹ç£šå¡Šï¼Œè‹¥è·é›¢å°æ–¼åŠå¾‘å‰‡æ‰£è¡€/æ‘§æ¯€
    for(let i=bricks.length-1;i>=0;i--){
      const b = bricks[i];
      const bx = b.x + b.w/2, by = b.y + b.h/2;
      const d = Math.hypot(bx - cx, by - cy);
      if(d <= rad){
        if(b.unbreakable) continue;
        if(b.boss){
          b.hp -= 1;
          if(b.hp <= 0){
            revealBrickArea(b);
            bricks.splice(i,1);
            score += 50; stats.bossKills++;
          }
        } else {
          // ä¸€èˆ¬ç£š
          revealBrickArea(b);
          maybeDropFromBrick(b);
          bricks.splice(i,1);
          score += 10;
        }
        spawnParticles(bx, by, '#ff9955', 14, 1.8, 2.6, 3.2);
      }
    }
    spawnParticles(cx, cy, '#ffaa66', 28, 2.2, 3.4, 4.2);
    updateHUD();
    beep(220, 0.1, 0.08);
  }

  /**
   * é»‘æ´çˆ†ç‚¸ï¼šæ ¹æ“šæ­»äº¡æ¬¡æ•¸æ±ºå®šå‚·å®³èˆ‡ç¯„åœ
   */
  function performBlackHoleExplosion(){
    const deaths = buffs.BLACKHOLE.deaths || 0;
    const frac = Math.min(1, deaths / 8);
    const minR = 100, maxR = 500;
    const rad = minR + (maxR - minR) * frac;
    // ä»»æ„æå¤± HP è¨­å®šï¼Œmin 1 max 40
    const damage = Math.round(1 + (40 - 1) * frac);
    const cx = paddle.x + paddle.w/2;
    const cy = orientLeft ? paddle.y + paddle.h/2 : layout().top;
    for(let i=bricks.length-1;i>=0;i--){
      const b = bricks[i];
      if(b.unbreakable) continue;
      const dx=(b.x+b.w/2)-cx;
      const dy=(b.y+b.h/2)-cy;
      const d=Math.hypot(dx,dy);
      if(d <= rad){
        if(b.boss){ b.hp -= damage; if(b.hp<=0){ revealBrickArea(b); bricks.splice(i,1); score+=50; } }
        else { b.hp = (b.hp||1) - damage; if(b.hp<=0){ revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); score+=10; } }
        spawnParticles(b.x+b.w/2,b.y+b.h/2,'#aa66ff',20,2.0,3.0,4.0);
      }
    }
    spawnParticles(cx, cy, '#bb88ff', 32, 2.5, 3.5, 5);
  }

  function applyPower(type){
    const _defC=GAME_CONFIG.powers[type]; if(_defC){ if(_defC.type==='debuff') stats.debuffs++; else if(_defC.type){ stats.buffs++; lastGainPickupAt = performance.now(); nextForcedDropAt = lastGainPickupAt + 10000; } }
const def=GAME_CONFIG.powers[type]; if(!def) return; const now=performance.now();
    // ç½•è¦‹ç¬ç™¼
    if(def.instant && def.type==='rare'){
      if(type==='PHOENIX'){ // é³³å‡°é£›é + ç«ç„° + éš¨æ©Ÿä¸€åŠæ¶ˆé™¤ï¼ˆBossåªæ‰£1ï¼‰
        phoenixAnim={x:canvas.width+220,tEnd:now+1200};
        const keep=[]; for(const b of bricks){
          if(Math.random()<0.5){
            if(b.unbreakable){ keep.push(b); continue; }
            if(b.boss){ b.hp -= 1; if(b.hp>0){ keep.push(b);} else { revealBrickArea(b); score+=50; } }
            else { revealBrickArea(b); maybeDropFromBrick(b); score+=10; }
            fireBursts.push({x:b.x+b.w/2,y:b.y+b.h/2,life:400+Math.random()*400});
          } else keep.push(b);
        }
        bricks=keep; screenShake=6; beep(180,0.12,0.1);
      } else if(type==='NINE'){
        if(nineUsed < 2){
          lives = 9;
          nineUsed++;
          updateHUD();
          spawnParticles(550,350,'#ffd',40,2.2,3.5,4);
          beep(880,0.1,0.06);
        }
      }
      return;
    }
    // å®šæ™‚é¡
    if(def.durationMs){ if(type!=='LONG'){ const b=buffs[type]||(buffs[type]={active:false,until:0}); b.active=true; b.until=now+def.durationMs; } }
    if(def.paddleWidthAdd){ buffs.WIDE.active=true; buffs.WIDE.until=now+def.durationMs; }
    if (def.longPerStackAdd) {
      // LONG é¡å‹å¯ç–ŠåŠ  buffï¼šè¨ˆç®—ç•¶å‰å°šæœªéæœŸçš„å †ç–Šæ•¸é‡ï¼Œè‹¥æœªé”æœ€å¤§å †ç–Šå‰‡æ–°å¢ï¼Œå¦å‰‡è¦†è“‹æœ€æ—©éæœŸè€…
      const act = buffs.LONG.stacks.filter(t => t > now);
      const maxStacks = (def.stacksMax != null ? def.stacksMax : 2);
      if (act.length < maxStacks) {
        buffs.LONG.stacks.push(now + def.durationMs);
      } else {
        const earliest = Math.min(...act);
        const idx = buffs.LONG.stacks.indexOf(earliest);
        if (idx >= 0) buffs.LONG.stacks[idx] = now + def.durationMs;
      }
    }
    if (def.sticky) {
      buffs.STICKY.active = true;
      buffs.STICKY.until = now + def.durationMs;
    }
    if (def.multiDuplicate) {
      // è¤‡è£½çƒé«”ï¼Œé™åˆ¶æœ€å¤§æ•¸é‡ï¼ˆé è¨­ 4 é¡†ï¼‰ï¼›åŸå§‹é‚è¼¯åœ¨çƒæ•¸å°‘æ–¼ 3 æ™‚è¤‡è£½
      const cap = (def.maxBalls != null ? def.maxBalls : 4);
      if (balls.length < 3) {
        const news = [];
        for (const b of balls) {
          const b1 = { ...b };
          b1.trail = [];
          news.push(b1);
        }
        balls = balls.concat(news);
        if (balls.length > cap) balls.length = cap;
      }
    }
    if(def.speedMul){ buffs.SLOW.active=true; buffs.SLOW.until=now+def.durationMs; }
    if(def.piercing){ buffs.PIERCE.active=true; buffs.PIERCE.until=now+def.durationMs; for(const b of balls) b.piercing=true; }
    if(def.oneShotShield){ buffs.SHIELD.active=true; }
    if(def.forcePiercing && def.rampageMs){ buffs.RAMPAGE.active=true; buffs.RAMPAGE.until=now+def.durationMs; for(const b of balls){ b.rampageUntil=now+def.rampageMs; b.piercing=true; } }
    if(def.globalSpeedMul){ buffs.FAST.active=true; buffs.FAST.until=now+def.durationMs; if(def.screenShakeOnApply) screenShake=def.screenShakeOnApply; }
    if(def.wavy){ buffs.WAVY.active=true; buffs.WAVY.until=now+def.durationMs; buffs.WAVY.start=now; }
    if(type==='PLASMA'){ buffs.PLASMA.active=true; buffs.PLASMA.until=now+def.durationMs; }
    if(type==='FREEZE'){ buffs.FREEZE.active=true; buffs.FREEZE.until=now+def.durationMs; }
    if(type==='HOLY'){ buffs.HOLY.active=true; buffs.HOLY.until=now+def.durationMs; }

    if(type==='TRACK'){ buffs.TRACK.active=true; buffs.TRACK.until=now+def.durationMs; }
    if(type==='MISSILE'){ buffs.MISSILE.active=true; buffs.MISSILE.until=now+def.durationMs; }
    if(type==='HELL'){ buffs.HELL.active=true; buffs.HELL.until=now+def.durationMs; }
    if(type==='MEGA'){ if(!buffs.MEGA.active){ for(const ball of balls){ ball.r*=GAME_CONFIG.powers.MEGA.mega.sizeMul; } buffs.MEGA.applied=true; } buffs.MEGA.active=true; buffs.MEGA.until=now+def.durationMs; }
    if(type==='CHAIN'){ buffs.CHAIN.active=true; buffs.CHAIN.until=now+def.durationMs; }
    if(type==='NARROW'){ buffs.NARROW.active=true; buffs.NARROW.until=now+def.durationMs; }
    if(type==='HOLE'){ buffs.HOLE.active=true; buffs.HOLE.until=now+def.durationMs; }
    if(type==='FLIP'){ buffs.FLIP.active=true; buffs.FLIP.until=now+def.durationMs; orientLeft=true; paddle.y=700/2-paddle.w/2; 
        /* AIM BALLS TO LEFT PADDLE ON FLIP START */
        (function(){ 
          const pr = paddleRect();
          const tx = pr.x + pr.w/2;
          const ty = pr.y + pr.h/2;
          for (const b of balls){
            const sp = Math.max(6, Math.hypot(b.vx, b.vy));
            const ang = Math.atan2(ty - b.y, tx - b.x);
            b.vx = Math.cos(ang) * sp;
            b.vy = Math.sin(ang) * sp;
          }
          pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
        })();
        }
    if(type==='GODSPEED'){ buffs.GODSPEED.active=true; buffs.GODSPEED.until=now+def.durationMs; }
    if(type==='LASER'){ buffs.LASER.active=true; buffs.LASER.until=now+def.durationMs; buffs.LASER.lastShot=0; }

    // === æ–°å¢å¢ç›Š / ç‰¹æ®Šå¢ç›Š / æ¸›ç›Šé“å…· ===
    if(type==='FIREBALL'){
      buffs.FIREBALL.active = true;
      buffs.FIREBALL.until = now + def.durationMs;
      buffs.FIREBALL.energy = 0;
      showPrompt('fireball','ç²å¾—å¢ç›Šï¼šç«ç„°çƒï¼Œç´¯ç©èƒ½é‡çˆ†ç‚¸ï¼','buff');
    }
    if(type==='POISON'){
      buffs.POISON.active = true;
      buffs.POISON.until = now + def.durationMs;
      showPrompt('poison','ç²å¾—å¢ç›Šï¼šåŠ‡æ¯’çƒï¼ŒæŒçºŒå‚·å®³ç£šå¡Šã€‚','buff');
    }
    if(type==='TELEPORT'){
      buffs.TELEPORT.active = true;
      buffs.TELEPORT.until = now + def.durationMs;
      buffs.TELEPORT.nextTeleport = 0;
      showPrompt('teleport','ç²å¾—å¢ç›Šï¼šç¬ç§»çƒï¼Œåå½ˆå¾Œç¬ç§»åˆ°é ‚éƒ¨ã€‚','buff');
    }
    if(type==='SWORD'){
      buffs.SWORD.active = true;
      buffs.SWORD.until = now + def.durationMs;
      buffs.SWORD.count = 0;
      buffs.SWORD.released = false;
      showPrompt('sword','ç‰¹æ®Šå¢ç›Šï¼šåŠèŠ’è£‚ç©ºï¼Œè“„åŠ›é£›åŠã€‚','special');
    }
    if(type==='LASERSTORM'){
      buffs.LASERSTORM.active = true;
      buffs.LASERSTORM.until = now + def.durationMs;
      buffs.LASERSTORM.started = false;
      buffs.LASERSTORM.startAt = now;
      buffs.LASERSTORM.nextShot = 0;
      buffs.LASERSTORM.targetCount = 0;
      showPrompt('laserstorm','ç‰¹æ®Šå¢ç›Šï¼šé›·å°„é¢¨æš´ï¼ŒçŒ›çƒˆå°„æ“Šç£šå¡Šï¼','special');
    }
    if(type==='BLACKHOLE'){
      buffs.BLACKHOLE.active = true;
      buffs.BLACKHOLE.until = now + def.durationMs;
      buffs.BLACKHOLE.deaths = 0;
      showPrompt('blackhole','ç‰¹æ®Šå¢ç›Šï¼šé»‘æ´åå™¬ï¼Œæ­»äº¡è¶Šå¤šå¨åŠ›è¶Šå¤§ã€‚','special');
    }
    if(type==='ANNIHILATION'){
      buffs.ANNIHILATION.active = true;
      buffs.ANNIHILATION.until = 0; // ç„¡å›ºå®šæ™‚é–“ï¼ŒæŒçºŒåˆ°ä¸‹ä¸€æ¬¡æ­»äº¡
      buffs.ANNIHILATION.speeding = true;
      buffs.ANNIHILATION.nextSmash = now + 1000;
      buffs.ANNIHILATION.start = now;
      showPrompt('annihilation','ç‰¹æ®Šå¢ç›Šï¼šè¬ç‰©éŠ·æ¯€ï¼Œçƒé€Ÿé½å¢ä¸”éš¨æ©Ÿç²‰ç¢ç£šå¡Šï¼','special');
    }
    if(type==='ROTATE'){
      buffs.ROTATE.active = true;
      buffs.ROTATE.until = now + def.durationMs;
      buffs.ROTATE.start = now;
      showPrompt('rotate','æ¸›ç›Šï¼šå¹³å°ç¿»è½‰ï¼Œè«‹å°å¿ƒæ“ä½œã€‚','debuff');
    }

    updateBuffBadges();
  }

  
function drawPower(p){
  const x=p.x*scaleX, y=p.y*scaleY, w=p.w*scaleX, h=p.h*scaleY;
  const wobble=Math.sin(p.phase)*1.5; p.phase+=0.04;
  ctx.save(); ctx.translate(0,wobble);
  let top,bottom,textColor='#fff';

  if(p.isDebuff){ // æ¸›ç›Šï¼šç´…åº•ç™½å­—ã€æ‰è½æ›´å¿«
    top='#ff4d6d'; bottom='#a33';
  }else if(p.isSpecial){ // ç‰¹æ®Šå¢ç›Šï¼šé‡‘åº•é»‘å­—ï¼Œé–ƒäº®
    top='#f6d365'; bottom='#fda085'; textColor='#111';
  }else{ // ä¸€èˆ¬å¢ç›Šï¼šè—åº•ç™½å­—
    top='#6aa2ff'; bottom='#3a56a8';
  }

  const grd=ctx.createLinearGradient(x,y,x,y+h);
  grd.addColorStop(0,top); grd.addColorStop(1,bottom);
  ctx.fillStyle=grd; roundedRect(x,y,w,h,8); ctx.fill();
  ctx.strokeStyle=p.isSpecial?'rgba(255,220,150,.85)':'rgba(255,255,255,.25)'; ctx.stroke();

  // é–ƒäº®é‚Šå…‰ï¼ˆç‰¹æ®Šï¼‰
  if(p.isSpecial){
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.shadowColor='rgba(255,230,160,1)'; ctx.shadowBlur=18;
    ctx.strokeStyle='rgba(255,230,160,0.8)';
    roundedRect(x-1,y-1,w+2,h+2,9); ctx.stroke();
    ctx.restore();
  }

  ctx.fillStyle=textColor;
  ctx.font=`${Math.max(10,Math.round(12*scaleY))}px ui-monospace, monospace`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(p.type[0], x+w/2, y+h/2+0.5);
  ctx.restore();

  // close drawPower function
}


  function updateHUD(){ scoreEl.textContent=Math.max(0|score,0); levelEl.textContent=level + '/'+ GAME_CONFIG.totalLevels; livesEl.textContent=lives; }
  function showCenter(t, txt){
    noteTitle.textContent = t;
    noteText.innerHTML = txt || '';
    centerNote.style.display = 'flex';
  }
  function showGameOver(){
    paused = true; running = false; gameOver = true;
    hideCenter();
    const fs2 = document.getElementById('finalScore2'); if(fs2) fs2.textContent = String(Math.max(0|score,0));
    const so  = document.getElementById('statsOver'); if(so)  so.innerHTML = renderStatsHtml();
    if(gameover&&gameover.classList)gameover.classList.add('show');
  }
  function hideCenter(){ centerNote.style.display='none'; }

  function resetGame(load=false){ diff=getDiff(); level=load?level:1; score=load?score:0; lives=load?lives:3; updateHUD(); initBricks(); resetBalls(); paused=true; running=false;
    for(const k of Object.keys(buffs)){ if(k!=='LONG'){ buffs[k].active=false; buffs[k].until=0; } } buffs.LONG.stacks=[]; powerups.length=0; particles.length=0; plasmas.length=0; holyFlashes.length=0; phoenixAnim=null; fireBursts.length=0;
    updateBuffBadges(); computePaddleWidth(); paddle.x=1100/2-paddle.w/2; showCenter('æŒ‰ Space æˆ–é»ç•«é¢é–‹å§‹','ç”¨ â†/â†’ æˆ– A/D ç§»å‹•ï¼›æ‰‹æŒ‡æ‹–æ›³ç•«é¢ä¹Ÿå¯ã€‚'); countdownShow=0; scheduleNextSkyDrop(); }

  // === å­˜è®€æª”ï¼ˆå«éŸ³æ•ˆ/BGMèˆ‡å½±åƒé¸æ“‡ï¼‰ ===
  function saveProgress(){ try{
      const data={level,score,lives,difficulty:difficultySel.value, imageChoice, soundsOn, bgmOn, bgmVol: parseFloat(bgmVol.value)};
      localStorage.setItem('breakout_save_v_final_cfg', JSON.stringify(data)); alert('å·²å­˜æª”ï¼');
    }catch(e){ alert('å­˜æª”å¤±æ•—ï¼š'+e); } }
  function loadProgress(){ try{ const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4'); if(!raw){ alert('æ²’æœ‰å­˜æª”'); return; } const data=JSON.parse(raw);
      difficultySel.value=data.difficulty||'normal'; level=data.level||1; score=data.score||0; lives=data.lives||3; if(Array.isArray(data.imageChoice)) imageChoice=data.imageChoice;
      soundsOn=!!data.soundsOn; soundBtn.textContent=`éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`;
      if(typeof data.bgmOn==='boolean'){ bgmOn=data.bgmOn; } if(typeof data.bgmVol==='number'){ bgmVol.value=String(data.bgmVol); if(bgmGain) bgmGain.gain.value=data.bgmVol; localStorage.setItem('bgm_vol', data.bgmVol); }
      resetGame(true); updateHUD(); alert(`å·²è®€æª”ï¼šç­‰ç´š ${level}ï¼Œåˆ†æ•¸ ${score}ï¼Œç”Ÿå‘½ ${lives}`);}catch(e){ alert('è®€æª”å¤±æ•—ï¼š'+e); } }
  function clearSave(){ localStorage.removeItem('breakout_save_v_final_cfg'); alert('å·²æ¸…é™¤å­˜æª”'); }

  // === è¼¸å…¥ï¼ˆå«è§¸æ§ï¼‰ ===
  let keyL=false, keyR=false; let touchActive=false;
  window.addEventListener('keydown',(e)=>{ if(gameOver){ e.preventDefault(); return; }
    if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=true;
    if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=true;
    if(e.code==='Space'){ e.preventDefault(); // é–‹å§‹ / æš«åœ / å€’æ•¸
      if(!running){ startGameWithCountdown(); } else { togglePause(); }
      return;
    }
    if((e.code==='ArrowUp' || e.key==='Shift') && !paused && running){
      let released=false;
      for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy = -Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
    if(e.key==='r'||e.key==='R'){ resetGame(); }
    if(e.key==='f'||e.key==='F'){ toggleFullscreen(); }
  });
  window.addEventListener('keyup',(e)=>{ if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=false; if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=false; });
  canvas.addEventListener('mousemove',(e)=>{ const rect=canvas.getBoundingClientRect(); if(performance.now()<=paddleStunUntil) return; if(!orientLeft){ const x=(e.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(e.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } });
  canvas.addEventListener('click',()=>{ if(gameOver){ return; }
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  });
  canvas.addEventListener('touchstart',(e)=>{ if(gameOver){ e.preventDefault(); return; } touchActive=true; 
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  }, {passive:true});
  canvas.addEventListener('touchmove',(e)=>{ if(!touchActive) return; if(performance.now()<=paddleStunUntil) return; const t=e.touches[0]; const rect=canvas.getBoundingClientRect(); if(!orientLeft){ const x=(t.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(t.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } }, {passive:true});
  canvas.addEventListener('touchend',()=>{ touchActive=false; }, {passive:true});
  pauseBtn.addEventListener('click',()=>togglePause()); resetBtn.addEventListener('click',()=>resetGame()); fsBtn.addEventListener('click',()=>toggleFullscreen());
  soundBtn.addEventListener('click',()=>{ soundsOn=!soundsOn; localStorage.setItem('sfx_on', soundsOn?'1':'0'); soundBtn.textContent=`éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`; ensureAudio(); if(audioCtx && audioCtx.resume) audioCtx.resume(); beep(880,0.06,0.05); });
  difficultySel.addEventListener('change',()=>{ resetGame(); });
  if(ledStyleSel){ ledStyleSel.value = ledStyle; ledStyleSel.addEventListener('change', ()=>{ ledStyle = ledStyleSel.value; localStorage.setItem('led_style', ledStyle); }); }
  saveBtn.addEventListener('click',saveProgress); loadBtn.addEventListener('click',loadProgress); clearSaveBtn.addEventListener('click',clearSave);
  tutorBtn.addEventListener('click', ()=> toggleHelp('tutor'));
  effectsBtn.addEventListener('click', ()=> toggleHelp('effects'));
  againBtn.addEventListener('click', ()=>{ win.classList.remove('show'); resetGame(); });

  // BGM UI
  bgmBtn.addEventListener('click', ()=>{
    bgmOn=!bgmOn; localStorage.setItem('bgm_on', bgmOn?'1':'0'); bgmBtn.textContent= bgmOn?'é–‹':'é—œ';
    if(bgmOn){ ensureAudio(); startBGM(); } else { stopBGM(); }
  });
  bgmVol.addEventListener('input', ()=>{
    ensureAudio(); const v=parseFloat(bgmVol.value||'0.5'); if(bgmGain) bgmGain.gain.value=v; localStorage.setItem('bgm_vol', v);
  });

  function togglePause(){
    if(!running){ startGameWithCountdown(); return; }
    paused=!paused;
    if(paused){ showCenter('å·²æš«åœ','æŒ‰ Space / é»ç•«é¢ç¹¼çºŒ'); }
    else { startCountdown(); }
  }

  function startGameWithCountdown(){
    running=true; paused=true; hideCenter();
    ensureAudio(); if(audioCtx && audioCtx.resume) audioCtx.resume();
    // éŸ³æ•ˆèˆ‡BGMè¨­å®šè¼‰å…¥
    soundsOn = (localStorage.getItem('sfx_on')||'0')==='1';
    soundBtn.textContent=`éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`;
    bgmOn = (localStorage.getItem('bgm_on')||'0')==='1';
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.85'); bgmVol.value=String(v); ensureAudio(); if(bgmGain) bgmGain.gain.value=v;
    bgmBtn.textContent = bgmOn?'é–‹':'é—œ';
    if(bgmOn) startBGM(); applyBGMThemeForLevel();
    startCountdown();
  }

  // === æ•™å­¸/æ•ˆæœèªªæ˜ ===
  let helpMode=null; // 'tutor' | 'effects' | null
  function toggleHelp(mode){
    if(helpMode===mode){ helpMode=null; hideCenter(); if(running){ startCountdown(); } else { startGameWithCountdown(); } return; }
    helpMode=mode;
    paused=true;
    if(mode==='tutor'){
      showCenter('æ•™å­¸ï¼ˆæŒ‰éˆ•å†æŒ‰ä¸€æ¬¡é—œé–‰ï¼‰', `
        <div class="cols">
          <div>
            <strong>æ“ä½œ</strong><br>
            é›»è…¦ï¼š<kbd>â†</kbd>/<kbd>â†’</kbd> æˆ– <kbd>A</kbd>/<kbd>D</kbd> ç§»å‹•ï¼›<kbd>Space</kbd> é–‹å§‹/æš«åœã€‚<br>
            é‡‹æ”¾é»ä½çš„çƒï¼š<kbd>â†‘</kbd> æˆ– <kbd>Shift</kbd>ã€‚<br>
            æ‰‹æ©Ÿï¼šæ‰‹æŒ‡æ‹–æ›³æ“‹æ¿ä½ç½®å³å¯ã€‚<br>
            å…¨è¢å¹•ï¼š<kbd>F</kbd>ã€‚
          </div>
          <div>
            <strong>ç›®æ¨™</strong><br>
            æ‰“ç ´æ‰€æœ‰å¯ç ´å£ç£šé€²å…¥ä¸‹ä¸€é—œã€‚æ¯ 5 é—œæœ‰ Bossï¼ˆåªæ‰£è¡€ä¸æœƒè¢«ç§’æ®ºï¼‰ã€‚<br>
            ç¬¬ 1~10 é—œèˆ‡ 11~20 é—œæœƒåˆ†åˆ¥é¡¯ç¤ºåŒçµ„ç…§ç‰‡çš„ä¸åŒå¼µï¼Œ20 é—œçµæŸæ’­æ”¾é€šé—œç•«é¢ã€‚
          </div>
          <div>
            <strong>å­˜è®€æª”</strong><br>
            å¯å„²å­˜é—œå¡/åˆ†æ•¸/ç”Ÿå‘½ã€é›£åº¦ã€ç…§ç‰‡é¸æ“‡ã€éŸ³æ•ˆ/BGM è¨­å®šã€‚
          </div>
        </div>`);
    }else{
      // æ•ˆæœèªªæ˜ï¼šå¾ powers è¼¸å‡º
      let html = '<div class="cols">';
      html += '<div><strong>å¢ç›Š/ç¨€æœ‰</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p=GAME_CONFIG.powers[k]; if(p.type==='debuff') continue;
        html += `${badgeIcon(k)} <em>${k}</em>ï¼š${p.label}<br>`;
      }
      html += '</div><div><strong>æ¸›ç›Š</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p=GAME_CONFIG.powers[k]; if(p.type!=='debuff') continue;
        html += `${badgeIcon(k)} <em>${k}</em>ï¼š${p.label}<br>`;
      }
      html += '</div><div><strong>ç‰¹æ®Šç£š</strong><br>ä¸å¯ç ´å£ç£šï¼šåªåå½ˆä¸æœƒå£ï¼›<br>ç§»å‹•ç£šï¼šæ°´å¹³ç§»å‹•ï¼›<br>å¼·åå½ˆç£šï¼šåå½ˆæ™‚åŠ é€Ÿæ›´å¼·ï¼›<br>Bossç£šï¼šå¤§å°ºå¯¸ã€åªæ‰£è¡€ï¼Œçˆ†ç‚¸/ç¥è–/é³³å‡°ä¹Ÿä¸æœƒè¢«ç§’æ®ºã€‚</div>';
      html += '</div>';
      showCenter('æ•ˆæœèªªæ˜ï¼ˆæŒ‰éˆ•å†æŒ‰ä¸€æ¬¡é—œé–‰ï¼‰', html);
    }
  }

  // === å…¨è¢å¹• ===
  async function toggleFullscreen(){
    const elem = document.documentElement;
    try{
      if(!document.fullscreenElement){
        await elem.requestFullscreen();
      }else{
        await document.exitFullscreen();
      }
    }catch(e){
      console.warn('Fullscreen failed:', e);
    }
  }

  // === æ“‹æ¿å¯¬åº¦ ===
  function computePaddleWidth(){ const now=performance.now(); buffs.LONG.stacks=buffs.LONG.stacks.filter(t=>t>now); const longStacks=Math.min(GAME_CONFIG.powers.LONG.stacksMax, buffs.LONG.stacks.length);
    const addLong=longStacks*(GAME_CONFIG.powers.LONG.longPerStackAdd||0); const addWide=(buffs.WIDE.active?(GAME_CONFIG.powers.WIDE.paddleWidthAdd||0):0); const base=getDiff().paddleBaseW;
    let newW=Math.min(GAME_CONFIG.caps.paddleMaxW, base+addWide+addLong);
    if((buffs.NARROW && buffs.NARROW.active)) newW = Math.max(60, newW*0.5);
    const center=paddle.x+paddle.w/2; paddle.w=newW; paddle.x=Math.max(0, Math.min(1100-paddle.w, center - paddle.w/2)); }

  // æ“‹æ¿åœ¨ä¸åŒæœå‘ä¸‹çš„å¯¦éš›çŸ©å½¢
  function paddleRect(){
    // æ©«å‘ï¼šx,y,w,hï¼›ç¸±å‘ï¼šä»¥ h ç‚ºåšåº¦ã€w ç‚ºé•·åº¦
    if(!orientLeft){
      return {x:paddle.x, y:paddle.y, w:paddle.w, h:paddle.h};
    }else{
      // å·¦å´ï¼šå›ºå®šé å·¦ 40px
      const thick = paddle.h;
      const len = paddle.w;
      const x = 40; // èˆ‡ç‰†è·
      return {x:x, y:Math.max(0, Math.min(700-len, paddle.y)), w:thick, h:len};
    }
  }


  function speedMultiplier(now){
    // è¨ˆç®—ç•¶å‰é€Ÿåº¦å€ç‡ï¼šæ…¢é€Ÿã€å¿«é€Ÿã€æ³¢æµªç­‰ buff å¯èƒ½å½±éŸ¿é€Ÿåº¦
    let mul = 1.0;
    if (buffs.SLOW.active) {
      const s = GAME_CONFIG.powers.SLOW.speedMul;
      mul *= (s != null ? s : 1.0);
    }
    if (buffs.FAST.active) {
      const s = GAME_CONFIG.powers.FAST.globalSpeedMul;
      mul *= (s != null ? s : 1.0);
    }
    if (buffs.WAVY.active) {
      const w = GAME_CONFIG.powers.WAVY.wavy || {amp: 0.6, base: 1.2, periodMs: 200};
      const phase = (now - (buffs.WAVY.start || now)) / (w.periodMs);
      mul *= (w.base + w.amp * Math.sin(phase));
    }
    return mul;
  }

  // === èƒŒæ™¯è£é£¾ & LED ç‡ˆæ¢ ===
  function ledColor(){
    if(buffs.GODSPEED.active) return '#ffe066';
    if(buffs.HOLY.active) return '#ffe08a';
    if(buffs.HELL.active) return '#a08cff';
    if(buffs.PLASMA.active) return '#9fe8ff';
    if(buffs.FREEZE.active) return '#cfe9ff';
    if(buffs.RAMPAGE.active || buffs.PIERCE.active || buffs.TRACK.active) return '#7fd8ff';
    if(buffs.FAST.active) return '#ffb37a';
    if(buffs.WAVY.active) return '#ba8fff';
    return '#8fb3ff';
  }

  function drawBGDecor(){ const w=canvas.width,h=canvas.height; bgTime+=0.003; ctx.save(); ctx.globalAlpha=0.12; ctx.translate(Math.sin(bgTime)*8, Math.cos(bgTime*0.7)*6); const step=40;

    for(let x=0;x<w;x+=step){ ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(x,0,1,h);} for(let y=0;y<h;y+=step){ ctx.fillStyle='rgba(255,255,255,.025)'; ctx.fillRect(0,y,w,1);} ctx.restore();
    const grad=ctx.createRadialGradient(w/2,h*0.2,0,w/2,h*0.5,Math.max(w,h)); grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
    if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }

    // é³³å‡°ç«ç„°æ®˜ç•™
    for(let i=fireBursts.length-1;i>=0;i--){ const f=fireBursts[i]; f.life-=16; if(f.life<=0){ fireBursts.splice(i,1); continue; } const a=Math.min(1, f.life/600); const rx= (f.x*scaleX), ry=(f.y*scaleY); const r=60*((scaleX+scaleY)/2); const g=ctx.createRadialGradient(rx,ry,1,rx,ry,r); g.addColorStop(0,`rgba(255,180,0,${0.6*a})`); g.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(rx,ry,r,0,Math.PI*2); ctx.fill(); }


    // LED ç‡ˆæ¢æ¡†ï¼ˆå¤šé¢¨æ ¼ï¼Œè½çƒå€åŸŸç„¡ç‡ˆæ¢ï¼‰
    const c=ledColor();
    let spAvg=0; for(const b of balls){ spAvg += Math.hypot(b.vx,b.vy); } spAvg = balls.length? spAvg/balls.length : 8;
    const nowT = performance.now();
    const fSp = (function(){ let spAvg=0; for(const b of balls){ spAvg += Math.hypot(b.vx,b.vy); } spAvg = balls.length? spAvg/balls.length : 8; return 1 + Math.min(1, Math.max(0,(spAvg-8)/8)); })();
    const breathClassic = (Math.sin(nowT / ((180 - Math.min(120, spAvg*6)) / fSp))+1)/2; // åŸï¼šä¾çƒé€Ÿ
    const breath5 = (Math.sin(nowT / ((5000/fSp) / (2*Math.PI)))+1)/2;  // 5s
    const breath3 = (Math.sin(nowT / ((3000/fSp) / (2*Math.PI)))+1)/2;  // 3s
    const breath8 = (Math.sin(nowT / ((8000/fSp) / (2*Math.PI)))+1)/2;  // 8s

    function pathThreeSides(){
      ctx.beginPath();
      if(!orientLeft){
        ctx.moveTo(6,6); ctx.lineTo(w-6,6);
        ctx.moveTo(6,6); ctx.lineTo(6,h-6);
        ctx.moveTo(w-6,6); ctx.lineTo(w-6,h-6);
      }else{
        ctx.moveTo(6,6); ctx.lineTo(w-6,6);
        ctx.moveTo(w-6,6); ctx.lineTo(w-6,h-6);
        ctx.moveTo(6,h-6); ctx.lineTo(w-6,h-6);
      }
    }

    ctx.save();
    switch(ledStyle){
      case 'tech': {
        ctx.globalAlpha = 0.55 + 0.35*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=8; ctx.shadowColor=c; ctx.shadowBlur=28 + 10*breath5;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'arc': {
        ctx.globalAlpha = 0.5 + 0.25*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=5; ctx.shadowColor=c; ctx.shadowBlur=16 + 6*breath5;
        pathThreeSides(); ctx.setLineDash([14,10]); ctx.lineDashOffset = -(nowT/20); ctx.stroke();
        ctx.setLineDash([]); ctx.globalAlpha = 0.3 + 0.2*breath8; ctx.lineWidth=2.5; ctx.shadowBlur=0;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'steel': {
        ctx.globalAlpha = 0.65 + 0.25*breath5;
        const g = ctx.createLinearGradient(0,0,w,0);
        g.addColorStop(0, 'rgba(220,230,255,0.85)');
        g.addColorStop(0.5, 'rgba(120,140,180,0.85)');
        g.addColorStop(1, 'rgba(200,210,240,0.85)');
        ctx.strokeStyle=g; ctx.lineWidth=7.5; ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=12;
        pathThreeSides(); ctx.stroke();
        ctx.shadowBlur=0; ctx.fillStyle=c;
        const ends = !orientLeft ? [[6,6],[w-6,6]] : [[w-6,6],[w-6,h-6]];
        for(const [ex,ey] of ends){ ctx.beginPath(); ctx.arc(ex,ey,6 + 2*breath5, 0, Math.PI*2); ctx.fill(); }
        break;
      }
      case 'vivid': {
        ctx.globalAlpha = 0.5 + 0.5*breath3;
        const grad = ctx.createLinearGradient(0,0,w,0);
        grad.addColorStop(0, 'rgba(255,255,255,0.85)');
        grad.addColorStop(1, c);
        ctx.strokeStyle=grad; ctx.lineWidth=4.5;
        for(const off of [-4,0,4]){ ctx.save(); ctx.translate(0,off); pathThreeSides(); ctx.stroke(); ctx.restore(); }
        break;
      }
      case 'reaper': {
        // éŠ€ç°é–éˆ + è¡€ç´…åˆå§‹è‰² + é®åˆ€
        const cc = '#c0c3cc';
        ctx.globalAlpha = 0.6 + 0.3*breath5;
        ctx.strokeStyle=cc; ctx.lineWidth=3.5; ctx.setLineDash([8,6]); ctx.lineDashOffset = -(nowT/25);
        pathThreeSides(); ctx.stroke(); ctx.setLineDash([]);
        // é®åˆ€åˆ€åˆƒï¼ˆè½‰æŠ˜è™•ï¼‰
        ctx.fillStyle = 'rgba(220,220,230,0.9)';
        const blades = !orientLeft ? [[6,6],[w-6,6],[6,h-6]] : [[6,6],[w-6,6],[w-6,h-6]];
        for(const [bx,by] of blades){ ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(bx+16,by-8); ctx.lineTo(bx+8,by+12); ctx.closePath(); ctx.fill(); }
        break;
      }
      case 'flame': {
        // ç«ç„°ç°‡
        ctx.globalAlpha = 0.5 + 0.3*breath5;
        const drawFlame = (px,py)=>{ ctx.save(); ctx.translate(px,py); ctx.rotate((Math.sin(nowT/700+px*0.01)+1)/10); const g=ctx.createRadialGradient(0,0,0,0,0,14); g.addColorStop(0,'rgba(255,230,120,0.95)'); g.addColorStop(1,'rgba(255,120,60,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.fill(); ctx.restore(); };
        for(let i=0;i<w;i+=48){ drawFlame(i+8, 8+6*Math.sin(i+nowT/500)); }
        for(let i=0;i<h;i+=50){ drawFlame(8, i+8); drawFlame(w-8, i+8); }
        // å¤–æ¡†æ·¡å…‰
        ctx.strokeStyle=c; ctx.lineWidth=2.2; pathThreeSides(); ctx.stroke();
        break;
      }
      default: {
        ctx.globalAlpha = 0.6 + 0.3*breathClassic;
        ctx.strokeStyle=c; ctx.lineWidth=6; ctx.shadowColor=c; ctx.shadowBlur=20 + 10*breathClassic; pathThreeSides(); ctx.stroke();
        break;
      }
    }
    ctx.restore();}

  // åªåœ¨ç£šå¡Šå€åŸŸæ­ç¤ºåœ–ç‰‡åˆ‡ç‰‡ï¼ˆä¾æœ¬é—œå½±åƒï¼‰
  function drawRevealTiles(){ const img=getLevelImage(level); if(!img || !(img.naturalWidth>0 && img.naturalHeight>0)) return; const L=layout();
    const area={x:L.pad,y:L.top,w:1100-L.pad*2,h:L.rows*(brickH+L.pad)-L.pad}; const rImg=img.naturalWidth/img.naturalHeight; const rArea=area.w/area.h; let dw,dh;
    if(rImg>rArea){ dh=area.h; dw=dh*rImg; } else { dw=area.w; dh=dw/rImg; } const dx=area.x+(area.w-dw)/2; const dy=area.y+(area.h-dh)/2;
    for(const r of revealRects){
      let sx=(r.x-dx)/dw*img.naturalWidth;
      let sy=(r.y-dy)/dh*img.naturalHeight;
      let sw=r.w/dw*img.naturalWidth;
      let sh=r.h/dh*img.naturalHeight;
      const sx0=Math.max(0, Math.min(img.naturalWidth, sx));
      const sy0=Math.max(0, Math.min(img.naturalHeight, sy));
      const sw0=Math.max(0, Math.min(img.naturalWidth - sx0, sw));
      const sh0=Math.max(0, Math.min(img.naturalHeight - sy0, sh));
      if(sw0>0 && sh0>0){
        ctx.drawImage(img, sx0,sy0,sw0,sh0, r.x*scaleX, r.y*scaleY, r.w*scaleX, r.h*scaleY);
      }
    } }

  function drawPlasmas(){ const now=performance.now(); ctx.save(); for(let i=plasmas.length-1;i>=0;i--){ const P=plasmas[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.995; P.vy*=0.995; if(now>P.until){ plasmas.splice(i,1); continue; }
      const x=P.x*scaleX, y=P.y*scaleY, r=P.radius*((scaleX+scaleY)/2); const grd=ctx.createRadialGradient(x,y,2,x,y,r); grd.addColorStop(0,'rgba(150,230,255,0.9)'); grd.addColorStop(0.4,'rgba(120,200,255,0.35)'); grd.addColorStop(1,'rgba(120,200,255,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(180,240,255,0.5)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,r*0.7,0,Math.PI*2); ctx.stroke();
      // æ²¿é€”æ¸…é™¤ç£šå¡Šï¼ˆBoss/ä¸å¯ç ´å£è±å…ï¼‰
      for(let j=bricks.length-1;j>=0;j--){ const b=bricks[j]; const bx=b.x+b.w/2, by=b.y+b.h/2; if(Math.hypot(P.x-bx,P.y-by)<=P.radius){
          if(b.unbreakable) continue;
          if(b.boss){ b.hp-=1; if(b.hp<=0){ revealBrickArea(b); bricks.splice(j,1); score+=50; } }
          else { revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(j,1); score+=10; }
        }
      }
    } ctx.restore(); }

  function drawHoly(){ const now=performance.now(); for(let i=holyFlashes.length-1;i>=0;i--){ const H=holyFlashes[i]; if(now>H.until){ holyFlashes.splice(i,1); continue; } const a=Math.max(0, (H.until-now)/300); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle=`rgba(255,240,180,${0.6*a})`; ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(0, H.y*scaleY); ctx.lineTo(canvas.width, H.y*scaleY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(H.x*scaleX, 0); ctx.lineTo(H.x*scaleX, canvas.height); ctx.stroke(); ctx.restore(); } }

  function drawPhoenix(){ if(!phoenixAnim) return; const now=performance.now(); const t=phoenixAnim; const prog=1-Math.max(0,(t.tEnd-now)/1200); const logicW=1100; const xLogic=(1-prog)*(logicW+200)-200; const x=xLogic*scaleX;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    // èº«å½¢å…‰ç¾½
    const grad=ctx.createLinearGradient((x+120),220*scaleY,x,260*scaleY); grad.addColorStop(0,'rgba(255,180,0,0.9)'); grad.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=grad;
    ctx.beginPath(); ctx.moveTo((x+180), 220*scaleY); ctx.quadraticCurveTo((x+60), 180*scaleY, (x), 230*scaleY); ctx.quadraticCurveTo((x-40), 260*scaleY, (x+120), 260*scaleY); ctx.closePath(); ctx.fill();
    // ç¾½æ¯›ç²’å­
    for(let i=0;i<3;i++){ fireBursts.push({x:(x-40)+Math.random()*120,y:220+Math.random()*60,life:300+Math.random()*400}); }
    ctx.restore(); if(now>=t.tEnd) phoenixAnim=null; }

  function draw(){

// 10s æœªå–å¾—å¢ç›Šæ™‚çš„ä¿åº•æ‰è½
if(performance.now() >= nextForcedDropAt){
  // åªæŠ•æ”¾ã€Œéæ¸›ç›Šã€
  const goodTypes = ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='debuff');
  const type = goodTypes[Math.floor(Math.random()*goodTypes.length)];
  const x = 40 + Math.random()*(1100-80);
  const y = layout().top - 20;
  const def = GAME_CONFIG.powers[type];
  let vy = GAME_CONFIG.powerCapsule.fallVy;
  if(def.type==='special' || def.type==='rare') vy *= 0.88;
  powerups.push({x,y,w:GAME_CONFIG.powerCapsule.width,h:GAME_CONFIG.powerCapsule.height,vy,type,isDebuff:false,isSpecial:(def.type==='special'||def.type==='rare'),phase:Math.random()*Math.PI*2});
  // ä¸‹ä¸€å€‹ä¿åº•åœ¨ 10 ç§’å¾Œï¼ˆè‹¥æœŸé–“æœ‰æ’¿åˆ°å¢ç›Šæœƒå†è¢«é‡è¨­ï¼‰
  nextForcedDropAt = performance.now() + 10000;
}

    if(screenShake>0){ const s=screenShake*0.6; ctx.save(); ctx.translate((Math.random()-0.5)*s,(Math.random()-0.5)*s); screenShake*=0.9; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBGDecor();
    drawRevealTiles();

    // ç£šå¡Š
    for(const b of bricks){
      // ç§»å‹•ç£šæ›´æ–°
      if(b.moving){
        b.x += b.vx;
        if(b.x<8){ b.x=8; b.vx=Math.abs(b.vx); }
        if(b.x+b.w>1100-8){ b.x=1100-8-b.w; b.vx=-Math.abs(b.vx); }
      }
      // ç¹ªè£½
      let base = b.boss ? '#ff4d6d' : b.unbreakable ? '#888' : b.strong ? '#bb7aff' : b.moving ? '#6ec6ff' : b.explosive ? getVar('--expl') : brickColor(b.colorIdx);
      const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY); g.addColorStop(0,base); g.addColorStop(1,'#1a1f3a'); ctx.fillStyle=g; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill();
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.stroke(); ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); }
      // é–éˆè¦†è“‹
      if(b.lockedUntil && performance.now() < b.lockedUntil){ ctx.fillStyle='rgba(90,0,120,0.35)'; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill();
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.stroke(); ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); } }
      // èè‹±èšæ°£å…‰
      if(b.elite && b.eliteChargeUntil && performance.now()<b.eliteChargeUntil){ const a=0.5+0.5*Math.sin(performance.now()/80); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,220,255,'+(0.6*a)+')'; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.restore(); }
      // è¡€æ¢ / é¢å­”
      if(b.boss){
        drawBossEmblem(b);
        // è¡€æ¢
        ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*scaleX,6*scaleY);
        const ratio=Math.max(0, b.hp/40);
        const hpGrad=ctx.createLinearGradient((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.x+b.w-8)*scaleX,(b.y+b.h-8)*scaleY);
        hpGrad.addColorStop(0,'rgba(255,150,150,.95)'); hpGrad.addColorStop(1,'rgba(255,240,240,.95)');
        ctx.fillStyle=hpGrad; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*ratio*scaleX,6*scaleY);
      }else if(b.hp>1 && b.hp<99 && b.hp<Infinity){
        ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*scaleX,4*scaleY);
        ctx.fillStyle='rgba(255,255,255,.75)'; const ratio=Math.max(0,(b.hp-1))/3; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*ratio*scaleX,4*scaleY);
      }
    }

    drawPlasmas(); drawHoly(); drawPhoenix();

    // Cyclops wind-up glow
    if(cyclopsChargeUntil && performance.now()<cyclopsChargeUntil){ for(const b of bricks){ if(b.boss && b.face==='ç›®'){ const a = 0.5 + 0.5*Math.sin(performance.now()/80); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(255,235,150,'+(0.6*a)+')'; ctx.lineWidth=4; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke(); ctx.restore(); } } }


    // æ“‹æ¿
    const pr=paddleRect();
    const padGlow=buffs.STICKY.active?'rgba(120,230,220,.6)':((buffs.WIDE.active||buffs.LONG.stacks.length)?'rgba(120,170,255,.6)':'rgba(200,210,255,.4)'); ctx.shadowColor=padGlow; ctx.shadowBlur=20;
    ctx.fillStyle='#9aaeff';
    if(!orientLeft){
      // æ°´å¹³
      drawRoundedRect(pr.x,pr.y,pr.w,pr.h,8); ctx.fill();
      // ç©ºæ´
      if(buffs.HOLE.active){ const gapW=pr.w/3; ctx.clearRect((pr.x+pr.w/3)*scaleX, pr.y*scaleY, gapW*scaleX, pr.h*scaleY); }
    }else{
      // å·¦å´å‚ç›´
      drawRoundedRect(pr.x,pr.y,pr.w,pr.h,8); ctx.fill();
      if(buffs.HOLE.active){ const gapH=pr.h/3; ctx.clearRect(pr.x*scaleX, (pr.y+pr.h/3)*scaleY, pr.w*scaleX, gapH*scaleY); }
    }
    ctx.shadowBlur=0;
    if(buffs.SHIELD.active && !orientLeft){ const g=ctx.createLinearGradient(0,(700-10)*scaleY,0,700*scaleY); g.addColorStop(0,'rgba(120,220,255,0.35)'); g.addColorStop(1,'rgba(120,220,255,0.05)'); ctx.fillStyle=g; ctx.fillRect(0,(700-10)*scaleY,canvas.width,10*scaleY); }
    if(performance.now()<=paddleStunUntil){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(255,230,160,0.35)'; drawRoundedRect(pr.x,pr.y,pr.w,pr.h,8); ctx.fill(); ctx.restore(); }
    // é›·å°„ç ²å±•ç¤º
    if(buffs.LASER.active){ ctx.fillStyle='rgba(120,255,120,0.8)'; if(!orientLeft){ ctx.fillRect((pr.x-6)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); ctx.fillRect((pr.x+pr.w+2)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); } else { ctx.fillRect((pr.x-4)*scaleX, (pr.y-6)*scaleY, (pr.w+8)*scaleX, 4*scaleY); ctx.fillRect((pr.x-4)*scaleX, (pr.y+pr.h+2)*scaleY, (pr.w+8)*scaleX, 4*scaleY); } }

    // çƒèˆ‡æ‹–å°¾
    const nowT=performance.now();
    for(const b of balls){
      b.trail.push({x:b.x,y:b.y,t:nowT}); while(b.trail.length>12) b.trail.shift();
      for(let i=b.trail.length-1;i>=0;i--){ const p=b.trail[i]; const age=(nowT-p.t)/200; if(age>1) continue; const alpha=(1-age)*0.6;
        let color=( (b.rampageUntil&&nowT<b.rampageUntil)||b.piercing )?`rgba(120,220,255,${alpha})`:(buffs.FAST.active?`rgba(255,140,90,${alpha})`:`rgba(255,255,255,${alpha*0.6})`);
        if(buffs.PLASMA.active) color=`rgba(160,240,255,${alpha})`; if(buffs.FREEZE.active) color=`rgba(200,230,255,${alpha})`; if(buffs.HOLY.active) color=`rgba(255,240,180,${alpha})`;
        if(buffs.TRACK.active) color=`rgba(${Math.floor(128+127*Math.sin(nowT/80))},${Math.floor(128+127*Math.sin(nowT/95+2))},${Math.floor(128+127*Math.sin(nowT/110+4))},${alpha})`;
        if(buffs.GODSPEED.active) color=`rgba(255,224,102,${alpha})`;
        ctx.fillStyle=color; ctx.beginPath(); ctx.arc(p.x*scaleX,p.y*scaleY,(b.r*0.7)*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill();
      }
      const bx=b.x*scaleX, by=b.y*scaleY, br=b.r*((scaleX+scaleY)/2); const grad=ctx.createRadialGradient(bx-3,by-4,2,bx,by,br);
      let edge=(b.piercing||(b.rampageUntil&&nowT<b.rampageUntil))?'#9ff':(buffs.FAST.active?'#ff9a66':'#cbd4ff'); if(buffs.PLASMA.active) edge='#aff'; if(buffs.FREEZE.active) edge='#e8f8ff'; if(buffs.HOLY.active) edge='#fff0a0'; if(buffs.GODSPEED.active) edge='#ffe066';
      grad.addColorStop(0,'#fff'); grad.addColorStop(1, edge); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();
      if(buffs.WAVY.active){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; const r1=br+2+2*Math.sin((nowT/100)+b.x*0.02); ctx.beginPath(); ctx.arc(bx,by,r1,0,Math.PI*2); ctx.stroke(); }
      if(b.stuck && !orientLeft){ ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect((paddle.x+paddle.w/2-12)*scaleX,(paddle.y-6)*scaleY,24*scaleX,4*scaleY); }
    }

    // é»‘æ´ç‰¹æ•ˆ
    for(let i=blackHoles.length-1;i>=0;i--){ const h=blackHoles[i]; if(performance.now()>h.until){ blackHoles.splice(i,1); continue; } const age=(h.until-performance.now())/2000; const r=40*((scaleX+scaleY)/2)*(0.8+0.2*Math.sin(performance.now()/120)); const x=h.x*scaleX, y=h.y*scaleY; const g=ctx.createRadialGradient(x,y,2,x,y,r); g.addColorStop(0,`rgba(0,0,0,${0.6})`); g.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }

    
    // é›·å°„å…‰æŸï¼ˆå¼·åŒ–è³ªæ„Ÿï¼‰
    for(let i=laserBeams.length-1;i>=0;i--){
      const b=laserBeams[i];
      const nowP=performance.now();
      if(nowP>b.until){ laserBeams.splice(i,1); continue; }
      const x1=b.x1*scaleX, y1=b.y1*scaleY, x2=b.x2*scaleX, y2=b.y2*scaleY;
      const t = Math.max(0, Math.min(1, (b.until-nowP)/200));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      // Outer glow
      ctx.strokeStyle='rgba(120,255,180,'+(0.25*t)+')';
      ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Mid beam
      const grd = ctx.createLinearGradient(x1,y1,x2,y2);
      grd.addColorStop(0,'rgba(160,255,220,'+(0.7*t)+')');
      grd.addColorStop(1,'rgba(255,255,255,'+(0.9*t)+')');
      ctx.strokeStyle=grd; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Core
      ctx.strokeStyle='rgba(255,255,255,'+(1*t)+')'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    }
    // Boss æŠ•å°„ç‰©
    drawAndStepBossProjectiles();

    // é›·å°„å‘½ä¸­æ•£é–‹ç‰¹æ•ˆ
    for(let i=laserImpacts.length-1;i>=0;i--){
      const it=laserImpacts[i]; const nowI=performance.now();
      if(nowI>it.tEnd){ laserImpacts.splice(i,1); continue; }
      const prog = 1 - Math.max(0, (it.tEnd - nowI)/ (it.tEnd - it.t0));
      const x = it.x*scaleX, y = it.y*scaleY;
      // expanding ring
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='rgba(160,255,200,'+(0.8*(1-prog))+')';
      ctx.lineWidth = 2 + 6*prog;
      ctx.beginPath(); ctx.arc(x,y, 6 + 26*prog, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
      // sparks
      for(let s=0;s<6;s++){
        const ang = (s/6)*Math.PI*2;
        const len = 8 + prog*24;
        ctx.save(); ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle='rgba(180,255,220,'+(0.7*(1-prog))+')';
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(x,y);
        ctx.lineTo(x+Math.cos(ang)*len, y+Math.sin(ang)*len);
        ctx.stroke(); ctx.restore();
      }
    }
    // é£›å½ˆ
    for(const m of missiles){ for(const tr of (m.trail||[])){ const a=Math.max(0,1-(performance.now()-tr.t)/300); ctx.fillStyle=`rgba(255,180,90,${0.6*a})`; ctx.beginPath(); ctx.arc(tr.x*scaleX,tr.y*scaleY,2*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); } ctx.fillStyle='#ddd'; ctx.beginPath(); ctx.arc(m.x*scaleX,m.y*scaleY,4*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    // æ‰è½é“å…·

    for(const p of powerups) drawPower(p);

    // é–å®šæ¡†
    drawLockBoxes();

    // ç²’å­
    for(let i=particles.length-1;i>=0;i--){ const P=particles[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.98; P.vy*=0.98; P.life-=16; if(P.life<=0){ particles.splice(i,1); continue; }
      const a=Math.max(0, Math.min(1, P.life/500)); ctx.fillStyle=P.color||`rgba(255,220,180,${a*0.6})`; ctx.beginPath(); ctx.arc(P.x*scaleX,P.y*scaleY,P.size*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    // å€’æ•¸æç¤º
    if(countdownShow>0){
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.font=`${Math.round(96*((scaleX+scaleY)/2))}px system-ui, sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(countdownShow), canvas.width/2, canvas.height/2);
      ctx.restore();
    }

    if(screenShake>0){ ctx.restore(); }
  }

  
  function speedForLevel(lv){
    // æ›´å¹³æ»‘çš„çƒé€Ÿæ›²ç·šï¼šå¾ baseSpeed ç·©æ…¢å¢é•·åˆ° +~3.2
    const base = getDiff().baseSpeed;
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const ease = t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2; // easeInOutQuad
    const extra = 0.6 + 2.6 * ease; // 0.6 -> 3.2
    return base + extra;
  }

  function resetBalls(center=true){ balls=[makeBall(false)]; const base=getDiff().baseSpeed; const speed=speedForLevel(level); const angle=(-60-Math.random()*60)*Math.PI/180;
    balls[0].x=center?1100/2:paddle.x+paddle.w/2; balls[0].y=700-70; balls[0].vx=Math.cos(angle)*speed; balls[0].vy=Math.sin(angle)*speed; balls[0].piercing=buffs.PIERCE.active; }

  function startCountdown(){
    paused=true; countdownShow=3; showCenter('', ''); centerNote.style.display='none'; // ç”¨ç•«é¢å€’æ•¸
    resumePending=true;
    const tick=()=>{
      if(countdownShow<=0){ resumePending=false; paused=false; stats.lifeStart=performance.now(); return; }
      beep(600 + (3-countdownShow)*100, 0.07, 0.05);
      setTimeout(()=>{ countdownShow--; if(countdownShow===0){ paused=false; } else { tick(); } }, 450);
    };
    tick();
  }


  function update(){
    const now=performance.now();
    // Buff éæœŸï¼šåµæ¸¬ä¸¦åŸ·è¡Œå„ç¨®çµæŸæ•ˆæœ
    for(const key of Object.keys(GAME_CONFIG.powers)){
      if(key==='LONG') continue;
      const b = buffs[key];
      if((b && b.active) && b.until && now > b.until){
        // åˆ°æœŸå‰è™•ç†ç‰¹å®š buff çš„çµ‚æ­¢äº‹ä»¶
        if(key === 'FIREBALL'){
          const energy = b.energy || 0;
          if(energy > 0){
            for(const ball of balls){
              fireballExplosionAt(ball.x, ball.y, energy);
            }
          }
          b.energy = 0;
        } else if(key === 'SWORD'){
          if(!b.released){
            releaseSwords(b.count || 0);
            b.released = true;
          }
        } else if(key === 'LASERSTORM'){
          b.started = false;
          b.targetCount = 0;
        } else if(key === 'BLACKHOLE'){
          performBlackHoleExplosion();
          b.deaths = 0;
        } else if(key === 'ANNIHILATION'){
          b.speeding = false;
        } else if(key === 'ROTATE'){
          // å¯åœ¨æ­¤é‚„åŸæ—‹è½‰ç‹€æ…‹ï¼ˆæ—‹è½‰ç‰¹æ•ˆæœªå¯¦ä½œï¼‰
        }
        // æ¸…é™¤ buff æ¿€æ´»ç‹€æ…‹
        b.active = false;
        // ç‰¹å®š buff é‚„åŸè™•ç†
        if(key==='PIERCE'){ for(const ball of balls) ball.piercing=false; }
        if(key==='STICKY'){ for(const ball of balls){ if(ball.stuck){ ball.stuck=false; ball.vy = -Math.abs(ball.vy||6); } } }
        if(key==='MEGA' && buffs.MEGA.applied){ for(const ball of balls){ ball.r/=GAME_CONFIG.powers.MEGA.mega.sizeMul; } buffs.MEGA.applied=false; }
        if(key==='FLIP'){ orientLeft=false; paddle.y=700-50; }
      }
    }
    computePaddleWidth(); updateBuffBadges();

    // åŠ‡æ¯’çƒï¼šå°å¸¶æ¯’ç£šå¡Šæ¯ 3 ç§’æ‰£ 1 è¡€ï¼ŒæŒçºŒæ™‚é™çµæŸå¾Œç§»é™¤ç‹€æ…‹
    for(let i=bricks.length-1;i>=0;i--){
      const bk = bricks[i];
      if(bk.poisonEnd){
        if(now >= bk.poisonEnd){
          delete bk.poisonEnd;
          delete bk.nextPoison;
        } else {
          if(!bk.nextPoison) bk.nextPoison = now + 3000;
          if(now >= bk.nextPoison){
            // å°ç£šå¡Šé€ æˆ 1 é»å‚·å®³
            damageOrDestroy(i, 1);
            bk.nextPoison = now + 3000;
            spawnParticles(bk.x + bk.w/2, bk.y + bk.h/2, '#55ff55', 6, 1.6, 1.6, 2.4);
          }
        }
      }
    }

    
    // èè‹±ç£šæŠ€èƒ½ï¼šæ¯30ç§’ç™¼å°„ï¼Œç™¼å°„å‰èšæ°£2ç§’
    for(const b of bricks){ if(!b.elite) continue; if(b.eliteChargeUntil && now<b.eliteChargeUntil){ /* charging */ } else { if(!b.eliteNext) b.eliteNext = now+30000; if(now>=b.eliteNext){ b.eliteChargeUntil = now+2000; b.eliteNext = now+30000; setTimeout(()=>{ const idx = bricks.indexOf(b); if(idx!==-1){ spawnLionBeamFrom(b.x+b.w/2, b.y+b.h/2); } }, 2000); } } }
// éµç›¤ç§»å‹•ï¼šå¤©åœ°ç¿»è½‰æ™‚æ”¹ç‚ºä¸Šä¸‹ç§»å‹•ï¼ˆä»ä½¿ç”¨å·¦å³éµï¼‰
    if(!orientLeft){ if(performance.now()>paddleStunUntil){ if(keyL) paddle.x-=paddle.speed; if(keyR) paddle.x+=paddle.speed; } paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x)); }
    else{ if(performance.now()>paddleStunUntil){ if(keyL) paddle.y-=paddle.speed; if(keyR) paddle.y+=paddle.speed; } paddle.y=Math.max(0, Math.min(700-paddle.w, paddle.y)); }

    // é›·å°„ç™¼å°„
    if(buffs.LASER.active){
      const interval = GAME_CONFIG.powers.LASER.laser.intervalMs;
      if(!buffs.LASER.lastShot || now - buffs.LASER.lastShot >= interval){
        buffs.LASER.lastShot = now;
        const pr=paddleRect();
        const barrels = !orientLeft ? [{x:pr.x, y:pr.y+pr.h/2},{x:pr.x+pr.w, y:pr.y+pr.h/2}] : [{x:pr.x+pr.w/2, y:pr.y},{x:pr.x+pr.w/2, y:pr.y+pr.h}];
        for(const s of barrels){
          // é–å®šæœ€é çš„ç£šå¡Š
          let targetIdx=-1, best=-1; for(let i=0;i<bricks.length;i++){ const bk=bricks[i]; if(!canDestroyBrick(bk)) continue; const dx=(bk.x+bk.w/2)-s.x; const dy=(bk.y+bk.h/2)-s.y; const d=dx*dx+dy*dy; if(d>best){ best=d; targetIdx=i; } }
          if(targetIdx>=0){
            const t=bricks[targetIdx]; const tx=t.x+t.w/2, ty=t.y+t.h/2;
            laserBeams.push({x1:s.x,y1:s.y,x2:tx,y2:ty,until:now+200});
            laserImpacts.push({x:tx, y:ty, t0:now, tEnd:now+320});
            spawnParticles(tx,ty,'rgba(160,255,200,0.9)',10,1.8,2.2,2.6);
            destroyBrick(targetIdx);
          }
        }
      }
    }

    // é›·å°„é¢¨æš´ï¼šåœ¨å•Ÿå‹•å¾Œå»¶é²3ç§’èšæ°£ï¼Œç„¶å¾Œä¾åºå°„æ“Šéš¨æ©Ÿç£šå¡Š
    if(buffs.LASERSTORM && buffs.LASERSTORM.active){
      // å°šæœªå•Ÿå‹•ï¼šç­‰å¾… 3 ç§’èšæ°£ï¼Œè¨ˆç®—è¦å°„æ“Šçš„æ•¸é‡ï¼ˆ21æ‰£æ‰ç©å®¶ç”Ÿå‘½å€¼ï¼Œæœ€å°‘ç‚º0ï¼‰
      if(!buffs.LASERSTORM.started){
        if(now - buffs.LASERSTORM.startAt >= 3000){
          const life = Math.max(0, lives);
          let tgt = 21 - life;
          if(tgt < 0) tgt = 0;
          buffs.LASERSTORM.targetCount = tgt;
          buffs.LASERSTORM.started = true;
          // èšæ°£çµæŸå¾Œå†ç­‰1ç§’é–‹å§‹å°„æ“Š
          buffs.LASERSTORM.nextShot = now + 1000;
        }
      } else {
        // å·²å•Ÿå‹•ï¼šå®šæ™‚å°„æ“Š
        if(buffs.LASERSTORM.targetCount > 0 && now >= buffs.LASERSTORM.nextShot){
          // é¸æ“‡ä¸€å€‹å¯ç ´å£çš„ç£šå¡Š
          const targets=[];
          for(let i=0;i<bricks.length;i++){
            const bk=bricks[i];
            if(canDestroyBrick(bk)) targets.push(i);
          }
          if(targets.length>0){
            const idx=targets[Math.floor(Math.random()*targets.length)];
            const t=bricks[idx];
            const pr=paddleRect();
            const s = !orientLeft ? {x:pr.x+pr.w/2, y:pr.y+pr.h/2} : {x:pr.x+pr.w/2, y:pr.y+pr.h/2};
            const tx=t.x+t.w/2, ty=t.y+t.h/2;
            laserBeams.push({x1:s.x,y1:s.y,x2:tx,y2:ty,until:now+200});
            laserImpacts.push({x:tx, y:ty, t0:now, tEnd:now+320});
            spawnParticles(tx,ty,'rgba(240,240,255,0.9)',12,1.8,2.2,2.6);
            destroyBrick(idx);
          }
          buffs.LASERSTORM.targetCount--;
          buffs.LASERSTORM.nextShot = now + 200;
          // å°„æ“Šå®Œæˆå¾ŒçµæŸæ•ˆæœ
          if(buffs.LASERSTORM.targetCount <= 0){
            buffs.LASERSTORM.active = false;
            buffs.LASERSTORM.started = false;
            buffs.LASERSTORM.nextShot = 0;
          }
        }
      }
    }

    // å…¨å±€é€Ÿåº¦å€ç‡ï¼ˆGODSPEED æ™‚å¿½ç•¥å…¶å®ƒï¼‰
    function effectiveMul(){
      // å…¨å±€é€Ÿåº¦å€ç‡ï¼šæ•´åˆæ…¢é€Ÿã€å¿«é€Ÿã€æ³¢æµªã€åœ°ç„èˆ‡ç‰¹å¤§çƒç­‰ buffã€‚è‹¥ GODSPEED ç”Ÿæ•ˆå‰‡ç›´æ¥è¿”å› 1ã€‚
      if (buffs.GODSPEED.active) return 1.0;
      let mul = 1.0;
      // æ…¢é€Ÿ buff
      if (buffs.SLOW.active) {
        const s = GAME_CONFIG.powers.SLOW.speedMul;
        mul *= (s != null ? s : 1.0);
      }
      // å¿«é€Ÿ buff
      if (buffs.FAST.active) {
        const s = GAME_CONFIG.powers.FAST.globalSpeedMul;
        mul *= (s != null ? s : 1.0);
      }
      // æ³¢æµª buff
      if (buffs.WAVY.active) {
        const w = GAME_CONFIG.powers.WAVY.wavy || {amp: 0.6, base: 1.2, periodMs: 200};
        const nowTime = performance.now();
        const phase = (nowTime - (buffs.WAVY.start || nowTime)) / (w.periodMs);
        mul *= (w.base + w.amp * Math.sin(phase));
      }
      // åœ°ç„ buff
      if (buffs.HELL.active) {
        const s = GAME_CONFIG.powers.HELL.hell.speedMul;
        mul *= (s != null ? s : 1.0);
      }
      // ç‰¹å¤§çƒ buff
      if (buffs.MEGA.active) {
        const s = GAME_CONFIG.powers.MEGA.mega.speedMul;
        mul *= (s != null ? s : 1.0);
      }
      return mul;
    }

    const mulGlobal=effectiveMul();

    // ç¬ç§»çƒï¼šå¦‚åˆ°é”é å®šæ™‚é–“ï¼Œå°‡æ‰€æœ‰çƒç¬ç§»åˆ°é ‚éƒ¨ä½ç½®ä¸¦é‡è¨­ç¬ç§»è¨ˆæ™‚
    if(buffs.TELEPORT.active && buffs.TELEPORT.nextTeleport && now >= buffs.TELEPORT.nextTeleport){
      for(const ball of balls){
        const rad = ball.r || 6;
        ball.y = rad + 1;
        ball.vy = Math.abs(ball.vy || 4);
      }
      buffs.TELEPORT.nextTeleport = 0;
      spawnParticles(550, 20, '#aaffff', 20, 2.0, 2.4, 3.0);
      beep(440,0.06,0.06);
    }

    // Boss èƒ½åŠ›æ’ç¨‹
    updateBossAbilities();
    for(const b of balls){
      if(b.rampageUntil && now>b.rampageUntil){ b.rampageUntil=0; if(!buffs.PIERCE.active) b.piercing=false; }

      // FREEZE ç‹€æ…‹
      if(b.freeze.state==='delay'){
        if(now - b.freeze.t0 >= b.freeze.delay){
          b.freeze.state = 'stopped';
          b.freeze.until = now + b.freeze.stop;
          b.vx = 0; b.vy = 0;
          spawnParticles(b.x,b.y,'rgba(230,247,255,0.9)',16,1.2,1.0,2.5);
        }
      }
      if(b.freeze.state==='stopped'){
        if(now < b.freeze.until){
          continue;
        }else{
          b.freeze.state = 'idle';
          let vx = b.freeze.oldVX, vy = b.freeze.oldVY;
          const tiny = Math.abs(vx)+Math.abs(vy) < 0.2;
          if(tiny){ vx = (Math.random()<0.5?-1:1) * 4; vy = -Math.max(4, speedForLevel(level)*0.8); }
          const sp = Math.max(4, Math.hypot(vx, vy));
          const ang = Math.atan2(vy, vx);
          b.vx = Math.cos(ang)*sp;
          b.vy = Math.sin(ang)*sp;
        }
      }

      if(b.stuck){ if(!orientLeft){ b.x=paddle.x+paddle.w/2+b.offsetX; b.y=paddle.y-b.r-0.1; } else { const pr=paddleRect(); b.x=pr.x+pr.w+b.r+0.1; b.y=pr.y+pr.h/2; } continue; }
      // ç§»å‹•
      let speedMul = mulGlobal;
      b.x+=b.vx*speedMul; b.y+=b.vy*speedMul;

      // GODSPEEDï¼šé€Ÿåº¦é–å®šåˆ°ä¸Šé™
      if(buffs.GODSPEED.active){
        const sp=Math.hypot(b.vx,b.vy); const cap=b.speedCap;
        if(sp<cap*0.98){ const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*cap; b.vy=Math.sin(ang)*cap; }
      }

      // ç‰†å£
      const r=b.r;
      if(!orientLeft){
        if(b.x-r<0){ b.x=r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
        if(b.y-r<0){ b.y=r; b.vy*=-1; beep(700,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
        if(b.y-r>700){
          // åº•éƒ¨ï¼šGODSPEED ä¸è½åœ° / SHIELD æ“‹ä¸€æ¬¡
          if(buffs.GODSPEED.active){ b.y=700-r; b.vy=-Math.abs(b.vy); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.y=700-r-1; b.vy=-Math.abs(b.vy); }
          else {
            const idx=balls.indexOf(b);
            if(idx>=0) balls.splice(idx,1);
            // é»‘æ´åå™¬ï¼šè¨˜éŒ„æ­»äº¡æ¬¡æ•¸
            if(buffs.BLACKHOLE.active){
              buffs.BLACKHOLE.deaths = (buffs.BLACKHOLE.deaths || 0) + 1;
            }
            // è¬ç‰©éŠ·æ¯€ï¼šè½çƒå³çµ‚æ­¢æ•ˆæœ
            if(buffs.ANNIHILATION.active){
              buffs.ANNIHILATION.active = false;
              buffs.ANNIHILATION.speeding = false;
            }
            break;
          }
        }
      }else{
        // å·¦å´æ¨¡å¼ï¼šä¸Šä¸‹ç‚ºç‰†ï¼Œå·¦å´ç‚ºè½é»ï¼›GODSPEED ç„¡è½åœ°
        if(b.y-r<0){ b.y=r; b.vy*=-1; }
        if(b.y+r>700){ b.y=700-r; b.vy*=-1; }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; }
        if(b.x-r<0){
          if(buffs.GODSPEED.active){ b.x=r; b.vx=Math.abs(b.vx); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.x=r+1; b.vx=Math.abs(b.vx); }
          else {
            const idx=balls.indexOf(b);
            if(idx>=0) balls.splice(idx,1);
            if(buffs.BLACKHOLE.active){
              buffs.BLACKHOLE.deaths = (buffs.BLACKHOLE.deaths || 0) + 1;
            }
            if(buffs.ANNIHILATION.active){
              buffs.ANNIHILATION.active = false;
              buffs.ANNIHILATION.speeding = false;
            }
            break;
          }
        }
      }

      // æ“‹æ¿ç¢°æ’
      const pr=paddleRect();
      // æ“‹æ¿æœ‰ç©ºæ´ï¼šæ‹†æˆå…©æ®µ
      let hitPaddle=false;
      if(!orientLeft){
        const gap = buffs.HOLE.active ? pr.w/3 : 0;
        const l1=pr.x, r1=pr.x+pr.w*(gap?1/3:1);
        const l2=pr.x+pr.w*(gap?2/3:1), r2=pr.x+pr.w;
        const inSeg1 = (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l1 && b.x<=r1);
        const inSeg2 = gap? (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l2 && b.x<=r2):false;
        hitPaddle = inSeg1 || inSeg2;
      }else{
        const gap = buffs.HOLE.active ? pr.h/3 : 0;
        const t1=pr.y, b1=pr.y+pr.h*(gap?1/3:1);
        const t2=pr.y+pr.h*(gap?2/3:1), b2=pr.y+pr.h;
        const inSeg1 = (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t1 && b.y<=b1);
        const inSeg2 = gap? (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t2 && b.y<=b2):false;
        hitPaddle = inSeg1 || inSeg2;
      }
      if(hitPaddle){ stats.catches++;
        if(!orientLeft){
          const hitPos=(b.x-(pr.x+pr.w/2))/(pr.w/2); const sp=Math.min(Math.hypot(b.vx,b.vy)*1.02, b.speedCap); const angle=hitPos*(Math.PI/3);
          b.vx=Math.sin(angle)*sp; b.vy=-Math.cos(angle)*sp; b.y=pr.y-b.r-0.1;
        }else{
          const hitPos=(b.y-(pr.y+pr.h/2))/(pr.h/2); const sp=Math.min(Math.hypot(b.vx,b.vy)*1.02, b.speedCap); const angle=hitPos*(Math.PI/3);
          b.vx=Math.cos(angle)*sp; b.vy=Math.sin(angle)*sp; b.x=pr.x+pr.w+b.r+0.1;
        }
        beep(880,0.03); spawnParticles(b.x,b.y,'#caddff',8,1.3,1.5,2.5);
        if(buffs.STICKY.active){ b.stuck=true; b.offsetX= (!orientLeft) ? (b.x-(paddle.x+paddle.w/2)) : 0; }

        // MISSILEï¼šæ“‹æ¿å½ˆå‡ºæ™‚ç™¼å°„ä¸‰æš
        if(buffs.MISSILE.active){
          // å–æœ€è¿‘/ä¸­è·é›¢/æœ€é 
          const src={x:b.x,y:b.y};
          const candidates = bricks.map((bk,idx)=>({idx, d: (bk.x+bk.w/2-src.x)**2 + (bk.y+bk.h/2-src.y)**2 })).sort((a,b)=>a.d-b.d);
          const pickIdxs = [0, Math.floor(candidates.length/2), candidates.length-1].filter(i=>i>=0 && i<candidates.length);
          for(const i of pickIdxs){
            const targetId = (candidates[i] ? candidates[i].idx : undefined);
            if(targetId==null) continue;
            const ang=Math.random()*Math.PI*2;
            missiles.push({x:src.x,y:src.y,vx:Math.cos(ang)*2,vy:Math.sin(ang)*2,targetId,lifeUntil:now+GAME_CONFIG.powers.MISSILE.missile.lifeMs,trail:[]});
            const ttt = bricks[targetId];
            if(ttt){ pushLockBox(ttt.x, ttt.y, ttt.w, ttt.h, 'target'); }
          }
        }

        // è¿½è¹¤çƒï¼šæ“‹æ¿å½ˆå‡ºå¾Œç„æº–ç›®æ¨™ç£šï¼ˆç¨ç«‹å„ªå…ˆï¼‰
        if(buffs.TRACK.active){
          function neighborCount(t){
            let cnt=0; const L=layout(); for(const o of bricks){ if(o===t) continue; const dx=Math.abs((o.x+o.w/2)-(t.x+t.w/2)); const dy=Math.abs((o.y+o.h/2)-(t.y+t.h/2)); const thx=brickW+L.pad+2, thy=brickH+L.pad+2; if(dx<=thx && dy<=thy) cnt++; } return cnt;
          }
          let best=null; for(const t of bricks){ if(t.unbreakable) continue; const iso=neighborCount(t); const d=Math.hypot((t.x+t.w/2)-b.x,(t.y+t.h/2)-b.y); const score=iso*1000 + d; if(best==null || score<best.score) best={t,score}; }
          const tx = best? (best.t.x+best.t.w/2) : (1100/2);
          const ty = best? (best.t.y+best.t.h/2) : (layout().top);
          const sp=Math.hypot(b.vx,b.vy); const ang=Math.atan2(ty-b.y, tx-b.x); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        
          if(best){ pushLockBox(best.t.x, best.t.y, best.t.w, best.t.h, 'target'); }
}

        // æ–°å¢ï¼šç«ç„°çƒã€ç¬ç§»çƒã€åŠèŠ’è£‚ç©ºåœ¨æ“‹æ¿åå½ˆæ™‚ç´¯ç©èƒ½é‡æˆ–æ’ç¨‹
        if(buffs.FIREBALL.active){
          buffs.FIREBALL.energy = (buffs.FIREBALL.energy||0) + 1;
        }
        if(buffs.TELEPORT.active){
          buffs.TELEPORT.nextTeleport = now + 1000;
        }
        if(buffs.SWORD.active){
          buffs.SWORD.count = (buffs.SWORD.count||0) + 1;
        }
      }

      // ç¢°ç£š
      let hit=-1; for(let i=0;i<bricks.length;i++){ const bk=bricks[i]; if(b.x+r>bk.x && b.x-r<bk.x+bk.w && b.y+r>bk.y && b.y-r<bk.y+bk.h){ hit=i; break; } }
      if(hit>=0){
        const bk=bricks[hit]; const inRampage=b.rampageUntil && now<b.rampageUntil;
        // æ–°å¢ï¼šç«ç„°çƒç£šç¢°æ’ç´¯ç©èƒ½é‡ã€åŠ‡æ¯’çƒå°ç£šå¡Šæ–½åŠ æ¯’ç´ 
        if(buffs.FIREBALL.active){
          buffs.FIREBALL.energy = (buffs.FIREBALL.energy||0) + 1;
        }
        if(buffs.POISON.active && !bk.unbreakable){
          bk.poisonEnd = now + GAME_CONFIG.powers.POISON.durationMs;
          bk.nextPoison = now + 3000;
        }
        // åå½ˆ
        const oL=(b.x+r)-bk.x, oR=(bk.x+bk.w)-(b.x-r), oT=(b.y+r)-bk.y, oB=(bk.y+bk.h)-(b.y-r); const m=Math.min(oL,oR,oT,oB);
        if(!inRampage && !b.piercing){
          if(m===oL){ b.x=bk.x-r; b.vx=-Math.abs(b.vx); } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=Math.abs(b.vx); } else if(m===oT){ b.y=bk.y-r; b.vy=-Math.abs(b.vy); } else { b.y=bk.y+bk.h+r; b.vy=Math.abs(b.vy); }
        }else{
          if(m===oL){ b.x=bk.x-r; b.vx=Math.abs(b.vx)||4; } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=-Math.abs(b.vx)||-4; } else if(m===oT){ b.y=bk.y-r; b.vy=Math.abs(b.vy)||4; } else { b.y=bk.y+bk.h+r; b.vy=-Math.abs(b.vy)||-4; }
          b.piercing=true;
        }

        // å¼·åå½ˆåŠ é€Ÿ
        if(bk.strong){ const sp=Math.min(Math.hypot(b.vx,b.vy)*1.08, b.speedCap); const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp; screenShake=Math.max(screenShake,3); }

        // ç‰¹æ•ˆè§¸ç™¼ï¼ˆGODSPEED æœŸé–“å¿½ç•¥ï¼‰
        if(!buffs.GODSPEED.active){
          if(buffs.PLASMA.active){ const cfg=GAME_CONFIG.powers.PLASMA.plasma; const ang=Math.random()*Math.PI*2; plasmas.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,vx:Math.cos(ang)*cfg.drift,vy:Math.sin(ang)*cfg.drift,until:now+cfg.lifeMs,radius:cfg.radius}); }
          if(buffs.FREEZE.active && (b.freeze.state==='idle' || !b.freeze.state)){ const f=GAME_CONFIG.powers.FREEZE.freeze; b.freeze.state = 'delay'; b.freeze.t0 = now; b.freeze.delay = f.delayMs; b.freeze.stop = f.stopMs; b.freeze.oldVX = b.vx; b.freeze.oldVY = b.vy; }
          if(buffs.HOLY.active){ holyFlashes.push({x:bk.x+bk.w/2, y:bk.y+bk.h/2, until:now+350}); for(let i=bricks.length-1;i>=0;i--){ const t=bricks[i]; const sameRow=Math.abs(t.y-bk.y)<1; const sameCol=Math.abs(t.x-bk.x)<1; if(sameRow||sameCol){ destroyBrick(i); } } screenShake=Math.max(screenShake,4); }
          if(buffs.CHAIN.active){ bk.lockedUntil = now + GAME_CONFIG.powers.CHAIN.chain.lockMs; }
          if(buffs.HELL.active){ blackHoles.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,until:now+GAME_CONFIG.powers.HELL.hell.haloMs}); destroyNeighbors(hit); destroyBrick(hit); }
        }

        // ç•¶å‰ç£šæ‰£è¡€ï¼ˆè‹¥å·²åœ¨ä¸Šé¢è¢«è™•ç†å‰‡ç•¥éï¼‰
        if(!buffs.HELL.active && !buffs.HOLY.active){
          // é–éˆä¸­ä¸å—å‚·å®³
          if(!(bk.lockedUntil && now<bk.lockedUntil)){
            bk.hp=(bk.hp||1)-1; score+=10; updateHUD();
            if(bk.hp<=0){
              const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
              revealBrickArea(bk);
              if(Math.random()<dropRateForLevel(level)) spawnPower(cx-12,cy);
              if(bk.explosive){ explodeAt(cx,cy); } else { bricks.splice(hit,1); }
            }
          }
        }

        // è¿½è¹¤çƒï¼šæ’ç£šå¾Œç„æº–æ“‹æ¿ä¸­å¿ƒ
        if(buffs.TRACK.active){
          const pr=paddleRect(); const tx = pr.x + (orientLeft? (pr.w + 60) : pr.w/2); const ty = pr.y + pr.h/2;
          const sp=Math.hypot(b.vx,b.vy); const ang=Math.atan2(ty-b.y, tx-b.x); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        
          pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
}

        beep(520+Math.random()*200,0.03,0.05);
      }

      // å®‰å…¨ä¿åº•é€Ÿåº¦
      const sp2 = Math.hypot(b.vx,b.vy);
      if(sp2 < 0.2 && !b.stuck && b.freeze.state==='idle'){
        b.vx = (Math.random()<0.5?-1:1) * 4;
        b.vy = -Math.max(4, speedForLevel(level)*0.8);
      }
    }

    // é£›å½ˆæ›´æ–°
    for(let i=missiles.length-1;i>=0;i--){
      const m=missiles[i];
      if(now>m.lifeUntil){ missiles.splice(i,1); continue; }
      // ç›®æ¨™ä½ç½®
      const t=bricks[m.targetId];
      if(!t){ missiles.splice(i,1); continue; }
      const tx=t.x+t.w/2, ty=t.y+t.h/2;
      const ang=Math.atan2(ty-m.y, tx-m.x);
      const sp=GAME_CONFIG.powers.MISSILE.missile.speed;
      // è½‰å‘
      const curAng=Math.atan2(m.vy, m.vx);
      let diff=ang-curAng; while(diff>Math.PI) diff-=2*Math.PI; while(diff<-Math.PI) diff+=2*Math.PI;
      const maxTurn=GAME_CONFIG.powers.MISSILE.missile.turn;
      const newAng = curAng + Math.max(-maxTurn, Math.min(maxTurn, diff));
      m.vx=Math.cos(newAng)*sp; m.vy=Math.sin(newAng)*sp;
      m.x+=m.vx; m.y+=m.vy;
      (m.trail||(m.trail=[])).push({x:m.x,y:m.y,t:now}); if(m.trail.length>20) m.trail.shift();
      // å‘½ä¸­åˆ¤å®š
      if(m.x>t.x && m.x<t.x+t.w && m.y>t.y && m.y<t.y+t.h){
        destroyBrick(m.targetId); missiles.splice(i,1); spawnParticles(m.x,m.y,'#ffbb66',12,1.8,2.2,3);
      }
    }

    // çƒå…¨æ²’äº†
    if(balls.length===0){ const nowL=performance.now(); if(stats.lifeStart){ const dur=(nowL-stats.lifeStart)/1000; if(dur<stats.fastestDeath) stats.fastestDeath=dur; if(dur>stats.longestLife) stats.longestLife=dur; } stats.livesUsed++;
      lives--; updateHUD();
      if(lives<=0){ running=false; paused=true; showGameOver(); return; }
      else { resetBalls(false); startCountdown(); return; }
    }

    // æ‰è½é“å…·ç§»å‹•/æ’¿å–
    for(let i=powerups.length-1;i>=0;i--){
      const p=powerups[i]; p.y+=p.vy;
      const pr=paddleRect();
      const hit = (!orientLeft) ? (p.y+p.h>=pr.y && p.x+p.w>=pr.x && p.x<=pr.x+pr.w && p.y<=pr.y+pr.h) : (p.x+p.w>=pr.x && p.x<=pr.x+pr.w && p.y+p.h>=pr.y && p.y<=pr.y+pr.h);
      if(hit){ applyPower(p.type); powerups.splice(i,1); continue; }
      if(p.y>710) powerups.splice(i,1);
    }

        // å¤©ç©ºå®šæ™‚æ‰è½
    if(performance.now() >= nextSkyDropAt){ spawnBeneficialAtTop(); scheduleNextSkyDrop(); }

    // æ¸…é—œï¼ˆé€²å…¥ç•«å»Šæˆ–é€šé—œï¼‰
    if(!hasBreakables()){
      paused=true; running=false;
      if(level>=GAME_CONFIG.totalLevels){
        finalScore.textContent=String(score);
          const el=document.getElementById('statsWin'); if(el) el.innerHTML = renderStatsHtml();
        ring.innerHTML='';
        for(let i=1;i<=GAME_CONFIG.totalLevels;i++){
          const im=getLevelImage(i);
          const th=document.createElement('img'); th.src=im.src; ring.appendChild(th);
        }
        win.classList.add('show');
        ensureAudio(); if(audioCtx){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(659, audioCtx.currentTime); g.gain.value=0.04; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.frequency.value=880; }, 200); setTimeout(()=>{ o.stop(); }, 600); }
      }else{
        galleryImg.src=getLevelImage(level).src;
        gallery.style.display='flex'; requestAnimationFrame(()=>gallery.classList.add('show'));
        const proceed=()=>{ gallery.classList.remove('show'); setTimeout(()=>{ gallery.style.display='none'; gallery.removeEventListener('click',proceed); },200); level++; updateHUD(); initBricks(); resetBalls(); paused=true; running=false; applyBGMThemeForLevel(); showCenter(`é€²å…¥é—œå¡ ${level}`,'æŒ‰ Space æˆ–é»ç•«é¢é–‹å§‹'); };
        gallery.addEventListener('click',proceed,{once:true}); return;
      }
    }
  }


  function loop(){ if(!paused && running) update(); draw(); requestAnimationFrame(loop); }
  function boot(){
    resetGame(); updateHUD(); loop();
    // è‡ªå‹•è®€å–éŸ³æ•ˆ/BGMåå¥½
    soundsOn = (localStorage.getItem('sfx_on')||'0')==='1'; soundBtn.textContent=`éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`;
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.85'); bgmVol.value=String(v);
    bgmOn = (localStorage.getItem('bgm_on')||'0')==='1'; bgmBtn.textContent = bgmOn?'é–‹':'é—œ';
    // è‹¥æœ‰å­˜æª”çµ¦æç¤º
    const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4');
    if(raw){ setTimeout(()=>{ if(confirm('åµæ¸¬åˆ°å­˜æª”ï¼Œè¦è®€å–é€²åº¦å—ï¼Ÿ')) loadProgress(); }, 400); }
  }
  boot();
})();
// /* __CENTERNOTE_HIDE_FIX__ */
(function(){
  const centerNote = document.getElementById('centerNote');
  if(!centerNote) return;
  const refresh = () => {
    const style = window.getComputedStyle(centerNote);
    centerNote.style.pointerEvents = (style.display==='none' || style.visibility==='hidden' || centerNote.hidden) ? 'none' : 'auto'
  };
  new MutationObserver(refresh).observe(centerNote, { attributes:true, attributeFilter:['style','hidden','class']});
  refresh();
})();
</script>

<!-- ===== å¯éš¨æ™‚é€²å…¥çš„ç•«å»Šé¢æ¿ï¼ˆç”±è£œä¸æ³¨å…¥ï¼‰ ===== -->
<div class="win" id="album" style="display:none;">
  <div class="backdrop"></div>
  <div class="center" style="max-width:min(92vw,1020px)">
    <h2>ç•«å»Š</h2>
    <div id="albumGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(96px,1fr));gap:10px;max-height:min(60vh,560px);overflow:auto;margin:8px 0;"></div>
    <div class="small">é»ç¸®åœ–å¯æ”¾å¤§ï¼Œå†æ¬¡é»æ“Šç¸®å›</div>
    <div class="again" style="margin-top:12px"><button class="btn" id="albumClose">å›åˆ°éŠæˆ²</button></div>
  </div>
</div>


<script>
// ===== Breakout Mobile Stability & Feature Patch =====
(()=>{
  // 0) Guard: wait DOM
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPatch, {once:true});
  } else {
    initPatch();
  }

  function initPatch(){
    try{
      addAlbumButton();
      hookPauseTimers();
      hookFlipBehavior();
      hookDrawWrap();
      hookGetLevelImageSeen();
      wireAlbumUI();
    }catch(e){ console.error('[Patch init error]', e); }
  }

  // Add "ç•«å»Š" button next to effectsBtn
  function addAlbumButton(){
    const effectsBtn = document.getElementById('effectsBtn');
    if (effectsBtn && !document.getElementById('albumBtn')){
      const btn=document.createElement('button');
      btn.id='albumBtn'; btn.className='btn'; btn.textContent='ç•«å»Š';
      effectsBtn.insertAdjacentElement('afterend', btn);
    }
    // show album overlay element
    const album = document.getElementById('album');
    if (album) album.style.display=''; // let css/JS control
  }

  // === Soft cap arrays to avoid runaway memory ===
  function capArray(arr, max){ if(arr && arr.length>max){ arr.splice(0, arr.length-max); } }

  // === Pause timers freezing & resume shifting ===
  let __pausedAt = 0;
  function shiftAllTimers(dt){
    try{ for(const k in window.buffs){ const v=window.buffs[k]; if(v && typeof v.until==='number') v.until+=dt; } }catch(e){}
    try{ if(window.buffs?.LONG?.stacks) window.buffs.LONG.stacks = window.buffs.LONG.stacks.map(t=>t+dt); }catch(e){}
    try{ if(typeof window.buffs?.LASER?.lastShot==='number') window.buffs.LASER.lastShot += dt; }catch(e){}
    try{ if(window.nextSkyDropAt) window.nextSkyDropAt += dt; }catch(e){}
    try{ if(window.nextForcedDropAt) window.nextForcedDropAt += dt; }catch(e){}
    try{ if(window.lockBoxes) window.lockBoxes.forEach(o=> o.until && (o.until += dt)); }catch(e){}
    try{ if(window.laserBeams) window.laserBeams.forEach(o=> o.until && (o.until += dt)); }catch(e){}
    try{ if(window.laserImpacts) window.laserImpacts.forEach(o=> o.until && (o.until += dt)); }catch(e){}
    try{ if(window.blackHoles) window.blackHoles.forEach(o=> o.until && (o.until += dt)); }catch(e){}
    try{ if(window.hostileColumns) window.hostileColumns.forEach(o=> { if(o.tStart) o.tStart+=dt; if(o.tEnd) o.tEnd+=dt; }); }catch(e){}
    try{ if(window.cyclopsChargeUntil) window.cyclopsChargeUntil += dt; }catch(e){}
    try{ if(window.nextBossAtkA) window.nextBossAtkA += dt; }catch(e){}
    try{ if(window.nextBossAtkB) window.nextBossAtkB += dt; }catch(e){}
  }
  function hookPauseTimers(){
    const t = window.togglePause;
    if (typeof t!=='function') return;
    window.togglePause = function(){
      if(!window.running){ window.startGameWithCountdown?.(); return; }
      window.paused = !window.paused;
      if(window.paused){
        __pausedAt = performance.now();
        window.showCenter?.('å·²æš«åœ','æŒ‰ Space / é»ç•«é¢ç¹¼çºŒ');
      }else{
        const dt = performance.now() - __pausedAt;
        shiftAllTimers(dt);
        window.startCountdown?.();
      }
    };
  }

  // === FLIP behavior: 2s pre cue + 2s end cue; homing; reversed drops ===
  let flipPreUntil=0, flipActiveFrom=0, flipEndCueFrom=0, flipActiveUntil=0, flipEndAt=0;
  let flipRetargetedStart=false, flipRetargetedEnd=false;
  function hookFlipBehavior(){
    const ap = window.applyPower;
    if (typeof ap!=='function') return;
    window.applyPower = function(type){
      if (type==='FLIP'){
        const D   = (window.GAME_CONFIG?.powers?.FLIP?.durationMs) || 15000;
        const pre = 2000, endCue = 2000;
        const now = performance.now();
        flipPreUntil    = now + pre;
        flipActiveFrom  = flipPreUntil;
        flipActiveUntil = flipActiveFrom + D;
        flipEndCueFrom  = flipActiveUntil - endCue;
        flipEndAt       = flipActiveUntil;
        if(window.buffs?.FLIP){ window.buffs.FLIP.active=true; window.buffs.FLIP.until=flipEndAt; }
        flipRetargetedStart=false; flipRetargetedEnd=false;
        return;
      }
      return ap(type);
    };
  }

  // === Wrap draw(): caps + flip state shift + cues + reversed drop direction ===
  function hookDrawWrap(){
    if (typeof window.draw!=='function') return;
    const orig = window.draw;
    const canvas = document.getElementById('game');
    const ctx = canvas?.getContext('2d');
    window.draw = function(){
      // soft caps
      try{
        capArray(window.particles,1200);
        capArray(window.plasmas,240);
        capArray(window.fireBursts,200);
        capArray(window.missiles,60);
        capArray(window.laserBeams,80);
        capArray(window.laserImpacts,160);
        capArray(window.hostileBeams,80);
        capArray(window.hostileArcs,80);
        capArray(window.hostileColumns,16);
        capArray(window.hazardClouds,20);
      }catch(e){}

      // FLIP transitions + homing
      (function(){
        const now = performance.now();
        if (flipActiveFrom && now>=flipActiveFrom && now<flipActiveUntil){
          if(!window.orientLeft) window.orientLeft = true;
          if(!flipRetargetedStart && window.paddle && window.balls){
            const cx = window.paddle.x + window.paddle.w/2, cy = window.paddle.y;
            for(const b of window.balls){
              const dx=cx-b.x, dy=cy-b.y, m=Math.hypot(dx,dy)||1, sp=Math.hypot(b.vx,b.vy)||6;
              b.vx=(dx/m)*sp; b.vy=(dy/m)*sp;
            }
            flipRetargetedStart=true;
          }
        }else if(flipActiveUntil && now>=flipActiveUntil){
          if(window.orientLeft) window.orientLeft=false;
          if(!flipRetargetedEnd && window.paddle && window.balls){
            const cx = window.paddle.x + window.paddle.w/2, cy = window.paddle.y;
            for(const b of window.balls){
              const dx=cx-b.x, dy=cy-b.y, m=Math.hypot(dx,dy)||1, sp=Math.hypot(b.vx,b.vy)||6;
              b.vx=(dx/m)*sp; b.vy=(dy/m)*sp;
            }
            flipRetargetedEnd=true;
          }
          flipPreUntil=flipActiveFrom=flipEndCueFrom=flipActiveUntil=flipEndAt=0;
        }
      })();

      // run original draw
      orig();

      // cue symbol (non-blocking)
      if (ctx && canvas){
        const now=performance.now();
        const showPre = (flipPreUntil && now<flipPreUntil);
        const showEnd = (flipEndCueFrom && now>=flipEndCueFrom && now<=flipActiveUntil);
        if(showPre || showEnd){
          try { (window.balls||[]).forEach(b=>{ b.vx*=0.995; b.vy*=0.995; }); } catch(e){}
          ctx.save(); ctx.globalAlpha=0.14; ctx.fillStyle='#9cf'; ctx.textAlign='center'; ctx.textBaseline='middle';
          const size = Math.round(0.16 * Math.min(canvas.width, canvas.height));
          ctx.font = size + 'px system-ui';
          ctx.fillText('â†»', canvas.width/2, canvas.height/2);
          ctx.restore();
        }
      }

      // reverse powerup fall dir during flip
      try{
        if (Array.isArray(window.powerups)) {
          const flipOn = !!window.orientLeft;
          for(const p of window.powerups){ p.vy = flipOn? -Math.abs(p.vy) : Math.abs(p.vy); }
        }
      }catch(e){}
    };
  }

  // === Album / Gallery ===
  function wireAlbumUI(){
    const album = document.getElementById('album');
    const albumGrid = document.getElementById('albumGrid');
    const albumBtn = document.getElementById('albumBtn');
    const albumClose = document.getElementById('albumClose');
    const gallery = document.getElementById('gallery');
    const galleryImg = document.getElementById('galleryImg');
    const seenStoreKey = 'breakout_gallery_seen_v1';
    let seen = {}; try{ seen = JSON.parse(localStorage.getItem(seenStoreKey)||'{}'); }catch(e){ seen={}; }
    function markSeen(idx, kind){ const key = kind+idx; if(!seen[key]){ seen[key]=true; localStorage.setItem(seenStoreKey, JSON.stringify(seen)); } }
    window.__markSeen = markSeen; // export for getLevelImage hook

    function openGalleryImage(key){
      const m = key.match(/(bg|cg)(\d+)/); if(!m) return;
      const kind=m[1], n=parseInt(m[2],10);
      const src = (kind==='bg')? window.IMG_PAIRS?.[n-1]?.bg : window.IMG_PAIRS?.[n-1]?.cg;
      if (!src || !gallery || !galleryImg) return;
      galleryImg.src = src; gallery.classList.add('show');
      setTimeout(()=> document.addEventListener('click', ()=>{ gallery.classList.remove('show'); galleryImg.src=''; }, {once:true}), 0);
    }

    function buildAlbum(){
      if(!albumGrid || !Array.isArray(window.IMG_PAIRS)) return;
      albumGrid.innerHTML='';
      const items=[];
      for(let i=1;i<=10;i++) items.push({key:'bg'+i, src: window.IMG_PAIRS[i-1].bg});
      for(let i=1;i<=10;i++) items.push({key:'cg'+i, src: window.IMG_PAIRS[i-1].cg});
      for(const it of items){
        const wrap=document.createElement('div'); wrap.style.cssText='position:relative;border:1px solid rgba(255,255,255,.12);border-radius:10px;overflow:hidden;';
        const img=document.createElement('img'); img.src=it.src; img.loading='lazy'; img.style.cssText='width:100%;height:72px;object-fit:cover;display:block;';
        if(!seen[it.key]) img.style.filter='grayscale(100%) brightness(60%)';
        wrap.appendChild(img);
        wrap.addEventListener('click', ()=>openGalleryImage(it.key));
        albumGrid.appendChild(wrap);
      }
    }
    function openAlbum(){ if(!album) return; window.paused=true; __pausedAt=performance.now(); buildAlbum(); album.classList.add('show'); }
    function closeAlbum(){ if(!album) return; album.classList.remove('show'); const dt=performance.now()-__pausedAt; shiftAllTimers(dt); window.startCountdown?.(); }
    albumBtn?.addEventListener('click', openAlbum);
    albumClose?.addEventListener('click', closeAlbum);
  }

  // mark seen when stage image chosen
  function hookGetLevelImageSeen(){
    const f = window.getLevelImage;
    if (typeof f!=='function') return;
    window.getLevelImage = function(levelNum){
      const img = f(levelNum);
      try{
        const idx=((levelNum-1)%10)+1;
        const chosenIsBG = (window.imageChoice?.[((levelNum-1)%10)]===0);
        window.__markSeen?.(idx, (levelNum<=10 ? (chosenIsBG?'bg':'cg') : (chosenIsBG?'cg':'bg')));
      }catch(e){}
      return img;
    };
  }
})();
// /* __CENTERNOTE_HIDE_FIX__ */
(function(){
  const centerNote = document.getElementById('centerNote');
  if(!centerNote) return;
  const refresh = () => {
    const style = window.getComputedStyle(centerNote);
    centerNote.style.pointerEvents = (style.display==='none' || style.visibility==='hidden' || centerNote.hidden) ? 'none' : 'auto'
  };
  new MutationObserver(refresh).observe(centerNote, { attributes:true, attributeFilter:['style','hidden','class']});
  refresh();
})();
</script>

</body>
</html>
