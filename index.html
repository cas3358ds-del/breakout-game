<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rockæ‰“ç£šå¡Š Breakoutï¼ˆæœ€çµ‚å¢å¼·ç‰ˆï¼‰</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
  <style>
    /* å…¨é¢æ›ç”¨å…¨æ–° UI é¢¨æ ¼ï¼ˆå–è‡ª index_skin.htmlï¼‰ */
    :root{
      --ink:#eaf2ff; --muted:#b8c7ea;
      --glass-1:rgba(255,255,255,.08); --glass-2:rgba(255,255,255,.06);
      --stroke:rgba(140,180,255,.28);
      --bg1:#13224a; --bg2:#081022;
      --hudGrad1:rgba(20,25,44,.62); --hudGrad2:rgba(12,20,42,.44);
      --stageGlass:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
      --panelPattern:none;
      --btnGlow:0 0 0 rgba(0,0,0,0);
      --hudBottom:96px;
      --heartGlow: rgba(0,0,0,0);
      /* ä¿ç•™åŸæœ¬ç£šå¡Šèˆ‡é“å…·é¡è‰² */
      --brick1:#ff6b6b; --brick2:#ffd166; --brick3:#06d6a0; --brick4:#4cc9f0;
      --expl:#ff8c00; --power:#7aa2ff; --debuff:#ff6aa3;
      --glass-stroke:rgba(255,255,255,.12);
    }
    html,body{
      height:100%; margin:0; color:var(--ink);
      background: radial-gradient(140% 140% at 50% -12%, var(--bg1) 0%, #0e1a3a 50%, #0b1633 75%, var(--bg2) 100%);
      font-family: ui-sans-serif, -apple-system, system-ui, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:0 12px 24px}
    header{
      padding:calc(8px + env(safe-area-inset-top)) 0 10px;
      display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:space-between
    }
    h1{font-size:clamp(16px,2.6vw,22px);margin:0 8px 0 0;letter-spacing:.4px;opacity:.95}
    .small{font-size:12px;color:var(--muted)}

    /* HUD èˆ‡ UI */
    .hud{
      position:sticky;top:0;z-index:30;
      display:grid;gap:8px;align-items:center;
      grid-template-columns:1fr;max-width:min(1080px,96vw);margin:8px auto 0;
      border:1px solid var(--stroke);
      border-radius:18px;padding:10px;
      background:linear-gradient(180deg,var(--hudGrad1),var(--hudGrad2));
      backdrop-filter: blur(8px);
      box-shadow:0 6px 28px rgba(0,0,0,.28)
    }
    .stats{display:grid;grid-template-columns:auto auto 1fr;grid-auto-rows:minmax(36px,auto);gap:8px 10px;align-items:center}
    .stats .wide{grid-column:1 / -1}
    .pill{
      padding:8px 18px;border:1px solid var(--stroke);
      background:var(--glass-2);border-radius:999px;
      min-height:36px;display:flex;align-items:center;gap:10px;
      color:#d7e3ff;font-weight:650;font-size:15px
    }
    .pill b{color:#fff;font-variant-numeric:tabular-nums}
    .inline-controls{justify-self:end;display:flex;gap:8px;align-items:center;position:relative}
    .ic-btn{
      width:48px;height:36px;border-radius:12px;border:1px solid var(--stroke);
      background:radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.16), rgba(255,255,255,0) 58%), var(--glass-1);
      display:grid;place-items:center;cursor:pointer;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.05), 0 8px 20px rgba(0,0,0,.28), var(--btnGlow);
      color:#fff
    }
    .ic-btn:active{transform:translateY(1px)}
    .ic-btn .ico{font-size:18px;line-height:1}
    .menu{
      position:absolute;top:46px;right:0;min-width:280px;padding:10px;
      border:1px solid var(--stroke);border-radius:14px;
      background:rgba(12,18,36,.96);backdrop-filter:blur(10px);
      transform:scale(.96);opacity:0;pointer-events:none;transition:.16s ease;z-index:60
    }
    .menu.show{transform:scale(1);opacity:1;pointer-events:auto}
    .menu .item{display:flex;align-items:center;gap:10px;padding:10px;border:1px solid var(--stroke);border-radius:10px;background:var(--glass-2);margin-bottom:8px}
    .menu h4{margin:6px 0 8px;font-size:13px;color:#cfe0ff}
    .btn{
      padding:8px 12px;border-radius:10px;border:1px solid var(--stroke);cursor:pointer;
      background:var(--glass-2);color:#fff;box-shadow:var(--btnGlow)
    }
    .level-select{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .level-select select{
      min-width:120px;
      color:#d7e3ff;
    }
    .level-select select option{
      background:#0b1633;
      color:#d7e3ff;
    }
    .level-select select option.boss-level{
      color:#ffb347;
      font-weight:800;
      background:rgba(255,155,74,.22);
    }
    .level-select select.boss-selected{
      color:#ffb347;
      font-weight:700;
    }
    select,input[type="range"]{background:var(--glass-2);color:#fff;border:1px solid var(--stroke);border-radius:8px;padding:6px 10px}
    /* Buffs & Prompts */
    #buffs{
      position:sticky;z-index:22;
      top:calc(var(--hudBottom) + 6px);
      display:flex;align-items:center;
      max-width:min(1080px,96vw);margin:6px auto 0;padding-left:6px;
      overflow:auto;scrollbar-width:none;
      --buff-scale:1;
      font-size:calc(12px * var(--buff-scale));
      gap:calc(8px * var(--buff-scale));
    }
    #buffs::-webkit-scrollbar{display:none}
    #buffs .badge{
      display:inline-flex;align-items:center;
      gap:calc(8px * var(--buff-scale));
      padding:calc(6px * var(--buff-scale)) calc(10px * var(--buff-scale));
      border:1px solid var(--stroke);border-radius:999px;
      background:var(--glass-1);font-size:1em;white-space:nowrap;color:#cfe0ff
    }
    #playArea{
      position:relative;
      max-width:min(1080px,96vw);
      margin:12px auto 0;
      padding-top:72px;
    }
    #promptsDock{
      position:absolute;left:0;right:0;top:0;z-index:20;
      display:flex;gap:8px;justify-content:center;padding:0 6px;
      overflow:hidden;
    }
    #promptsDock .prompt{
      flex:1 1 calc((100% - 16px)/3);
      max-width:calc((100% - 16px)/3);
      min-width:0;height:48px;
      padding:8px 10px;border:1px solid var(--stroke);border-radius:12px;
      background:linear-gradient(180deg,var(--glass-1),var(--glass-2));
      backdrop-filter:blur(6px);
      box-shadow:0 8px 20px rgba(0,0,0,.3);
      font-size:12px;line-height:1.45;color:#eaf2ff;white-space:normal;
      word-break:break-word;overflow-wrap:anywhere;
      display:flex;align-items:center;justify-content:center;text-align:center;
      opacity:1;transition:opacity .4s
    }
    #promptsDock .prompt.fade{opacity:0}
    @media (min-width:768px){
      #playArea{padding-top:0;display:flex;gap:12px;align-items:flex-start;}
      #promptsDock{
        position:absolute;top:0;left:-200px;right:auto;width:180px;
        flex-direction:column;justify-content:flex-start;
      }
      #promptsDock .prompt{
        width:100%;height:60px;flex:none;
      }
    }
    /* Stage */
    .stage{position:relative;margin:0 auto 0;max-width:100%;border-radius:18px;padding:12px;box-sizing:border-box;background:var(--stageGlass);background-image:var(--panelPattern);background-blend-mode:overlay;}
    canvas#game{background:linear-gradient(180deg,#0d132a,#0b1226 55%, #091223);border:1px solid rgba(80,110,170,.45);border-radius:16px;display:block;width:100%;height:auto;margin:0 auto;box-shadow:inset 0 0 160px rgba(255,255,255,.03), 0 28px 90px rgba(0,0,0,.46);touch-action:none;}
    .legend{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;font-size:12px;color:#cfe0ff;margin-top:6px}
    .legend .item{padding:4px 8px;border-radius:10px;background:rgba(255,255,255,.05);border:1px solid var(--stroke);display:flex;align-items:center;gap:4px}
    .legend .box{width:14px;height:14px;border-radius:3px;display:inline-block;vertical-align:middle}
    .sealed{opacity:0.4;filter:grayscale(100%)}
    .unlockHint{font-size:0.8em;color:#f88;margin-left:4px;}
    #combo{
      position:absolute;
      top:8px;
      right:12px;
      font-size:19px;
      font-family:'Playfair Display',serif;
      font-weight:700;
      text-transform:none;
      font-variant-caps:normal;
      pointer-events:none;
      opacity:0;
      transform-origin:top right;
      transition:opacity .4s,transform .2s;
      text-shadow:0 1px 0 rgba(0,0,0,.6),0 2px 0 rgba(0,0,0,.6),0 3px 0 rgba(0,0,0,.5),0 4px 3px rgba(0,0,0,.7);
    }
    #combo.show{opacity:1}
    #combo.tier1{color:#ffffff}
    #combo.tier2{color:#00ff7f}
    #combo.tier3{color:#00bfff}
    #combo.tier4{color:#8a2be2}
    #combo.tier5{color:#ff69b4}
    #combo.tier6{color:#ffd700}
    #combo.glow{animation:goldBlink 1s infinite}
    #combo.pop{animation:comboPop .5s}
    #combo.glow.pop{animation:goldBlink 1s infinite,comboPop .5s}
    #combo.star{animation:comboStarGlow 1s linear infinite}
    #combo.star.pop{animation:comboStarGlow 1s linear infinite,comboPop .5s}
    @keyframes comboStarGlow{
      0%{color:#ff4d6d;text-shadow:0 0 8px #ff4d6d,0 0 16px #ff4d6d}
      25%{color:#ffd166;text-shadow:0 0 8px #ffd166,0 0 16px #ffd166}
      50%{color:#06d6a0;text-shadow:0 0 8px #06d6a0,0 0 16px #06d6a0}
      75%{color:#4cc9f0;text-shadow:0 0 8px #4cc9f0,0 0 16px #4cc9f0}
      100%{color:#ff4d6d;text-shadow:0 0 8px #ff4d6d,0 0 16px #ff4d6d}
    }
    #comboNotice{
      position:absolute;left:0;right:0;top:0;z-index:30;
      overflow:hidden;pointer-events:none;
      font-family:'Playfair Display',serif;font-weight:700;font-size:24px;
      color:#fff;text-shadow:0 2px 4px rgba(0,0,0,.6);
      opacity:0;transition:opacity 3s;
      display:flex;align-items:center;justify-content:center;
    }
    #comboNotice.show{opacity:1}
    #comboNotice.fade{opacity:0}
    #comboNotice .marqueeText{white-space:nowrap;display:inline-block;animation:comboMarquee 5s linear;}
    @keyframes comboPop{0%{transform:scale(.3) rotate(-15deg);}60%{transform:scale(1.4) rotate(10deg);}80%{transform:scale(.9) rotate(-5deg);}100%{transform:scale(1) rotate(0);}}
    @keyframes goldBlink{0%{text-shadow:0 0 6px rgba(255,215,0,.7);}50%{text-shadow:0 0 18px rgba(255,215,0,1);}100%{text-shadow:0 0 6px rgba(255,215,0,.7);}}
    @keyframes comboMarquee{0%{transform:translateX(100%);}100%{transform:translateX(-100%);}}
    /* Hearts and Nine-cat history */
    .hearts{filter:drop-shadow(0 0 10px var(--heartGlow));display:inline-block}
    .hearts.compact .life-icon{width:14px;height:14px}
    .fire-energy{margin-left:6px;display:none;color:#ffb347;font-weight:700;filter:drop-shadow(0 0 6px #ff8c00)}
    .cats{display:flex;margin-left:auto;gap:4px}
    .cats .cat-icon{width:14px;height:14px;display:inline-block}
    /* Gallery and overlay (retain original styles) */
    .overlay{position:fixed;inset:0;z-index:40;pointer-events:none}
    .gallery{position:absolute;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;z-index:4;pointer-events:auto}
    .gallery .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.75);opacity:0;transition:opacity .6s;}
    .gallery img{max-width:min(94vw,1040px);max-height:min(88vh,680px);border-radius:16px;box-shadow:0 30px 120px rgba(0,0,0,.6);opacity:0;transform:translateY(12px) scale(.98);transition:opacity .6s, transform .6s;}
    .gallery .hint{position:absolute;bottom:24px;color:#fff;font-size:16px;opacity:0;text-shadow:0 2px 10px rgba(0,0,0,.6);}
    .gallery.show .backdrop{opacity:1;}
    .gallery.show img{opacity:1;transform:translateY(0) scale(1);} 
    .gallery.show .hint{opacity:.9;}
    .gallery .dialog,
    .gallery-page .viewer .dialog{position:absolute;left:50%;transform:translateX(-50%);bottom:60px;background:rgba(0,0,0,.6);color:#fff;padding:12px 20px;border-radius:12px;font-size:18px;max-width:90%;text-align:center;display:none;z-index:2;}
    .gallery-page .viewer .options{position:absolute;left:50%;transform:translateX(-50%);bottom:20px;display:flex;gap:8px;z-index:2;}
    .gallery-page .viewer .options button.locked{filter:grayscale(1);opacity:0.5;cursor:default;}

    /* Gallery page overlay */
    .gallery-page{position:fixed;inset:0;display:none;z-index:70;align-items:center;justify-content:center;pointer-events:auto}
    .gallery-page .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.8)}
    .gallery-page .content{position:relative;z-index:2;width:min(96vw,1080px);max-height:92vh;display:flex;flex-direction:column;background:linear-gradient(180deg,rgba(10,14,30,.95),rgba(10,14,30,.88));border:1px solid var(--glass-stroke);border-radius:16px;padding:12px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .gallery-page .close{align-self:flex-end;cursor:pointer;font-size:24px;line-height:1}
    .gallery-page .thumbs{flex:1 1 auto;display:grid;grid-template-columns:repeat(5,1fr);gap:8px;overflow:auto;padding:4px}
    .gallery-page .thumb{position:relative;border:1px solid var(--stroke);border-radius:10px;overflow:hidden;cursor:pointer;aspect-ratio:1/1}
    .gallery-page .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .gallery-page .thumb.locked{cursor:default;filter:grayscale(1) brightness(.3)}
    .gallery-page .thumb.locked::after{content:'\1F512';position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:32px;background:rgba(0,0,0,.6)}
    .gallery-page .nav{display:flex;gap:12px;justify-content:center;padding-top:8px}
    .gallery-page .viewer{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.85);z-index:3}
    .gallery-page .viewer img{max-width:94vw;max-height:88vh;border-radius:16px;box-shadow:0 30px 120px rgba(0,0,0,.6)}

    /* Leaderboard overlay */
    .rank-page{position:fixed;inset:0;display:none;z-index:75;align-items:center;justify-content:center;pointer-events:auto}
    .rank-page .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.8)}
    .rank-page .content{position:relative;z-index:2;width:min(96vw,960px);max-height:92vh;display:flex;flex-direction:column;background:linear-gradient(180deg,rgba(10,14,30,.95),rgba(10,14,30,.88));border:1px solid var(--glass-stroke);border-radius:16px;padding:12px;box-shadow:0 20px 90px rgba(0,0,0,.5);overflow:auto;min-width:0}
    .rank-page .close{align-self:flex-end;cursor:pointer;font-size:24px;line-height:1}
    .rank-page table{width:100%;border-collapse:collapse;font-size:14px;margin-top:4px}
    .rank-page th,.rank-page td{border:1px solid var(--stroke);padding:4px 6px;text-align:center}
    @media (max-width: 600px){
      .rank-page table{font-size:12px;}
      .rank-page th,.rank-page td{padding:2px 4px;}
    }
    @media (max-width: 420px){
      .rank-page table{font-size:10px;}
    }

    /* Win and Game Over overlays */
    .win{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:6;pointer-events:auto}
    .win.show{display:flex;}
    .gameover{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:8;pointer-events:auto}
    .gameover.show{display:flex;}
    .gameover .backdrop{position:absolute;inset:0;background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .gameover .center{position:relative;z-index:2;text-align:center;background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75));padding:18px 22px;border:1px solid var(--glass-stroke);border-radius:16px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .win .backdrop{position:absolute;inset:0;background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .thumb-ring{position:absolute;inset:16px;pointer-events:none;display:grid;grid-template-columns:repeat(10,1fr);gap:6px;opacity:.95}
    .thumb-ring img{width:100%;height:100%;object-fit:cover;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,.5);}
    .win .center{position:relative;z-index:2;text-align:center;background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75));padding:18px 22px;border:1px solid var(--glass-stroke);border-radius:16px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .win h2{margin:4px 0 6px;font-size:28px;letter-spacing:2px}
    .win .small{opacity:.8;font-size:12px;margin-top:6px}
    .win .again{margin-top:10px}
    /* Note box */
    .center-note{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:auto;z-index:3}
    .note-box{background:linear-gradient(180deg, rgba(8,12,28,.9), rgba(8,12,28,.85));border:1px solid var(--glass-stroke);padding:16px 18px;border-radius:14px;text-align:center;max-width:min(90vw,860px);max-height:90vh;overflow:auto;box-shadow:0 12px 60px rgba(0,0,0,.5);font-size:14px;position:relative}
    .note-box h2{margin:0 0 8px 0;font-size:18px}
    .note-box p{margin:6px 0;line-height:1.6}
    @media (max-width:480px){
      .note-box{font-size:12px;}
      .note-box h2{font-size:16px;}
    }
    kbd{background:#0e1836;border:1px solid #2a356a;border-radius:6px;padding:2px 6px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:90%}
    .note-close{
      position:absolute;top:8px;right:8px;width:28px;height:28px;border-radius:999px;
      display:grid;place-items:center;cursor:pointer;user-select:none;
      border:1px solid var(--glass-stroke);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), rgba(255,255,255,.02));
      box-shadow: 0 6px 16px rgba(0,0,0,.25);
      color:#d7dcff;font-weight:800;line-height:1;
    }
    .note-close:hover{filter:brightness(1.1);}
    .note-close:active{transform:translateY(1px);}
    @media (max-width:390px){
      .pill{font-size:14px;padding:7px 14px}
      .ic-btn{width:44px;height:36px}
    }

  

/* === ä¿®æ­£ä¸‹æ‹‰é¸å–®ï¼šé¿å…å…¨ç™½çœ‹ä¸åˆ°é¸é …æ–‡å­— === */
select { color: #fff; background: var(--glass-2); }
/* å¼·åˆ¶ä¸‹æ‹‰æ¸…å–®çš„é¸é …å¯è¦‹ï¼ˆä¸åŒç€è¦½å™¨å¯èƒ½å„è‡ªè™•ç†ï¼Œä½†é€™èƒ½æ”¹å–„å¤šæ•¸æƒ…æ³ï¼‰ */
select option { color: #0b1022; background: #eaf2ff; }
select optgroup { color: #0b1022; }
/* èœå–®å…§çš„ select ç¶­æŒæ·±è‰²å¤–è§€ï¼Œä½†é¸å–®å±•é–‹çš„é¸é …ä»æ˜¯æ·±å­—æ·ºåº• */
.menu select { color: #eaf2ff; background: rgba(20,28,52,.6); border:1px solid var(--stroke); }
.menu select option { color: #0b1022; background: #eaf2ff; }


/* === Canvas FX å±¤ï¼šåœ¨éŠæˆ²ç•«å¸ƒä¸‹å±¤ç¹ªè£½éœ“è™¹å…‰æŸèˆ‡å½©è™¹æšˆ === */
.stage{position:relative}
.stage #fx{
  position:absolute; inset:12px; border-radius:16px; display:block; width:calc(100% - 24px); height:auto;
  pointer-events:none; filter: blur(0.2px);
}
.stage{--fxViz:0}

    /* === ç§‘æŠ€ï¼é­…å½±å¹»å½©ï¼ˆæœ¦æœ§ç´«é»‘ä¸ƒå½©éœ“è™¹ï¼‰ === */
    body[data-skin="ç§‘æŠ€ï¼é­…å½±å¹»å½©"]{
      --ink:#f3e8ff;
      --muted:#d6c3ff;
      --stroke:rgba(200,160,255,.4);
      --bg1:#140022;
      --bg2:#05000c;
      --hudGrad1:rgba(30,10,60,.62);
      --hudGrad2:rgba(20,6,40,.44);
      --glass-1:rgba(255,255,255,.1);
      --glass-2:rgba(255,255,255,.07);
      --stageGlass:linear-gradient(180deg, rgba(80,40,120,.04), rgba(0,0,0,0));
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(160,80,255,.25);
    }
    body[data-skin="ç§‘æŠ€ï¼é­…å½±å¹»å½©"] .stage{--fxViz:0}

    /* === ç§‘æŠ€ï¼è³½åšæ ¼ç¶ ï¼ˆé«˜è³ªæ„Ÿè³½åšç‰¹æ•ˆï¼‰ === */
    body[data-skin="ç§‘æŠ€ï¼è³½åšæ ¼ç¶ "]{
      --ink:#eafff3;
      --muted:#aee4c8;
      --stroke:rgba(180,255,200,.4);
      --bg1:#02190f;
      --bg2:#00150a;
      --hudGrad1:rgba(0,40,20,.62);
      --hudGrad2:rgba(0,30,15,.44);
      --glass-1:rgba(255,255,255,.1);
      --glass-2:rgba(255,255,255,.07);
      --stageGlass:linear-gradient(180deg, rgba(0,50,30,.05), rgba(0,0,0,0));
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(30,200,100,.25);
    }
    body[data-skin="ç§‘æŠ€ï¼è³½åšæ ¼ç¶ "] .stage{--fxViz:0}

    /* === å®‡å®™ï¼æ˜Ÿè¾°çµ®èª === */
    body[data-skin="å®‡å®™ï¼æ˜Ÿè¾°çµ®èª"]{ --ink:#eef0ff; --muted:#c9c9ff; --stroke:rgba(160,140,255,.34); --bg1:#0c0b24; --bg2:#09081a; --hudGrad1:rgba(30,24,70,.58); --hudGrad2:rgba(20,18,50,.44); --glass-1:rgba(200,180,255,.10); --glass-2:rgba(160,140,255,.08); --stageGlass:linear-gradient(180deg, rgba(160,140,255,.05), rgba(0,0,0,0)); --panelPattern:radial-gradient(120px 80px at 20% 10%, rgba(110,80,255,.08), transparent 60%), radial-gradient(160px 120px at 80% 20%, rgba(180,100,255,.08), transparent 60%); --btnGlow:0 0 22px rgba(150,120,255,.25); }

    /* === å†°é›ªï¼æ¥µå…‰çµ²ç¶¢ === */
    body[data-skin="å†°é›ªï¼æ¥µå…‰çµ²ç¶¢"]{ --ink:#f6fbff; --muted:#d7e9ff; --stroke:rgba(190,220,255,.38); --bg1:#0b1626; --bg2:#060b14; --hudGrad1:rgba(18,28,60,.56); --hudGrad2:rgba(10,20,44,.42); --glass-1:rgba(220,245,255,.12); --glass-2:rgba(210,235,255,.09); --stageGlass:linear-gradient(180deg, rgba(230,245,255,.04), transparent); --panelPattern:conic-gradient(from 0deg at 60% 40%, rgba(180,220,255,.06), rgba(160,210,255,.05), rgba(180,230,255,.06)); --btnGlow:0 0 20px rgba(180,220,255,.26); }
    body[data-skin="å†°é›ªï¼æ¥µå…‰çµ²ç¶¢"] .hearts .life-icon{ width:24px; height:24px; }
    body[data-skin="å†°é›ªï¼æ¥µå…‰çµ²ç¶¢"] .hearts .life-icon svg{ width:24px; height:24px; }

    /* === çƒˆé™½ï¼ç‚™é‡‘å¹»ç„° === */
    body[data-skin="çƒˆé™½ï¼ç‚™é‡‘å¹»ç„°"]{
      --ink:#fff6e8;
      --muted:#ffd3a6;
      --stroke:rgba(255,180,120,.36);
      --bg1:#3a1000;
      --bg2:#1a0400;
      --hudGrad1:rgba(90,30,0,.58);
      --hudGrad2:rgba(60,20,0,.44);
      --glass-1:rgba(255,170,80,.12);
      --glass-2:rgba(255,130,40,.09);
      --stageGlass:linear-gradient(180deg, rgba(255,160,40,.05), transparent);
      --panelPattern:none;
      --btnGlow:0 0 22px rgba(255,160,80,.28);
    }

    /* === æ©Ÿæ¢°ï¼é½’è¼ªé¨å£« === */
    body[data-skin="æ©Ÿæ¢°ï¼é½’è¼ªé¨å£«"]{
      --ink:#fff4e6;
      --muted:#e6cfa6;
      --stroke:rgba(200,150,80,.4);
      --bg1:#3d2b1f;
      --bg2:#1b120b;
      --hudGrad1:rgba(80,60,40,.6);
      --hudGrad2:rgba(50,40,30,.44);
      --glass-1:rgba(255,200,120,.12);
      --glass-2:rgba(200,150,90,.08);
      --stageGlass:linear-gradient(180deg, rgba(120,80,40,.05), transparent);
      --panelPattern:radial-gradient(40px 40px at 20% 30%, rgba(120,80,40,.1), transparent 60%),
                      radial-gradient(50px 50px at 80% 60%, rgba(160,110,50,.1), transparent 60%);
      --btnGlow:0 0 18px rgba(255,190,90,.25);
    }
    /* === å’Œé¢¨ï¼ç„¡é™ä¹‹åŸ === */
    body[data-skin="å’Œé¢¨ï¼ç„¡é™ä¹‹åŸ"]{
      --ink:#ffedc2;
      --muted:#cbb07a;
      --stroke:rgba(247,227,174,.35);
      --bg1:#130a00;
      --bg2:#060300;
      --hudGrad1:rgba(80,60,20,.55);
      --hudGrad2:rgba(50,35,10,.45);
      --glass-1:rgba(255,255,255,.08);
      --glass-2:rgba(255,255,255,.05);
      --stageGlass:linear-gradient(180deg, rgba(255,200,120,.07), transparent);
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(255,200,120,.25);
    }
    body[data-skin="å’Œé¢¨ï¼ç„¡é™ä¹‹åŸ"] #game{
      /* ä¿®æ­£èƒŒæ™¯ä½ç½®å±¬æ€§æ‹¼å¯«éŒ¯èª¤ï¼Œç¢ºä¿åœ–ç‰‡æ­£å¸¸é¡¯ç¤º */
      background:url("images/d1.JPG") center/cover no-repeat;
    }

/* HUD/æŒ‰éµçš„éœ“è™¹èªå½™ï¼ˆæŒ‰éµé‚Šç·£æµå…‰ï¼‹å¿ƒå½¢å…‰æšˆï¼‰ */

    /* ä¸Šå‚³æ’è¡Œæ¦œé€²åº¦æç¤º */
    #uploadOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #uploadOverlay .box {
      background: var(--bg1);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      width: 260px;
    }
    #uploadOverlay .progress {
      width: 100%;
      height: 10px;
      background: var(--glass-2);
      border-radius: 5px;
      overflow: hidden;
      margin-top: 12px;
    }
    #uploadOverlay .progress > div {
      height: 100%;
      width: 0%;
      background: var(--ink);
      transition: width 0.1s;
    }
    #uploadOverlay .percent {
      margin-top: 8px;
      font-size: 14px;
    }


/* === Mobile scaling & LED alignment tweaks (Game Director standard) === */
@media (max-width: 430px) {
  .wrap { padding: 8px; }
  .stage { max-width: 100vw; padding: 8px; }
  .stage #fx { inset: 8px; border-radius: 18px; }
  canvas#game { border-radius: 18px; }
  .legend { transform: scale(0.92); transform-origin: top center; }
  #buffs { --buff-scale: 0.9; }
}
</style>
</head>
<body>
  <!-- æ–°å¢ UI åŒ…è£ -->
  <div class="wrap" id="app">
    <header>
      <h1>Rockæ‰“ç£šå¡Š â€” <span id="skinTitle">ç¶“å…¸é¢¨æ ¼</span></h1>
      <span class="small" id="skinDesc">LEDï¼šä¸‰å´ä¸€è‡´æ·±è—ï¼Œå³å´é¡åƒï¼Œ2s å‘¼å¸ã€‚</span>
    </header>
    <!-- é ‚éƒ¨ HUD -->
    <section class="hud" aria-label="éŠæˆ² HUD">
      <div class="stats">
        <div class="pill">åˆ†æ•¸ <b id="score">0</b></div>
        <div class="pill">é—œå¡ <b id="level">1</b>/<span id="totalLevels">20</span></div>
        <div class="inline-controls">
          <button class="ic-btn" id="sndBtn" aria-haspopup="true" aria-expanded="false" aria-controls="soundMenu" title="è²éŸ³"><span class="ico">ğŸ”Š</span></button>
          <div class="menu" id="soundMenu">
            <div class="item"><span>ğŸµ</span><label><input type="checkbox" id="bgmOn"> BGM é–‹é—œ</label></div>
            <div class="item"><span>ğŸš</span><label style="width:100%">BGM éŸ³é‡ <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.7" style="width:60%" aria-label="BGM éŸ³é‡"></label></div>
            <div class="item"><span>ğŸ”ˆ</span><label><input type="checkbox" id="sfxOn" checked> éŸ³æ•ˆé–‹é—œ</label></div>
            <!-- éš±è—çš„èˆŠç‰ˆæŒ‰éˆ•ï¼Œç”¨æ–¼è…³æœ¬ç¶­æŒé‚è¼¯ -->
            <button id="soundBtn" style="display:none;"></button>
            <button id="bgmBtn" style="display:none;"></button>
          </div>
          <button class="ic-btn" id="optBtn" aria-haspopup="true" aria-expanded="false" aria-controls="optMenu" title="é¸é …">â‹¯</button>
          <div class="menu" id="optMenu">
            <h4>éŠæˆ²</h4>
            <div class="item"><span>ğŸ®</span>é›£åº¦ <select id="difficulty" aria-label="é›£åº¦">
              <option value="easy">ç°¡å–®</option>
              <option value="normal" selected>ä¸€èˆ¬</option>
              <option value="hard">å›°é›£</option>
            </select></div>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn" id="pauseBtn" style="display:none;">æš«åœ/ç¹¼çºŒ</button>
              <button class="btn" id="resetBtn">é‡æ–°é–‹å§‹</button>
              <button class="btn" id="saveBtn">å­˜æª”</button>
              <button class="btn" id="loadBtn">è®€æª”</button>
              <button class="btn" id="clearSaveBtn">æ¸…é™¤å­˜æª”</button>
              <label class="btn level-select" id="levelJumpLabel">è·³è‡³é—œå¡
                <select id="levelJumpSel" aria-label="è·³è‡³é—œå¡"></select>
              </label>
            </div>
            <h4>å…¶ä»–</h4>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn" id="fsBtn">å…¨è¢å¹•</button>
              <button class="btn" id="tutorBtn">æ•™å­¸</button>
              <button class="btn" id="effectsBtn">æ•ˆæœèªªæ˜</button>
              <button class="btn" id="galleryBtn">ç•«å»Š</button>
              <button class="btn" id="rankBtn">æ’è¡Œæ¦œ</button>
            </div>
            <div class="item"><span>ğŸ¨</span>Skin <select aria-label="Skin" id="skinSel">
              <option>ç¶“å…¸ï¼å†·è—ç»ç’ƒ</option>
            </select></div>
          </div>
        </div>
        <div class="pill wide">ç”Ÿå‘½ <b id="lives">3</b> <span class="hearts" id="hearts">â¤ï¸â¤ï¸â¤ï¸</span> <span id="fireEnergy" class="fire-energy"></span> <span class="cats" id="cats" style="display:none"></span></div>
      </div>
    </section>
    <div class="hud-sentinel" style="height:0"></div>
    <!-- Buffs / æç¤º -->
    <div id="buffs" class="badges"></div>
    <div id="playArea">
      <div id="promptsDock"></div>
      <!-- éŠæˆ²å€åŸŸ -->
      <div class="stage">
        <canvas id="fx"></canvas>
<canvas id="game" width="1100" height="700"></canvas>
        <div id="combo" class="combo"></div>
        <div class="legend">
        <span class="item"><span class="box" style="background:var(--expl)"></span>çˆ†ç‚¸ç£š</span>
        <span class="item"><span class="box" style="background:var(--brick2)"></span>ä¸€èˆ¬ç£š</span>
        <span class="item"><span class="box" style="background:#888"></span>ä¸å¯ç ´å£ç£š</span>
        <span class="item"><span class="box" style="background:#bb7aff"></span>å¼·åå½ˆç£š</span>
        <span class="item"><span class="box" style="background:#6ec6ff"></span>ç§»å‹•ç£š</span>
        <span class="item"><span class="box" style="background:#ff4d6d"></span>Bossç£š</span>
        <span class="item"><span class="box" style="background:var(--power)"></span>å¢ç›Šé“å…·</span>
        <span class="item"><span class="box" style="background:var(--debuff)"></span>æ¸›ç›Šé“å…·</span>
      </div>
    </div>
  </div>

    <!-- è¦†è“‹å±¤/ç•«å»Š/å‹åˆ©/çµæŸ/æç¤º -->
    <div class="overlay">
      <div class="gallery" id="gallery">
        <div class="backdrop"></div>
        <img id="galleryImg" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" alt="é—œå¡å¤§åœ–" />
        <div class="hint" id="galleryHint">é»ä¸€ä¸‹é¡¯ç¤ºå°è© â–¶</div>
        <div class="dialog" id="galleryDialog"></div>
      </div>

      <div class="gallery-page" id="galleryPage">
        <div class="backdrop"></div>
        <div class="content">
          <div class="close" id="galleryClose">âŒ</div>
          <div class="thumbs" id="galleryThumbs"></div>
          <div class="nav">
            <button class="btn" id="galleryPrev">å‰ä¸€é </button>
            <span id="galleryPageInfo">1 / 2</span>
            <button class="btn" id="galleryNext">ä¸‹ä¸€é </button>
          </div>
        </div>
        <div class="viewer" id="galleryViewer">
          <img id="galleryViewerImg" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" alt="ç•«å»Šå¤§åœ–" />
          <div class="options" id="viewerOptions"></div>
          <div class="dialog" id="viewerDialog"></div>
        </div>
      </div>

      <div class="rank-page" id="rankPage">
        <div class="backdrop"></div>
        <div class="content">
          <div class="close" id="rankClose">âŒ</div>
          <h2 style="text-align:center;margin:4px 0 8px;">æ’è¡Œæ¦œ</h2>
          <table id="rankTable">
            <thead>
              <tr>
                <th>åæ¬¡</th>
                <th>ç©å®¶</th>
                <th>åˆ†æ•¸</th>
                <th>æ¶ˆè€—ç”Ÿå‘½</th>
                <th>æ¥çƒæ•¸</th>
                <th>å¢ç›Šæ¬¡æ•¸</th>
                <th>æ¸›ç›Šæ¬¡æ•¸</th>
                <th>æ®ºæ•µæ•¸</th>
                <th>æ®ºBossæ•¸</th>
                <th>æœ€å¿«æ­»äº¡</th>
                <th>æœ€ä¹…å­˜æ´»</th>
                <th>æœ€é«˜Comboæ•¸</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="win" id="win">
        <div class="backdrop"></div>
        <div class="thumb-ring" id="ring"></div>
        <div class="center">
          <h2>æ­å–œéé—œï¼</h2>
          <div style="font-size:28px;margin:6px 0;">ç¸½åˆ†æ•¸ï¼š<span id="finalScore">0</span></div>
          <div id="statsWin" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:360px"></div>
          <div class="small">ä½œè€…ï¼š ChatGPTã€€ï¼ã€€æŒ‡å°è€…ï¼š Rock</div>
          <div class="again"><button class="btn" id="uploadWin">ä¸Šå‚³æ’è¡Œæ¦œ</button> <button class="btn" id="againBtn">å†ç©ä¸€æ¬¡</button></div>
        </div>
      </div>

      <div class="gameover" id="gameover">
        <div class="backdrop"></div>
        <div class="center">
          <h2>éŠæˆ²çµæŸ</h2>
          <div style="font-size:28px;margin:6px 0;">æœ€çµ‚åˆ†æ•¸ï¼š<span id="finalScore2">0</span></div>
          <div id="statsOver" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:320px"></div>
          <div class="again"><button class="btn" id="uploadOver">ä¸Šå‚³æ’è¡Œæ¦œ</button> <button class="btn" id="retryBtn">å†æ¬¡éŠæˆ²</button></div>
        </div>
      </div>
      
      <div class="center-note" id="centerNote">
        <div class="note-box" id="noteBox"><button class="note-close" id="noteClose" aria-label="é—œé–‰">Ã—</button>
          <h2 id="noteTitle">æŒ‰ <kbd>Space</kbd> æˆ–é»ç•«é¢é–‹å§‹</h2>
          <p id="noteText">
            æ“ä½œï¼š<kbd>â†</kbd>/<kbd>â†’</kbd> æˆ– <kbd>A</kbd>/<kbd>D</kbd>ï¼›æ‰‹æŒ‡æ‹–æ›³ç•«é¢ä¹Ÿå¯ç§»å‹•å¹³å°ã€‚<br>
            å·²æ•´åˆï¼šèƒŒæ™¯é€æ­¥æ­ç¤º + æ¸…é—œç•«å»Šã€å¢ç›Š/æ¸›ç›Šï¼ˆå«é›»æ¼¿çƒ/å‡çµçƒ/ç¥è–çƒ/é³³å‡°å¯©åˆ¤/9å‘½æ€ªè²“ï¼‰ã€çˆ†ç‚¸ç£šã€éŸ³æ•ˆã€é›£åº¦ã€å­˜è®€æª”ã€BGMã€æ•™å­¸/æ•ˆæœèªªæ˜ã€Bossèˆ‡é€²éšç£šã€‚
          </p>
        </div>
      </div>
</div>
  </div>
  <div id="uploadOverlay">
    <div class="box">
      <div>ä¸Šå‚³ä¸­...</div>
      <div class="progress"><div id="uploadBar"></div></div>
      <div class="percent" id="uploadPercent">0%</div>
    </div>
  </div>

<!-- Load skin definitions before the game script.  This file defines
     window.SKINS, window.applySkin and initializes the default skin. -->
<script src="skin.js"></script>
<script>
(() => {

  // Google Apps Script éƒ¨ç½²å¾Œçš„ Web App URLï¼Œéœ€æ›¿æ›ç‚ºæ‚¨è‡ªå·±çš„ç¶²å€
  const RANK_API = 'https://script.google.com/macros/s/AKfycbwuIqqynB0ohVwnMhcA3u2Gv9GimGqUvfCJ_Nw_UnoCuEMCHG_rGhlKA_pxOO51HHU/exec';
  // é€¾æ™‚æ¯«ç§’æ•¸ï¼šé¿å…ç¶²è·¯ä¸ç©©æˆ–å¾Œç«¯æœªå›æ‡‰å°è‡´ Promise å¡ä½
  const FETCH_TIMEOUT = 8000;
  // Apps Script backend å¿…é ˆå›æ‡‰ CORS æ¨™é ­ï¼Œæ‰èƒ½è·¨ç¶²åŸŸå­˜å–
  // === è¨­å®š ===
  const GAME_CONFIG = {
    totalLevels: 20,
    difficulty: {
      easy:   { paddleBaseW: 220, baseSpeed: 4, rowsBase: 6, dropRate: 0.72 },
      normal: { paddleBaseW: 180, baseSpeed: 4.5, rowsBase: 7, dropRate: 0.52 },
      hard:   { paddleBaseW: 140, baseSpeed: 6, rowsBase: 8, dropRate: 0.32 },
    },
    bricks: { explosiveChance: 0.18, brickHeight: 30, padding: 9, topOffset: 60, cols: 12 },
    powers: {
      // æ—¢æœ‰
      WIDE:{label:'å¹³å°è®Šå¯¬',type:'buff',durationMs:30000,paddleWidthAdd:50,badge:'â†”ï¸'},
      LONG:{label:'å¹³å°è®Šé•·(å¯ç–Š)',type:'buff',durationMs:30000,longPerStackAdd:40,stacksMax:2,badge:'ğŸ“'},
      STICKY:{label:'é»æ€§å¹³å°(ä¸Šå½ˆå¯æš«é»)',type:'buff',durationMs:5000,sticky:true,badge:'ğŸ§²'},
      MULTI:{label:'å¤šçƒ',type:'buff',multiDuplicate:true,maxBalls:4,badge:'âœ¨'},
      SLOW:{label:'å…¨å±€æ…¢é€Ÿ',type:'buff',durationMs:15000,speedMul:0.8,badge:'ğŸ¢'},
      PIERCE:{label:'ç©¿é€çƒ',type:'buff',durationMs:12000,piercing:true,badge:'ğŸ¯'},
      SHIELD:{label:'è­·ç›¾(æ‰çƒæ“‹ä¸€æ¬¡)',type:'buff',oneShotShield:true,badge:'ğŸ›¡'},
      RAMPAGE:{label:'æš´èµ°çƒ(çŸ­æš«å¼·ç©¿)',type:'buff',durationMs:5000,forcePiercing:true,rampageMs:5000,badge:'ğŸ”¥'},
      FAST:{label:'å¿«é€Ÿçƒ',type:'debuff',durationMs:5000,globalSpeedMul:1.5,screenShakeOnApply:6,badge:'âš¡'},
      WAVY:{label:'è®Šé€Ÿçƒ',type:'debuff',durationMs:5000,wavy:{amp:0.6,base:1.2,periodMs:200},badge:'ã€°ï¸'},
      COMBO:{label:'é€£æ“Šä¹‹æ˜Ÿ',desc:'é€£æ“Šæ™‚é–“å»¶é•·2å€ã€å¾—åˆ†Ã—1.5',type:'buff',durationMs:30000,combo:{timeMul:2,scoreMul:1.5},badge:'ğŸŒŸ'},
      // æ–°å¢
      PLASMA:{label:'é›»æ¼¿çƒ(æ“Šä¸­æ”¾å‡ºé›»æ¼¿åœˆæ¸…åˆ—)',type:'buff',durationMs:10000,plasma:{drift:1.2,radius:38,lifeMs:3000},badge:'âš¡ï¸'},
      FREEZE:{label:'å‡çµçƒ(å»¶é²åœé “ä¸€ä¸‹)',type:'buff',durationMs:10000,freeze:{delayMs:300,stopMs:2000},badge:'â„ï¸'},
      HOLY:{label:'ç¥è–çƒ(åå­—æ¸…ç·š)',type:'buff',durationMs:5000,holy:{},badge:'âœï¸'},
      TRACK:{label:'è¿½è¹¤çƒ(è‡ªå‹•ä¿®æ­£è»Œè·¡)',type:'buff',durationMs:10000,track:{},badge:'ğŸ§­'},
      MISSILE:{label:'é£›å½ˆçƒ(æ“‹æ¿åå½ˆæ™‚ç™¼å°„3æš)',type:'buff',durationMs:5000,missile:{speed:7,turn:0.08,lifeMs:4000},badge:'ğŸš€'},
      HELL:{label:'åœ°ç„çƒ(é»‘æ´åé„°è¿‘æ ¼)',type:'buff',durationMs:5000,hell:{speedMul:1.2,haloMs:2000},badge:'ğŸ•³ï¸'},
      MEGA:{label:'ç‰¹å¤§çƒ(åŠå¾‘Ã—3, é€Ÿåº¦Ã—0.8)',type:'buff',durationMs:5000,mega:{sizeMul:3,speedMul:0.8},badge:'ğŸŸ¢'},
      CHAIN:{label:'é–éˆçƒ(å‘½ä¸­ç£šé–10ç§’)',type:'debuff',durationMs:5000,chain:{lockMs:10000},badge:'â›“ï¸'},
      NARROW:{label:'å¹³å°ç¸®å°(å¯¬åº¦æ¸›åŠ)',type:'debuff',durationMs:5000,narrow:true,badge:'ğŸ“‰'},
      HOLE:{label:'å¹³å°ç©ºæ´(ä¸­é–“1/3ç„¡æ•ˆ)',type:'debuff',durationMs:5000,hole:true,badge:'ğŸ•³'},
      PADSPIN:{label:'å¹³å°ç¿»è½‰',desc:'å¹³å°æ—‹è½‰8ç§’',type:'debuff',durationMs:8000,spin:{periodMs:8000},badge:'ğŸŒ€'},
      PADBOOM:{label:'å¹³å°çˆ†ç‚¸',desc:'é–ƒçˆå¾Œæ¶ˆå¤±3ç§’',type:'debuff',explosion:{flashMs:3000,goneMs:3000},badge:'ğŸ’£'},
      FIRE:{label:'ç«ç„°çƒ(ç¢°æ’è“„èƒ½10ç§’çˆ†ç‚¸)',type:'buff',durationMs:10000,badge:'ğŸ”¥'},
      POISON:{label:'åŠ‡æ¯’çƒ(å‘½ä¸­ç£šæ¯2ç§’æ‰£è¡€)',type:'buff',durationMs:12000,poison:{tickMs:2000},badge:'â˜ ï¸'},
      BLINK:{label:'ç¬ç§»çƒ(å½ˆå¾Œ1ç§’é ‚éƒ¨è½ä¸‹)',type:'buff',durationMs:10000,blink:{delayMs:1000},badge:'ğŸŒ€'},
      LASER:{label:'è‡ªå‹•é›·å°„(æ¯2ç§’å…©ç«¯ç™¼å°„)',type:'special',durationMs:10000,specialWeight:0.1,laser:{intervalMs:2000},badge:'ğŸ”«'},
      FLIP:{label:'å¤©åœ°ç¿»è½‰(æ”¹ç‚ºå·¦å´æ“‹æ¿)',type:'special',durationMs:15000,specialWeight:0.1,badge:'ğŸ”„'},
      NINE:{label:'9å‘½æ€ªè²“(ç”Ÿå‘½è®Š9)',type:'special',instant:true,badge:'ğŸ±'},
      PHOENIX:{label:'é³³å‡°å¯©åˆ¤(æ¶ˆåŠå ´/ä¸ç§’æ®ºBoss)',type:'special',instant:true,badge:'ğŸª½'},
      GATLING:{label:'ç«åŠ›å£“åˆ¶',desc:'å¹³å°æ©Ÿæ§æƒå°„8ç§’',type:'special',durationMs:11000,specialWeight:0.1,gatling:{chargeMs:3000,fireMs:8000,intervalMs:100,bulletSpeed:10},badge:'ğŸ”«'},
      SWORD:{label:'åŠèŠ’è£‚ç©º',desc:'é£›åŠæƒå ´',type:'special',durationMs:20000,specialWeight:0.1,badge:'ğŸ—¡ï¸'},
      GODSPEED:{label:'ç¥é€Ÿæµè½‰(ä¸è½åœ°/æ»¿é€Ÿ)',type:'special',durationMs:10000,specialWeight:0.1,badge:'â˜„ï¸'},
      STORM:{label:'é›·å°„é¢¨æš´',desc:'å…¨å ´æƒå°„',type:'special',durationMs:5000,specialWeight:0.1,storm:{},badge:'ğŸŒ©ï¸'},
      BLACKHOLE:{label:'é»‘æ´åå™¬',desc:'é»‘æ´åå ´',type:'special',durationMs:20000,specialWeight:0.1,badge:'âš«'},
      ANNIHIL:{label:'è¬ç‰©éŠ·æ¯€',desc:'éš¨æ©Ÿæ¯€ç£š',type:'special',specialWeight:0.1,annihil:{speedMul:3},badge:'ğŸ’¥'}

    },
    powerCapsule:{width:24,height:16,fallVy:2.2},
    caps:{paddleMaxW:300,ballSpeedMax:19.5}
  };

  // === å½±åƒè¼‰å…¥ï¼ˆæ”¯æ´ .png / .jpgï¼‰ ===
  const IMG_PAIRS = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.png`, cg:`images/cg${i}.png`}));
  // æº–å‚™ jpg å¾Œå‚™
  const IMG_PAIRS_FALLBACK = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.jpg`, cg:`images/cg${i}.jpg`}));

  const DIALOGS = {
    bg1: [
      'é€™éº¼å¿«å°±ç ´å†°è€Œä¾†ï¼Ÿå°å¿ƒï¼Œæˆ‘çš„å¿ƒæ¯”å¯’éœœæ›´é›£èåŒ–å“¦ã€‚',
      'å—¯â€¦â€¦ä½ çš„æ‰‹æŒ‡ä¸€å®šå¾ˆéˆå·§ï¼Œæ‰èƒ½ç©¿éæˆ‘çš„å†°é™£ã€‚',
      'åˆ¥ç«™å¤ªè¿‘ï¼Œæˆ‘æ€•ä¸å°å¿ƒå‡ä½ä½ çš„å¿ƒã€‚'
    ],
    bg2: [
      'æ„Ÿè¬ä½ çš„å‹‡æ°£ï¼Œé¡˜æœˆç¥çš„ç¥ç¦ä¼´ä½ ç¹¼çºŒå‰è¡Œã€‚',
      'ä½ çš„å…‰èŠ’â€¦â€¦æ¯”è–å ‚çš„æ˜Ÿå…‰é‚„è¦è€€çœ¼ã€‚',
      'æˆ–è¨±ï¼Œæˆ‘è©²ç‚ºä½ çš„å¿ƒç¥ˆç¦±ï¼Œä¸è¦è¢«æˆ‘å¥ªèµ°ã€‚'
    ],
    bg3: [
      'ä¸éŒ¯ï¼Œä½ çš„å‘½æš«æ™‚ä¿ä½äº†â€¦â€¦è‡³å°‘åœ¨æˆ‘æ‡·è£¡ã€‚',
      'ä½ æ‰“ç ´çš„ä¸åªæ˜¯ç£šå¡Šï¼Œé‚„æ˜¯æˆ‘å°ä½ çš„è©¦æ¢ã€‚',
      'åˆ¥æ€•é®åˆ€ï¼Œå®ƒåªæ”¶å‰²æ•µäººâ€¦â€¦æˆ–è€…å·å»ç›Ÿå‹ã€‚'
    ],
    bg4: [
      'ä½ è®“æˆ‘ç­‰å¤ªä¹…äº†â€¦â€¦é€™æ¯é…’æ—©è©²æ•¬ä½ ã€‚',
      'åˆ¥å•æˆ‘æƒ…å ±çš„åƒ¹éŒ¢ï¼Œä¹Ÿè¨±â€¦â€¦ç”¨ä¸€å€‹å»å°±å¤ ã€‚',
      'å—¯ï¼Œå‹•ä½œä¿è½ï¼Œä»Šæ™šä½ å€¼å¾—æ›´å¤šçå‹µã€‚'
    ],
    bg5: [
      'å­©å­ï¼Œä½ çš„éˆé­‚æ¯”æˆ‘æƒ³åƒçš„é‚„è¦ç´”æ·¨â€¦â€¦æˆ–è€…å±éšªã€‚',
      'åœ¨è–å…‰ä¸‹ï¼Œé€£ä½ çš„çœ¼ç¥éƒ½è®Šå¾—ç„¡æ³•éš±è—ã€‚',
      'æˆ‘å¯ä»¥ç¥ç¦ä½ â€¦â€¦æˆ–è€…èª˜æƒ‘ä½ ï¼Œä½ é¸å“ªå€‹ï¼Ÿ'
    ],
    bg6: [
      'å¥½åŠæ³•â€¦â€¦ä¸å¦‚æ‰¾æ™‚é–“ï¼Œèˆ‡æˆ‘åˆ‡ç£‹æ›´å¤šå›åˆã€‚',
      'ä½ è´å¾—äº†é€™å ´æˆ°å½¹ï¼Œä¹Ÿè´å¾—äº†æˆ‘çš„æ³¨æ„ã€‚',
      'åˆ¥æ€¥è‘—èµ°ï¼ŒçœŸæ­£çš„æ±ºæˆ°åœ¨æˆ‘å¿ƒè£¡ç­‰ä½ ã€‚'
    ],
    bg7: [
      'çœŸæœ‰è¶£â€¦â€¦ä½ é—–é€²ä¾†ï¼Œå°±æ˜¯ç‚ºäº†è¦‹æˆ‘å—ï¼Ÿ',
      'å°å¿ƒé»ï¼Œæˆ‘çš„ç¬‘å®¹æ¯”åœ°ç„çš„ç«ç„°æ›´è‡´å‘½ã€‚',
      'æ—¢ç„¶ä½ è´äº†ï¼Œé‚£å°±â€¦â€¦è®“æˆ‘å¥½å¥½å“åšä½ çš„éˆé­‚å§ã€‚'
    ],
    bg8: [
      'ä½ çœŸå¹¸é‹ï¼Œèƒ½æ´»è‘—è¦‹åˆ°æˆ‘ã€‚',
      'æ‰“ç£šå¡Šå¾ˆå²å®³ï¼Ÿä¸‹æ¬¡è©¦è©¦æ‰“ç ´æˆ‘çš„å¿ƒé˜²ã€‚',
      'çœ‹ä¾†â€¦â€¦æˆ‘å¾—é‡æ–°è©•ä¼°ä½ æ˜¯æ•µäººï¼Œé‚„æ˜¯æˆ‘çš„äººã€‚'
    ],
    bg9: [
      'å”‰å‘€ï¼Œè¢«ä½ é—–é€²ä¾†äº†ï¼Œç«ç„°å¯ä¸åªç‡’ç£šå“¦ã€‚',
      'ä½ çŸ¥é“å—ï¼Ÿæˆ‘å–œæ­¡æœƒè®“æˆ‘å¿ƒè·³åŠ é€Ÿçš„å°æ‰‹ã€‚',
      'åˆ¥èµ°å¤ªå¿«ï¼Œæˆ‘é‚„æ²’æ±ºå®šæ˜¯è¦å»ä½ é‚„æ˜¯ç‡’äº†ä½ ã€‚'
    ],
    bg10: [
      'å‘€â€¦â€¦ä½ èµ°å¾—é€™éº¼å¿«ï¼Œä¸æ€•æˆ‘å·èµ°ä½ çš„å¿ƒå—ï¼Ÿ',
      'çå‹µï¼Ÿç•¶ç„¶æœ‰ï¼Œä¸éè¦ç”¨ä¸€é»çœŸå¿ƒä¾†æ›ã€‚',
      'ä½ ç ´äº†é—œï¼Œæˆ‘çš„å°¾å·´â€¦â€¦å¯ä»¥å¤šçºä½ ä¸€æœƒå…’ã€‚'
    ],
    cg1: [
      'ä½ é—–éä¾†çš„æ¨£å­ï¼Œåƒé›ªå´©ä¸€æ¨£é©šå¿ƒå‹•é­„ã€‚',
      'åˆ¥å‹•ï¼Œæˆ‘æƒ³çœ‹çœ‹ä½ åœ¨å†°éœœæ˜ ç…§ä¸‹çš„çœ¼ç¥ã€‚',
      'å°å¿ƒï¼Œæˆ‘çš„å¿ƒæƒ…è‹¥èåŒ–â€¦â€¦å¯æ˜¯æœƒæ·¹æ²’ä½ çš„ã€‚'
    ],
    cg2: [
      'ä½ çš„æ­¥ä¼å¾ˆè¼•ï¼Œä½†è¶³è·¡å»æ·±æ·±åˆ»åœ¨æˆ‘å¿ƒä¸Šã€‚',
      'ä½ é—–éé€™æ®µè·¯ï¼Œè®“æˆ‘æƒ³èµ·äº†å¤±è½çš„å‹‡è€…å‚³èªªã€‚',
      'è–å ‚çš„èŠ±ç‚ºä½ è€Œé–‹â€¦â€¦ä¹Ÿè¨±æˆ‘ä¹Ÿæ˜¯ã€‚'
    ],
    cg3: [
      'ä½ çš„è†½é‡â€¦â€¦è¶³ä»¥å’Œæ­»ç¥ååœ¨åŒä¸€å¼µæ¡Œå‰ã€‚',
      'å‰›å‰›é‚£ä¸€ä¸‹ï¼Œæˆ‘å¹¾ä¹æƒ³æ”¶å‰²ä½ çš„å¿ƒè€Œééˆé­‚ã€‚',
      'åˆ¥é€€ï¼Œæˆ‘é‚„æ²’æ±ºå®šè¦æŠŠä½ ç•™åœ¨å“ªä¸€é‚Šã€‚'
    ],
    cg4: [
      'ä½ è·‘å¾—å¿«ï¼Œé‚„æ˜¯æˆ‘çš„å¿ƒè·³å¿«ï¼Ÿ',
      'ä½ è´äº†ï¼Œçå“å˜›â€¦â€¦ä¹Ÿè¨±æ˜¯æˆ‘çš„é™ªä¼´ä¸€å›åˆã€‚',
      'ä¸‹æ¬¡è¦‹é¢å‰ï¼Œè¨˜å¾—å¤šç·´ç¿’â€¦â€¦æˆ‘ä¸å–œæ­¡æ…¢ååçš„çµç‰©ã€‚'
    ],
    cg5: [
      'ä½ çš„åå­—ï¼Œå·²ç¶“è¢«æˆ‘å¯«é€²ç¦å¿Œçš„è©©ç¯‡è£¡ã€‚',
      'åœ¨é»‘æš—ä¸­ï¼Œä½ çš„å…‰â€¦â€¦ä»¤äººæƒ³çŠ¯ç½ªã€‚',
      'åˆ¥ä»¥ç‚ºç ´é—œäº†å°±èƒ½é€ƒé›¢ï¼Œæˆ‘çš„é­”å’’å¾ˆé»äººã€‚'
    ],
    cg6: [
      'å‰›æ‰é‚£ä¸€æ“Šâ€¦â€¦æˆ‘éƒ½æƒ³è·Ÿä½ éæ‹›å¹¾ç™¾æ¬¡äº†ã€‚',
      'ä½ çš„çœ¼ç¥å‘Šè¨´æˆ‘ï¼Œä½ ä¸åªæ˜¯ç‚ºå‹åˆ©è€Œæˆ°ã€‚',
      'æˆ°å ´ä¸Šæˆ‘å¾ˆå…‡ï¼Œä½†å°è´å¾—æˆ‘å¿ƒçš„äººâ€¦â€¦å¾ˆæº«æŸ”ã€‚'
    ],
    cg7: [
      'æ­å–œï¼Œä½ å·²ç¶“è¢«æƒ¡é­”çš„èˆˆè¶£é–å®šã€‚',
      'ä½ çš„éˆé­‚é¦™æ°£â€¦â€¦æ¯”æˆ‘æƒ³åƒçš„é‚„èª˜äººã€‚',
      'ä»Šæ™šï¼Œä½ æœ€å¥½é–å¥½é–€â€¦â€¦æˆ–è€…ä¹¾è„†æ•é–‹ç­‰æˆ‘ã€‚'
    ],
    cg8: [
      'åˆ¥å›é ­ï¼Œæˆ‘çš„å½±å­å·²ç¶“çºä¸Šä½ äº†ã€‚',
      'å‹•ä½œé‚„ä¸éŒ¯ï¼Œä¸‹æ¬¡æ›æˆ‘ä¾†è©¦æ¢ä½ ã€‚',
      'ä½ é—–éçš„ä¸æ˜¯é—œå¡ï¼Œè€Œæ˜¯æˆ‘çš„æˆ’å¿ƒã€‚'
    ],
    cg9: [
      'èŠ±è‰æœƒè¨˜ä½ä½ çš„åå­—â€¦â€¦å°±åƒæˆ‘ä¸€æ¨£ã€‚',
      'ä½ çš„æ°£æ¯ï¼Œè®“æ£®æ—ä¹Ÿå®‰éœä¸‹ä¾†è†è½ã€‚',
      'å°å¿ƒå“¦ï¼Œæˆ‘çš„é­”æ³•æœƒè®“ä½ æ¨ä¸å¾—é›¢é–‹ã€‚'
    ],
    cg10: [
      'ä»–ï¼ˆç‹¼ï¼‰ä¼¼ä¹å–œæ­¡ä½ â€¦â€¦æˆ‘ä¹Ÿæ˜¯ã€‚',
      'ä½ çš„å‹‡æ°£ï¼Œé€£æ£®æ—è£¡çš„ç‹¼éƒ½ä½é ­ã€‚',
      'æƒ³ç•™ä¸‹ä¾†åƒé»ä»€éº¼å—ï¼Ÿé™¤äº†é»å¿ƒï¼Œé‚„æœ‰æˆ‘ã€‚'
    ]
  };

  function makeImg(src, fallback){
    const im = new Image();
    im.decoding = 'async';
    im.loading = 'eager';
    im.src = src;
    if (fallback) {
      im.onerror = () => { if (im.src !== fallback) im.src = fallback; };
    }
    if (im.decode) { im.decode().catch(() => {}); }
    return im;
  }
  const IMG_MAP = new Array(10); // caches {bg, cg}
  function loadImagePair(i){
    if(!IMG_MAP[i]){
      IMG_MAP[i] = {
        bg: makeImg(IMG_PAIRS[i].bg, IMG_PAIRS_FALLBACK[i].bg),
        cg: makeImg(IMG_PAIRS[i].cg, IMG_PAIRS_FALLBACK[i].cg),
      };
    }
    return IMG_MAP[i];
  }

  // === ç‰¹æ®Šå¢ç›Šè§£é– ===
  const SPECIAL_UNLOCK_LEVELS = {
    PHOENIX:1,
    GATLING:3,
    SWORD:5,
    GODSPEED:7,
    STORM:9,
    BLACKHOLE:10,
    ANNIHIL:15,
  };
  const defaultUnlocked=['LASER','FLIP','NINE'];
  let unlockedSpecials=new Set(defaultUnlocked);
  try{
    const stored=JSON.parse(localStorage.getItem('unlocked_specials')||'[]');
    if(Array.isArray(stored)) stored.forEach(k=>unlockedSpecials.add(k));
  }catch(e){}
  function saveUnlockedSpecials(){
    localStorage.setItem('unlocked_specials',JSON.stringify(Array.from(unlockedSpecials)));
  }
  let pendingUnlockNotice=null;
  let ALL_TYPES=[]; let NORMAL_TYPES=[];
  function recomputePowerTypes(){
    ALL_TYPES=Object.keys(GAME_CONFIG.powers).filter(k=>GAME_CONFIG.powers[k].type!=='special'||unlockedSpecials.has(k));
    NORMAL_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='special');
  }
  function unlockSpecials(clearLevel){
    for(const [key,req] of Object.entries(SPECIAL_UNLOCK_LEVELS)){
      if(clearLevel>=req && !unlockedSpecials.has(key)){
        unlockedSpecials.add(key);
        saveUnlockedSpecials();
        pendingUnlockNotice=`å·²è§£é–ç‰¹æ®Šå¢ç›Š:${GAME_CONFIG.powers[key].label.split('(')[0]}`;
        recomputePowerTypes();
      }
    }
  }
  recomputePowerTypes();

  // === åƒè€ƒ DOM ===
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const scoreEl=document.getElementById('score'), levelEl=document.getElementById('level'), livesEl=document.getElementById('lives');
  const pauseBtn=document.getElementById('pauseBtn'), resetBtn=document.getElementById('resetBtn'), fsBtn=document.getElementById('fsBtn');
  const soundBtn=document.getElementById('soundBtn'), saveBtn=document.getElementById('saveBtn'), loadBtn=document.getElementById('loadBtn'), clearSaveBtn=document.getElementById('clearSaveBtn');
  const levelJumpSel=document.getElementById('levelJumpSel');
  let refreshLevelJumpVisual=null;
  const tutorBtn=document.getElementById('tutorBtn'), effectsBtn=document.getElementById('effectsBtn'), galleryBtn=document.getElementById('galleryBtn'), rankBtn=document.getElementById('rankBtn');
  const centerNote=document.getElementById('centerNote'), noteTitle=document.getElementById('noteTitle'), noteText=document.getElementById('noteText'), noteBox=document.getElementById('noteBox');
  const difficultySel=document.getElementById('difficulty'), activeBuffsEl=document.getElementById('buffs'), promptsDock=document.getElementById('promptsDock');
  const ledStyleSel=document.getElementById('ledStyle');

  // æ–°å¢å…ƒç´ åƒè€ƒ
  const heartsEl = document.getElementById('hearts');
  const fireEnergyEl = document.getElementById('fireEnergy');
  const catsEl = document.getElementById('cats');
  const totalLevelsEl = document.getElementById('totalLevels');
  const sfxOnEl = document.getElementById('sfxOn');
  const bgmOnEl = document.getElementById('bgmOn');
  const skinSel = document.getElementById('skinSel');
  const gallery=document.getElementById('gallery'), galleryImg=document.getElementById('galleryImg'), galleryHint=document.getElementById('galleryHint'), galleryDialog=document.getElementById('galleryDialog');
  const win=document.getElementById('win'), ring=document.getElementById('ring'), finalScore=document.getElementById('finalScore'), againBtn=document.getElementById('againBtn');
  document.getElementById('retryBtn')?.addEventListener('click', ()=>{ gameover.classList.remove('show'); gameOver=false; resetGame(); startGameWithCountdown(); });

  const bgmBtn=document.getElementById('bgmBtn'), bgmVol=document.getElementById('bgmVol');
  const gameover=document.getElementById('gameover'), finalScore2=document.getElementById('finalScore2');
  const retryBtn=document.getElementById('retryBtn');

  // Gallery page elements
  const galleryPage=document.getElementById('galleryPage'), galleryThumbs=document.getElementById('galleryThumbs'), galleryClose=document.getElementById('galleryClose'), galleryPrev=document.getElementById('galleryPrev'), galleryNext=document.getElementById('galleryNext'), galleryPageInfo=document.getElementById('galleryPageInfo'), galleryViewer=document.getElementById('galleryViewer'), galleryViewerImg=document.getElementById('galleryViewerImg'), viewerOptions=document.getElementById('viewerOptions'), viewerDialog=document.getElementById('viewerDialog');

  // Rank page elements
  const rankPage=document.getElementById('rankPage'), rankClose=document.getElementById('rankClose'), rankTableBody=document.querySelector('#rankTable tbody');
  const uploadWin=document.getElementById('uploadWin'), uploadOver=document.getElementById('uploadOver'),
        uploadOverlay=document.getElementById('uploadOverlay'), uploadBar=document.getElementById('uploadBar'),
        uploadPercent=document.getElementById('uploadPercent');

  // === Gallery page logic ===
  let galleryPageIdx = 0;
  function renderGalleryPage(){
    const type = galleryPageIdx===0?'bg':'cg';
    galleryThumbs.innerHTML='';
    for(let i=1;i<=10;i++){
      const key = `${type}${i}`;
      const div=document.createElement('div');
      div.className='thumb';
      const im=document.createElement('img');
      im.src=`images/${key}.png`;
      div.appendChild(im);
      if(!galleryUnlocks[key]){
        div.classList.add('locked');
      }else{
        div.addEventListener('click',()=>{
          openGalleryViewer(key);
        },{passive:true});
      }
      galleryThumbs.appendChild(div);
    }
    galleryPageInfo.textContent=`${galleryPageIdx+1} / 2`;
    galleryPrev.disabled = galleryPageIdx===0;
    galleryNext.disabled = galleryPageIdx===1;
  }

  function openGalleryViewer(key){
    galleryViewerImg.src=`images/${key}.png`;
    galleryViewer.style.display='flex';
    if(viewerDialog) viewerDialog.style.display='none';
    if(viewerOptions){
      viewerOptions.innerHTML='';
      const mask = dialogUnlocks[key] || 0;
      const lines = DIALOGS[key] || [];
      for(let i=0;i<3;i++){
        const btn=document.createElement('button');
        btn.className='btn';
        if(mask & (1<<i)){
          btn.textContent=`å°è©${i+1}`;
          btn.addEventListener('click',e=>{ e.stopPropagation(); if(viewerDialog){ viewerDialog.textContent=lines[i]; viewerDialog.style.display='block'; } },{passive:true});
        }else{
          btn.textContent='ğŸ”’';
          btn.disabled=true;
          btn.classList.add('locked');
        }
        viewerOptions.appendChild(btn);
      }
    }
  }
  function openGalleryPage(){
    galleryPageIdx=0;
    renderGalleryPage();
    galleryPage.style.display='flex';
    window.__setMenuPause?.(true);
  }
  function closeGalleryPage(){
    galleryPage.style.display='none';
    galleryViewer.style.display='none';
    if(viewerDialog) viewerDialog.style.display='none';
    if(!menusOpen()) window.__setMenuPause?.(false);
  }
  galleryClose?.addEventListener('click', closeGalleryPage, {passive:true});
  galleryPrev?.addEventListener('click', ()=>{ if(galleryPageIdx>0){galleryPageIdx--; renderGalleryPage();}}, {passive:true});
  galleryNext?.addEventListener('click', ()=>{ if(galleryPageIdx<1){galleryPageIdx++; renderGalleryPage();}}, {passive:true});
  galleryViewer?.addEventListener('click', ()=>{ if(viewerDialog && viewerDialog.style.display==='block'){ viewerDialog.style.display='none'; } else { galleryViewer.style.display='none'; } }, {passive:true});
  viewerOptions?.addEventListener('click', e=>{ e.stopPropagation(); }, {passive:true});
  galleryBtn?.addEventListener('click', ()=>{
    openGalleryPage();
  }, {passive:true});

  // === Rank page logic ===
  async function fetchLeaderboard(){
    const controller = new AbortController();
    const to = setTimeout(()=>controller.abort(), FETCH_TIMEOUT);
    // GET leaderboard as JSON (supports both array-of-arrays and array-of-objects)
    const res = await fetch(RANK_API + '?t=' + Date.now(), { cache: 'no-store', signal: controller.signal });
    clearTimeout(to);
    if (!res.ok) throw new Error('fetch failed: ' + res.status);
    const text = await res.text();
    let data;
    try { data = JSON.parse(text); }
    catch { throw new Error('invalid json'); }
    // Normalize to array-of-arrays: [timestamp,name,score,lives,catches,powerUps,powerDowns,enemiesKilled,bossKilled,fastestDeath,longestSurvival,maxCombo]
    if (Array.isArray(data) && data.length && !Array.isArray(data[0]) && typeof data[0] === 'object') {
      // array of objects
      data = data.map(o => [
        o.timestamp ?? '',
        o.name ?? '',
        Number(o.score ?? 0),
        Number(o.lives ?? 0),
        Number(o.catches ?? 0),
        Number(o.powerUps ?? 0),
        Number(o.powerDowns ?? 0),
        Number(o.enemiesKilled ?? 0),
        Number(o.bossKilled ?? 0),
        Number(o.fastestDeath ?? 0),
        Number(o.longestSurvival ?? 0),
        Number(o.maxCombo ?? o.comboMax ?? 0),
      ]);
    }
    if (!Array.isArray(data)) throw new Error('unexpected data');
  return data;
  }
  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
  }
  function renderLeaderboard(data){
    rankTableBody.innerHTML='';
    try{
      data.sort((a,b)=>Number(b[2]||0)-Number(a[2]||0));
    }catch{}
    (data||[]).slice(0,20).forEach((row,i)=>{
      const tr=document.createElement('tr');
      const fd = Number(row[9]||0).toFixed(1);
      const ld = Number(row[10]||0).toFixed(1);
      const mc = Number(row[11]||0);
      tr.innerHTML = `<td>${i+1}</td>
        <td>${escapeHtml(row[1]??'')}</td>
        <td>${Number(row[2]||0)}</td>
        <td>${Number(row[3]||0)}</td>
        <td>${Number(row[4]||0)}</td>
        <td>${Number(row[5]||0)}</td>
        <td>${Number(row[6]||0)}</td>
        <td>${Number(row[7]||0)}</td>
        <td>${Number(row[8]||0)}</td>
        <td>${fd}</td>
        <td>${ld}</td>
        <td>${mc}</td>`;
      rankTableBody.appendChild(tr);
    });
    if(!rankTableBody.children.length){
      rankTableBody.innerHTML='<tr><td colspan="12">æš«ç„¡è³‡æ–™</td></tr>';
    }
  }
  async function openRankPage(){
    document.getElementById('optMenu')?.classList.remove('show');
    rankPage.style.display='flex';
    rankTableBody.innerHTML='<tr><td colspan="12">è¼‰å…¥ä¸­...</td></tr>';
    window.__setMenuPause?.(true);
    try{
      const data = await fetchLeaderboard();
      renderLeaderboard(data);
    }catch(e){
      console.error(e);
      rankTableBody.innerHTML='<tr><td colspan="12">è¼‰å…¥å¤±æ•—</td></tr>';
    }
  }
  function closeRankPage(){
    rankPage.style.display='none';
    if(!menusOpen()) window.__setMenuPause?.(false);
  }
  rankClose?.addEventListener('click', closeRankPage, {passive:true});
  rankBtn?.addEventListener('click', openRankPage, {passive:true});

    async function uploadScore(){
      if(scoreUploaded){
        alert('å·²ä¸Šå‚³éï¼Œè«‹å‹¿å†æ¬¡ä¸Šå‚³');
        return;
      }
      if(uploading){
        alert('ä¸Šå‚³ä¸­ï¼Œè«‹å‹¿å†æ¬¡é»æ“Š!');
        return;
      }
      const rawName = prompt('è«‹è¼¸å…¥ç©å®¶åç¨±ï¼š\næ³¨æ„: å§“åæœ€å¤šè¼¸å…¥8å€‹å­—');
    if(rawName==null) return;
    const name = (rawName||'').trim();
    if(!name) return;
    if([...(name||'')].length>8){
      alert('åå­—é€™éº¼é•·æ˜¯æƒ³æ€æ¨£å•¦? è«‹é‡æ–°è¼¸å…¥!');
      return uploadScore();
    }
      const payload = {
        name,
        score,
        lives: stats.livesUsed,
        catches: stats.catches,
        powerUps: stats.buffs,
        powerDowns: stats.debuffs,
        enemiesKilled: stats.eliteKills,
        bossKilled: stats.bossKills,
        fastestDeath: stats.fastestDeath===Infinity?0:stats.fastestDeath,
        longestSurvival: stats.longestLife,
        maxCombo: stats.maxCombo
      };
      uploading = true;
      uploadOverlay.style.display='flex';
      let prog=0;
      const setProg=p=>{ uploadBar.style.width=p+'%'; uploadPercent.textContent=p+'%'; };
      setProg(0);
      const progTimer=setInterval(()=>{ if(prog<90){ prog+=5; setProg(prog); } },200);
      const controller = new AbortController();
      const to = setTimeout(()=>controller.abort(), FETCH_TIMEOUT);
      try{
        const res = await fetch(RANK_API, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain; charset=UTF-8' }, // simple request to avoid preflight
          body: JSON.stringify(payload),
          signal: controller.signal
        });
        const text = await res.text().catch(()=> '');
        clearTimeout(to);
        clearInterval(progTimer);
        setProg(100);
        uploadOverlay.style.display='none';
        if (res.ok && /ok/i.test(text.trim())) {
          alert('ä¸Šå‚³å®Œæˆ');
          scoreUploaded = true;
        } else {
          alert('ä¸Šå‚³å¤±æ•—');
        }
      }catch(e){
        clearTimeout(to);
        clearInterval(progTimer);
        uploadOverlay.style.display='none';
        console.error(e);
        alert('ä¸Šå‚³å¤±æ•—');
      }finally{
        uploading = false;
      }
    }
  uploadWin?.addEventListener('click', uploadScore, {passive:true});
  uploadOver?.addEventListener('click', uploadScore, {passive:true});

  // === Skin initialization ===
  // Populate the skin dropdown and set up the current skin.  Skins are
  // defined in skin.js and exposed via the global SKINS object.  Each
  // option uses its key as the value; the displayed text comes from
  // selectLabel or falls back to the label.
  if (window.SKINS && skinSel) {
    // Remove any existing options before populating.
    skinSel.innerHTML = '';
    Object.keys(window.SKINS).forEach((key) => {
      const opt = document.createElement('option');
      opt.value = key;
      const s = window.SKINS[key];
      opt.textContent = (s.selectLabel || s.label || key);
      skinSel.appendChild(opt);
    });
    // Provide a UI update callback on window so skin.js can call it.
    window.updateSkinUI = function (skin) {
      const titleEl = document.getElementById('skinTitle');
      const descEl = document.getElementById('skinDesc');
      if (titleEl) titleEl.textContent = skin.label || '';
      if (descEl) descEl.textContent = skin.desc || '';
    };
    // Determine the initial skin from localStorage, with fallback.
    let initKey;
    try {
      initKey = localStorage.getItem('selected_skin') || 'classic';
    } catch (e) {
      initKey = 'classic';
    }
    if (!window.SKINS[initKey]) initKey = 'classic';
    skinSel.value = initKey;
    // Apply the initial skin using the helper from skin.js.  This also
    // stores the selection for later and updates the UI via updateSkinUI.
    if (typeof window.applySkin === 'function') {
      window.applySkin(initKey);
    }
    // Listen for changes and re-apply skins accordingly.
    skinSel.addEventListener('change', function () {
      if (typeof window.applySkin === 'function') {
        window.applySkin(this.value);
      }
    }, { passive: true });
  }

  /*
   * æ–° UI éŸ³æ•ˆèˆ‡ BGM æ§åˆ¶
   *
   * ç‚ºäº†æ²¿ç”¨æ—¢æœ‰çš„è²éŸ³é‚è¼¯ï¼Œæˆ‘å€‘ç”¨è¤‡é¸æ¡†æ§åˆ¶éš±è—çš„èˆŠæŒ‰éˆ• soundBtn / bgmBtnã€‚
   * ç”±æ–¼ soundsOn èˆ‡ bgmOn åœ¨ç¨å¾Œæ‰å®£å‘Šï¼ˆä½¿ç”¨ letï¼‰ï¼Œé€™æ®µåˆå§‹åŒ–é‚è¼¯æœƒåœ¨
   * ç‹€æ…‹å®£å‘Šä¹‹å¾Œé‡æ–°æ’å…¥ã€‚é€™è£¡åƒ…é ç•™èªªæ˜æ–‡å­—ï¼Œå¯¦éš›é‚è¼¯è¦‹å¾Œæ–¹çš„æ’å…¥å€å¡Šã€‚
  */


  function menusOpen(){
    return !!(
      document.querySelector('#soundMenu.show, #optMenu.show') ||
      (galleryPage && galleryPage.style.display && galleryPage.style.display !== 'none') ||
      (rankPage && rankPage.style.display && rankPage.style.display !== 'none')
    );
  }

  // é—œé–‰è¦–çª—æŒ‰éˆ•ï¼ˆé—œé–‰å¾Œç«‹å³å€’æ•¸ã€ç¹¼çºŒéŠæˆ²ï¼‰
  const noteClose = document.getElementById('noteClose');
  function closeNoteAndResume(){
    hideCenter();
    helpMode = null;
    // åœ¨é—œé–‰èªªæ˜è¦–çª—å¾Œæ¢å¾©éŠæˆ²ï¼šå…ˆèª¿æ•´æ‰€æœ‰è¨ˆæ™‚ï¼Œå†é€éå€’æ•¸ç¹¼çºŒ
    if(menusOpen()) return;
    if(running){ onResumeFromPause(); startCountdown(); } else { startGameWithCountdown(); }
  }
  noteClose.addEventListener('click', (e)=>{ e.stopPropagation(); closeNoteAndResume(); });

  // === æš«åœèˆ‡æ¢å¾©è¨ˆæ™‚ ===
  // åœ¨æš«åœé–‹å§‹æ™‚å‘¼å«ï¼Œè¨˜éŒ„ç•¶å‰æ™‚é–“ä»¥ä¾¿æ¢å¾©æ™‚ä¿®æ­£å„ç¨®å®šæ™‚å™¨ã€‚
  function onPauseStart(){
    // åªåœ¨ç¬¬ä¸€æ¬¡æš«åœæ™‚è¨˜éŒ„æ™‚é–“ï¼Œé¿å…é‡è¦†è¦†å¯«
    if(pauseStartedAt === null){
      pauseStartedAt = performance.now();
    }
  }

  // åœ¨æ¢å¾©éŠæˆ²æ™‚å‘¼å«ï¼Œå°‡æš«åœæœŸé–“çš„ç¶“éæ™‚é–“åŠ å›æ‰€æœ‰ä¾è³´çµ•å°æ™‚é–“çš„å®šæ™‚å™¨ã€‚
  function onResumeFromPause(){
    if(pauseStartedAt !== null){
      const delta = performance.now() - pauseStartedAt;
      pauseStartedAt = null;
      // èª¿æ•´å„å¢ç›Š buff çš„æœ‰æ•ˆæœŸ
      for(const key of Object.keys(GAME_CONFIG.powers)){
        const b = buffs[key];
        if(!b) continue;
        // é€šç”¨ until å±¬æ€§
        if(b.active && b.until){ b.until += delta; }
        // LONG buff çš„ stacks ç‚ºå¤šå€‹ until æ™‚é–“
        if(key === 'LONG' && Array.isArray(b.stacks)){
          for(let i=0;i<b.stacks.length;i++){ b.stacks[i] += delta; }
        }
        // è¬ç‰©éŠ·æ¯€ï¼šèª¿æ•´èµ·å§‹èˆ‡ä¸‹æ¬¡è¨ˆæ™‚
        if(key === 'ANNIHIL'){
          if(b.start){ b.start += delta; }
          if(b.next){ b.next += delta; }
        }
      }
      // èª¿æ•´å¤©åœ°ç¿»è½‰ç‰¹æ•ˆçš„èµ·æ­¢æ™‚é–“
      if(buffs.FLIP){
        const bf = buffs.FLIP;
        if(bf.startAt) bf.startAt += delta;
        if(bf.endAt) bf.endAt += delta;
      }
      // èª¿æ•´ä¸‹ä¸€æ¬¡å¤©ç©ºæ‰è½èˆ‡è‡ªå‹•å¢ç›Šæ‰è½æ™‚é–“
      if(nextSkyDropAt){ nextSkyDropAt += delta; }
      if(nextAutoBeneficialDropAt){ nextAutoBeneficialDropAt += delta; }
      // èª¿æ•´ Boss èƒ½åŠ›æ’ç¨‹
      if(typeof nextBossAtkA !== 'undefined' && nextBossAtkA){ nextBossAtkA += delta; }
      if(typeof nextBossAtkB !== 'undefined' && nextBossAtkB){ nextBossAtkB += delta; }
      if(typeof bossChargeUntil !== 'undefined' && bossChargeUntil){ bossChargeUntil += delta; }
      if(typeof cyclopsShakeUntil !== 'undefined' && cyclopsShakeUntil){ cyclopsShakeUntil += delta; }
      if(typeof cyclopsForcedPetrifyAt !== 'undefined' && cyclopsForcedPetrifyAt){ cyclopsForcedPetrifyAt += delta; }
      if(gatling){ gatling.chargeUntil+=delta; gatling.fireStart+=delta; gatling.fireUntil+=delta; if(gatling.lastShot) gatling.lastShot+=delta; }
      if(spaceBossRevealScheduled) spaceBossRevealScheduled += delta;
      if(spaceBossNextAttackAt) spaceBossNextAttackAt += delta;
      if(spaceBossAttack){
        if(spaceBossAttack.start) spaceBossAttack.start += delta;
        if(spaceBossAttack.countdownEnd) spaceBossAttack.countdownEnd += delta;
        if(spaceBossAttack.fireStart) spaceBossAttack.fireStart += delta;
        if(spaceBossAttack.fireEnd) spaceBossAttack.fireEnd += delta;
        if(spaceBossAttack.sweepStart) spaceBossAttack.sweepStart += delta;
        if(spaceBossAttack.sweepEnd) spaceBossAttack.sweepEnd += delta;
      }
      if(spaceBossMarquee){ spaceBossMarquee.start+=delta; if(spaceBossMarquee.fadeStart) spaceBossMarquee.fadeStart+=delta; if(spaceBossMarquee.end) spaceBossMarquee.end+=delta; }
      for(const fx of spaceBossBursts){ if(fx.t0) fx.t0 += delta; }
      if(spaceBossPaddleRespawnAt) spaceBossPaddleRespawnAt += delta;
      if(spaceBossDeathAnim){ spaceBossDeathAnim.start+=delta; spaceBossDeathAnim.explosionAt+=delta; spaceBossDeathAnim.end+=delta; spaceBossDeathAnim.lastBurst+=delta; }
      if(spaceBossSuppressLifeLossUntil) spaceBossSuppressLifeLossUntil += delta;
      // èª¿æ•´å„ç¨®ç‰¹æ•ˆç‰©ä»¶ï¼ˆç²’å­ã€é›·å°„ã€é»‘æ´ç­‰ï¼‰çš„ till/until çµ‚æ­¢æ™‚é–“
      const lists = [plasmas, holyFlashes, blackHoles, laserBeams, laserImpacts, missiles, hostileBeams, hostileArcs, hostileColumns, hazardClouds];
      for(const arr of lists){
        if(!arr) continue;
        for(const item of arr){
          if(item.until){ item.until += delta; }
          if(item.tEnd){ item.tEnd += delta; }
          if(item.t0){ item.t0 += delta; }
          if(item.lifeUntil){ item.lifeUntil += delta; }
          if(item.tStart){ item.tStart += delta; }
        }
      }
      // èª¿æ•´çƒçš„å‡çµç‹€æ…‹
      for(const ball of balls){
        const fr = ball.freeze;
        if(fr && fr.t0){ fr.t0 += delta; }
        if(fr && fr.until){ fr.until += delta; }
      }
      if(combo>0 && comboLastTime){ comboLastTime += delta; }
    }
  }


  // === DPR ç¸®æ”¾ ===
  function resizeCanvasDPR(){ const dpr=Math.min(window.devicePixelRatio||1,2); const cssW=canvas.clientWidth; const cssH=Math.round(cssW*(700/1100)); canvas.style.height=cssH+'px'; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); scaleX=canvas.width/1100; scaleY=canvas.height/700; }
  let scaleX=1, scaleY=1; window.addEventListener('resize', resizeCanvasDPR, {passive:true}); resizeCanvasDPR();

  // === ç‹€æ…‹ ===
  let running=false, paused=true, level=1, score=0, lives=3, soundsOn=false;
  let nineCatEaten=0;
  let fireEnergy=0;
  let gameOver=false;
  let combo=0;
  let comboLastTime=0;
  const comboEl=document.getElementById('combo');
  let comboNoticeTriggered={50:false,100:false,200:false,300:false,400:false,500:false,800:false,1000:false};
  let stats={catches:0,buffs:0,debuffs:0,eliteKills:0,bossKills:0,lifeStart:0,fastestDeath:Infinity,longestLife:0,livesUsed:0,maxCombo:0};
  const SPACE_BOSS_MAX_HP = 30;
  const SPACE_BOSS_ATTACK_INTERVAL = 15000;
  const SPACE_BOSS_PADDLE_MIN_WIDTH = 60;
  const SPACE_BOSS_GUN_FIRE_RATE = 100; // ms between each burst per gun
  const SPACE_BOSS_GUN_FIRE_DURATION = 3000;
  const SPACE_BOSS_LASER_SWEEP_DURATION = 2000;
  const DRAGON_MAX_HP = 80;
  const DRAGON_BASE_MODEL_WIDTH = 260;
  let spaceBossPhase='inactive';
  let spaceBoss=null;
  let spaceBossPlaceholder=null;
  let spaceBossAnchor=null;
  let spaceBossRevealScheduled=0;
  let spaceBossBursts=[];
  let spaceBossMarquee=null;
  let spaceBossDefeatedAt=0;
  let spaceBossAttack=null;
  let spaceBossNextAttackAt=0;
  const spaceBossBullets=[];
  let spaceBossPaddlePenalty=0;
  let spaceBossPaddleRespawnAt=0;
  let spaceBossDeathAnim=null;
  let spaceBossLastPaddleCenter=0;
  let spaceBossPrevPaddleCenter=0;
  let spaceBossSuppressLifeLossUntil=0;

  let reaperPhase='inactive';
  let reaperBoss=null;
  let reaperPlaceholder=null;
  let reaperAnchor=null;
  let reaperRevealScheduled=0;
  let reaperBursts=[];
  let cyclopsFirstAttackAt=0;
  let cyclopsEventStarted=false;
  let cyclopsMarqueeShown=false;
  let cyclopsRowBlastIndex=-1;
  let cyclopsNextRowBlast=0;
  let cyclopsShellBurst=false;
  let cyclopsEventComplete=false;
  let cyclopsForcedPetrifyAt=0;
  let cyclopsForcedPetrifyFired=false;
  let reaperAfterimages=[];
  let reaperMarquee=null;
  let reaperDefeatedAt=0;
  let reaperDeathAnim=null;
  let reaperTeleportSchedule=null;
  let reaperTargetHighlightUntil=0;
  let reaperAttackState=null;
  let reaperSlashZone=null;
  let reaperSlashEffects=[];
  let reaperBlackHoleAttack=null;
  let reaperLifeLossCooldownUntil=0;
  let reaperPaddlePenalty=0;
  let reaperPenaltyLastUpdate=0;
  const REAPER_PADDLE_MIN_WIDTH=80;
  let dragonPhase='inactive';
  let dragonBoss=null;
  let dragonPlaceholder=null;
  let dragonAnchor=null;
  let dragonRevealScheduled=0;
  let dragonBursts=[];
  let dragonMarquee=null;
  let dragonDefeatedAt=0;
  let dragonDeathAnim=null;
  let dragonAttackState=null;
  let dragonNextAttackAt=0;
  const dragonDeathRayOrbs=[];
  const dragonDeathRayBeams=[];
  let demonShellBrick=null;
  let demonEventPhase='inactive';
  let demonEventTimerStart=0;
  let demonEventTriggeredAt=0;
  let demonEventMarquee=null;
  let demonEventWave=null;
  let demonEventRows=[];
  let demonEventNextRowAt=0;
  let demonFallingDebris=[];
  let demonEventShakeUntil=0;
  let demonCore=null;
  let demonEventTargets=0;
  let demonEventCleared=0;
  let demonPhase='inactive';
  let demonBoss=null;
  let demonRevealScheduled=0;
  let demonAfterimages=[];
  let demonDeathAnim=null;
  let demonDefeatedAt=0;

  function isSpaceBossActive(){
    return level===5 && spaceBossPhase==='active' && !!spaceBoss;
  }

  function isReaperActive(){
    return level===10 && reaperPhase==='active' && !!reaperBoss;
  }

  function isDragonActive(){
    return level===15 && dragonPhase==='active' && !!dragonBoss;
  }

  function isDemonActive(){
    return level===20 && demonPhase==='active' && !!demonBoss;
  }

  function getSpaceBossBounds(){
    if(!spaceBoss) return null;
    return {
      x: spaceBoss.x - spaceBoss.w/2,
      y: spaceBoss.y - spaceBoss.h/2,
      w: spaceBoss.w,
      h: spaceBoss.h
    };
  }

  function computeDragonHitZones(bossOverride=null){
    const boss = bossOverride || dragonBoss;
    if(!boss) return [];
    const scale = (boss.w||DRAGON_BASE_MODEL_WIDTH)/DRAGON_BASE_MODEL_WIDTH;
    const cx = boss.x;
    const cy = boss.y;
    const wingPhase = boss.wingPhase||0;
    const sine=Math.sin(wingPhase);
    const downstroke=Math.pow(Math.max(0, sine), 1.6);
    const upstroke=Math.pow(Math.max(0, -sine), 1.2);
    const flap=(downstroke*0.65 - upstroke*0.42);
    let wingLift = 26*flap;
    let wingSpread = 1.38 + flap*0.42;
    if(boss.pose==='deathRay'){
      wingLift += 18;
      wingSpread += 0.6;
    }
    const zones=[];
    const addZone=(ox, oy, radius)=>{
      zones.push({
        cx: cx + ox*scale,
        cy: cy + oy*scale,
        r: Math.max(6, radius*scale)
      });
    };

    addZone(0,-48,62);
    addZone(0,24,70);
    addZone(0,110,58);
    addZone(0,190,48);
    addZone(0,268,42);
    addZone(0,-132,28);

    addZone(96,-12,42);
    addZone(-96,-12,42);
    addZone(102,108,38);
    addZone(-102,108,38);

    const tailSegments=[
      {y:146,r:44},
      {y:214,r:38},
      {y:286,r:32},
      {y:344,r:28}
    ];
    for(const seg of tailSegments){ addZone(0,seg.y,seg.r); }

    const wingClusters=[
      {x:-150, y:-72-wingLift*0.15, r:76},
      {x:-212, y:18-wingLift*0.05, r:70},
      {x:-252, y:126+wingLift*0.18, r:64},
      {x:-220, y:202+wingLift*0.32, r:58}
    ];
    for(const cluster of wingClusters){
      addZone(cluster.x*wingSpread, cluster.y, cluster.r);
      addZone(-cluster.x*wingSpread, cluster.y, cluster.r);
    }

    return zones;
  }

  function getDragonBounds(){
    if(!dragonBoss) return null;
    const zones=computeDragonHitZones();
    if(!zones.length){
      return {
        x: dragonBoss.x - dragonBoss.w/2,
        y: dragonBoss.y - dragonBoss.h/2,
        w: dragonBoss.w,
        h: dragonBoss.h
      };
    }
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const zone of zones){
      minX=Math.min(minX, zone.cx - zone.r);
      minY=Math.min(minY, zone.cy - zone.r);
      maxX=Math.max(maxX, zone.cx + zone.r);
      maxY=Math.max(maxY, zone.cy + zone.r);
    }
    return {x:minX, y:minY, w:maxX-minX, h:maxY-minY};
  }

  function circleIntersectsSpaceBoss(cx, cy, radius){
    const bounds=getSpaceBossBounds();
    if(!bounds) return false;
    const nearestX = Math.max(bounds.x, Math.min(cx, bounds.x + bounds.w));
    const nearestY = Math.max(bounds.y, Math.min(cy, bounds.y + bounds.h));
    const dx = cx - nearestX;
    const dy = cy - nearestY;
    return dx*dx + dy*dy <= radius*radius;
  }

  function circleIntersectsDragon(cx, cy, radius){
    const zones=computeDragonHitZones();
    if(!zones.length) return false;
    for(const zone of zones){
      const dx=cx-zone.cx;
      const dy=cy-zone.cy;
      const rr=radius + zone.r;
      if(dx*dx + dy*dy <= rr*rr) return true;
    }
    return false;
  }

  function resolveDragonBallCollision(ball, radius, inRampage){
    const zones=computeDragonHitZones();
    if(!zones.length) return null;
    let best=null;
    for(const zone of zones){
      const dx=ball.x - zone.cx;
      const dy=ball.y - zone.cy;
      const dist=Math.hypot(dx,dy);
      const overlap=(zone.r + radius) - dist;
      if(overlap>0 && (!best || overlap>best.overlap)){
        best={zone, dx, dy, dist:dist||0.0001, overlap};
      }
    }
    if(!best) return null;
    const nx=best.dx/(best.dist||0.0001);
    const ny=best.dy/(best.dist||0.0001);
    const impactX=best.zone.cx + nx*best.zone.r;
    const impactY=best.zone.cy + ny*best.zone.r;
    ball.x = impactX + nx*(radius+0.5);
    ball.y = impactY + ny*(radius+0.5);
    const dot = ball.vx*nx + ball.vy*ny;
    ball.vx -= 2*dot*nx;
    ball.vy -= 2*dot*ny;
    if(inRampage || ball.piercing){
      ball.piercing=true;
    }
    if(Math.abs(ball.vx)<0.2){ ball.vx += nx*4; }
    if(Math.abs(ball.vy)<0.2){ ball.vy += ny*4; }
    const bounceAxis = Math.abs(nx) > Math.abs(ny) ? 'x' : 'y';
    return {impactX, impactY, bounceAxis};
  }

  function triggerBallBuffEffectsOnBossHit(ball, impactX, impactY, now){
    if(buffs.PLASMA.active){
      const cfg=GAME_CONFIG.powers.PLASMA.plasma;
      const ang=Math.random()*Math.PI*2;
      plasmas.push({
        x:impactX,
        y:impactY,
        vx:Math.cos(ang)*cfg.drift,
        vy:Math.sin(ang)*cfg.drift,
        until:now+cfg.lifeMs,
        radius:cfg.radius,
        phase:Math.random()*Math.PI*2
      });
      playSFX('plasma');
    }

    if(buffs.FREEZE.active && (ball.freeze.state==='idle' || !ball.freeze.state)){
      const f=GAME_CONFIG.powers.FREEZE.freeze;
      ball.freeze.state='delay';
      ball.freeze.t0=now;
      ball.freeze.delay=f.delayMs;
      ball.freeze.stop=f.stopMs;
      ball.freeze.oldVX=ball.vx;
      ball.freeze.oldVY=ball.vy;
    }

    if(buffs.HOLY.active){
      playSFX('holy');
      holyFlashes.push({x:impactX, y:impactY, until:now+350});
      const L=layout();
      const rowIdx=Math.round((impactY - L.top) / (brickH + L.pad));
      const colIdx=Math.round((impactX - L.pad) / (brickW + L.pad));
      const rowY=L.top + rowIdx*(brickH + L.pad) + brickH/2;
      const colX=L.pad + colIdx*(brickW + L.pad) + brickW/2;
      for(let i=bricks.length-1;i>=0;i--){
        const t=bricks[i];
        const sameRow=Math.abs((t.y+t.h/2) - rowY)<1;
        const sameCol=Math.abs((t.x+t.w/2) - colX)<1;
        if(sameRow || sameCol){ destroyBrick(i,'none'); }
      }
      if(isSpecialBossActive()){
        const bounds=getActiveBossBounds();
        let bossHit=false;
        if(bounds && rowY>=bounds.y && rowY<=bounds.y+bounds.h){
          const cx=bounds.x+bounds.w/2;
          damageActiveBoss(1,'holy',{x:cx,y:rowY});
          bossHit=true;
        }
        if(bounds && !bossHit && colX>=bounds.x && colX<=bounds.x+bounds.w){
          const cy=bounds.y+bounds.h/2;
          damageActiveBoss(1,'holy',{x:colX,y:cy});
        }
      }
      screenShake=Math.max(screenShake,4);
    }

    if(buffs.HELL.active){
      const holeSpin=(Math.random()>0.5?1:-1);
      blackHoles.push({
        x:impactX,
        y:impactY,
        r:40,
        until:now+GAME_CONFIG.powers.HELL.hell.haloMs,
        start:performance.now(),
        spinDir:holeSpin
      });
      playSFX('blackhole');
    }
  }

  function getReaperBounds(){
    if(!reaperBoss) return null;
    return {
      x: reaperBoss.x - reaperBoss.w/2,
      y: reaperBoss.y - reaperBoss.h/2,
      w: reaperBoss.w,
      h: reaperBoss.h
    };
  }

  function circleIntersectsReaper(cx, cy, radius){
    const bounds=getReaperBounds();
    if(!bounds) return false;
    const nearestX = Math.max(bounds.x, Math.min(cx, bounds.x + bounds.w));
    const nearestY = Math.max(bounds.y, Math.min(cy, bounds.y + bounds.h));
    const dx = cx - nearestX;
    const dy = cy - nearestY;
    return dx*dx + dy*dy <= radius*radius;
  }

  function getDemonBounds(){
    if(!demonBoss) return null;
    const hitW=demonBoss.hitW||demonBoss.w;
    const hitH=demonBoss.hitH||demonBoss.h;
    const offsetX=demonBoss.hitOffsetX||0;
    const offsetY=demonBoss.hitOffsetY||0;
    return {
      x: demonBoss.x + offsetX - hitW/2,
      y: demonBoss.y + offsetY - hitH/2,
      w: hitW,
      h: hitH
    };
  }

  function computeDemonHitZones(){
    if(!demonBoss) return [];
    const bounds=getDemonBounds();
    if(!bounds) return [];
    const cx=bounds.x + bounds.w/2;
    const hitW=bounds.w;
    const hitH=bounds.h;
    const top=bounds.y;
    const zones=[];

    const headH=hitH*0.22;
    const headW=hitW*0.56;
    zones.push({x:cx-headW/2, y:top, w:headW, h:headH});

    const torsoH=hitH*0.38;
    const torsoW=hitW*0.74;
    zones.push({x:cx-torsoW/2, y:top+headH*0.7, w:torsoW, h:torsoH});

    const waistH=hitH*0.26;
    const waistW=hitW*0.7;
    zones.push({x:cx-waistW/2, y:top+headH*0.7+torsoH*0.85, w:waistW, h:waistH});

    const legH=hitH*0.34;
    const legW=hitW*0.32;
    const legY=top+hitH*0.6;
    const legOffset=hitW*0.18;
    zones.push({x:cx-legOffset-legW/2, y:legY, w:legW, h:legH});
    zones.push({x:cx+legOffset-legW/2, y:legY, w:legW, h:legH});

    const armH=hitH*0.34;
    const armW=hitW*0.34;
    const armY=top+hitH*0.28;
    const armOffset=torsoW/2 + armW*0.3;
    zones.push({x:cx-armOffset-armW/2, y:armY, w:armW, h:armH});
    zones.push({x:cx+armOffset-armW/2, y:armY, w:armW, h:armH});

    return zones;
  }

  function demonPointInHitArea(px, py){
    const zones=computeDemonHitZones();
    for(const zone of zones){
      if(px>=zone.x && px<=zone.x+zone.w && py>=zone.y && py<=zone.y+zone.h){
        return true;
      }
    }
    return false;
  }

  function circleIntersectsRect(cx, cy, radius, rect){
    const nearestX=Math.max(rect.x, Math.min(cx, rect.x+rect.w));
    const nearestY=Math.max(rect.y, Math.min(cy, rect.y+rect.h));
    const dx=cx-nearestX;
    const dy=cy-nearestY;
    return dx*dx + dy*dy <= radius*radius;
  }

  function circleIntersectsDemon(cx, cy, radius){
    const zones=computeDemonHitZones();
    if(!zones.length) return false;
    for(const zone of zones){
      if(circleIntersectsRect(cx, cy, radius, zone)) return true;
    }
    return false;
  }

  function getDemonCloakBounds(){
    if(!demonBoss) return null;
    const cloakW=demonBoss.cloakW || ((demonBoss.hitW||demonBoss.w)*1.8);
    const cloakH=demonBoss.cloakH || ((demonBoss.hitH||demonBoss.h)*1.2);
    const offsetX=(demonBoss.cloakOffsetX!=null?demonBoss.cloakOffsetX:(demonBoss.hitOffsetX||0));
    const offsetY=(demonBoss.cloakOffsetY!=null?demonBoss.cloakOffsetY:(demonBoss.hitOffsetY||0));
    const cx=demonBoss.x + offsetX;
    const cy=demonBoss.y + offsetY + cloakH*0.1;
    return {
      x: cx - cloakW/2,
      y: cy - cloakH/2,
      w: cloakW,
      h: cloakH
    };
  }

  function demonCloakCenter(){
    const bounds=getDemonCloakBounds();
    if(!bounds) return null;
    return {x:bounds.x + bounds.w/2, y:bounds.y + bounds.h/2};
  }

  function resolveDemonBallCollision(ball, radius){
    const zones=computeDemonHitZones();
    if(!zones.length) return null;
    let best=null;
    for(const zone of zones){
      if(ball.x+radius<=zone.x || ball.x-radius>=zone.x+zone.w || ball.y+radius<=zone.y || ball.y-radius>=zone.y+zone.h) continue;
      const oL=(ball.x+radius)-zone.x;
      const oR=(zone.x+zone.w)-(ball.x-radius);
      const oT=(ball.y+radius)-zone.y;
      const oB=(zone.y+zone.h)-(ball.y-radius);
      const minOverlap=Math.min(oL,oR,oT,oB);
      if(minOverlap<=0) continue;
      if(!best || minOverlap<best.penetration){
        best={zone, penetration:minOverlap, oL, oR, oT, oB};
      }
    }
    return best;
  }

  function captureBallInCloak(ball, now){
    const center=demonCloakCenter();
    if(!center) return false;
    const anchor={dx:ball.x-center.x, dy:ball.y-center.y};
    ball.demonCloakState='captured';
    ball.demonCloakCapturedAt=now;
    ball.demonCloakReleaseAt=now+2000;
    ball.demonCloakAnchor=anchor;
    ball.demonCloakStoredSpeed=Math.max(Math.hypot(ball.vx, ball.vy), 4);
    ball.demonCloakStayStart=0;
    ball.demonCloakInside=true;
    const wrapRadius=Math.max(36, Math.min(120, Math.hypot(anchor.dx, anchor.dy)));
    ball.demonCloakWrapRadius=wrapRadius;
    ball.demonCloakWrapPhase=Math.atan2(anchor.dy, anchor.dx);
    ball.demonCloakWrapProgress=0;
    ball.demonCloakWrapDuration=900+Math.random()*400;
    ball.demonCloakLastUpdate=now;
    ball.vx=0;
    ball.vy=0;
    return true;
  }

  function releaseBallFromCloak(ball){
    const center=demonCloakCenter();
    const anchor=ball.demonCloakAnchor||{dx:0,dy:0};
    if(center){
      ball.x=center.x + anchor.dx;
      ball.y=center.y + anchor.dy;
    }
    const speedCap=ball.speedCap||GAME_CONFIG.caps.ballSpeedMax;
    const stored=Math.max(ball.demonCloakStoredSpeed||speedCap, 4);
    const speed=Math.min(speedCap, stored*1.2);
    const phase=ball.demonCloakWrapPhase||Math.atan2(anchor.dy, anchor.dx||1);
    const tangent={
      x:-Math.sin(phase),
      y:Math.abs(Math.cos(phase))*0.75 + 0.35
    };
    const dirX=tangent.x>=0?1:-1;
    const len=Math.hypot(tangent.x, tangent.y)||1;
    ball.vx=(tangent.x/len)*speed;
    ball.vy=(tangent.y/len)*speed;
    ball.demonCloakState='launched';
    ball.demonCloakReleaseAt=0;
    ball.demonCloakCapturedAt=0;
    ball.demonCloakWrapProgress=0;
    ball.demonCloakWrapRadius=0;
    ball.demonCloakLastUpdate=0;
    if(demonBoss){
      const now=performance.now();
      demonBoss.cloakWhipStart=now;
      demonBoss.cloakWhipDuration=420;
      demonBoss.cloakWhipUntil=now+420;
      demonBoss.cloakWhipStrength=Math.min(1.4, 0.7+(ball.demonCloakStoredSpeed?Math.min(ball.demonCloakStoredSpeed/10,0.8):0));
      demonBoss.cloakWhipDir=dirX||1;
    }
  }

  function handleDemonCloakState(ball, now){
    if(!demonBoss || demonPhase!=='active'){
      if(ball.demonCloakState==='captured'){
        const restore=Math.max(ball.demonCloakStoredSpeed||4,4);
        if(Math.abs(ball.vx)+Math.abs(ball.vy)<0.2){
          ball.vx=0;
          ball.vy=-restore;
        }
        ball.demonCloakState=null;
      }
      ball.demonCloakStoredSpeed=0;
      ball.demonCloakAnchor=null;
      ball.demonCloakStayStart=0;
      ball.demonCloakInside=false;
      ball.demonCloakWrapProgress=0;
      ball.demonCloakWrapRadius=0;
      ball.demonCloakLastUpdate=0;
      return false;
    }

    if(ball.demonCloakState==='captured'){
      const center=demonCloakCenter();
      if(center){
        const anchor=ball.demonCloakAnchor||{dx:0,dy:0};
        const dt=now-(ball.demonCloakLastUpdate||now);
        const wrapDuration=ball.demonCloakWrapDuration||1000;
        const progress=Math.max(0, Math.min(1, (ball.demonCloakWrapProgress||0) + (wrapDuration>0?dt/wrapDuration:0)));
        ball.demonCloakWrapProgress=progress;
        const baseRadius=ball.demonCloakWrapRadius||Math.max(36, Math.hypot(anchor.dx, anchor.dy));
        const eased=Math.pow(progress,0.85);
        const radius=Math.max(18, baseRadius*(1-eased) + 18*eased);
        const swirlSpeed=0.006 + 0.006*progress;
        ball.demonCloakWrapPhase=(ball.demonCloakWrapPhase||Math.atan2(anchor.dy, anchor.dx||1)) + dt*swirlSpeed;
        const phase=ball.demonCloakWrapPhase;
        const lift=Math.sin(progress*Math.PI*1.2)*10;
        const dx=Math.cos(phase)*radius;
        const dy=Math.sin(phase)*radius*0.65 + lift;
        const sway=Math.sin((now-(ball.demonCloakCapturedAt||now))/260)*3;
        ball.demonCloakAnchor={dx, dy:dy+sway};
        ball.x=center.x + dx;
        ball.y=center.y + dy + sway;
        ball.demonCloakLastUpdate=now;
      }
      ball.vx=0;
      ball.vy=0;
      if(ball.demonCloakReleaseAt && now>=ball.demonCloakReleaseAt){
        releaseBallFromCloak(ball);
      }
      return ball.demonCloakState==='captured';
    }

    const cloakBounds=getDemonCloakBounds();
    if(!cloakBounds) return false;
    const inCloak=(ball.x>=cloakBounds.x && ball.x<=cloakBounds.x+cloakBounds.w && ball.y>=cloakBounds.y && ball.y<=cloakBounds.y+cloakBounds.h);
    const wasInside=!!ball.demonCloakInside;
    ball.demonCloakInside=inCloak;
    if(inCloak && ball.demonCloakState!=='launched' && !demonPointInHitArea(ball.x, ball.y)){
      if(!wasInside){
        ball.demonCloakStayStart=now;
        if(Math.random()<0.05){
          if(captureBallInCloak(ball, now)){
            return true;
          }
        }
      }
    }else if(!inCloak){
      if(wasInside){ ball.demonCloakStayStart=0; }
      if(ball.demonCloakState!=='launched'){ ball.demonCloakState=null; }
    }
    return false;
  }

  function spaceBossImpactPoint(fromX, fromY){
    const bounds=getSpaceBossBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const targetX = spaceBoss.x;
    const targetY = spaceBoss.y;
    const dx = targetX - fromX;
    const dy = targetY - fromY;
    let bestT = Infinity;
    function test(t){
      if(t<=0 || t>=1e6) return;
      const ix = fromX + dx*t;
      const iy = fromY + dy*t;
      if(ix>=bounds.x-1e-6 && ix<=bounds.x+bounds.w+1e-6 && iy>=bounds.y-1e-6 && iy<=bounds.y+bounds.h+1e-6){
        if(t<bestT) bestT=t;
      }
    }
    if(Math.abs(dx)>1e-6){
      test((bounds.x - fromX)/dx);
      test((bounds.x + bounds.w - fromX)/dx);
    }
    if(Math.abs(dy)>1e-6){
      test((bounds.y - fromY)/dy);
      test((bounds.y + bounds.h - fromY)/dy);
    }
    if(bestT!==Infinity){
      return {x: fromX + dx*bestT, y: fromY + dy*bestT};
    }
    return {x: targetX, y: targetY};
  }

  function reaperImpactPoint(fromX, fromY){
    const bounds=getReaperBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const targetX = reaperBoss.x;
    const targetY = reaperBoss.y;
    const dx = targetX - fromX;
    const dy = targetY - fromY;
    let bestT = Infinity;
    function test(t){
      if(t<=0 || t>=1e6) return;
      const ix = fromX + dx*t;
      const iy = fromY + dy*t;
      if(ix>=bounds.x-1e-6 && ix<=bounds.x+bounds.w+1e-6 && iy>=bounds.y-1e-6 && iy<=bounds.y+bounds.h+1e-6){
        if(t<bestT) bestT=t;
      }
    }
    if(Math.abs(dx)>1e-6){
      test((bounds.x - fromX)/dx);
      test((bounds.x + bounds.w - fromX)/dx);
    }
    if(Math.abs(dy)>1e-6){
      test((bounds.y - fromY)/dy);
      test((bounds.y + bounds.h - fromY)/dy);
    }
    if(bestT!==Infinity){
      return {x: fromX + dx*bestT, y: fromY + dy*bestT};
    }
    return {x: targetX, y: targetY};
  }

  function demonImpactPoint(fromX, fromY){
    const bounds=getDemonBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const targetX = demonBoss.x;
    const targetY = demonBoss.y;
    const dx = targetX - fromX;
    const dy = targetY - fromY;
    let bestT = Infinity;
    function test(t){
      if(t<=0 || t>=1e6) return;
      const ix = fromX + dx*t;
      const iy = fromY + dy*t;
      if(ix>=bounds.x-1e-6 && ix<=bounds.x+bounds.w+1e-6 && iy>=bounds.y-1e-6 && iy<=bounds.y+bounds.h+1e-6){
        if(t<bestT) bestT=t;
      }
    }
    if(Math.abs(dx)>1e-6){
      test((bounds.x - fromX)/dx);
      test((bounds.x + bounds.w - fromX)/dx);
    }
    if(Math.abs(dy)>1e-6){
      test((bounds.y - fromY)/dy);
      test((bounds.y + bounds.h - fromY)/dy);
    }
    if(bestT!==Infinity){
      return {x: fromX + dx*bestT, y: fromY + dy*bestT};
    }
    return {x: targetX, y: targetY};
  }

  function highlightSpaceBossTarget(){
    if(isReaperActive()){
      const bounds=getReaperBounds();
      if(bounds){
        reaperTargetHighlightUntil = Math.max(reaperTargetHighlightUntil, performance.now()+600);
        pushLockBox(bounds.x, bounds.y, bounds.w, bounds.h, 'target');
      }
      return;
    }
    const bounds=getSpaceBossBounds();
    if(bounds){
      pushLockBox(bounds.x, bounds.y, bounds.w, bounds.h, 'target');
      return;
    }
    if(isDragonActive()){
      const dragonBounds=getDragonBounds();
      if(dragonBounds){
        pushLockBox(dragonBounds.x, dragonBounds.y, dragonBounds.w, dragonBounds.h, 'target');
      }
    }
  }
    let scoreUploaded=false;
    let uploading=false;
  let ledStyle = (localStorage.getItem('led_style')||'classic');
  function resetCombo(){
    combo=0; comboLastTime=0;
    comboNoticeTriggered={50:false,100:false,200:false,300:false,400:false,500:false,800:false,1000:false};
    if(comboEl){ comboEl.textContent=''; comboEl.className='combo'; comboEl.style.opacity=0; }
  }
  function showComboNotice(text,showMs=5000,fadeMs=3000){
    let notice=document.getElementById('comboNotice');
    if(!notice){
      notice=document.createElement('div');
      notice.id='comboNotice';
      document.getElementById('playArea').appendChild(notice);
    }
    notice.className='';
    notice.innerHTML='';
    const span=document.createElement('span');
    span.className='marqueeText';
    span.textContent=text;
    span.style.animation=`comboMarquee ${showMs}ms linear`;
    notice.appendChild(span);
    notice.style.transition=`opacity ${fadeMs/1000}s`;
    void notice.offsetWidth;
    notice.className='show';
    setTimeout(()=>notice.classList.add('fade'),showMs);
    setTimeout(()=>{notice.className=''; notice.innerHTML=''; notice.style.transition='';},showMs+fadeMs);
  }
  function incrementCombo(){
    combo++; comboLastTime=performance.now();
    if(combo>stats.maxCombo) stats.maxCombo=combo;
    if(!comboEl) return;
    comboEl.textContent='Combo '+combo;
    comboEl.className='combo show';
    if(combo>=200){ comboEl.classList.add('tier6','glow'); }
    else if(combo>=100){ comboEl.classList.add('tier5'); }
    else if(combo>=50){ comboEl.classList.add('tier4'); }
    else if(combo>=30){ comboEl.classList.add('tier3'); }
    else if(combo>=10){ comboEl.classList.add('tier2'); }
    else { comboEl.classList.add('tier1'); }
    if(buffs.COMBO?.active){ comboEl.classList.add('star'); }
    comboEl.classList.add('pop'); setTimeout(()=>comboEl.classList.remove('pop'),500);
    comboEl.style.opacity=1;
    if(combo===50 && !comboNoticeTriggered[50]){ comboNoticeTriggered[50]=true; showComboNotice('çœ‹ä¾†æ˜¯å€‹é«˜æ‰‹å‘¢ï¼'); }
    else if(combo===100 && !comboNoticeTriggered[100]){ comboNoticeTriggered[100]=true; showComboNotice('çœŸæ˜¯é©šäººï¼ ä½ â€¦â€¦æ˜¯æ€ªç‰©å—ï¼Ÿ'); }
    else if(combo===200 && !comboNoticeTriggered[200]){ comboNoticeTriggered[200]=true; showComboNotice('é›£ä»¥ç½®ä¿¡ï¼ ä½ â€¦â€¦æ˜¯ç¥å—ï¼Ÿ'); }
    else if(combo===300 && !comboNoticeTriggered[300]){ comboNoticeTriggered[300]=true; showComboNotice('ä½ æ˜¯é‚„æƒ³çªç ´å¤©éš›åˆ°å“ªè£¡å»å‘€ï¼Ÿç•°æ¬¡å…ƒå—ï¼Ÿ'); }
    else if(combo===400 && !comboNoticeTriggered[400]){ comboNoticeTriggered[400]=true; showComboNotice('ä½ é€™å·²ç¶“ç ´ç¢è™›ç©ºäº†å§ï¼Ÿ'); }
    else if(combo===500 && !comboNoticeTriggered[500]){ comboNoticeTriggered[500]=true; showComboNotice('ç®—ä½ ç‹ ï¼æœ‰ç¨®Combo 1000çœ‹çœ‹å‘€ï¼'); }
    else if(combo===800 && !comboNoticeTriggered[800]){ comboNoticeTriggered[800]=true; showComboNotice('æˆ‘çœ‹ä½ æ˜¯åˆ°ä¸äº†Combo 1000çš„å•¦ï¼æ˜¯ä¸æ˜¯é–‹å§‹æ„Ÿè¦ºæ‰‹æ»‘å•¦ï¼Ÿ'); }
    else if(combo===1000 && !comboNoticeTriggered[1000]){ comboNoticeTriggered[1000]=true; showComboNotice('å¿«æˆªåœ–çµ¦åŒäº‹çœ‹å§ï¼ä½ æ˜¯çœŸæ­£çš„é€£æ“Šä¹‹ç¥ï¼',10000,5000); }
  }
  function getComboMultiplier(){
    if(combo>=1000) return 10;
    if(combo>=800) return 8;
    if(combo>=500) return 7;
    if(combo>=400) return 6;
    if(combo>=300) return 5;
    if(combo>=200) return 4;
    if(combo>=100) return 3;
    if(combo>=50) return 2;
    if(combo>=30) return 1.5;
    if(combo>=10) return 1.2;
    return 1;
  }
  function addScore(base){
    let mul=getComboMultiplier();
    if(buffs.COMBO?.active){ mul*=GAME_CONFIG.powers.COMBO.combo.scoreMul; }
    const d=difficultySel?.value;
    if(d==='easy') mul*=0.5;
    else if(d==='hard') mul*=1.2;
    score += Math.round(base * mul);
  }
  function scoreForBrick(b){ return b.boss ? 3000 : (b.elite ? 100 : 10); }
  const BOSS_DEFEAT_SCORE = {
    space: 5000,
    reaper: 10000,
    dragon: 20000,
    demon: 50000
  };
  const BOSS_HIT_SCORE = 30;
  function renderStatsHtml(){
    const fd = (stats.fastestDeath===Infinity)? '-' : stats.fastestDeath.toFixed(1);
    const ld = (stats.longestLife===0)? '-' : stats.longestLife.toFixed(1);
    return `<div class="grid">
      <div>æ¶ˆè€—ç”Ÿå‘½ï¼š<strong>${stats.livesUsed}</strong></div>
      <div>æ¥çƒæ¬¡æ•¸ï¼š<strong>${stats.catches}</strong></div>
      <div>å¢ç›Šæ¬¡æ•¸ï¼š<strong>${stats.buffs}</strong></div>
      <div>æ¸›ç›Šæ¬¡æ•¸ï¼š<strong>${stats.debuffs}</strong></div>
      <div>æ®ºèè‹±æ•¸ï¼š<strong>${stats.eliteKills}</strong></div>
      <div>æ®ºBossæ•¸ï¼š<strong>${stats.bossKills}</strong></div>
      <div>æœ€é«˜Comboæ•¸ï¼š<strong>${stats.maxCombo}</strong></div>
      <div>æœ€å¿«æ­»äº¡ï¼š<strong>${fd}</strong> s</div>
      <div>æœ€ä¹…å­˜æ´»ï¼š<strong>${ld}</strong> s</div>
    </div>`;
  }

  let bgTime=0; let screenShake=0;
  let countdownTimer=null, countdownShow=0, resumePending=false;
  // === æ–°å¢æš«åœæ™‚é–“è¿½è¹¤èˆ‡è‡ªå‹•å¢ç›Šæ‰è½è¨ˆæ™‚ ===
  // pauseStartedAt: è¨˜éŒ„æš«åœé–‹å§‹æ™‚çš„æ™‚é–“æˆ³ã€‚ç•¶é null æ™‚è¡¨éŠæˆ²è™•æ–¼æš«åœç‹€æ…‹ï¼ˆåŒ…æ‹¬é–‹å•ŸéŸ³æ•ˆ/é¸é …èœå–®ã€æ•™å­¸èªªæ˜ç­‰ï¼‰ã€‚
  // lastBeneficialPickupAt: ä¸Šä¸€æ¬¡å–å¾—å¢ç›Šæˆ–ç‰¹æ®Šå¢ç›Šçš„æ™‚é–“æˆ³ï¼Œç”¨æ–¼è§¸ç™¼åç§’æœªæ‹¾å–å¢ç›Šæ™‚è‡ªå‹•æ‰è½ã€‚
  // nextAutoBeneficialDropAt: ä¸‹ä¸€æ¬¡è‡ªå‹•æ‰è½å¢ç›Šçš„é å®šæ™‚é–“ï¼Œå°‡åœ¨ update ä¸­æª¢æŸ¥ä¸¦è§¸ç™¼ã€‚
  let pauseStartedAt = null;
  let lastBeneficialPickupAt = 0;
  let nextAutoBeneficialDropAt = 0;
  // å½±åƒé¸æ“‡ï¼š1~10 éš¨æ©Ÿ bg/cgï¼Œ11~20 ç”¨å°æ‡‰æœªç”¨è€…
  let imageChoice = new Array(10).fill(-1); // 0=bg,1=cg; -1: æœªæ±º
  let galleryUnlocks = {};
  try{ galleryUnlocks = JSON.parse(localStorage.getItem('gallery_unlocks')||'{}'); }catch(e){ galleryUnlocks={}; }
  function markImageUnlocked(type, idx){
    const key = `${type}${idx+1}`;
    if(!galleryUnlocks[key]){
      galleryUnlocks[key]=true;
      try{ localStorage.setItem('gallery_unlocks', JSON.stringify(galleryUnlocks)); }catch(e){}
    }
  }

  let dialogUnlocks = {};
  try{ dialogUnlocks = JSON.parse(localStorage.getItem('dialog_unlocks')||'{}'); }catch(e){ dialogUnlocks={}; }
  function unlockDialog(key, idx){
    const mask = dialogUnlocks[key] || 0;
    dialogUnlocks[key] = mask | (1<<idx);
    try{ localStorage.setItem('dialog_unlocks', JSON.stringify(dialogUnlocks)); }catch(e){}
  }
  function getRandomDialog(key){
    const lines = DIALOGS[key] || [];
    const mask = dialogUnlocks[key] || 0;
    const lockedIdx = [];
    for(let i=0;i<lines.length;i++){
      if(!(mask & (1<<i))) lockedIdx.push(i);
    }
    let idx;
    if(lockedIdx.length>0){
      idx = lockedIdx[Math.floor(Math.random()*lockedIdx.length)];
    }else{
      idx = Math.floor(Math.random()*lines.length);
    }
    return {idx, text: lines[idx]||''};
  }
  // BGM
  let audioCtx=null, bgmGain=null, bgmOn=false, bgmStarted=false;
  // è¿½è¹¤ç›®å‰ä½œç”¨ä¸­çš„ BGM nodeï¼Œä¾¿æ–¼åœæ­¢èˆ‡æ¸…é™¤
  let bgmNodes=new Set();

  // === åˆå§‹åŒ–æ–° UI çš„è²éŸ³/BGM æ§åˆ¶ ===
  // é€£çµè¤‡é¸æ¡†è‡³åŸæœ‰çš„ soundBtn/bgmBtn æŒ‰éˆ•ï¼Œä¸¦åŒæ­¥æœ¬åœ°å„²å­˜å€¼
  if (sfxOnEl) {
    const stored = localStorage.getItem('sfx_on');
    // è‹¥æœ¬åœ°æœ‰è¨­å®šå‰‡ä½¿ç”¨ï¼Œå¦å‰‡æ²¿ç”¨é è¨­çš„ soundsOn
    soundsOn = (stored ?? (soundsOn ? '1' : '0')) === '1';
    sfxOnEl.checked = soundsOn;
    // åˆ‡æ›è¤‡é¸æ¡†å³å‘¼å«èˆŠé‚è¼¯çš„æŒ‰éˆ• clickï¼Œä¸¦ä¾æ“šæ›´æ–°å¾Œçš„è®Šæ•¸åŒæ­¥è¤‡é¸æ¡†ç‹€æ…‹
    sfxOnEl.addEventListener('change', () => {
      soundBtn.click();
      sfxOnEl.checked = soundsOn;
    });
  }
  if (bgmOnEl) {
    const stored = localStorage.getItem('bgm_on');
    bgmOn = (stored ?? (bgmOn ? '1' : '0')) === '1';
    bgmOnEl.checked = bgmOn;
    bgmOnEl.addEventListener('change', () => {
      bgmBtn.click();
      bgmOnEl.checked = bgmOn;
    });
  }
  // åˆå§‹åŒ– BGM éŸ³é‡æ»‘æ¡¿
  if (localStorage.getItem('bgm_vol')) {
    const vol = parseFloat(localStorage.getItem('bgm_vol'));
    if (!isNaN(vol)) {
      bgmVol.value = String(vol);
      if (bgmGain) bgmGain.gain.value = vol;
    }
  }

  // ç²’å­ / ç‰¹æ•ˆå®¹å™¨
  const particles=[]; // {x,y,vx,vy,life,size,color}
  const plasmas=[];   // {x,y,vx,vy,until,radius}
  const holyFlashes=[]; // {x,y,until}
  let phoenixAnim=null; // {x, tEnd}
  const fireBursts=[];  // ç«ç„°ç‰‡æ®µ {x,y,life}
  const fireExplosions=[]; // ç«ç„°çƒçˆ†ç‚¸æ•ˆæœ {x,y,r,t0,life}

  // æ–°å¢å®¹å™¨ï¼šé£›å½ˆã€é»‘æ´ç‰¹æ•ˆã€é›·å°„å…‰æŸ
  const missiles=[]; // {x,y,vx,vy,targetId,targetType,lifeUntil,trail:[]}
  const blackHoles=[]; // {x,y,until}
  const laserBeams=[]; // {x1,y1,x2,y2,until}
  const laserImpacts=[]; // {x,y,t0,tEnd}
  const gatlingBullets=[]; // ç«åŠ›å£“åˆ¶å­å½ˆ {x,y,vx,vy}
  const lockBoxes=[]; // {x,y,w,h,until,kind}
  let nextTreasureBrickAt=0;

  function scheduleNextTreasureBrick(now=performance.now()){
    nextTreasureBrickAt = now + 5000 + Math.random()*3000;
  }

  function isTrueBossFightActive(){
    return (spaceBossPhase==='active' && spaceBoss) || (reaperPhase==='active' && reaperBoss) || (dragonPhase==='active' && dragonBoss) || (demonPhase==='active' && demonBoss);
  }

  function spawnBossTreasureBrick(){
    if(!isTrueBossFightActive()) return;
    const L=layout();
    const width=Math.max(48, brickW||80);
    const height=Math.max(20, brickH||24);
    const pad=40;
    const minX=pad;
    const maxX=Math.max(minX, 1100 - pad - width);
    const spawnX=minX + Math.random()*(maxX - minX);
    const top=L?L.top:0;
    const spawnY=(top||0) - height - 12;
    const fallVy=GAME_CONFIG.powerCapsule.fallVy||2.2;
    addBrick(bricks, spawnX, spawnY, width, height, {
      hp:1,
      treasure:true,
      fallingTreasure:true,
      vy:fallVy,
      colorIdx:0
    });
    spawnParticles(spawnX + width/2, Math.max(spawnY + height/2, 0), '#a8e3ff', 14, 1.6, 2.6, 2.4);
    spawnParticles(spawnX + width/2, Math.max(spawnY + height/2, 0), '#ff9bf1', 10, 1.2, 2.0, 2.0);
    updateHUD();
  }

  // ç‰¹æ®Šå¢ç›Šç›¸é—œå®¹å™¨
  const swords=[]; // åŠèŠ’è£‚ç©ºï¼š{x,y,vx,vy,state,tx,ty}
  let swordFireStart=0, nextSwordFire=0;

  let stormTurret=null; // é›·å°„é¢¨æš´ï¼š{x,y,chargeUntil,fireAt,shots,lastShot}
  let gatling=null; // ç«åŠ›å£“åˆ¶ï¼š{x,y,chargeUntil,fireStart,fireUntil,lastShot,angle}

  const annihilSparks=[]; // è¬ç‰©éŠ·æ¯€ï¼šå¤©ç©ºç‘è½çš„é‡‘è‰²å…‰é» {x,y,v}

  // === Boss æŠ•å°„ç‰© ===
  const hostileBeams=[]; // ç·šæ€§å…‰æŸå½ˆ {x,y,vx,vy,color,hit,onHit}
  const hostileArcs=[];  // å¼§å½¢åŠæ°£ {x,y,vx,vy,phase,amp,color,onHit}
  const hostileColumns=[]; // ç›´ä¸‹çŸ³åŒ–å…‰æŸ {x,w,tStart,tEnd,color,applied}
  const hazardClouds=[]; // çƒé›² {x,y,tEnd,spawned}

  function bossCenter(){
    if(isDragonActive() && dragonBoss) return {b:null, x:dragonBoss.x, y:dragonBoss.y, type:'dragon'};
    for(const b of bricks){ if(b.boss) return {b, x:b.x+b.w/2, y:b.y+b.h/2}; }
    return null;
  }

  function spawnLionBeamFrom(x,y){
    const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
    const ang=Math.atan2(ty-y, tx-x); const speed=6.0;
    hostileBeams.push({x:x, y:y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); screenShake=Math.max(screenShake,6); }});
    beep(1100,0.12,0.08);
  }
  function spawnLionBeam(){
    const bc=bossCenter(); if(!bc) return;
    bossChargeColor='255,215,90'; bossChargeUntil=performance.now()+2000;
    setTimeout(()=>{
      const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
      const ang=Math.atan2(ty-bc.y, tx-bc.x); const speed=6.0;
      hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); screenShake=Math.max(screenShake,6); }});
      beep(1100,0.12,0.08);
    },2000);
  }
  function spawnKnightArc(){
    const bc=bossCenter(); if(!bc) return;
    bossChargeColor='210,210,255'; bossChargeUntil=performance.now()+2000;
    setTimeout(()=>{
      const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
      const ang=Math.atan2(ty-bc.y, tx-bc.x);
      const speed=4.5;
      hostileArcs.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, phase:0, amp:32, color:'silver', onHit:()=>{ lives=Math.max(0, lives-1); updateHUD(); screenShake=Math.max(screenShake,10); }});
      beep(900,0.12,0.07);
    },2000);
  }
  function spawnCyclopsColumn(opts={}){
    const bc=bossCenter(); if(!bc) return;
    const now=performance.now();
    bossChargeColor='255,235,150';
    bossChargeUntil=now+3000;
    if(isDragonActive() && dragonBoss){
      dragonBoss.petrifyCharge={start:now,end:now+3000};
      dragonMarquee={text:'å±éšªï¼ æ¯€æ»…ä¹‹é¾å³å°‡ä½¿å‡ºçŸ³åŒ–å…‰æŸ!', start:now, fadeStart:now+2600, end:now+3000, style:'elegant'};
    }
    setTimeout(()=>{
      const center=bossCenter();
      if(!center){
        if(dragonBoss) dragonBoss.petrifyCharge=null;
        return;
      }
      const releaseAt=performance.now();
      hostileColumns.push({x:center.x, w:150, tStart:releaseAt, tEnd:releaseAt+1000, color:'#eedc9a', applied:false});
      cyclopsShakeUntil=releaseAt+2000;
      if(isDragonActive() && dragonBoss){
        dragonBoss.petrifyCharge=null;
      }
      noteCyclopsFirstAttack(releaseAt);
      beep(500,0.12,0.08);
      if(opts.onComplete){ setTimeout(()=>{ opts.onComplete(); },1000); }
    },3000);
  }
  function finishDragonAttack(expectType=null){
    const now=performance.now();
    if(expectType && dragonAttackState && dragonAttackState.type!==expectType){ return; }
    dragonAttackState=null;
    dragonDeathRayOrbs.length=0;
    dragonDeathRayBeams.length=0;
    if(dragonBoss){
      dragonBoss.pose=null;
      dragonBoss.moveTarget=null;
      dragonBoss.nextMove=now+1400;
    }
    dragonNextAttackAt=now+20000;
  }

  function maybeStartDragonAttack(now){
    if(!isDragonActive() || !dragonBoss) return;
    if(dragonAttackState) return;
    if(!dragonNextAttackAt){ dragonNextAttackAt=now+3000; }
    if(now<dragonNextAttackAt) return;
    const options=['petrify','deathRay','annihilation'];
    const pick=options[Math.floor(Math.random()*options.length)];
    startDragonAttack(pick);
  }

  function startDragonAttack(type){
    if(!dragonBoss) return;
    const now=performance.now();
    if(type==='petrify'){
      dragonAttackState={type:'petrify', startedAt:now, phase:'charge'};
      spawnCyclopsColumn({onComplete:()=>finishDragonAttack('petrify')});
    }else if(type==='deathRay'){
      const L=layout();
      const targetY=L.top+120;
      dragonBoss.moveTarget=null;
      dragonAttackState={
        type:'deathRay',
        startedAt:now,
        phase:'countdown',
        overrideMovement:true,
        targetX:550,
        targetY,
        countdownEnd:now+3000,
        nextOrb:now,
        countdownValue:3,
        nextCountdownTick:now+1000,
        fireIndex:0,
        fireNext:0,
        lockedTarget:null,
        beamTravel:900,
        beamFade:320
      };
      dragonDeathRayOrbs.length=0;
      dragonBoss.pose='deathRay';
      dragonMarquee={text:'å±éšªï¼ æ¯€æ»…ä¹‹é¾å³å°‡ä½¿å‡ºç ´å£æ­»å…‰! 3', start:now, fadeStart:now+2600, end:now+3000, style:'elegant'};
    }else if(type==='annihilation'){
      const L=layout();
      const tag=`annihilation_${now}`;
      const rowY=L.top + brickH + L.pad*0.5;
      const challengeBricks=[];
      for(let c=0;c<L.cols;c++){
        const x=L.pad + c*(brickW+L.pad);
        addBrick(bricks, x, rowY, brickW, brickH, {hp:1, colorIdx:c%4, annihilationTag:tag});
        challengeBricks.push(brickIdCounter-1);
      }
      updateHUD();
      dragonBoss.moveTarget=null;
      dragonAttackState={
        type:'annihilation',
        startedAt:now,
        phase:'challenge',
        overrideMovement:true,
        countdownEnd:now+10000,
        bricksTag:tag,
        challengeBricks,
        targetY:Math.max(L.top-240, dragonBoss.baseY-220),
        returnY:dragonBoss.baseY,
        explosionEnd:0,
        hideDragon:false
      };
      dragonBoss.pose=null;
      dragonMarquee={text:'å±éšªï¼ æ¯€æ»…ä¹‹é¾å³å°‡ä½¿å‡ºè¬ç‰©éŠ·æ¯€!', start:now, fadeStart:now+9000, end:now+10000, style:'elegant'};
      showPrompt('è«‹æ–¼10secå…§æ“Šæ¯€æ‰€æœ‰ç£šå¡Šé˜»æ­¢è¬ç‰©éŠ·æ¯€');
    }
    dragonNextAttackAt=0;
  }

  function updateDragonAttackState(now, dt){
    if(!dragonAttackState){
      maybeStartDragonAttack(now);
      return false;
    }
    const state=dragonAttackState;
    if(state.type==='petrify'){
      return false;
    }
    if(state.type==='deathRay'){
      const travelDuration = state.beamTravel || 900;
      const fadeDuration = state.beamFade || 320;
      const speed=Math.min(0.28, (dt/1000)*0.9);
      const tx=state.targetX||dragonBoss.x;
      const ty=state.targetY||dragonBoss.baseY;
      dragonBoss.x += (tx - dragonBoss.x)*speed;
      dragonBoss.baseY += (ty - dragonBoss.baseY)*speed;

      for(const orb of dragonDeathRayOrbs){
        if(!orb.angle){ orb.angle=Math.random()*Math.PI*2; }
        const rot=0.0024*dt;
        orb.angle += rot;
        const radius=orb.radius||(110+Math.random()*40);
        orb.radius=radius;
        const verticalScale=orb.vertScale||0.55+Math.random()*0.25;
        orb.vertScale=verticalScale;
        orb.x = dragonBoss.x + Math.cos(orb.angle)*radius;
        orb.y = dragonBoss.y - 40 + Math.sin(orb.angle)*radius*verticalScale;
      }

      if(state.phase==='countdown'){
        if(now>=state.nextOrb){
          state.nextOrb=now+500;
          dragonDeathRayOrbs.push({createdAt:now});
        }
        if(state.countdownValue>1 && now>=state.nextCountdownTick){
          state.countdownValue--;
          state.nextCountdownTick+=1000;
          if(dragonMarquee){ dragonMarquee.text=`å±éšªï¼ æ¯€æ»…ä¹‹é¾å³å°‡ä½¿å‡ºç ´å£æ­»å…‰! ${state.countdownValue}`; }
          beep(720+(3-state.countdownValue)*40,0.08,0.05);
        }
        if(now>=state.countdownEnd){
          state.phase='firing';
          state.fireNext=now;
          if(dragonMarquee){
            dragonMarquee.text='ç ´å£æ­»å…‰å•Ÿå‹•ï¼';
            dragonMarquee.start=now;
            dragonMarquee.fadeStart=now+800;
            dragonMarquee.end=now+1400;
          }
        }
      }
      if(state.phase==='firing' && now>=state.fireNext){
        const orb=dragonDeathRayOrbs.shift();
        if(orb){
          const pr=paddleRect();
          let target=state.lockedTarget;
          if(!target || now>=paddleGoneUntil){
            target={x:pr.x+pr.w/2, y:pr.y+pr.h/2};
            state.lockedTarget={...target};
          }
          dragonDeathRayBeams.push({
            x1:orb.x||dragonBoss.x,
            y1:orb.y||dragonBoss.y,
            x2:target.x,
            y2:target.y,
            start:now,
            impactAt:now+travelDuration,
            end:now+travelDuration+fadeDuration,
            hit:false
          });
          state.fireNext=now+500;
        }else{
          state.phase='cooldown';
          state.cooldownUntil=now+800;
        }
      }
      for(const beam of dragonDeathRayBeams){
        if(beam.hit) continue;
        const impactAt=beam.impactAt || beam.end;
        if(now>=impactAt){
          beam.hit=true;
          const targetX=beam.x2;
          const targetY=beam.y2;
          const pr=paddleRect();
          const intersects = pr.w>0 && pr.h>0 && segmentIntersectsRect(beam.x1, beam.y1, targetX, targetY, pr);
          if(intersects){
            spawnParticles(targetX, targetY, '#ffec8a', 36, 2.4, 4.0, 4.0);
            dragonBursts.push({type:'flare',x:targetX,y:targetY,r0:0,r1:280,t0:now,life:900,color:'255,225,150'});
            screenShake=Math.max(screenShake,14);
            playSFX('fireExplosion');
            if(now>=paddleGoneUntil){
              paddleGoneUntil=now+3000;
            }
          }
        }
      }
      if(state.phase==='cooldown' && now>=state.cooldownUntil && !dragonDeathRayBeams.length){
        finishDragonAttack('deathRay');
      }
      return true;
    }
    if(state.type==='annihilation'){
      if(state.phase==='challenge'){
        const speed=Math.min(0.32, (dt/1000)*1.1);
        dragonBoss.x += (550 - dragonBoss.x)*speed;
        dragonBoss.baseY += (state.targetY - dragonBoss.baseY)*speed;
        if(dragonBoss.baseY<=state.targetY+2){ state.hideDragon=true; }
        const remain = bricks.some(b=>b.annihilationTag===state.bricksTag);
        if(!remain){
          state.phase='returning';
          state.hideDragon=false;
          state.returnStart=now;
          if(dragonMarquee){
            dragonMarquee.text='æˆåŠŸé˜»æ­¢è¬ç‰©éŠ·æ¯€!';
            dragonMarquee.start=now;
            dragonMarquee.fadeStart=now+1600;
            dragonMarquee.end=now+2000;
          }
        }else if(now>=state.countdownEnd){
          state.phase='detonate';
          state.detonated=false;
          state.detonateStart=now;
          state.explosionEnd=now+5000;
          state.hideDragon=true;
          dragonMarquee={text:'è¬ç‰©éŠ·æ¯€å•Ÿå‹•!', start:now, fadeStart:now+4200, end:now+5000, style:'alert'};
        }
        return true;
      }
      if(state.phase==='detonate'){
        if(!state.detonated){
          state.detonated=true;
          screenShake=Math.max(screenShake,36);
          playSFX('dragonAnnihilation');
          const nowDet=now;
          for(let i=bricks.length-1;i>=0;i--){
            const b=bricks[i];
            const cx=b.x+b.w/2, cy=b.y+b.h/2;
            spawnParticles(cx, cy, '#ffe7a6', 30, 2.8, 4.0, 4.2);
            dragonBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:280,t0:nowDet,life:1200,color:'255,220,150'});
            bricks.splice(i,1);
          }
          const L=layout();
          const stageHeight=L.rows*(brickH+L.pad) - L.pad;
          const centerX=550;
          const centerY=L.top + stageHeight/2;
          dragonBursts.push({type:'apocalypse',x:centerX,y:centerY,r0:140,r1:960,t0:nowDet,life:2600,color:'255,236,190'});
          dragonBursts.push({type:'shockwave',x:centerX,y:centerY,r0:0,r1:1100,width:46,t0:nowDet,life:2200,color:'255,230,180'});
          const emberParticles=Array.from({length:90},()=>({
            angle:Math.random()*Math.PI*2,
            radius:40+Math.random()*220,
            speed:260+Math.random()*360,
            size:10+Math.random()*18,
            drift:(Math.random()*0.6-0.3)
          }));
          dragonBursts.push({type:'emberRain',x:centerX,y:centerY,t0:nowDet,life:2400,count:emberParticles.length,particles:emberParticles});
          const aftershockDelays=[0,200,420,660,900];
          aftershockDelays.forEach((delay, idx)=>{
            setTimeout(()=>{
              screenShake=Math.max(screenShake, Math.max(18, 30 - idx*4));
              if(idx>0){ playSFX('fireExplosion'); }
            }, delay);
          });
          updateHUD();
          paddleGoneUntil=Math.max(paddleGoneUntil, now+5500);
        }
        if(now>=state.explosionEnd){
          state.phase='returning';
          state.hideDragon=false;
          dragonBoss.baseY=state.targetY;
          dragonBoss.y=state.targetY;
          dragonBoss.x=550;
        }
        return true;
      }
      if(state.phase==='returning'){
        const speed=Math.min(0.26, (dt/1000)*0.9);
        dragonBoss.x += (550 - dragonBoss.x)*speed;
        dragonBoss.baseY += (state.returnY - dragonBoss.baseY)*speed;
        if(Math.abs(dragonBoss.baseY-state.returnY)<2 && Math.abs(dragonBoss.x-550)<3){
          finishDragonAttack('annihilation');
        }
        return true;
      }
      return true;
    }
    return false;
  }

  function spawnDemonBeam(){
    const bc=bossCenter(); if(!bc) return;
    bossChargeColor='255,60,80'; bossChargeUntil=performance.now()+2000;
    setTimeout(()=>{
      const pr=paddleRect(); const tx=pr.x+pr.w/2, ty=pr.y+pr.h/2;
      const ang=Math.atan2(ty-bc.y, tx-bc.x); const speed=7.2;
      hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'red', hit:false, onHit:()=>{ lives=Math.max(0, lives-1); updateHUD(); screenShake=Math.max(screenShake,12); }});
      beep(600,0.14,0.09);
    },2000);
  }
  function spawnDemonClouds(){
    showPrompt('å“ˆå“ˆå“ˆ! æ¥å—æƒ¡é­”çš„è©›å’’å§!');
    const picks = Array.from({length:5}, ()=> 40 + Math.random()*(1100-80));
    const y = layout().top - 10;
    const tEnd = performance.now() + 1000;
    for(const x of picks){ hazardClouds.push({x,y,tEnd,spawned:false}); }
  }
  function noteCyclopsFirstAttack(at){
    if(level!==15 || cyclopsFirstAttackAt) return;
    cyclopsFirstAttackAt = at;
    cyclopsMarqueeShown=false;
    cyclopsEventStarted=false;
    cyclopsEventComplete=false;
    cyclopsForcedPetrifyAt=0;
    cyclopsForcedPetrifyFired=false;
    cyclopsRowBlastIndex=-1;
    cyclopsNextRowBlast=0;
    cyclopsShellBurst=false;
  }
  function updateCyclopsEvent(){
    if(level!==15 || !cyclopsFirstAttackAt || cyclopsEventComplete) return;
    const now=performance.now();
    const triggerAt = cyclopsFirstAttackAt + 5000;
    if(now>=triggerAt){
      if(!cyclopsMarqueeShown){
        showComboNotice('ç«Ÿç„¶å¦„æƒ³è¸å…¥ç¥ä¹‹é ˜åŸŸå—? çœŸæ˜¯æ„šè ¢çš„äººé¡!',5000,3000);
        cyclopsMarqueeShown=true;
      }
      if(!cyclopsEventStarted){
        cyclopsEventStarted=true;
        const L=layout();
        cyclopsRowBlastIndex=L.rows-1;
        cyclopsNextRowBlast=now;
      }
    }
    if(cyclopsEventStarted){
      screenShake=Math.max(screenShake,20);
      if(cyclopsRowBlastIndex>=0 && now>=cyclopsNextRowBlast){
        cyclopsBlastRow(cyclopsRowBlastIndex);
        cyclopsRowBlastIndex--;
        cyclopsNextRowBlast=now+500;
      }
      if(cyclopsRowBlastIndex<0){
        cyclopsEventStarted=false;
        cyclopsEventComplete=true;
      }
    }
  }

  function prepareDemonRows(){
    const L=layout();
    const spacing = brickH + L.pad;
    const rowsMap=new Map();
    for(const b of bricks){
      if(b.demonShell) continue;
      if(b.fallingTreasure) continue;
      const row=Math.round((b.y - L.top)/spacing);
      if(!rowsMap.has(row)) rowsMap.set(row, []);
      rowsMap.get(row).push(b);
    }
    demonEventRows = Array.from(rowsMap.entries())
      .sort((a,b)=>b[0]-a[0])
      .map(([,arr])=>{
        const copy=arr.slice();
        for(let i=copy.length-1;i>0;i--){
          const j=Math.floor(Math.random()*(i+1));
          [copy[i], copy[j]]=[copy[j], copy[i]];
        }
        return copy;
      });
    demonEventTargets = demonEventRows.reduce((sum,row)=>sum+row.length,0);
    demonEventCleared=0;
  }

  function dropDemonRow(row, now){
    if(!Array.isArray(row)) return;
    const debris=[];
    for(const brick of row){
      const idx=bricks.indexOf(brick);
      if(idx>=0){
        revealBrickArea(brick);
        bricks.splice(idx,1);
      }
      demonEventCleared++;
      const baseColor = brick.treasure ? '#ffd166' : brick.boss ? '#ff4d6d' : brick.unbreakable ? '#888888' : brick.strong ? '#bb7aff' : brick.moving ? '#6ec6ff' : brick.explosive ? getVar('--expl') : brickColor(brick.colorIdx||0);
      debris.push({
        x:brick.x,
        y:brick.y,
        w:brick.w,
        h:brick.h,
        color:baseColor,
        treasure:!!brick.treasure,
        vx:(Math.random()-0.5)*1.4,
        vy:2.1 + Math.random()*2.0,
        gravity:0.16 + Math.random()*0.07,
        angle:(Math.random()-0.5)*0.25,
        spin:(Math.random()-0.5)*0.06
      });
    }
    if(debris.length){
      demonFallingDebris.push(...debris);
      screenShake=Math.max(screenShake,16);
    }
    if(row){ row.length=0; }
  }

  function startDemonEvent(now){
    if(demonEventPhase!=='awaiting') return;
    demonEventPhase='collapse';
    demonPhase='event';
    demonEventTriggeredAt=now;
    const shell=demonShellBrick;
    const cx=shell? shell.x + shell.w/2 : 1100/2;
    const cy=shell? shell.y + shell.h/2 : layout().top;
    demonEventMarquee={
      text:'è·ªä¼æ–¼æˆ‘çš„åŠ›é‡ä¹‹ä¸‹å§!',
      start:now,
      fadeStart:now+5000,
      end:now+8000,
      style:'elegant'
    };
    demonEventWave={x:cx, y:cy, start:now, duration:2000, maxRadius:Math.hypot(1100,700)};
    demonEventShakeUntil = now + 7000;
    prepareDemonRows();
    demonEventNextRowAt=now;
    if(demonEventTargets===0){
      explodeDemonShell(now);
      return;
    }
    screenShake=Math.max(screenShake,26);
  }

  function explodeDemonShell(now){
    if(!demonShellBrick) return;
    const shell=demonShellBrick;
    const idx=bricks.indexOf(shell);
    if(idx>=0) bricks.splice(idx,1);
    const cx=shell.x + shell.w/2;
    const cy=shell.y + shell.h/2;
    spawnParticles(cx,cy,'#fff5d6',120,3.2,5.0,5.5);
    spawnParticles(cx,cy,'#8a6bff',90,2.6,4.2,4.6);
    spawnParticles(cx,cy,'#d476ff',70,2.3,3.8,4.2);
    demonEventWave={x:cx,y:cy,start:now,duration:2600,maxRadius:Math.hypot(1100,700)};
    demonCore={x:cx,y:cy,start:now,visibleUntil:now+4000};
    screenShake=Math.max(screenShake,22);
    demonShellBrick=null;
    demonEventPhase='revealed';
    demonPhase='intro';
    demonRevealScheduled=now+1400;
    demonAfterimages=[];
  }

  function updateDemonEvent(now){
    if(level!==20){
      return;
    }
    if(demonEventPhase==='awaiting'){
      if(running && !paused && !resumePending){
        if(!demonEventTimerStart){
          demonEventTimerStart=now;
        }else if(now - demonEventTimerStart >= 10000){
          startDemonEvent(now);
        }
      }
    }else if(demonEventPhase==='collapse'){
      if(demonEventRows.length && now>=demonEventNextRowAt){
        const row=demonEventRows.shift();
        dropDemonRow(row, now);
        demonEventNextRowAt = now + 1000;
      }
      if(demonEventTargets>0 && demonEventCleared>=demonEventTargets){
        explodeDemonShell(now);
      }
    }else if(demonEventPhase==='revealed'){
      if(demonCore && now>=demonCore.visibleUntil){
        demonCore=null;
        demonEventPhase='complete';
      }
    }

    if(demonEventMarquee && now>=demonEventMarquee.end){
      demonEventMarquee=null;
    }
    if(demonEventWave && now>=demonEventWave.start + demonEventWave.duration){
      demonEventWave=null;
    }
    if(demonEventShakeUntil && now<demonEventShakeUntil){
      screenShake=Math.max(screenShake,18);
    }
  }

  function drawDemonMarquee(now){
    if(level!==20 || !demonEventMarquee) return;
    const evt=demonEventMarquee;
    if(now<evt.start) return;
    if(now>=evt.end){
      demonEventMarquee=null;
      return;
    }
    let alpha=1;
    if(evt.fadeStart && now>evt.fadeStart){
      const span=Math.max(1, evt.end - evt.fadeStart);
      alpha=Math.max(0, 1 - (now - evt.fadeStart)/span);
    }
    if(alpha<=0) return;
    const L=layout();
    const areaHeight=60;
    const top=Math.max(16, L.top - areaHeight - 14);
    const width=Math.min(560, 1100-120);
    const x=(1100-width)/2;
    const radius=20;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, top, width, areaHeight, radius);
    const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
    grad.addColorStop(0,'rgba(48,22,10,0.9)');
    grad.addColorStop(1,'rgba(28,12,6,0.88)');
    ctx.fillStyle=grad;
    ctx.fill();
    ctx.strokeStyle='rgba(255,210,150,0.85)';
    ctx.lineWidth=2.4;
    drawRoundedRect(x, top, width, areaHeight, radius);
    ctx.stroke();
    const innerX=x+10;
    const innerY=top+6;
    const innerW=width-20;
    const innerH=areaHeight-12;
    ctx.save();
    drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
    const innerGrad=ctx.createLinearGradient(innerX*scaleX, innerY*scaleY, innerX*scaleX, (innerY+innerH)*scaleY);
    innerGrad.addColorStop(0,'rgba(140,70,30,0.45)');
    innerGrad.addColorStop(1,'rgba(80,34,14,0.35)');
    ctx.fillStyle=innerGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(255,220,180,0.45)';
    ctx.lineWidth=1.4;
    ctx.stroke();
    ctx.restore();
    ctx.save();
    drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
    ctx.clip();
    ctx.fillStyle='#ffeedd';
    const fontSize=Math.max(20, Math.round(26*((scaleX+scaleY)/2)));
    ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.shadowColor='rgba(255,150,110,0.55)';
    ctx.shadowBlur=14*((scaleX+scaleY)/2);
    ctx.fillText(evt.text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
    ctx.restore();
  }


  function renderDemonFigure(entity, now, opts={}){
    if(!entity) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const baseSize=entity.h||entity.w||150;
    const size=baseSize/150;
    let alpha = opts.alpha!=null ? opts.alpha : 1;
    if(entity.deathFade!=null) alpha*=entity.deathFade;
    if(alpha<=0) return;
    ctx.save();
    ctx.translate(entity.x*scaleX, entity.y*scaleY);
    ctx.scale(scaleAvg*size, scaleAvg*size);
    const ghostMul = opts.ghost ? 0.65 : 1;
    ctx.globalAlpha *= Math.max(0, Math.min(1, alpha*ghostMul));

    const flash = entity.hitFlashUntil && now<entity.hitFlashUntil;
    const hoverPhase = entity.hoverPhase||0;
    const whipActive = entity.cloakWhipUntil && now<entity.cloakWhipUntil;
    let whipStrength=0;
    let whipDir=entity.cloakWhipDir||1;
    if(whipActive){
      const duration=Math.max(1, (entity.cloakWhipDuration||360));
      const start=entity.cloakWhipStart|| (entity.cloakWhipUntil-duration);
      const total=Math.max(1, entity.cloakWhipUntil-start);
      const phase=Math.max(0, Math.min(1, 1-((entity.cloakWhipUntil-now)/total)));
      whipStrength=(entity.cloakWhipStrength||1)*Math.sin(phase*Math.PI);
    }

    const palette={
      metalDark: flash ? 'rgba(238,234,242,0.96)' : 'rgba(24,26,34,0.96)',
      metalMid: flash ? 'rgba(255,250,252,0.92)' : 'rgba(46,48,62,0.92)',
      metalEdge: flash ? 'rgba(255,255,255,0.86)' : 'rgba(134,138,166,0.75)',
      accent: flash ? 'rgba(255,200,160,0.95)' : 'rgba(210,70,40,0.92)',
      glowCore: flash ? 'rgba(255,220,210,0.85)' : 'rgba(255,90,50,0.8)',
      glowOuter: flash ? 'rgba(255,220,220,0.45)' : 'rgba(160,20,30,0.38)',
      horn: flash ? 'rgba(220,210,240,0.92)' : 'rgba(44,42,62,0.92)',
      visor: flash ? 'rgba(255,248,246,0.9)' : 'rgba(18,18,24,0.88)',
      eye: flash ? 'rgba(255,150,110,0.95)' : 'rgba(255,50,40,0.95)'
    };
    const bodyStretch=1.3;

    // ground shadow
    ctx.save();
    ctx.globalAlpha*=0.32;
    ctx.fillStyle='rgba(0,0,0,0.6)';
    ctx.scale(1,0.34);
    ctx.beginPath();
    ctx.ellipse(0,240,72,30,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // aura glow
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const auraPulse = 0.55 + 0.25*Math.sin(now/240 + hoverPhase*0.7);
    ctx.globalAlpha*=0.55 + auraPulse*0.25;
    const aura=ctx.createRadialGradient(0,20,18,0,20,190);
    aura.addColorStop(0,palette.glowCore);
    aura.addColorStop(0.45,palette.glowOuter);
    aura.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=aura;
    ctx.beginPath();
    ctx.ellipse(0,30,120,140,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // tattered cloak with long flowing hem (only below the pauldrons)
    ctx.save();
    ctx.translate(0,-12);
    const cloakPhase=entity.cloakPhase||0;
    const baseCloakSway = entity.cloakSway!=null ? entity.cloakSway : 0.18;
    const cloakSwayStrength = baseCloakSway + (whipStrength?0.35*whipStrength:0);
    const hoverLift = Math.sin(hoverPhase*0.7)*4;
    const whipSwing=whipStrength?whipDir*(32+60*cloakSwayStrength)*whipStrength:0;
    const anchorLift = Math.sin(cloakPhase*0.5 + hoverPhase*0.45)*6*cloakSwayStrength + whipStrength*10;
    const swayLeft = Math.sin(cloakPhase - whipStrength*0.4)* (16 + 34*cloakSwayStrength) - whipSwing;
    const swayRight = Math.sin(cloakPhase + Math.PI*0.65 + whipStrength*0.4)* (18 + 36*cloakSwayStrength) + whipSwing;
    const ragAmplitude = 26 + 48*cloakSwayStrength + (whipStrength?38*whipStrength:0);
    const hemBase = 288 + hoverLift*0.25;
    const hemDrift = (t)=>Math.sin(cloakPhase + t*Math.PI*1.9 + hoverPhase*0.5)*ragAmplitude;
    const ragJut = (i)=> (i%2===0 ? -ragAmplitude*0.85 : ragAmplitude*0.3);
    const cloak=ctx.createLinearGradient(0,-40,0,320);
    cloak.addColorStop(0, flash ? 'rgba(255,220,220,0.5)' : 'rgba(96,8,18,0.96)');
    cloak.addColorStop(0.38, flash ? 'rgba(255,200,200,0.42)' : 'rgba(140,0,18,0.94)');
    cloak.addColorStop(1, flash ? 'rgba(255,188,188,0.34)' : 'rgba(56,0,8,0.88)');
    ctx.beginPath();
    ctx.moveTo(-118,36 + anchorLift + hoverLift*0.3);
    ctx.bezierCurveTo(-198,96 - swayLeft*0.4, -218,212 + hoverLift*0.25, -202, hemBase - ragAmplitude*0.45);
    const segments=12;
    for(let i=0;i<=segments;i++){
      const t=i/segments;
      const x=-202 + (404*t) + Math.sin(cloakPhase*0.8 + t*Math.PI*2.1)*18*cloakSwayStrength;
      const wave=hemDrift(t);
      const jag = (i===0||i===segments) ? -ragAmplitude*0.4 : ragJut(i);
      ctx.lineTo(x, hemBase + wave + jag);
    }
    ctx.bezierCurveTo(218,212 + hoverLift*0.25, 198,96 - swayRight*0.4, 118,36 + anchorLift + hoverLift*0.3);
    ctx.quadraticCurveTo(56,18 + swayRight*0.12, 42,74 + anchorLift*0.15);
    ctx.quadraticCurveTo(0,24, -42,74 + anchorLift*0.15);
    ctx.quadraticCurveTo(-56,18 + swayLeft*0.12, -118,36 + anchorLift + hoverLift*0.3);
    ctx.closePath();
    ctx.fillStyle=cloak;
    ctx.fill();
    ctx.strokeStyle=flash ? 'rgba(255,226,220,0.56)' : 'rgba(54,0,8,0.7)';
    ctx.lineWidth=3.6;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=flash ? 'rgba(255,230,224,0.62)' : 'rgba(200,40,40,0.44)';
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(-56,18 + anchorLift*0.3 + hoverLift*0.2);
    ctx.quadraticCurveTo(-42,138 + swayLeft*0.08,-32,hemBase-18 + swayLeft*0.05);
    ctx.moveTo(56,18 + anchorLift*0.3 + hoverLift*0.2);
    ctx.quadraticCurveTo(42,138 + swayRight*0.08,32,hemBase-18 + swayRight*0.05);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0,12 + anchorLift*0.2 + hoverLift*0.2);
    ctx.quadraticCurveTo(-4,144 + (swayLeft+swayRight)*0.04,0,hemBase-12 + (swayLeft+swayRight)*0.04);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // lower tabard, battle skirt and waist armour
    ctx.save();
    ctx.translate(0,62);
    ctx.scale(1, bodyStretch);
    const tabard=ctx.createLinearGradient(0,-44,0,156);
    tabard.addColorStop(0, flash ? 'rgba(255,232,232,0.84)' : 'rgba(80,20,32,0.9)');
    tabard.addColorStop(0.5, flash ? 'rgba(255,214,214,0.76)' : 'rgba(46,12,20,0.82)');
    tabard.addColorStop(1, flash ? 'rgba(255,206,206,0.68)' : 'rgba(26,6,12,0.7)');
    ctx.fillStyle=tabard;
    ctx.beginPath();
    ctx.moveTo(-36,-10);
    ctx.quadraticCurveTo(-10,-92,0,-98);
    ctx.quadraticCurveTo(10,-92,36,-10);
    ctx.quadraticCurveTo(22,188,0,208);
    ctx.quadraticCurveTo(-22,188,-36,-10);
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth=2.4;
    ctx.strokeStyle=palette.metalEdge;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(0,-44);
    ctx.lineTo(0,182);
    ctx.stroke();
    ctx.restore();

    const innerPlates=ctx.createLinearGradient(0,-20,0,146);
    innerPlates.addColorStop(0, flash ? 'rgba(255,226,226,0.72)' : 'rgba(96,30,44,0.86)');
    innerPlates.addColorStop(1, flash ? 'rgba(255,210,210,0.62)' : 'rgba(52,14,24,0.78)');
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(12,-24);
      ctx.quadraticCurveTo(54,-80,62,-14);
      ctx.quadraticCurveTo(48,122,16,188);
      ctx.lineTo(-4,122);
      ctx.closePath();
      ctx.fillStyle=innerPlates;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2;
      ctx.stroke();
      ctx.restore();
    }

    const skirtPanel=ctx.createLinearGradient(-110,-20,-10,160);
    skirtPanel.addColorStop(0, flash ? 'rgba(255,224,224,0.82)' : 'rgba(66,16,24,0.86)');
    skirtPanel.addColorStop(1, flash ? 'rgba(255,204,204,0.62)' : 'rgba(28,8,14,0.72)');
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(30,-6);
      ctx.quadraticCurveTo(102,-84,118,12);
      ctx.quadraticCurveTo(110,188,38,214);
      ctx.quadraticCurveTo(22,112,30,-6);
      ctx.closePath();
      ctx.fillStyle=skirtPanel;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.2;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=1.8;
      ctx.beginPath();
      ctx.moveTo(52,18);
      ctx.quadraticCurveTo(84,112,46,198);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    const waist=ctx.createLinearGradient(-70,-48,70,66);
    waist.addColorStop(0,palette.metalMid);
    waist.addColorStop(1,palette.metalDark);
    ctx.fillStyle=waist;
    ctx.beginPath();
    ctx.moveTo(-88,-22);
    ctx.quadraticCurveTo(0,-86,88,-22);
    ctx.lineTo(68,68);
    ctx.quadraticCurveTo(0,98,-68,68);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(-52,-8);
    ctx.quadraticCurveTo(0,-44,52,-8);
    ctx.moveTo(-48,38);
    ctx.quadraticCurveTo(0,70,48,38);
    ctx.stroke();
    ctx.restore();

    const waistPlates=ctx.createLinearGradient(-50,-18,50,80);
    waistPlates.addColorStop(0,palette.metalDark);
    waistPlates.addColorStop(1,palette.metalMid);
    ctx.fillStyle=waistPlates;
    ctx.beginPath();
    ctx.moveTo(-58,-10);
    ctx.quadraticCurveTo(-18,-58,-6,-32);
    ctx.lineTo(-10,62);
    ctx.quadraticCurveTo(-36,70,-52,36);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=1.8;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(58,-10);
    ctx.quadraticCurveTo(18,-58,6,-32);
    ctx.lineTo(10,62);
    ctx.quadraticCurveTo(36,70,52,36);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    const layeredSkirt=ctx.createLinearGradient(-20,-12,-20,200);
    layeredSkirt.addColorStop(0, flash ? 'rgba(255,230,220,0.82)' : 'rgba(70,18,26,0.92)');
    layeredSkirt.addColorStop(1, flash ? 'rgba(255,206,198,0.7)' : 'rgba(32,8,12,0.78)');
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(34,0);
      ctx.quadraticCurveTo(92,-48,122,30);
      ctx.quadraticCurveTo(112,196,40,216);
      ctx.quadraticCurveTo(24,128,34,0);
      ctx.closePath();
      ctx.fillStyle=layeredSkirt;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=1.6;
      ctx.beginPath();
      ctx.moveTo(52,28);
      ctx.quadraticCurveTo(86,132,44,204);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    const frontSkirt=ctx.createLinearGradient(0,-18,0,210);
    frontSkirt.addColorStop(0, flash ? 'rgba(255,224,214,0.84)' : 'rgba(78,18,26,0.92)');
    frontSkirt.addColorStop(1, flash ? 'rgba(255,200,188,0.68)' : 'rgba(34,10,14,0.78)');
    ctx.beginPath();
    ctx.moveTo(-42,12);
    ctx.quadraticCurveTo(-12,-68,0,-82);
    ctx.quadraticCurveTo(12,-68,42,12);
    ctx.quadraticCurveTo(26,188,0,214);
    ctx.quadraticCurveTo(-26,188,-42,12);
    ctx.closePath();
    ctx.fillStyle=frontSkirt;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.2;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(0,-26);
    ctx.lineTo(0,198);
    ctx.moveTo(-18,64);
    ctx.lineTo(18,64);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // legs, greaves and sabatons
    ctx.save();
    ctx.translate(0,102);
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      const thigh=ctx.createLinearGradient(12,-70,78,160);
      thigh.addColorStop(0,palette.metalMid);
      thigh.addColorStop(1,palette.metalDark);
      ctx.beginPath();
      ctx.moveTo(20,-52);
      ctx.quadraticCurveTo(58,-28,54,38);
      ctx.quadraticCurveTo(46,112,18,142);
      ctx.quadraticCurveTo(6,52,10,-12);
      ctx.closePath();
      ctx.fillStyle=thigh;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.6;
      ctx.stroke();

      const shin=ctx.createLinearGradient(14,-10,74,210);
      shin.addColorStop(0,palette.metalMid);
      shin.addColorStop(1,'rgba(26,26,40,0.92)');
      ctx.beginPath();
      ctx.moveTo(18,18);
      ctx.quadraticCurveTo(60,72,56,156);
      ctx.quadraticCurveTo(42,214,12,204);
      ctx.quadraticCurveTo(0,148,10,36);
      ctx.closePath();
      ctx.fillStyle=shin;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      const sabaton=ctx.createLinearGradient(12,120,76,220);
      sabaton.addColorStop(0,'rgba(34,34,48,0.95)');
      sabaton.addColorStop(1,'rgba(8,8,14,0.92)');
      ctx.beginPath();
      ctx.moveTo(18,154);
      ctx.quadraticCurveTo(66,182,68,210);
      ctx.quadraticCurveTo(46,226,12,214);
      ctx.quadraticCurveTo(0,188,6,164);
      ctx.closePath();
      ctx.fillStyle=sabaton;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(34,-20);
      ctx.quadraticCurveTo(48,72,28,152);
      ctx.moveTo(28,96);
      ctx.quadraticCurveTo(40,138,26,186);
      ctx.stroke();
      ctx.restore();

      ctx.beginPath();
      ctx.moveTo(14,174);
      ctx.quadraticCurveTo(40,188,16,208);
      ctx.strokeStyle=flash ? 'rgba(255,204,170,0.75)' : 'rgba(86,24,20,0.68)';
      ctx.lineWidth=1.6;
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();

    // torso armour layers
    ctx.save();
    ctx.translate(0,-16);
    const chest=ctx.createLinearGradient(-74,-162,74,148);
    chest.addColorStop(0,palette.metalMid);
    chest.addColorStop(1,palette.metalDark);
    ctx.fillStyle=chest;
    ctx.beginPath();
    ctx.moveTo(-64,-68);
    ctx.quadraticCurveTo(0,-136,64,-68);
    ctx.lineTo(82,48);
    ctx.quadraticCurveTo(0,96,-82,48);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const breastplate=ctx.createLinearGradient(-56,-118,56,80);
    breastplate.addColorStop(0,palette.metalDark);
    breastplate.addColorStop(1,palette.metalMid);
    ctx.fillStyle=breastplate;
    ctx.beginPath();
    ctx.moveTo(-48,-46);
    ctx.quadraticCurveTo(-12,-106,0,-112);
    ctx.quadraticCurveTo(12,-106,48,-46);
    ctx.lineTo(40,54);
    ctx.quadraticCurveTo(0,84,-40,54);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.8;
    ctx.stroke();

    const chestCrest=ctx.createLinearGradient(-40,-80,40,32);
    chestCrest.addColorStop(0,palette.metalMid);
    chestCrest.addColorStop(1,palette.metalDark);
    ctx.fillStyle=chestCrest;
    ctx.beginPath();
    ctx.moveTo(-34,-26);
    ctx.quadraticCurveTo(0,-68,34,-26);
    ctx.quadraticCurveTo(18,40,0,64);
    ctx.quadraticCurveTo(-18,40,-34,-26);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const abdomen=ctx.createLinearGradient(-32,-26,32,104);
    abdomen.addColorStop(0,palette.metalMid);
    abdomen.addColorStop(1,palette.metalDark);
    ctx.fillStyle=abdomen;
    ctx.beginPath();
    ctx.moveTo(-30,-6);
    ctx.lineTo(30,-6);
    ctx.quadraticCurveTo(20,84,0,106);
    ctx.quadraticCurveTo(-20,84,-30,-6);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const waistExtension=ctx.createLinearGradient(-38,18,38,160);
    waistExtension.addColorStop(0,palette.metalDark);
    waistExtension.addColorStop(1,palette.metalMid);
    ctx.fillStyle=waistExtension;
    ctx.beginPath();
    ctx.moveTo(-38,32);
    ctx.lineTo(38,32);
    ctx.quadraticCurveTo(26,138,0,158);
    ctx.quadraticCurveTo(-26,138,-38,32);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=2.4;
    ctx.beginPath();
    ctx.moveTo(0,-52);
    ctx.lineTo(0,138);
    ctx.moveTo(-18,34);
    ctx.lineTo(18,34);
    ctx.moveTo(-16,-4);
    ctx.lineTo(16,-4);
    ctx.moveTo(-16,96);
    ctx.lineTo(16,96);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // left arm assembly with shortened proportions
    ctx.save();
    ctx.translate(0,-18);
    const leftArmSwing=Math.sin(now/340 + hoverPhase*0.65);

    ctx.save();
    ctx.translate(-96,36);
    ctx.rotate(-0.12 + Math.sin(hoverPhase*0.6)*0.04);
    ctx.scale(0.9,0.6);
    const leftUpper=ctx.createLinearGradient(-34,-28,44,140);
    leftUpper.addColorStop(0,palette.metalMid);
    leftUpper.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-18,-26);
    ctx.quadraticCurveTo(-58,10,-44,96);
    ctx.quadraticCurveTo(-18,146,12,140);
    ctx.quadraticCurveTo(-4,68,-6,-20);
    ctx.closePath();
    ctx.fillStyle=leftUpper;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-26,-4);
    ctx.lineTo(-12,86);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.translate(-24,112);
    ctx.rotate(-0.18 + Math.sin(now/260 + hoverPhase)*0.06 + leftArmSwing*0.02);
    const leftFore=ctx.createLinearGradient(-32,-20,36,140);
    leftFore.addColorStop(0,palette.metalMid);
    leftFore.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-16,-14);
    ctx.quadraticCurveTo(-46,18,-32,78);
    ctx.quadraticCurveTo(0,114,22,98);
    ctx.quadraticCurveTo(6,20,-16,-14);
    ctx.closePath();
    ctx.fillStyle=leftFore;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(-10,14);
    ctx.lineTo(-6,74);
    ctx.stroke();
    ctx.restore();

    ctx.beginPath();
    ctx.moveTo(-22,78);
    ctx.quadraticCurveTo(-36,108,-10,120);
    ctx.quadraticCurveTo(6,104,-2,84);
    ctx.closePath();
    ctx.fillStyle=flash ? 'rgba(255,222,212,0.9)' : 'rgba(48,22,26,0.9)';
    ctx.fill();
    ctx.restore();
    ctx.restore();

    // left shoulder armour layers (rendered above the arm connection)
    ctx.save();
    ctx.translate(0,-18);
    const leftShoulderBase=ctx.createLinearGradient(-162,-72,-36,124);
    leftShoulderBase.addColorStop(0,palette.metalMid);
    leftShoulderBase.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-82,-18);
    ctx.quadraticCurveTo(-160,-108,-172,12);
    ctx.quadraticCurveTo(-148,112,-90,104);
    ctx.quadraticCurveTo(-70,30,-82,-18);
    ctx.closePath();
    ctx.fillStyle=leftShoulderBase;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const leftShoulderMid=ctx.createLinearGradient(-148,-36,-60,96);
    leftShoulderMid.addColorStop(0,palette.metalDark);
    leftShoulderMid.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(-78,-2);
    ctx.quadraticCurveTo(-128,-48,-134,20);
    ctx.quadraticCurveTo(-118,104,-84,94);
    ctx.closePath();
    ctx.fillStyle=leftShoulderMid;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const leftShoulderRidge=ctx.createLinearGradient(-120,-12,-70,60);
    leftShoulderRidge.addColorStop(0,palette.metalMid);
    leftShoulderRidge.addColorStop(1,palette.metalEdge);
    ctx.beginPath();
    ctx.moveTo(-86,18);
    ctx.quadraticCurveTo(-120,-18,-120,28);
    ctx.quadraticCurveTo(-110,88,-92,82);
    ctx.closePath();
    ctx.fillStyle=leftShoulderRidge;
    ctx.fill();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-110,8);
    ctx.quadraticCurveTo(-98,72,-88,86);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // right arm assembly with shortened proportions
    ctx.save();
    ctx.translate(0,-18);
    const rightArmSwing=Math.sin(now/320 + hoverPhase*0.8);

    ctx.save();
    ctx.translate(96,36);
    ctx.rotate(0.14 + rightArmSwing*0.06);
    ctx.scale(0.9,0.6);
    const upper=ctx.createLinearGradient(-28,-26,42,140);
    upper.addColorStop(0,palette.metalMid);
    upper.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-14,-26);
    ctx.quadraticCurveTo(44,6,34,102);
    ctx.quadraticCurveTo(10,150,-18,144);
    ctx.quadraticCurveTo(-30,62,-18,-18);
    ctx.closePath();
    ctx.fillStyle=upper;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-2,-4);
    ctx.lineTo(10,86);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.translate(24,118);
    ctx.rotate(0.26 + rightArmSwing*0.1);
    const fore=ctx.createLinearGradient(-30,-18,38,150);
    fore.addColorStop(0,palette.metalMid);
    fore.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-12,-18);
    ctx.quadraticCurveTo(36,16,30,96);
    ctx.quadraticCurveTo(10,126,-16,120);
    ctx.quadraticCurveTo(-32,48,-12,-18);
    ctx.closePath();
    ctx.fillStyle=fore;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    const gauntlet=ctx.createLinearGradient(-18,32,28,120);
    gauntlet.addColorStop(0,palette.metalDark);
    gauntlet.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(-14,40);
    ctx.lineTo(22,40);
    ctx.quadraticCurveTo(26,76,2,96);
    ctx.quadraticCurveTo(-20,78,-14,40);
    ctx.closePath();
    ctx.fillStyle=gauntlet;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.2;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(0,8);
    ctx.lineTo(12,70);
    ctx.stroke();
    ctx.restore();

    ctx.beginPath();
    ctx.moveTo(-4,86);
    ctx.quadraticCurveTo(18,124,30,104);
    ctx.quadraticCurveTo(16,78,6,74);
    ctx.closePath();
    ctx.fillStyle=flash ? 'rgba(255,226,212,0.88)' : 'rgba(54,24,30,0.88)';
    ctx.fill();
    ctx.restore();
    ctx.restore();

    // right shoulder armour layers (rendered above the arm connection)
    ctx.save();
    ctx.translate(0,-18);
    const rightShoulderBase=ctx.createLinearGradient(24,-60,180,120);
    rightShoulderBase.addColorStop(0,palette.metalMid);
    rightShoulderBase.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(68,-12);
    ctx.quadraticCurveTo(150,-94,168,12);
    ctx.quadraticCurveTo(140,116,86,104);
    ctx.quadraticCurveTo(66,36,68,-12);
    ctx.closePath();
    ctx.fillStyle=rightShoulderBase;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const rightShoulderMid=ctx.createLinearGradient(54,-32,156,88);
    rightShoulderMid.addColorStop(0,palette.metalDark);
    rightShoulderMid.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(74,2);
    ctx.quadraticCurveTo(128,-46,134,18);
    ctx.quadraticCurveTo(118,108,90,94);
    ctx.closePath();
    ctx.fillStyle=rightShoulderMid;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const rightShoulderRidge=ctx.createLinearGradient(90,-6,128,66);
    rightShoulderRidge.addColorStop(0,palette.metalMid);
    rightShoulderRidge.addColorStop(1,palette.metalEdge);
    ctx.beginPath();
    ctx.moveTo(84,20);
    ctx.quadraticCurveTo(118,-16,116,30);
    ctx.quadraticCurveTo(110,86,94,82);
    ctx.closePath();
    ctx.fillStyle=rightShoulderRidge;
    ctx.fill();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(106,8);
    ctx.quadraticCurveTo(96,70,90,88);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    ctx.restore();
    ctx.restore();
    // chest core glow
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.translate(0,24);
    const core=ctx.createRadialGradient(0,0,4,0,0,30);
    core.addColorStop(0,palette.glowCore);
    core.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=core;
    ctx.beginPath();
    ctx.arc(0,0,24,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // mech helm with angular visor
    ctx.save();
    const headScale=0.7;
    ctx.translate(0,-74);
    ctx.scale(headScale, headScale);
    const helmBase=ctx.createLinearGradient(-48,-90,48,92);
    helmBase.addColorStop(0,palette.metalMid);
    helmBase.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-46,42);
    ctx.lineTo(-30,-12);
    ctx.quadraticCurveTo(-8,-96,0,-104);
    ctx.quadraticCurveTo(8,-96,30,-12);
    ctx.lineTo(46,42);
    ctx.quadraticCurveTo(0,92,-46,42);
    ctx.closePath();
    ctx.fillStyle=helmBase;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3;
    ctx.stroke();

    const helmPlates=ctx.createLinearGradient(-36,-54,36,68);
    helmPlates.addColorStop(0,palette.metalDark);
    helmPlates.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(-34,28);
    ctx.lineTo(-18,-18);
    ctx.quadraticCurveTo(0,-64,18,-18);
    ctx.lineTo(34,28);
    ctx.quadraticCurveTo(0,70,-34,28);
    ctx.closePath();
    ctx.fillStyle=helmPlates;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    const facePlate=ctx.createLinearGradient(-26,-12,26,44);
    facePlate.addColorStop(0,'rgba(20,22,34,0.92)');
    facePlate.addColorStop(1,'rgba(10,12,20,0.9)');
    ctx.beginPath();
    ctx.moveTo(-32,14);
    ctx.lineTo(-14,-24);
    ctx.quadraticCurveTo(0,-44,14,-24);
    ctx.lineTo(32,14);
    ctx.quadraticCurveTo(0,48,-32,14);
    ctx.closePath();
    ctx.fillStyle=facePlate;
    ctx.fill();

    const maskRidge=ctx.createLinearGradient(-16,-32,16,28);
    maskRidge.addColorStop(0,palette.metalMid);
    maskRidge.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-18,-12);
    ctx.quadraticCurveTo(0,-28,18,-12);
    ctx.quadraticCurveTo(10,28,0,38);
    ctx.quadraticCurveTo(-10,28,-18,-12);
    ctx.closePath();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=1.8;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=flash ? 'rgba(255,232,220,0.7)' : 'rgba(210,130,90,0.5)';
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(-16,-6);
    ctx.quadraticCurveTo(0,-22,16,-6);
    ctx.stroke();
    ctx.restore();

    const eyeScale=0.7;
    const eyeBase=28*eyeScale;
    const eyeLength=66*eyeScale;
    const eyeTilt=Math.PI/4;
    ctx.fillStyle=palette.eye;
    ctx.save();
    ctx.translate(-30,-18);
    ctx.rotate(-eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-eyeBase/2,0);
    ctx.lineTo(eyeBase/2,0);
    ctx.lineTo(0,eyeLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.translate(30,-18);
    ctx.rotate(eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-eyeBase/2,0);
    ctx.lineTo(eyeBase/2,0);
    ctx.lineTo(0,eyeLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const eyeGlow=flash ? 'rgba(255,220,210,0.6)' : 'rgba(255,70,40,0.55)';
    ctx.fillStyle=eyeGlow;
    const glowBase=eyeBase*0.6;
    const glowLength=eyeLength*0.6;
    ctx.save();
    ctx.translate(-32,-22);
    ctx.rotate(-eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-glowBase/2,0);
    ctx.lineTo(glowBase/2,0);
    ctx.lineTo(0,glowLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.translate(32,-22);
    ctx.rotate(eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-glowBase/2,0);
    ctx.lineTo(glowBase/2,0);
    ctx.lineTo(0,glowLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=flash ? 'rgba(255,236,226,0.8)' : 'rgba(255,80,60,0.75)';
    ctx.beginPath();
    ctx.moveTo(-4,-42);
    ctx.lineTo(0,-50);
    ctx.lineTo(4,-42);
    ctx.lineTo(4,30);
    ctx.quadraticCurveTo(0,40,-4,30);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    const crest=ctx.createLinearGradient(-12,-72,12,-12);
    crest.addColorStop(0,palette.metalEdge);
    crest.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-12,-58);
    ctx.lineTo(0,-86);
    ctx.lineTo(12,-58);
    ctx.quadraticCurveTo(0,-40,-12,-58);
    ctx.closePath();
    ctx.fillStyle=crest;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=1.6;
    ctx.stroke();

    const antenna=ctx.createLinearGradient(0,-120,0,-20);
    antenna.addColorStop(0,palette.metalDark);
    antenna.addColorStop(1,palette.metalMid);
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(14,-18);
      ctx.lineTo(92,-112);
      ctx.lineTo(54,-12);
      ctx.closePath();
      ctx.fillStyle=antenna;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=1.4;
      ctx.beginPath();
      ctx.moveTo(44,-42);
      ctx.lineTo(70,-94);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }
    ctx.restore();
    ctx.restore();

    ctx.restore();

    ctx.restore();

    ctx.restore();
  }


  function renderDemonAfterimageFigure(state, now, alpha){
    if(!state) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const baseSize=state.h||state.w||150;
    const size=baseSize/150;
    const t0=state.t0||now;
    const elapsed=Math.max(0, now-t0);
    const hoverPhase=state.hoverPhase||0;
    ctx.save();
    ctx.translate(state.x*scaleX, state.y*scaleY);
    ctx.scale(scaleAvg*size, scaleAvg*size);
    ctx.globalAlpha *= alpha;

    const auraPulse = 0.55 + 0.35*Math.sin(elapsed/220 + hoverPhase*0.6);
    ctx.fillStyle = `rgba(190,140,255,${0.22*auraPulse})`;
    ctx.beginPath();
    ctx.ellipse(0,34,92,164,0,0,Math.PI*2);
    ctx.fill();

    const cloakPhase=state.cloakPhase||0;
    const cloakSwayStrength=state.cloakSway!=null?state.cloakSway:0.2;
    const ragAmplitude=10 + 28*cloakSwayStrength;
    const hoverLift=Math.sin(hoverPhase*0.7 + elapsed*0.0012)*3;

    // spectral cloak trail
    ctx.fillStyle=`rgba(220,60,90,${0.14 + 0.06*Math.sin(elapsed/240)})`;
    ctx.strokeStyle=`rgba(255,120,160,${0.12 + 0.04*Math.sin(elapsed/200)})`;
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(-112,-52 + hoverLift*0.4);
    ctx.bezierCurveTo(-174,-6, -182,110 + hoverLift*0.2, -156,212 + hoverLift);
    const hemBase=230 + hoverLift*0.12;
    ctx.lineTo(-156, hemBase + Math.sin(cloakPhase + hoverPhase*0.45)*ragAmplitude - ragAmplitude*0.55);
    for(let i=1;i<8;i++){
      const t=i/8;
      const x=-156 + 312*t;
      const wave=Math.sin(cloakPhase + t*Math.PI*1.6 + hoverPhase*0.45)*ragAmplitude;
      const jag=(i%2===0?-ragAmplitude*0.55:ragAmplitude*0.28);
      ctx.lineTo(x, hemBase + wave + jag);
    }
    ctx.lineTo(156, hemBase + Math.sin(cloakPhase + Math.PI*1.6 + hoverPhase*0.45)*ragAmplitude - ragAmplitude*0.55);
    ctx.bezierCurveTo(182,110 + hoverLift*0.2, 174,-6, 112,-52 + hoverLift*0.4);
    ctx.quadraticCurveTo(36,-126,0,-134);
    ctx.quadraticCurveTo(-36,-126,-112,-52 + hoverLift*0.4);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=`rgba(255,160,200,${0.1 + 0.04*Math.sin(elapsed/180)})`;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-46,-60 + hoverLift*0.3);
    ctx.quadraticCurveTo(-32,36, -18,208 + hoverLift*0.1);
    ctx.moveTo(46,-60 + hoverLift*0.3);
    ctx.quadraticCurveTo(32,36, 18,208 + hoverLift*0.1);
    ctx.moveTo(0,-120 + hoverLift*0.3);
    ctx.quadraticCurveTo(-6,18,0,216 + hoverLift*0.1);
    ctx.stroke();
    ctx.restore();

    // elongated armour silhouette
    ctx.fillStyle='rgba(220,170,255,0.26)';
    ctx.beginPath();
    ctx.moveTo(-30,-28);
    ctx.quadraticCurveTo(0,-118,30,-28);
    ctx.quadraticCurveTo(18,164,0,198);
    ctx.quadraticCurveTo(-18,164,-30,-28);
    ctx.closePath();
    ctx.fill();

    // battle skirt glow
    ctx.beginPath();
    ctx.moveTo(-50,10);
    ctx.quadraticCurveTo(-10,-94,50,10);
    ctx.quadraticCurveTo(28,226,0,262);
    ctx.quadraticCurveTo(-28,226,-50,10);
    ctx.closePath();
    ctx.fillStyle='rgba(210,150,255,0.22)';
    ctx.fill();

    const orbPulse = 1 + 0.18*Math.sin(elapsed/260 + hoverPhase*0.9);
    ctx.save();
    ctx.translate(22,84);
    ctx.scale(orbPulse, orbPulse);
    ctx.fillStyle='rgba(255,220,255,0.26)';
    ctx.beginPath();
    ctx.arc(0,0,26,0,Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(255,200,255,0.35)';
    ctx.lineWidth=3.4;
    ctx.beginPath();
    ctx.arc(0,0,20,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();
    ctx.restore();
  }

  function drawDemonAfterimages(now){
    if(!demonAfterimages.length) return;
    for(const ghost of demonAfterimages){
      const life=ghost.life||420;
      const age=now-ghost.t0;
      const alpha=Math.max(0, 1 - age/life);
      if(alpha<=0) continue;
      const ghostState={
        x:ghost.x,
        y:ghost.y + Math.sin((now-ghost.t0)/260)*4,
        w:ghost.w,
        h:ghost.h,
        hoverPhase:ghost.hoverPhase,
        cloakPhase:ghost.cloakPhase,
        cloakSway:ghost.cloakSway,
        t0:ghost.t0
      };
      const fadeAlpha = ghost.fade ? alpha*alpha : alpha;
      renderDemonAfterimageFigure(ghostState, now, fadeAlpha);
    }
  }

  function drawDemonLayer(now){
    if(level!==20) return;
    drawDemonCore(now);
    drawDemonAfterimages(now);
    if(demonBoss && (demonPhase==='active' || demonPhase==='dying')){
      renderDemonFigure(demonBoss, now);
    }
    if(demonDeathAnim && demonPhase!=='defeated'){
      const anim=demonDeathAnim;
      const elapsed=now-anim.start;
      const life=Math.max(1, (anim.duration||2200));
      const prog=Math.max(0, Math.min(1, elapsed/life));
      const cx=(anim.centerX||550)*scaleX;
      const cy=(anim.centerY|| (layout().top+160))*scaleY;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const outer=200*((scaleX+scaleY)/2)*(1+prog*0.6);
      const glow=ctx.createRadialGradient(cx,cy,0,cx,cy,outer);
      glow.addColorStop(0,`rgba(240,220,255,${0.55*(1-prog)})`);
      glow.addColorStop(0.55,`rgba(180,120,220,${0.4*(1-prog)})`);
      glow.addColorStop(1,'rgba(110,50,200,0)');
      ctx.fillStyle=glow;
      ctx.beginPath();
      ctx.arc(cx,cy,outer,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawDemonCloakWraps(now, layer='front'){
    if(level!==20 || demonPhase!=='active' || !demonBoss) return;
    if(!Array.isArray(balls) || !balls.length) return;
    const captured=balls.filter(b=>b && b.demonCloakState==='captured');
    if(!captured.length) return;
    const center=demonCloakCenter();
    if(!center) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const centerX=center.x*scaleX;
    const centerY=center.y*scaleY;
    for(const ball of captured){
      const progress=Math.max(0, Math.min(1, ball.demonCloakWrapProgress||0));
      const ballX=ball.x*scaleX;
      const ballY=ball.y*scaleY;
      const anchor=ball.demonCloakAnchor||{dx:0,dy:0};
      const wrapRadius=Math.max(ball.r*scaleAvg*1.8, Math.hypot((anchor.dx||0)*scaleX, (anchor.dy||0)*scaleY)*0.6, 22*scaleAvg);
      const dx=ballX-centerX;
      const dy=ballY-centerY;
      const baseAngle=Math.atan2(dy, dx);
      const swirl=ball.demonCloakWrapPhase||baseAngle;
      if(layer==='behind'){
        ctx.save();
        ctx.globalAlpha=0.45 + 0.25*progress;
        ctx.lineCap='round';
        ctx.lineJoin='round';
        ctx.strokeStyle=`rgba(140,0,28,${0.55+0.3*progress})`;
        ctx.lineWidth=(16 + 18*progress)*scaleAvg;
        const ctrlX=centerX + dx*0.45 + Math.cos(swirl)*wrapRadius*0.55;
        const ctrlY=centerY + dy*0.45 + Math.sin(swirl)*wrapRadius*0.45;
        const tailX=ballX - Math.cos(baseAngle)*wrapRadius*0.55;
        const tailY=ballY - Math.sin(baseAngle)*wrapRadius*0.35;
        ctx.beginPath();
        ctx.moveTo(centerX - 18*scaleAvg, centerY - 28*scaleAvg);
        ctx.quadraticCurveTo(ctrlX, ctrlY, tailX, tailY);
        ctx.stroke();
        ctx.restore();
        continue;
      }
      if(layer!=='front') continue;
      ctx.save();
      ctx.translate(ballX, ballY);
      ctx.rotate(baseAngle + Math.PI/2);
      const flapW=wrapRadius*(0.85 + 0.45*progress);
      const flapLen=wrapRadius*(1.28 + 0.55*progress);
      const topLift=wrapRadius*(0.68 + 0.24*progress);
      ctx.beginPath();
      ctx.moveTo(-flapW*0.62, -wrapRadius*0.24);
      ctx.quadraticCurveTo(-flapW*1.05, flapLen*0.18, -flapW*0.2, flapLen*0.82);
      ctx.quadraticCurveTo(0, flapLen*(1.1+0.22*progress), flapW*0.2, flapLen*0.82);
      ctx.quadraticCurveTo(flapW*1.05, flapLen*0.18, flapW*0.62, -wrapRadius*0.24);
      ctx.quadraticCurveTo(flapW*0.18, -topLift, 0, -topLift*1.08);
      ctx.quadraticCurveTo(-flapW*0.18, -topLift, -flapW*0.62, -wrapRadius*0.24);
      ctx.closePath();
      const grad=ctx.createLinearGradient(0,-topLift*1.1,0,flapLen*(1.12+0.2*progress));
      grad.addColorStop(0,`rgba(200,48,58,${0.55+0.2*progress})`);
      grad.addColorStop(0.5,`rgba(140,0,24,${0.78+0.18*progress})`);
      grad.addColorStop(1,`rgba(70,0,12,${0.92+0.06*progress})`);
      ctx.fillStyle=grad;
      ctx.shadowColor=`rgba(255,120,150,${0.18+0.22*progress})`;
      ctx.shadowBlur=26*scaleAvg*progress;
      ctx.fill();
      ctx.shadowBlur=0;
      ctx.strokeStyle=`rgba(255,200,210,${0.18+0.18*progress})`;
      ctx.lineWidth=2.4*scaleAvg;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -topLift*0.82);
      ctx.quadraticCurveTo(-flapW*0.12, flapLen*0.34, 0, flapLen*0.96);
      ctx.strokeStyle=`rgba(255,180,200,${0.18+0.2*progress})`;
      ctx.lineWidth=1.2*scaleAvg;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, -topLift*0.82);
      ctx.quadraticCurveTo(flapW*0.12, flapLen*0.34, 0, flapLen*0.96);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,120,140,${0.18+0.24*progress})`;
      ctx.lineWidth=3.2*scaleAvg;
      ctx.beginPath();
      ctx.arc(ballX, ballY, wrapRadius*0.72, baseAngle-0.5, baseAngle+1.05);
      ctx.stroke();
      ctx.restore();
    }
  }

  function activateDemonBoss(){
    if(level!==20) return;
    const now=performance.now();
    const L=layout();
    const cx=1100/2;
    const baseY=L.top + 160;
    demonBoss={
      x:cx,
      y:baseY,
      baseY,
      w:90,
      h:90,
      hitW:150,
      hitH:220,
      hitOffsetY:10,
      cloakW:260,
      cloakH:260,
      cloakOffsetY:20,
      hp:90,
      maxHp:90,
      hoverPhase:0,
      cloakPhase:Math.random()*Math.PI*2,
      cloakSway:0,
      hitFlashUntil:0,
      hitCooldownUntil:0,
      lastUpdate:now,
      lastAfterimage:0,
      deathFade:1,
      spawnAt:now
    };
    demonPhase='active';
    demonAfterimages=[];
    screenShake=Math.max(screenShake,16);
    spawnParticles(cx, baseY, '#dcb6ff', 110, 2.0, 3.2, 3.0);
    spawnParticles(cx, baseY, '#f0e4ff', 80, 1.8, 2.6, 2.4);
    demonEventWave={x:cx,y:baseY,start:now,duration:2000,maxRadius:Math.hypot(1100,700)};
  }

  function damageDemonBoss(amount=1, source='generic', impact){
    if(demonPhase!=='active' || !demonBoss) return false;
    const now=performance.now();
    if(demonBoss.hitCooldownUntil && now<demonBoss.hitCooldownUntil) return false;
    demonBoss.hitCooldownUntil=now+140;
    demonBoss.hp=Math.max(0, demonBoss.hp-amount);
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    demonBoss.hitFlashUntil=now+220;
    const ix=(impact&&impact.x!=null)?impact.x:demonBoss.x;
    const iy=(impact&&impact.y!=null)?impact.y:demonBoss.y;
    spawnParticles(ix,iy,'#dcb6ff',24,1.8,3.0,2.8);
    screenShake=Math.max(screenShake,4);
    if(demonBoss.hp<=0){
      defeatDemonBoss();
    }
    return true;
  }

  function defeatDemonBoss(){
    if(demonPhase==='dying' || demonPhase==='defeated') return;
    const now=performance.now();
    const centerX=demonBoss?demonBoss.x:550;
    const centerY=demonBoss?demonBoss.y:(layout().top+160);
    demonPhase='dying';
    demonDeathAnim={start:now, duration:2200, vanishAt:now+900, lastSpark:0, centerX:centerX, centerY:centerY};
    demonEventWave={x:centerX,y:centerY,start:now,duration:2600,maxRadius:Math.hypot(1100,700)};
    demonEventMarquee={text:'æˆåŠŸæ“Šæ®ºBoss: é­”ç‹åŸƒé‡Œèµ«æ›¼!', start:now, fadeStart:now+5000, end:now+5000};
    if(demonBoss){
      demonBoss.hp=0;
      demonBoss.hitFlashUntil=now+260;
    }
    addScore(BOSS_DEFEAT_SCORE.demon);
    stats.bossKills++;
    updateHUD();
    screenShake=Math.max(screenShake,24);
    spawnParticles(centerX,centerY,'#fff5ff',200,3.0,4.4,4.8);
    spawnParticles(centerX,centerY,'#c08cff',150,2.4,3.6,3.8);
    spawnParticles(centerX,centerY,'#ffd1ff',120,2.6,3.8,3.6);
    spawnPower(centerX-12, centerY, {forceType:'NINE'});
  }

  function updateDemonBoss(){
    if(level!==20) return;
    const now=performance.now();
    if(demonPhase==='intro' && !demonBoss && demonRevealScheduled && now>=demonRevealScheduled){
      activateDemonBoss();
    }
    if(demonPhase==='active' && demonBoss){
      const dt = now - (demonBoss.lastUpdate||now);
      demonBoss.lastUpdate=now;
      const prevX=demonBoss.x;
      const prevBaseY=demonBoss.baseY;
      if(!demonBoss.moveTarget || now>=demonBoss.nextMove){
        const L=layout();
        const minX=210;
        const maxX=890;
        const minY=L.top + 100;
        const maxY=L.top + 260;
        demonBoss.moveTarget={x:minX + Math.random()*(maxX-minX), y:minY + Math.random()*(maxY-minY)};
        demonBoss.nextMove = now + 1400 + Math.random()*1400;
      }
      if(demonBoss.moveTarget){
        const speed=Math.min(0.22, (dt/1000)*0.75);
        demonBoss.x += (demonBoss.moveTarget.x - demonBoss.x)*speed;
        demonBoss.baseY += (demonBoss.moveTarget.y - demonBoss.baseY)*speed;
      }
      demonBoss.hoverPhase += dt*0.0026;
      demonBoss.cloakPhase += dt*0.0018;
      const moveDelta=Math.hypot(demonBoss.x-prevX, demonBoss.baseY-prevBaseY);
      const baseSway=0.16 + Math.abs(Math.sin(demonBoss.hoverPhase))*0.1;
      const swayTarget=Math.min(1.1, baseSway + moveDelta*14);
      demonBoss.cloakSway = (demonBoss.cloakSway||0) + (swayTarget - (demonBoss.cloakSway||0))*0.35;
      demonBoss.y = demonBoss.baseY + Math.sin(demonBoss.hoverPhase)*14;
      if(!demonBoss.lastAfterimage || now - demonBoss.lastAfterimage > 140){
        demonAfterimages.push({x:demonBoss.x, y:demonBoss.y, baseY:demonBoss.baseY, w:demonBoss.w, h:demonBoss.h, hoverPhase:demonBoss.hoverPhase, cloakPhase:demonBoss.cloakPhase, cloakSway:demonBoss.cloakSway, t0:now, life:420});
        if(demonAfterimages.length>6){ demonAfterimages.splice(0, demonAfterimages.length-6); }
        demonBoss.lastAfterimage=now;
      }
    }else if(demonPhase==='dying' && demonDeathAnim){
      const anim=demonDeathAnim;
      const elapsed=now-anim.start;
      const fadeDuration=Math.max(1, (anim.vanishAt|| (anim.start+900)) - anim.start);
      if(demonBoss){
        const dt = now - (demonBoss.lastUpdate||now);
        demonBoss.lastUpdate=now;
        demonBoss.hoverPhase += dt*0.002;
        demonBoss.y = demonBoss.baseY + Math.min(120, elapsed*0.18);
        demonBoss.deathFade = Math.max(0, 1 - elapsed/fadeDuration);
        if(!anim.lastSpark || now-anim.lastSpark>90){
          const ox=(Math.random()-0.5)*demonBoss.w*0.6;
          const oy=(Math.random()-0.5)*demonBoss.h*0.6;
          spawnParticles(demonBoss.x+ox, demonBoss.y+oy, '#dcb6ff', 16, 1.4, 2.4, 2.5);
          anim.lastSpark=now;
        }
        if(elapsed>=fadeDuration){
          demonAfterimages.push({x:demonBoss.x, y:demonBoss.y, baseY:demonBoss.baseY, w:demonBoss.w, h:demonBoss.h, hoverPhase:demonBoss.hoverPhase, cloakPhase:demonBoss.cloakPhase, cloakSway:demonBoss.cloakSway, t0:now, life:600, fade:true});
          if(demonAfterimages.length>8){ demonAfterimages.splice(0, demonAfterimages.length-8); }
          demonBoss=null;
        }
      }
      if(elapsed>=(anim.duration||2200)){
        demonPhase='defeated';
        demonDeathAnim=null;
        demonDefeatedAt=now;
      }
    }
    for(let i=demonAfterimages.length-1;i>=0;i--){
      const ghost=demonAfterimages[i];
      const life=ghost.life||520;
      if(now-ghost.t0>=life){ demonAfterimages.splice(i,1); }
    }
  }

  function demonClampPoint(x, y){
    const bounds=getDemonBounds();
    if(!bounds) return {x, y};
    return {
      x: Math.max(bounds.x, Math.min(x, bounds.x + bounds.w)),
      y: Math.max(bounds.y, Math.min(y, bounds.y + bounds.h))
    };
  }

  function drawDemonWave(now){
    if(level!==20 || !demonEventWave) return;
    const wave=demonEventWave;
    const life = wave.duration||1;
    const prog = Math.max(0, Math.min(1,(now-wave.start)/life));
    const radius = (wave.maxRadius||Math.hypot(1100,700)) * prog;
    const alpha = 0.45*(1-prog);
    if(alpha<=0) return;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const maxR = radius*((scaleX+scaleY)/2);
    const minR = maxR*0.35;
    const grad=ctx.createRadialGradient(wave.x*scaleX, wave.y*scaleY, minR, wave.x*scaleX, wave.y*scaleY, Math.max(minR+1,maxR));
    grad.addColorStop(0,`rgba(210,170,255,${alpha})`);
    grad.addColorStop(0.6,`rgba(160,110,255,${alpha*0.6})`);
    grad.addColorStop(1,'rgba(110,40,200,0)');
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(wave.x*scaleX, wave.y*scaleY, Math.max(minR+1,maxR),0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawDemonCore(now){
    if(level!==20 || !demonCore) return;
    const life = demonCore.visibleUntil ? Math.max(1, demonCore.visibleUntil - demonCore.start) : 1;
    const remain = demonCore.visibleUntil ? Math.max(0, demonCore.visibleUntil - now) : life;
    const alpha = Math.max(0, Math.min(1, remain/life));
    const baseRadius = 34*((scaleX+scaleY)/2);
    const pulse = 1 + 0.08*Math.sin(now/160);
    const outer = baseRadius*1.6*pulse;
    const cx=demonCore.x*scaleX;
    const cy=demonCore.y*scaleY;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const glow=ctx.createRadialGradient(cx, cy, 0, cx, cy, outer);
    glow.addColorStop(0,`rgba(230,210,255,${0.6*alpha})`);
    glow.addColorStop(0.45,`rgba(170,100,255,${0.45*alpha})`);
    glow.addColorStop(1,'rgba(90,30,200,0)');
    ctx.fillStyle=glow;
    ctx.beginPath();
    ctx.arc(cx,cy,outer,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.fillStyle=`rgba(200,120,255,${0.9*alpha})`;
    ctx.beginPath();
    ctx.arc(cx,cy,baseRadius*pulse,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  function cyclopsBlastRow(rowIndex){
    const L=layout();
    const rowHeight = brickH + L.pad;
    let removed=false;
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const row=Math.round(((b.y - L.top) / rowHeight));
      if(row!==rowIndex) continue;
      if(b.boss){
        if(b.cyclops && !cyclopsShellBurst){
          cyclopsShellBurst=true;
          startDragonReveal(b);
        }
        continue;
      }
      const cx=b.x+b.w/2, cy=b.y+b.h/2;
      spawnParticles(cx,cy,'#ffe6a1',28,2.4,3.2,3.6);
      spawnParticles(cx,cy,'#ffb46d',18,2.0,2.8,3.2);
      if(!b.fallingTreasure){ revealBrickArea(b); }
      bricks.splice(i,1);
      removed=true;
    }
    if(removed){
      screenShake=Math.max(screenShake,18);
      playSFX('fireExplosion');
      updateHUD();
    }
  }
  let nextBossAtkA=0, nextBossAtkB=0, bossChargeUntil=0, bossChargeColor='', cyclopsShakeUntil=0;

  function updateBossAbilities(){
    const bossLv = (level%5===0)? level : 0;
    if(!bossLv) return;
    if(level===5 && spaceBossPhase!=='inactive') return;
    if(level===15 && (dragonPhase==='dying' || dragonPhase==='defeated' || dragonPhase==='inactive')) return;
    const now=performance.now();
    if(bossLv===5){ if(now>=nextBossAtkA){ spawnLionBeam(); nextBossAtkA = now + 10000; } }
    else if(bossLv===10){ if(now>=nextBossAtkA){ spawnKnightArc(); nextBossAtkA = now + 15000; } }
    else if(bossLv===15){
      if(!cyclopsForcedPetrifyFired && cyclopsForcedPetrifyAt && now>=cyclopsForcedPetrifyAt){
        if(dragonPhase==='awaiting'){ spawnCyclopsColumn(); }
        cyclopsForcedPetrifyFired=true;
      }
      if(dragonPhase!=='awaiting'){ cyclopsForcedPetrifyFired=true; cyclopsForcedPetrifyAt=0; }
      maybeStartDragonAttack(now);
    }
    else if(bossLv===20){ /* ç¬¬20é—œæ–°äº‹ä»¶æœŸé–“æš«åœåŸæœ‰æ”»æ“Š */ }
  }

  function drawAndStepBossProjectiles(){
    const pr=paddleRect();
    // é‡‘/ç´…é›·å°„
    for(let i=hostileBeams.length-1;i>=0;i--){
      const b = hostileBeams[i];
      b.x += b.vx; b.y += b.vy;
      // render
      const x1 = (b.x - b.vx*2)*scaleX, y1=(b.y - b.vy*2)*scaleY;
      const x2 = b.x*scaleX, y2=b.y*scaleY;
      ctx.save(); ctx.globalCompositeOperation='lighter';
      if(b.color==='gold'){
        const grd=ctx.createLinearGradient(x1,y1,x2,y2);
        grd.addColorStop(0,'rgba(255,240,160,0)');
        grd.addColorStop(1,'rgba(255,220,120,0.95)');
        ctx.strokeStyle=grd; ctx.lineWidth=6; ctx.shadowColor='rgba(255,230,150,0.9)'; ctx.shadowBlur=15;
      }else if(b.color==='red'){
        const grd=ctx.createLinearGradient(x1,y1,x2,y2);
        grd.addColorStop(0,'rgba(255,120,120,0)');
        grd.addColorStop(1,'rgba(255,60,80,0.95)');
        ctx.strokeStyle=grd; ctx.lineWidth=6; ctx.shadowColor='rgba(255,40,60,0.9)'; ctx.shadowBlur=20;
      }else{
        ctx.strokeStyle='rgba(255,80,120,0.8)'; ctx.lineWidth=5;
      }
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
      // hit check
      if(!b.hit && x2>=pr.x*scaleX && x2<= (pr.x+pr.w)*scaleX && y2>=pr.y*scaleY && y2<= (pr.y+pr.h)*scaleY){
        b.hit=true; b.onHit?.(pr); spawnParticles(b.x,b.y,'#ffd',12,1.6,2.2,2.5);
      }
      // out of bounds
      if(b.x<0||b.x>1100||b.y<0||b.y>700){ hostileBeams.splice(i,1); }
    }
    // å¼§å½¢åŠæ°£
    for(let i=hostileArcs.length-1;i>=0;i--){
      const a = hostileArcs[i];
      a.phase += 0.15;
      a.x += a.vx + Math.sin(a.phase)*0.9;
      a.y += a.vy + Math.cos(a.phase)*0.4;
      // render
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const grad=ctx.createLinearGradient((a.x-a.vx*4)*scaleX,(a.y-a.vy*4)*scaleY,a.x*scaleX,a.y*scaleY);
      grad.addColorStop(0,'rgba(200,200,255,0)');
      grad.addColorStop(1,'rgba(220,220,255,0.9)');
      ctx.strokeStyle=grad; ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(a.x*scaleX, a.y*scaleY, 22*((scaleX+scaleY)/2), Math.PI*0.2, Math.PI*1.2);
      ctx.stroke();
      // ç²’å­
      for(let k=0;k<5;k++){ particles.push({x:a.x, y:a.y, vx:(Math.random()-0.5)*0.8, vy:(Math.random()-0.5)*0.8, life:220, size:1.6, color:'rgba(200,200,255,0.7)'}); }
      ctx.restore();
      // hit
      if(a.x>=pr.x && a.x<=pr.x+pr.w && a.y>=pr.y && a.y<=pr.y+pr.h){
        a.onHit?.(); hostileArcs.splice(i,1);
      }
      if(a.x<0||a.x>1100||a.y>700||a.y<0){ hostileArcs.splice(i,1); }
    }
    // çŸ³åŒ–æŸ±
    for(let i=hostileColumns.length-1;i>=0;i--){
      const c = hostileColumns[i];
      const now=performance.now();
      if(now>c.tEnd){ hostileColumns.splice(i,1); continue; }
      const x = (c.x - c.w/2)*scaleX, y = (layout().top)*scaleY;
      const w = c.w*scaleX, h = (700 - layout().top)*scaleY;
      const alpha = 0.5 + 0.5*Math.sin(now/80);
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const grd = ctx.createLinearGradient(c.x*scaleX, layout().top*scaleY, c.x*scaleX, 700*scaleY);
      grd.addColorStop(0, 'rgba(245,228,150,0.85)'); grd.addColorStop(1, 'rgba(240,210,120,0.35)');
      ctx.fillStyle = grd; ctx.fillRect(x, y, w, h);
      ctx.restore();
      // å‘½ä¸­å¹³å°ï¼šåƒµç›´3ç§’
      const pr = paddleRect();
      if(!c.applied){
        const inter = !( pr.x+pr.w < (c.x - c.w/2) || pr.x > (c.x + c.w/2) );
        if(inter){ paddleStunUntil = Math.max(paddleStunUntil, performance.now()+3000); screenShake=Math.max(screenShake,7); c.applied=true; }
      }
    }
    // çƒé›²
    for(let i=hazardClouds.length-1;i>=0;i--){
      const cl = hazardClouds[i];
      const now=performance.now();
      // draw cloud
      ctx.save();
      const x = cl.x*scaleX, y=cl.y*scaleY;
      ctx.globalAlpha = 0.9 * Math.max(0, (cl.tEnd - now)/1000);
      ctx.fillStyle='rgba(60,60,80,0.9)';
      ctx.beginPath(); ctx.arc(x-20,y,14,0,Math.PI*2); ctx.arc(x,y-6,18,0,Math.PI*2); ctx.arc(x+18,y,16,0,Math.PI*2); ctx.fill();
      ctx.restore();
      if(now>=cl.tEnd && !cl.spawned){
        // æ‰è½æ¸›ç›Šé“å…·
        const debuffs = ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type==='debuff');
        const type = debuffs[Math.floor(Math.random()*debuffs.length)] || 'FAST';
        // ç”Ÿæˆä¸€å€‹æ¸›ç›Šé“å…·ï¼Œé€Ÿåº¦ç•¥å¿«ï¼Œæ–¹å‘æ ¹æ“šç•¶å‰ç¿»è½‰ç‹€æ…‹
        {
          const baseSpeed = GAME_CONFIG.powerCapsule.fallVy;
          const speed = baseSpeed * 1.4;
          const horizontal = orientLeft;
          let px = cl.x - 12;
          let py = cl.y;
          if(horizontal){
            // æ°´å¹³æ‰è½ï¼šå¾å³å´é–‹å§‹
            px = 1100 - 40;
            const L = layout();
            py = L.top + 20 + Math.random() * (700 - 60 - L.top);
          }
          powerups.push({
            x: px,
            y: py,
            w: GAME_CONFIG.powerCapsule.width,
            h: GAME_CONFIG.powerCapsule.height,
            speed: speed,
            horizontal: horizontal,
            type: type,
            isDebuff: true,
            isSpecial: false,
            phase: Math.random()*Math.PI*2
          });
        }
        cl.spawned=true;
      }
      if(now > cl.tEnd + 2000){ hazardClouds.splice(i,1); }
    }
  }

  // å¤©åœ°ç¿»è½‰ç‹€æ…‹
  let orientLeft=false; // true æ™‚æ”¹ç‚ºå·¦å´æ“‹æ¿æ¨¡å¼
  let paddleStunUntil=0;
  let paddleGoneUntil=0;


  function spawnParticles(x,y,color,count=10,spread=1.6,speed=3,size=3){
    for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const v=speed*(.4+Math.random()); particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:400+Math.random()*300,size:size*(.6+Math.random()*0.8),color}); }
  }

  // === å·¥å…· ===
  function getDiff(){ return GAME_CONFIG.difficulty[difficultySel.value]; }
  function brickColor(i){ return [getVar('--brick1'),getVar('--brick2'),getVar('--brick3'),getVar('--brick4')][i%4]; }
  function getVar(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }
  function clampHP(h){ return Math.max(1, Math.min(4, (h|0))); }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo((x+r)*scaleX,y*scaleY); ctx.arcTo((x+w)*scaleX,y*scaleY,(x+w)*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo((x+w)*scaleX,(y+h)*scaleY,x*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo(x*scaleX,(y+h)*scaleY,x*scaleX,y*scaleY,r*scaleX); ctx.arcTo(x*scaleX,y*scaleY,(x+w)*scaleX,y*scaleY,r*scaleX); ctx.closePath(); }

  // === çµ±ä¸€é–å®šæ¡†ï¼ˆé¡¯ç¤º 1 ç§’ï¼‰ ===
  function pushLockBox(x,y,w,h,kind='target'){ lockBoxes.push({x,y,w,h,until:performance.now()+1000,kind}); }
  function drawLockBoxes(){
    const now=performance.now();
    for(let i=lockBoxes.length-1;i>=0;i--){
      const b=lockBoxes[i];
      if(now>b.until){ lockBoxes.splice(i,1); continue; }
      const t = 1 - Math.max(0, (b.until-now)/1000);
      const pulse = 0.7 + 0.3*Math.sin(now/100);
      let col = b.kind==='paddle' ? 'rgba(120,220,255,'+(0.6*pulse)+')' : 'rgba(255,220,140,'+(0.6*pulse)+')';
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle = col;
      ctx.lineWidth = 2 + 2*pulse;
      drawRoundedRect(b.x, b.y, b.w, b.h, 10);
      ctx.stroke();
      ctx.restore();
    }
  }


  
  function drawBossEmblem(b){
    const cx = (b.x + b.w/2)*scaleX, cy = (b.y + b.h/2)*scaleY;
    if(b.cyclops && b.cyclopsRevealed){
      const pulse = 0.7 + 0.3*Math.sin(performance.now()/240);
      const radius = Math.min(b.w,b.h)*0.36*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.shadowColor=`rgba(255,220,120,${0.5+0.4*pulse})`;
      ctx.shadowBlur=30*((scaleX+scaleY)/2);
      const grad=ctx.createRadialGradient(cx,cy,radius*0.15,cx,cy,radius);
      grad.addColorStop(0,'rgba(255,255,220,0.98)');
      grad.addColorStop(0.45,'rgba(255,230,150,0.9)');
      grad.addColorStop(1,'rgba(255,170,60,0.08)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(cx,cy,radius,0,Math.PI*2);
      ctx.fill();
      ctx.shadowBlur=0;
      ctx.lineWidth=2.4*((scaleX+scaleY)/2);
      ctx.strokeStyle=`rgba(255,245,200,${0.75+0.2*pulse})`;
      ctx.beginPath();
      ctx.arc(cx,cy,radius*0.72,0,Math.PI*2);
      ctx.stroke();
      ctx.strokeStyle=`rgba(255,210,120,${0.25+0.2*Math.sin(performance.now()/180)})`;
      ctx.lineWidth=1.6*((scaleX+scaleY)/2);
      ctx.beginPath();
      const swing=performance.now()/520;
      ctx.arc(cx,cy,radius*1.18,swing, swing+Math.PI*1.1);
      ctx.stroke();
      ctx.restore();
      return;
    }
    const t = performance.now()/600;
    // è£ç”²å±¤
    ctx.save();
    const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
    g.addColorStop(0,'#5f0d2a'); g.addColorStop(1,'#130812');
    ctx.fillStyle = g; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.fill();
    // å¤–æ¡†å‘¼å¸
    const glow = 0.5 + 0.5*Math.sin(t*2);
    ctx.strokeStyle = 'rgba(255,90,120,'+(0.6*glow)+')'; ctx.lineWidth = 3 + 2*glow;
    drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke();
    // Emblem
    ctx.translate(cx, cy);
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,230,230,0.9)';
    const idx = ['ç…','é¨','ç›®','é­”'].indexOf(b.face);
    if(idx===0){
      // ç…ï¼šé¬ƒæ¯›åœ“ç’° + ç‰™
      ctx.beginPath(); ctx.arc(0,0, Math.min(b.w,b.h)*0.22*scaleX, 0, Math.PI*2); ctx.stroke();
      for(let i=0;i<6;i++){ const a = i*Math.PI/3; ctx.beginPath(); ctx.moveTo(Math.cos(a)*18, Math.sin(a)*18); ctx.lineTo(Math.cos(a)*30, Math.sin(a)*30); ctx.stroke(); }
      ctx.beginPath(); ctx.moveTo(-14,8); ctx.lineTo(-6,14); ctx.moveTo(14,8); ctx.lineTo(6,14); ctx.stroke();
    }else if(idx===1){
      // é ­ç›” + ç¾½é£¾
      ctx.beginPath(); ctx.arc(0,0,22,Math.PI*0.15, Math.PI*0.85); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-14,0); ctx.lineTo(14,0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-10,-10); ctx.lineTo(0,-22); ctx.lineTo(10,-10); ctx.stroke();
    }else if(idx===2){
      // ç¨çœ¼ï¼šå·¨çœ¼ + çœ¼ç¼
      ctx.beginPath(); ctx.ellipse(0,0,26,18,0,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,0); ctx.lineTo(26,0); ctx.stroke();
    }else{
      // äº”èŠ’æ˜Ÿ + è§’
      ctx.beginPath();
      for(let i=0;i<5;i++){ const a = -Math.PI/2 + i*2*Math.PI/5; const x = Math.cos(a)*22, y=Math.sin(a)*22;
        const a2 = -Math.PI/2 + ((i*2+2)%10)*Math.PI/5; const x2=Math.cos(a2)*9, y2=Math.sin(a2)*9;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); ctx.lineTo(x2,y2);
      } ctx.closePath(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,-18); ctx.lineTo(-10,-30); ctx.moveTo(26,-18); ctx.lineTo(10,-30); ctx.stroke();
    }
    ctx.restore();
  }

  // === Buff/De-buff é¡¯ç¤º ===
  function badgeIcon(k){ return (GAME_CONFIG.powers[k]?.badge)||'â—'; }
  function fitBuffBadges(){
    if(!activeBuffsEl) return;
    activeBuffsEl.style.setProperty('--buff-scale','1');
    const total=activeBuffsEl.scrollWidth;
    const avail=activeBuffsEl.clientWidth;
    const base=window.innerWidth<=430?0.9:1;
    let scale=base;
    if(total*base>avail){ scale=avail/total; }
    activeBuffsEl.style.setProperty('--buff-scale',scale);
  }
  function updateBuffBadges(){ activeBuffsEl.innerHTML=''; const now=performance.now();
    // LONG å †ç–Š
    const longAct=buffs.LONG.stacks.filter(t=>t>now);
    if(longAct.length){
      const s=document.createElement('span');
      s.className='badge';
      const leftSec=(Math.max(...longAct)-now)/1000;
      s.textContent=`${badgeIcon('LONG')} LONGÃ—${longAct.length} ${leftSec.toFixed(1)}s`;
      activeBuffsEl.appendChild(s);
    }
    // å…¶å®ƒ
    for(const key of Object.keys(GAME_CONFIG.powers)){ if(key==='LONG') continue; const b=buffs[key]; if(!b?.active) continue; const left=b.until&&b.until>now?((b.until-now)/1000).toFixed(1)+'s':''; const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon(key)} ${key}${left?' '+left:''}`; activeBuffsEl.appendChild(s); }
    fitBuffBadges();
  }
  window.addEventListener('resize', fitBuffBadges);

  const promptQueue=[];
  function showPrompt(text){
    if(!promptsDock) return;
    const div=document.createElement('div');
    div.className='prompt';
    div.textContent=text;
    promptsDock.appendChild(div);
    promptQueue.push(div);
    while(promptQueue.length>3){ const old=promptQueue.shift(); old.remove(); }
    setTimeout(()=>{ div.classList.add('fade'); setTimeout(()=>{ const idx=promptQueue.indexOf(div); if(idx>=0) promptQueue.splice(idx,1); div.remove(); },400); },5000);
  }

  // === Buff ç‹€æ…‹ ===
  const buffs={WIDE:{active:false,until:0},STICKY:{active:false,until:0},MULTI:{active:false,until:0},SLOW:{active:false,until:0},PIERCE:{active:false,until:0},SHIELD:{active:false,until:0},RAMPAGE:{active:false,until:0},FAST:{active:false,until:0},WAVY:{active:false,until:0,start:0},COMBO:{active:false,until:0},LONG:{active:false,until:0,stacks:[]},PLASMA:{active:false,until:0},FREEZE:{active:false,until:0},HOLY:{active:false,until:0},TRACK:{active:false,until:0},MISSILE:{active:false,until:0},HELL:{active:false,until:0},MEGA:{active:false,until:0,applied:false},CHAIN:{active:false,until:0},NARROW:{active:false,until:0},HOLE:{active:false,until:0},PADSPIN:{active:false,until:0,start:0},PADBOOM:{active:false,until:0,explodeAt:0,returnAt:0,exploded:false},FLIP:{active:false,until:0},GODSPEED:{active:false,until:0},LASER:{active:false,until:0,lastShot:0},GATLING:{active:false,until:0},FIRE:{active:false,until:0},POISON:{active:false,until:0},BLINK:{active:false,until:0},SWORD:{active:false,until:0},STORM:{active:false,until:0},BLACKHOLE:{active:false,until:0,deaths:0},ANNIHIL:{active:false,until:0,start:0,next:0}};

  // === æ“‹æ¿ & çƒ ===
  let diff=getDiff(); const paddle={w:diff.paddleBaseW,h:18,x:1100/2-diff.paddleBaseW/2,y:700-50,speed:12};
let balls=[]; function makeBall(stuck=false,x=null){ return {x:x??(1100/2),y:700/2,r:10,vx:5,vy:-5,speedCap:GAME_CONFIG.caps.ballSpeedMax,piercing:false,stuck:stuck,offsetX:0,rampageUntil:0,trail:[],freeze:{state:'idle',t0:0,until:0,oldVX:0,oldVY:0,delay:0,stop:0},blinkAt:0,loopBrick:null,loopHits:0,lastBrickId:null,lastBrickHitTime:0,sameBrickHits:0,lastBounce:null,speedBoostSuppressedUntil:0,lastCeilingBounce:0}; }

  function isSpeedSuppressed(ball, now){
    return !!(ball?.speedBoostSuppressedUntil && now < ball.speedBoostSuppressedUntil);
  }

  function suppressSpeedBoost(ball, now, duration=1000){
    if(!ball) return;
    const target = now + duration;
    if(!ball.speedBoostSuppressedUntil || ball.speedBoostSuppressedUntil < target){
      ball.speedBoostSuppressedUntil = target;
    }
  }

  function noteCeilingBounce(ball, now){
    if(!ball) return;
    if(ball.lastCeilingBounce && now - ball.lastCeilingBounce <= 1000){
      suppressSpeedBoost(ball, now);
    }
    ball.lastCeilingBounce = now;
  }

  function applyBounceNudge(ball, axis){
    const sp=Math.hypot(ball.vx,ball.vy);
    if(sp<=0.0001) return;
    const minFrac=0.18;
    if(axis==='y'){
      let sign=Math.sign(ball.vx);
      if(!sign) sign=Math.random()<0.5?-1:1;
      const target=Math.max(Math.abs(ball.vx), sp*minFrac);
      const newVX=sign*target;
      const vySign=Math.sign(ball.vy)||1;
      const remain=Math.sqrt(Math.max(sp*sp - newVX*newVX, 0));
      ball.vx=newVX;
      ball.vy=vySign*remain;
    }else if(axis==='x'){
      let sign=Math.sign(ball.vy);
      if(!sign) sign=Math.random()<0.5?-1:1;
      const target=Math.max(Math.abs(ball.vy), sp*minFrac);
      const newVY=sign*target;
      const vxSign=Math.sign(ball.vx)||1;
      const remain=Math.sqrt(Math.max(sp*sp - newVY*newVY, 0));
      ball.vx=vxSign*remain;
      ball.vy=newVY;
    }
  }

  function noteBounce(ball, x, y, axis, now){
    if(!ball) return;
    const last=ball.lastBounce;
    const maxDist=8;
    const maxInterval=800;
    if(last && last.axis===axis && now-last.time<=maxInterval){
      const dx=x-last.x;
      const dy=y-last.y;
      if(Math.hypot(dx,dy)<=maxDist){
        const count=last.count+1;
        ball.lastBounce={axis,time:now,x,y,count};
        if(count>=3){
          applyBounceNudge(ball, axis);
          ball.lastBounce={axis,time:now,x,y,count:0};
        }
        return;
      }
    }
    ball.lastBounce={axis,time:now,x,y,count:1};
  }

  // === è²éŸ³èˆ‡BGM ===

  // === BGM ä¸»é¡Œä¾é—œå¡æ®µè½ ===
  function bgmThemeForLevel(lv){
    if(lv<=4) return 'picnic';      // é–‹å¿ƒéƒŠéŠ
    if(lv===5) return 'lion';       // ç…å­ç‹æ±ºæˆ°
    if(lv<=9) return 'castle';      // æ”»å…¥åŸå ¡
    if(lv===10) return 'duel';      // é¨å£«å°æ±º
    if(lv<=14) return 'valley';     // æ½›å…¥å·¨äººå±±è°·
    if(lv===15) return 'giant';     // æ±ºæˆ°å·¨äºº
    if(lv<=19) return 'demon';      // æƒ¡é­”åŸ
    return 'finale';                // æœ€çµ‚é­”ç‹
  }

  // === BGM è®Šå¥è³‡æ–™ ===
  function midi(n){ return 440*Math.pow(2,(n-69)/12); }
  const transposeSeq=(seq,s)=>seq.map(ch=>Array.isArray(ch)?ch.map(n=>n+s):ch+s);
  const rotateSeq=(arr,k)=>arr.slice(k).concat(arr.slice(0,k));

  function buildTheme(tempo, chords, melody){
    const play=(ch,mel,start,tone)=>{
      const beat=60/tempo;
      ch.forEach((c,i)=>c.forEach(n=>tone(midi(n),'triangle', start+i*4*beat, 3.8*beat, 0.04)));
      mel.forEach((m,i)=>tone(midi(m),'sine', start+i*2*beat, 1.6*beat, 0.045));
      for(let i=0;i<32;i++){ tone(100,'square', start+i*beat, 0.05*beat, 0.015); }
      return 32*beat;
    };
    return {
      tempo,
      patterns:[
        (t,tn)=>play(chords, melody, t, tn),
        (t,tn)=>play(transposeSeq(chords,2), melody, t, tn),
        (t,tn)=>play(chords, transposeSeq(melody,2), t, tn),
        (t,tn)=>play(rotateSeq(chords,2), melody, t, tn)
      ]
    };
  }

  const BGM_PATTERNS={
    picnic: buildTheme(100,
      [[60,64,67],[65,69,72],[67,71,74],[60,64,67],[57,60,64],[62,65,69],[67,71,74],[60,64,67]],
      [72,74,76,79,76,74,72,69,72,74,76,74,72,69,67,69]),
    lion: buildTheme(120,
      [[62,65,69],[58,62,65],[60,64,67],[62,65,69],[65,69,72],[60,64,67],[62,65,69],[57,62,65]],
      [74,74,76,74,72,71,72,74,76,74,72,69,67,69,71,72]),
    castle: buildTheme(90,
      [[64,67,71],[60,64,67],[62,65,69],[59,62,67],[64,67,71],[60,64,67],[62,65,69],[64,67,71]],
      [76,74,72,71,72,74,76,78,76,74,72,71,69,71,72,74]),
    duel: buildTheme(110,
      [[67,71,74],[64,67,71],[60,64,67],[62,65,69],[67,71,74],[60,64,67],[57,60,64],[62,65,69]],
      [79,76,74,72,74,76,79,81,79,76,74,72,74,76,77,79]),
    valley: buildTheme(100,
      [[69,73,76],[66,69,73],[62,66,69],[64,69,72],[69,73,76],[64,69,72],[62,66,69],[59,62,66]],
      [81,78,76,74,76,78,81,83,81,78,76,74,76,78,79,81]),
    giant: buildTheme(80,
      [[65,68,72],[63,66,70],[60,63,67],[58,61,65],[65,68,72],[60,63,67],[63,66,70],[65,68,72]],
      [77,75,72,70,72,75,77,79,77,75,72,70,72,75,77,79]),
    demon: buildTheme(140,
      [[71,74,78],[67,71,74],[69,72,76],[65,69,72],[71,74,78],[67,71,74],[69,72,76],[71,74,78]],
      [83,81,78,76,78,81,83,85,83,81,78,76,78,81,83,85]),
    finale: buildTheme(150,
      [[60,63,67],[65,68,72],[70,74,77],[65,68,72],[60,63,67],[65,68,72],[70,74,77],[72,75,79]],
      [72,75,77,79,77,75,72,70,72,75,77,75,72,70,68,70])
  };

  let currentBGMTheme=null;
  let bgmTimer=null;
  function startBGMTheme(theme){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || !bgmOn) return;
    clearInterval(bgmTimer);
    bgmTimer=null;
    stopBGM();
    bgmStarted=true;
    currentBGMTheme=theme;
    const data=BGM_PATTERNS[theme];
    let variant=0;
    const beat=60/data.tempo;
    const patternDur=32*beat;
    const scheduleAhead=0.1;
    function tone(freq,type,start,dur,gain=0.045){
      const o=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value=0; o.connect(g); g.connect(bgmGain);
      o.start(start); g.gain.setTargetAtTime(gain,start,0.015);
      g.gain.setTargetAtTime(0.0001,start+dur-0.03,0.02);
      o.stop(start+dur+0.1);
      // å°‡ node è¨˜éŒ„æ–¼é›†åˆä¸­ï¼Œä¸¦åœ¨æ’­æ”¾çµæŸå¾Œç§»é™¤ä»¥é¿å…ç´¯ç©
      bgmNodes.add(o); bgmNodes.add(g);
      o.onended = () => { try{o.disconnect();}catch{} try{g.disconnect();}catch{} bgmNodes.delete(o); bgmNodes.delete(g); };
    }
    function playVariant(){
      if(!bgmOn || !bgmStarted) return;
      const base=audioCtx.currentTime+0.05;
      data.patterns[variant](base, tone);
      variant=(variant+1)%data.patterns.length;
    }
    // æ–¼æ‰€æœ‰è®Šå¥æ’­æ”¾å®Œå¾Œï¼Œè‡ªå‹•å›åˆ°ç¬¬ä¸€ç¨®è®Šå¥ï¼Œä¸¦æŒçºŒå¾ªç’°
    playVariant();
    bgmTimer=setInterval(playVariant, Math.max(0,(patternDur-scheduleAhead))*1000);
  }
  function applyBGMThemeForLevel(){
    const theme = bgmThemeForLevel(level);
    if(theme!==currentBGMTheme){ startBGMTheme(theme); }
  }

  function ensureAudio(){ if(!audioCtx){ const AC=(window.AudioContext||window.webkitAudioContext); if(AC){ audioCtx=new AC(); } } if(audioCtx && !bgmGain){ bgmGain=audioCtx.createGain(); bgmGain.gain.value=parseFloat(localStorage.getItem('bgm_vol')||'0.7'); bgmGain.connect(audioCtx.destination); } }
  function beep(freq=600,dur=0.05,vol=0.06){ if(!soundsOn||!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.stop(); }, Math.max(10, dur*1000)); }

  function playSFX(type){
    if(!soundsOn) return; if(!audioCtx) ensureAudio(); if(!audioCtx) return;
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    switch(type){
      case 'explosion':
        o.type='sawtooth';
        o.frequency.setValueAtTime(200, now);
        o.frequency.exponentialRampToValueAtTime(40, now+0.4);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.4);
        o.start(now); o.stop(now+0.4); break;
      case 'laser':
        o.type='square';
        o.frequency.setValueAtTime(1200, now);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.15);
        o.start(now); o.stop(now+0.15); break;
      case 'sword':
        o.type='triangle';
        o.frequency.setValueAtTime(900, now);
        o.frequency.linearRampToValueAtTime(600, now+0.1);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.2);
        o.start(now); o.stop(now+0.2); break;
      case 'pierce':
        o.type='square';
        o.frequency.setValueAtTime(700, now);
        g.gain.setValueAtTime(0.04, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.1);
        o.start(now); o.stop(now+0.1); break;
      case 'holy':
        o.type='sine';
        o.frequency.setValueAtTime(880, now);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.5);
        o.start(now); o.stop(now+0.5); break;
      case 'missile':
        o.type='sawtooth';
        o.frequency.setValueAtTime(1000, now);
        o.frequency.linearRampToValueAtTime(300, now+0.3);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.3);
        o.start(now); o.stop(now+0.3); break;
      case 'blackhole':{
        o.type='sine';
        o.frequency.setValueAtTime(90, now);
        o.frequency.exponentialRampToValueAtTime(28, now+0.8);
        g.gain.setValueAtTime(0.09, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        const sub=audioCtx.createOscillator();
        const subGain=audioCtx.createGain();
        sub.type='sawtooth';
        sub.frequency.setValueAtTime(45, now);
        sub.frequency.exponentialRampToValueAtTime(18, now+0.8);
        subGain.gain.setValueAtTime(0.04, now);
        subGain.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        sub.connect(subGain); subGain.connect(audioCtx.destination);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='triangle';
        shimmer.frequency.setValueAtTime(620, now);
        shimmer.frequency.linearRampToValueAtTime(980, now+0.25);
        shimmer.frequency.exponentialRampToValueAtTime(320, now+0.8);
        shimmerGain.gain.setValueAtTime(0.02, now);
        shimmerGain.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        shimmer.connect(shimmerGain); shimmerGain.connect(audioCtx.destination);
        o.start(now); o.stop(now+0.8);
        sub.start(now); sub.stop(now+0.8);
        shimmer.start(now+0.05); shimmer.stop(now+0.8);
        break;
      }
      case 'phoenix':
        o.type='sine';
        o.frequency.setValueAtTime(800, now);
        o.frequency.linearRampToValueAtTime(1200, now+0.15);
        o.frequency.linearRampToValueAtTime(600, now+0.3);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.4);
        const oP=audioCtx.createOscillator(), gP=audioCtx.createGain();
        oP.type='sine'; gP.gain.value=0.05; oP.connect(gP); gP.connect(audioCtx.destination);
        oP.frequency.setValueAtTime(1200, now);
        oP.frequency.linearRampToValueAtTime(2000, now+0.15);
        oP.frequency.linearRampToValueAtTime(900, now+0.3);
        o.start(now); o.stop(now+0.4); oP.start(now); oP.stop(now+0.4); break;
      case 'spaceBossVolleyCharge':
        o.type='sawtooth';
        o.frequency.setValueAtTime(260, now);
        o.frequency.exponentialRampToValueAtTime(120, now+0.5);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.5);
        o.start(now); o.stop(now+0.5); break;
      case 'spaceBossVolleyShot':
        o.type='triangle';
        o.frequency.setValueAtTime(1400, now);
        o.frequency.exponentialRampToValueAtTime(520, now+0.18);
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.18);
        o.start(now); o.stop(now+0.2); break;
      case 'spaceBossLaserCharge':
        o.type='sine';
        o.frequency.setValueAtTime(320, now);
        o.frequency.linearRampToValueAtTime(960, now+0.8);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        const oCharge=audioCtx.createOscillator(), gCharge=audioCtx.createGain();
        oCharge.type='sawtooth'; gCharge.gain.value=0.02; oCharge.connect(gCharge); gCharge.connect(audioCtx.destination);
        oCharge.frequency.setValueAtTime(180, now);
        oCharge.frequency.linearRampToValueAtTime(540, now+0.8);
        o.start(now); o.stop(now+0.8); oCharge.start(now); oCharge.stop(now+0.8); break;
      case 'spaceBossLaserSweep':
        o.type='square';
        o.frequency.setValueAtTime(900, now);
        g.gain.setValueAtTime(0.07, now);
        g.gain.linearRampToValueAtTime(0.02, now+0.5);
        const oSweep=audioCtx.createOscillator(), gSweep=audioCtx.createGain();
        oSweep.type='triangle'; gSweep.gain.value=0.03; oSweep.connect(gSweep); gSweep.connect(audioCtx.destination);
        oSweep.frequency.setValueAtTime(400, now);
        oSweep.frequency.exponentialRampToValueAtTime(1200, now+0.5);
        o.start(now); o.stop(now+0.5); oSweep.start(now); oSweep.stop(now+0.5); break;
      case 'annihil':
        o.type='sawtooth';
        o.frequency.setValueAtTime(300, now);
        o.frequency.exponentialRampToValueAtTime(60, now+0.3);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.3);
        o.start(now); o.stop(now+0.3); break;
      case 'steam':
        o.type='sawtooth';
        o.frequency.setValueAtTime(800, now);
        o.frequency.exponentialRampToValueAtTime(200, now+0.4);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.4);
        o.start(now); o.stop(now+0.4); break;
      case 'gatlingShoot':
        o.type='square';
        o.frequency.setValueAtTime(900, now);
        g.gain.setValueAtTime(0.04, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.07);
        o.start(now); o.stop(now+0.07); break;
      case 'gatlingHit':
        o.type='sawtooth';
        o.frequency.setValueAtTime(300, now);
        o.frequency.exponentialRampToValueAtTime(80, now+0.15);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.15);
        o.start(now); o.stop(now+0.15); break;
      case 'plasma':
        o.type='square';
        o.frequency.setValueAtTime(1200, now);
        o.frequency.exponentialRampToValueAtTime(300, now+0.2);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.2);
        o.start(now); o.stop(now+0.2); break;
      case 'plasmaHit':
        o.type='sawtooth';
        o.frequency.setValueAtTime(600, now);
        o.frequency.exponentialRampToValueAtTime(120, now+0.2);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.2);
        o.start(now); o.stop(now+0.2); break;
      case 'dragonAnnihilation':{
        o.type='sawtooth';
        o.frequency.setValueAtTime(160, now);
        o.frequency.exponentialRampToValueAtTime(30, now+1.2);
        g.gain.setValueAtTime(0.12, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+1.2);
        const sub=audioCtx.createOscillator();
        const subGain=audioCtx.createGain();
        sub.type='sine';
        sub.frequency.setValueAtTime(48, now);
        sub.frequency.exponentialRampToValueAtTime(18, now+1.4);
        subGain.gain.setValueAtTime(0.16, now);
        subGain.gain.exponentialRampToValueAtTime(0.001, now+1.4);
        sub.connect(subGain); subGain.connect(audioCtx.destination);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='triangle';
        shimmer.frequency.setValueAtTime(960, now);
        shimmer.frequency.exponentialRampToValueAtTime(320, now+0.9);
        shimmerGain.gain.setValueAtTime(0.03, now);
        shimmerGain.gain.exponentialRampToValueAtTime(0.001, now+0.9);
        shimmer.connect(shimmerGain); shimmerGain.connect(audioCtx.destination);
        const buffer=audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*1.2), audioCtx.sampleRate);
        const data=buffer.getChannelData(0);
        for(let i=0;i<data.length;i++){
          const t=i/data.length;
          data[i]=(Math.random()*2-1)*(1-Math.pow(t,0.45))*0.6;
        }
        const noise=audioCtx.createBufferSource();
        const noiseGain=audioCtx.createGain();
        noise.buffer=buffer;
        noiseGain.gain.setValueAtTime(0.18, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, now+1.1);
        noise.connect(noiseGain); noiseGain.connect(audioCtx.destination);
        o.start(now); o.stop(now+1.2);
        sub.start(now); sub.stop(now+1.4);
        shimmer.start(now+0.05); shimmer.stop(now+0.9);
        noise.start(now); noise.stop(now+1.2);
        break;
      }
      case 'fireExplosion':
        o.type='sawtooth';
        o.frequency.setValueAtTime(400, now);
        o.frequency.exponentialRampToValueAtTime(30, now+0.6);
        g.gain.setValueAtTime(0.1, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.6);
        o.start(now); o.stop(now+0.6); break;
      case 'win':
        o.type='triangle';
        g.gain.setValueAtTime(0.04, now);
        o.frequency.setValueAtTime(660, now);
        o.start(now); o.stop(now+0.2);
        const o2=audioCtx.createOscillator(), g2=audioCtx.createGain();
        o2.type='triangle'; g2.gain.value=0.04; o2.connect(g2); g2.connect(audioCtx.destination);
        o2.frequency.setValueAtTime(880, now+0.2);
        o2.start(now+0.2); o2.stop(now+0.5); break;
      case 'lose':
        o.type='sawtooth';
        o.frequency.setValueAtTime(200, now);
        o.frequency.exponentialRampToValueAtTime(60, now+0.6);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.6);
        o.start(now); o.stop(now+0.6); break;
      default:
        o.type='square';
        o.frequency.setValueAtTime(600, now);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.1);
    o.start(now); o.stop(now+0.1); break;
    }
  }

  // å°ˆå±¬é½’è¼ªé¨å£«çš„æŒ‰éµè’¸æ±½éŸ³æ•ˆ
  document.addEventListener('click', (e) => {
    if(window.currentSkin && window.currentSkin.cssSkin === 'æ©Ÿæ¢°ï¼é½’è¼ªé¨å£«' && e.target.closest('button')){
      playSFX('steam');
    }
  }, {passive:true});

  function startBGM(){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || bgmStarted) return; audioCtx.resume?.(); bgmStarted=true; applyBGMThemeForLevel();
  }
  function stopBGM(){
    clearInterval(bgmTimer);
    bgmTimer=null;
    bgmStarted=false;
    bgmNodes.forEach(n=>{try{n.disconnect?.();}catch{}});
    bgmNodes.clear();
  }

  // === ç£šå¡Šèˆ‡æ­ç¤º ===
  let bricks=[]; let brickW=0, brickH=GAME_CONFIG.bricks.brickHeight; let revealRects=[];
  let brickIdCounter=0;
  function layout(){ return {rows:getDiff().rowsBase+Math.floor((level-1)%3), cols:GAME_CONFIG.bricks.cols, pad:GAME_CONFIG.bricks.padding, top:GAME_CONFIG.bricks.topOffset, h:GAME_CONFIG.bricks.brickHeight}; }

  // å–å¾—æœ¬é—œé¡¯ç¤ºå½±åƒï¼ˆ1~10éš¨æ©ŸBG/CGï¼›11~20ç”¨å¦ä¸€å¼µï¼‰
  function getLevelImage(levelNum){
    const idx=((levelNum-1)%10);
    const imgs = loadImagePair(idx);
    let img;
    if(levelNum<=10){
      if(imageChoice[idx]<0){ imageChoice[idx]= Math.random()<0.5 ? 0:1; }
      img = imageChoice[idx]===0? imgs.bg : imgs.cg;
    }else{
      if(imageChoice[idx]<0){ imageChoice[idx]=0; } // ä¿åº•
      img = imageChoice[idx]===0? imgs.cg : imgs.bg;
    }
    return img;
  }

  function getLevelImageKey(levelNum){
    const idx=((levelNum-1)%10);
    if(levelNum<=10){
      if(imageChoice[idx]<0){ imageChoice[idx]= Math.random()<0.5 ? 0:1; }
      return imageChoice[idx]===0 ? `bg${idx+1}` : `cg${idx+1}`;
    }else{
      if(imageChoice[idx]<0){ imageChoice[idx]=0; }
      return imageChoice[idx]===0 ? `cg${idx+1}` : `bg${idx+1}`;
    }
  }

  // ç‰¹æ®Šç£šæ¨¡æ¿
  function addBrick(list, x,y,w,h, opts={}){
    const id = (opts.id!=null)?opts.id:brickIdCounter++;
    list.push(Object.assign({id,x,y,w,h,hp:opts.unbreakable?Infinity:(opts.hp||1), colorIdx:0, explosive:false, unbreakable:false, strong:false, moving:false, vx:0, vy:0, boss:false, face:''}, opts));
  }

  
  function postAdjustAndDensify(L){
    // å°‡ä¸€èˆ¬ç£šè¡€é‡å¹³æ»‘ä¸Šé™ç‚º 4ï¼Œä¸¦è£œç£šè‡³ >= 3/4 é¢ç©
    const rows=L.rows, cols=L.cols, pad=L.pad;
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // ä½”ç”¨ç¶²æ ¼
    const occ = Array.from({length:rows}, ()=> Array(cols).fill(false));
    function markRect(x,y,w,h){
      const cellW = brickW, cellH = brickH;
      const c0 = Math.max(0, Math.min(cols-1, Math.round((x - L.pad) / (cellW + L.pad)) ));
      const r0 = Math.max(0, Math.min(rows-1, Math.round((y - L.top) / (cellH + L.pad)) ));
      const cellsX = Math.max(1, Math.round((w + L.pad) / (cellW + L.pad)));
      const cellsY = Math.max(1, Math.round((h + L.pad) / (cellH + L.pad)));
      for(let rr=0; rr<cellsY; rr++){
        for(let cc=0; cc<cellsX; cc++){
          const c = Math.min(cols-1, c0 + cc);
          const r = Math.min(rows-1, r0 + rr);
          occ[r][c] = true;
        }
      }
    }
    // å…ˆå¤¾è¡€é‡ + æ¨™è¨˜æ—¢æœ‰ä½”ç”¨
    for(const b of bricks){
      if(!b.unbreakable && !b.boss){
        b.hp = clampHP(b.hp||1);
      }
      markRect(b.x,b.y,b.w,b.h);
    }
    // è¨ˆç®—è¦†è“‹åº¦
    let filled = 0;
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(occ[r][c]) filled++;
    const target = Math.ceil(rows*cols * 0.75);
    if(filled >= target) return;

    // ç”±ä¸­å¿ƒå¾€å¤–è£œç£šï¼Œç¶­æŒç¾æ„Ÿ
    const midC = (cols-1)/2, midR = (rows-1)/2;
    const empties = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(!occ[r][c]){
          const score = (c-midC)**2 + (r-midR)**2;
          empties.push({r,c,score});
        }
      }
    }
    

    empties.sort((a,b)=> a.score - b.score);
    const baseHP = Math.min(1 + Math.floor((level-1)/5), 3);
    let idx=0;
    while(filled < target && idx<empties.length){
      const {r,c} = empties[idx++];
      if(occ[r][c]) continue;
      let hp = baseHP + ((level>=13 && r>rows/2)?1:0);
      hp = clampHP(hp);
      const moving = (Math.random()<0.08) && (r%2===0);
      const vx = moving ? ((Math.random()<0.5?-1:1)*0.6) : 0;
      addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp, colorIdx:(r%4), moving, vx});
      occ[r][c] = true  
      filled += 1;
    }
  }

  function initBricks(){
    const L=layout();
    const totalPad=(L.cols+1)*L.pad; brickW=Math.floor((1100-totalPad)/L.cols); brickH=L.h; bricks=[]; revealRects=[]; brickIdCounter=0;
    spaceBoss=null;
    spaceBossAnchor=null;
    spaceBossPlaceholder=null;
    spaceBossBursts=[];
    spaceBossMarquee=null;
    spaceBossRevealScheduled=0;
    spaceBossDefeatedAt=0;
    spaceBossAttack=null;
    spaceBossNextAttackAt=0;
    spaceBossBullets.length=0;
    spaceBossPaddlePenalty=0;
    spaceBossPaddleRespawnAt=0;
    spaceBossDeathAnim=null;
    spaceBossSuppressLifeLossUntil=0;
    spaceBossPhase = (level===5?'awaiting':'inactive');
    reaperBoss=null;
    reaperAnchor=null;
    reaperPlaceholder=null;
    reaperBursts=[];
    reaperAfterimages=[];
    reaperMarquee=null;
    reaperRevealScheduled=0;
    reaperDefeatedAt=0;
    reaperDeathAnim=null;
    reaperTeleportSchedule=null;
    reaperTargetHighlightUntil=0;
    reaperAttackState=null;
    reaperSlashZone=null;
    reaperSlashEffects=[];
    reaperBlackHoleAttack=null;
    reaperLifeLossCooldownUntil=0;
    reaperPaddlePenalty=0;
    reaperPenaltyLastUpdate=0;
    reaperPhase = (level===10?'awaiting':'inactive');
    dragonBoss=null;
    dragonAnchor=null;
    dragonPlaceholder=null;
    dragonBursts=[];
    dragonMarquee=null;
    dragonRevealScheduled=0;
    dragonDefeatedAt=0;
    dragonDeathAnim=null;
    dragonAttackState=null;
    dragonNextAttackAt=0;
    dragonDeathRayOrbs.length=0;
    dragonDeathRayBeams.length=0;
      dragonPhase = (level===15?'awaiting':'inactive');
      // Reset Cyclops/dragon forced petrify trigger so level 15 always re-schedules it
      cyclopsForcedPetrifyAt=0;
      cyclopsForcedPetrifyFired=false;
      cyclopsFirstAttackAt=0;
    cyclopsEventStarted=false;
    cyclopsMarqueeShown=false;
    cyclopsRowBlastIndex=-1;
    cyclopsNextRowBlast=0;
    cyclopsShellBurst=false;
    cyclopsEventComplete=false;
    demonShellBrick=null;
    demonEventPhase = (level===20?'awaiting':'inactive');
    demonEventTimerStart=0;
    demonEventTriggeredAt=0;
    demonEventMarquee=null;
    demonEventWave=null;
    demonEventRows=[];
    demonEventNextRowAt=0;
    demonFallingDebris=[];
    demonEventShakeUntil=0;
    demonCore=null;
    demonEventTargets=0;
    demonEventCleared=0;
    demonPhase = (level===20?'awaiting':'inactive');
    demonBoss=null;
    demonRevealScheduled=0;
    demonAfterimages=[];
    demonDeathAnim=null;
    demonDefeatedAt=0;
    const lvlImg = getLevelImage(level);
    if (lvlImg && lvlImg.decode) { lvlImg.decode().catch(()=>{}); }
    // ä¾é—œå¡è¨­è¨ˆé—œå¡å¸ƒå±€
    generateLevel(level, L);
    postAdjustAndDensify(L);
    // æ”¾ç½®èè‹±ç£šï¼ˆç¬¬6é—œä»¥å¾Œï¼Œæœ€å¤š2å€‹ï¼‰
    if(level>=6){ let placed=0; const candidates=bricks.filter(b=>!b.unbreakable && !b.boss);
      const cx=1100/2, cy=(layout().top + (layout().rows* (brickH+layout().pad) - layout().pad))/2;
      candidates.sort((a,b)=> (Math.hypot((a.x+a.w/2)-cx,(a.y+a.h/2)-cy) - Math.hypot((b.x+b.w/2)-cx,(b.y+b.h/2)-cy)) );
      for(const b of candidates){ if(placed>=2) break; b.elite=true; b.hp=Math.min(5, Math.max(3, b.hp||3)); placed++; }
    }
    // é‡ç½® Boss è¨ˆæ™‚
    nextBossAtkA = nextBossAtkB = bossChargeUntil = cyclopsShakeUntil = 0; bossChargeColor='';
    if(level===15){
      // é€²å…¥ç¬¬15é—œæ™‚é å…ˆæ’ç¨‹å¼·åˆ¶çŸ³åŒ–å…‰æŸã€‚
      // çŸ³åŒ–å…‰æŸéœ€è“„åŠ›3ç§’ï¼Œå› æ­¤é ç•™ 5 ç§’çš„é€²å ´ç·©è¡å¾Œç«‹å³é–‹å§‹è“„åŠ›ï¼Œ
      // è®“å…‰æŸåœ¨å€’æ•¸çµæŸæ™‚ï¼ˆç´„é€²å ´ 5 ç§’ï¼‰æ“Šä¸­èˆå°ã€è§¸ç™¼çœŸèº«ç¾èº«ã€‚
      const forcedDelay = 5000; // é€²å ´å¾Œå¸Œæœ›å…‰æŸå‘½ä¸­çš„æ™‚é–“
      const petrifyCharge = 3000; // å…‰æŸæ–½æ”¾æ‰€éœ€è“„åŠ›æ™‚é–“
      cyclopsForcedPetrifyAt = performance.now() + Math.max(0, forcedDelay - petrifyCharge);
    }
  }

  
  
  // === ä¿®æ­£ï¼šéé—œåˆ¤å®šæ”¹ç‚ºåªçœ‹ã€Œå¯ç ´å£ç£šã€æ˜¯å¦æ¸…ç©º ===
  function hasBreakables(){
    if(level===5){
      const now=performance.now();
      const breakables = bricks.some(b => !b.unbreakable && !b.treasure);
      if(breakables) return true;
      if(spaceBossPhase==='awaiting'){ startSpaceBossReveal(); return true; }
      if(spaceBossPhase==='intro' || spaceBossPhase==='active' || spaceBossPhase==='dying') return true;
      if(spaceBossPhase==='defeated' && spaceBossDefeatedAt && now < spaceBossDefeatedAt + 3000){
        return true;
      }
      return false;
    }
    if(level===10){
      const now=performance.now();
      const breakables = bricks.some(b => !b.unbreakable && !b.placeholderBoss && !b.treasure);
      if(breakables) return true;
      if(reaperPhase==='awaiting'){ startReaperReveal(); return true; }
      if(reaperPhase==='intro' || reaperPhase==='active' || reaperPhase==='dying') return true;
      if(reaperPhase==='defeated' && reaperDefeatedAt && now < reaperDefeatedAt + 3000){
        return true;
      }
      return false;
    }
    if(level===15){
      const now=performance.now();
      const hasBreakable = bricks.some(b => !b.unbreakable && !b.treasure && !b.placeholderBoss);
      if(hasBreakable) return true;
      if(dragonPhase==='awaiting'){
        if(dragonPlaceholder){ startDragonReveal(); return true; }
        const hasBossShell = bricks.some(b=>b.boss);
        if(hasBossShell) return true;
      }
      if(dragonPhase==='intro' || dragonPhase==='active' || dragonPhase==='dying') return true;
      if(dragonPhase==='defeated' && dragonDefeatedAt && now < dragonDefeatedAt + 3000){
        return true;
      }
      return false;
    }
    if(level===20){
      const now=performance.now();
      const remaining = bricks.some(b => !b.unbreakable && !b.demonShell);
      if(remaining) return true;
      if(demonPhase==='intro' || demonPhase==='event' || demonPhase==='active' || demonPhase==='dying') return true;
      if(demonPhase==='defeated' && demonDefeatedAt && now < demonDefeatedAt + 3000) return true;
      if(demonEventPhase && demonEventPhase!=='inactive' && demonEventPhase!=='complete') return true;
      return false;
    }
    return bricks.some(b => !b.unbreakable);
  }

  // === ç¬¬5é—œå¤ªç©ºæˆ°è‰¦ Boss ===
  function startSpaceBossReveal(){
    if(spaceBossPhase!=='awaiting') return;
    const now=performance.now();
    spaceBossPhase='intro';
    let anchor=spaceBossAnchor;
    if(spaceBossPlaceholder){
      anchor={x:spaceBossPlaceholder.x, y:spaceBossPlaceholder.y, w:spaceBossPlaceholder.w, h:spaceBossPlaceholder.h};
      const cx=anchor.x+anchor.w/2;
      const cy=anchor.y+anchor.h/2;
      spawnParticles(cx,cy,'#fff5d6',120,3.2,5.0,5.5);
      spawnParticles(cx,cy,'#8ab6ff',90,2.6,4.2,4.6);
      spawnParticles(cx,cy,'#ff9fde',70,2.3,3.8,4.2);
      spaceBossBursts.push({type:'ring',x:cx,y:cy,r0:24,r1:420,width:18,t0:now,life:1400,color:'255,220,180'});
      spaceBossBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:240,t0:now,life:1100,color:'140,200,255'});
      spaceBossBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:160,t0:now,life:900,color:'255,180,220'});
      const idx=bricks.indexOf(spaceBossPlaceholder);
      if(idx>=0) bricks.splice(idx,1);
      spaceBossPlaceholder=null;
      spaceBossAnchor=anchor;
    }
    if(!spaceBossAnchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      const anchorW=brickW*2+L.pad;
      const anchorH=brickH*2+L.pad;
      const anchorX=L.pad + bx*(brickW+L.pad);
      spaceBossAnchor={x:anchorX,y:L.top,w:anchorW,h:anchorH};
    }
    spaceBossRevealScheduled = now + 900;
    screenShake=Math.max(screenShake,8);
    playSFX('fireExplosion');
  }

  function activateSpaceBoss(){
    if(spaceBossPhase!=='intro' || spaceBoss) return;
    let anchor=spaceBossAnchor;
    if(!anchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      anchor={x:L.pad + bx*(brickW+L.pad), y:L.top, w:brickW*2+L.pad, h:brickH*2+L.pad};
      spaceBossAnchor=anchor;
    }
    const cx=anchor.x+anchor.w/2;
    const baseY=anchor.y+anchor.h+80;
    const now=performance.now();
    spaceBoss={
      x:cx,
      y:baseY,
      baseY,
      w:220,
      h:120,
      vx:(Math.random()<0.5?-1:1)*2.6,
      hp:SPACE_BOSS_MAX_HP,
      maxHp:SPACE_BOSS_MAX_HP,
      hitCooldownUntil:0,
      hitFlashUntil:0,
      spawnAt:now,
      guns:[
        {offsetX:-70,offsetY:32,phase:0,angle:Math.PI/2,spin:0},
        {offsetX:0,offsetY:42,phase:1.2,angle:Math.PI/2,spin:0},
        {offsetX:70,offsetY:32,phase:2.3,angle:Math.PI/2,spin:0}
      ],
      lasers:[
        {offsetX:-92,offsetY:-4,phase:0.6,angle:Math.PI},
        {offsetX:92,offsetY:-4,phase:1.8,angle:Math.PI}
      ],
      thrusterPhase:0
    };
    spaceBossPhase='active';
    spaceBossBursts.push({type:'halo',x:cx,y:baseY,r0:40,r1:260,t0:now,life:1600,color:'130,200,255'});
    spaceBossAttack=null;
    spaceBossNextAttackAt=now + SPACE_BOSS_ATTACK_INTERVAL;
    spaceBossBullets.length=0;
    spaceBossPaddlePenalty=0;
    spaceBossPaddleRespawnAt=0;
    spaceBossDeathAnim=null;
    spaceBossMarquee={text:'æœ‰è¶£ï¼ è®“ä½ è¦‹è­˜æˆ‘çš„çœŸé¢ç›®å§!', start:now, fadeStart:now+2600, end:now+3200, style:'alert'};
    scheduleNextTreasureBrick(now);
  }

  function damageSpaceBoss(amount=1, source='generic', impact){
    if(spaceBossPhase!=='active' || !spaceBoss) return false;
    const now=performance.now();
    if(spaceBoss.hitCooldownUntil && now<spaceBoss.hitCooldownUntil) return false;
    const dmg = amount>0 ? 1 : 0;
    if(!dmg) return false;
    spaceBoss.hitCooldownUntil = now + 140;
    spaceBoss.hp = Math.max(0, spaceBoss.hp - dmg);
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    spaceBoss.hitFlashUntil = now + 220;
    const jitterX=(Math.random()-0.5)*spaceBoss.w*0.4;
    const jitterY=(Math.random()-0.5)*spaceBoss.h*0.3;
    const colorMap={
      laser:'255,210,240',
      missile:'255,215,180',
      gatling:'255,220,180',
      plasma:'190,240,255',
      blackhole:'200,220,255',
      phoenix:'255,210,200',
      sword:'255,240,220'
    };
    const burstColor=colorMap[source]||'160,220,255';
    spaceBossBursts.push({type:'spark',x:spaceBoss.x+jitterX,y:spaceBoss.y+jitterY,r0:0,r1:140,t0:now,life:600,color:burstColor});
    if(impact && impact.x!=null && impact.y!=null){
      spawnParticles(impact.x, impact.y, '#b8d6ff', 22, 1.6, 2.6, 2.4);
    }
    spawnParticles(spaceBoss.x+jitterX, spaceBoss.y+jitterY, '#8fbaff', 18, 1.5, 2.6, 2.3);
    screenShake=Math.max(screenShake,5);
    const toneMap={laser:820, missile:680, gatling:720, plasma:760, blackhole:640, phoenix:700, ball:780, sword:840};
    const freq=toneMap[source]||760;
    beep(freq,0.04,0.04);
    if(spaceBoss.hp<=0){ defeatSpaceBoss(); }
    return true;
  }

  function defeatSpaceBoss(){
    if(spaceBossPhase!=='active' || !spaceBoss) return;
    const now=performance.now();
    const sb=spaceBoss;
    const fake={x:sb.x-sb.w/2,y:sb.y-sb.h/2,w:sb.w,h:sb.h};
    bossKillEffect(fake,{dropNineCat:'always'});
    addScore(BOSS_DEFEAT_SCORE.space);
    stats.bossKills++;
    updateHUD();
    spawnParticles(sb.x, sb.y, '#ffe9b2', 160, 3.2, 5.6, 6.0);
    spaceBossBursts.push({type:'ring',x:sb.x,y:sb.y,r0:40,r1:520,width:24,t0:now,life:2000,color:'255,200,150'});
    spaceBossBursts.push({type:'flare',x:sb.x,y:sb.y,r0:0,r1:320,t0:now,life:1600,color:'255,235,200'});
    spaceBossBursts.push({type:'spark',x:sb.x,y:sb.y,r0:0,r1:200,t0:now,life:1200,color:'200,240,255'});
    screenShake=Math.max(screenShake,12);
    playSFX('fireExplosion');
    spaceBossPhase='dying';
    spaceBossAttack=null;
    spaceBossBullets.length=0;
    spaceBossNextAttackAt=0;
    spaceBossMarquee={text:'æˆåŠŸæ“Šæ®ºBoss: å¤ªç©ºæˆ°è‰¦!', start:now, fadeStart:now+5000, end:now+5000, style:'victory'};
    nextTreasureBrickAt=0;
    spaceBossDeathAnim={
      start:now,
      startY:sb.y,
      dropDistance:220,
      fallDuration:3000,
      explosionAt:now+3000,
      bigExplosionEnd:now+5000,
      vanishAt:now+5000,
      finishAt:now+8000,
      lastBurst:now,
      bigBang:false,
      dropSpawned:false
    };
  }

  function updateSpaceBoss(){
    if(level!==5) return;
    const now=performance.now();
    if(spaceBossPhase==='intro' && !spaceBoss && spaceBossRevealScheduled && now>=spaceBossRevealScheduled){ activateSpaceBoss(); }
    if(spaceBossPhase==='active' && spaceBoss){
      const sb=spaceBoss;
      sb.x += sb.vx;
      const margin=110;
      if(sb.x - sb.w/2 < margin){ sb.x = margin + sb.w/2; sb.vx = Math.abs(sb.vx); }
      if(sb.x + sb.w/2 > 1100 - margin){ sb.x = 1100 - margin - sb.w/2; sb.vx = -Math.abs(sb.vx); }
      sb.y = sb.baseY + Math.sin((now - sb.spawnAt)/650)*28;
      sb.thrusterPhase = (sb.thrusterPhase||0) + 0.08;
      const atkMode = spaceBossAttack?.mode;
      const atkState = spaceBossAttack?.state;
      const pr = paddleRect();
      for(const gun of sb.guns){
        gun.spin=(gun.spin||0)+0.28;
        if(atkMode===1 && atkState==='firing'){
          const gx = sb.x + gun.offsetX;
          const gy = sb.y + gun.offsetY;
          const tx = pr.x + pr.w/2;
          const ty = pr.y + pr.h/2;
          const dir = Math.atan2(ty-gy, tx-gx);
          gun.angle = dir + Math.PI/2;
        }else{
          gun.angle = Math.PI/2 + Math.sin((now/520)+gun.phase)*0.45;
        }
      }
      for(const laser of sb.lasers){
        if(atkMode===2 && atkState==='sweeping' && spaceBossAttack?.currentTarget){
          const lx = sb.x + laser.offsetX;
          const ly = sb.y + laser.offsetY;
          const target = spaceBossAttack.currentTarget;
          const dir = Math.atan2(target.y-ly, target.x-lx);
          laser.angle = dir + Math.PI/2;
        }else{
          laser.angle = Math.PI + Math.sin((now/900)+laser.phase)*0.22;
        }
      }
      if(sb.hitFlashUntil && now>sb.hitFlashUntil){ sb.hitFlashUntil=0; }
    }
    if(spaceBossPhase==='dying' && spaceBoss){
      const anim=spaceBossDeathAnim;
      if(anim){
        const fallProg=Math.min(1, Math.max(0,(now-anim.start)/anim.fallDuration));
        spaceBoss.y = anim.startY + fallProg*anim.dropDistance;
        const burstInterval = anim.bigBang ? 80 : 110;
        if(now-anim.lastBurst>burstInterval){
          anim.lastBurst=now;
          const jitterX=(Math.random()-0.5)*spaceBoss.w*0.9;
          const jitterY=(Math.random()-0.3)*spaceBoss.h*0.9;
          spawnParticles(spaceBoss.x+jitterX, spaceBoss.y+jitterY, '#ffe6b8', 34, 2.6, 3.8, 3.6);
          spaceBossBursts.push({type:'spark',x:spaceBoss.x+jitterX,y:spaceBoss.y+jitterY,r0:0,r1:260,t0:now,life:850,color:'255,180,120'});
          screenShake=Math.max(screenShake,6);
        }
        if(!anim.bigBang && now>=anim.explosionAt){
          anim.bigBang=true;
          anim.bigBangStart=now;
          screenShake=Math.max(screenShake,22);
          spawnParticles(spaceBoss.x,spaceBoss.y,'#fff2d6',260,3.8,5.6,6.4);
          spawnParticles(spaceBoss.x,spaceBoss.y,'#ffddb8',160,3.4,5.0,5.2);
          spaceBossBursts.push({type:'ring',x:spaceBoss.x,y:spaceBoss.y,r0:90,r1:660,width:36,t0:now,life:2200,color:'255,220,190'});
          spaceBossBursts.push({type:'flare',x:spaceBoss.x,y:spaceBoss.y,r0:0,r1:460,t0:now,life:2400,color:'255,244,220'});
          spaceBossBursts.push({type:'halo',x:spaceBoss.x,y:spaceBoss.y,r0:120,r1:720,t0:now,life:2600,color:'255,200,150'});
          playSFX('explosion');
          if(!anim.dropSpawned){
            spawnPower(spaceBoss.x-12, spaceBoss.y, {forceType:'NINE'});
            anim.dropSpawned=true;
          }
        }
        if(anim.bigBang && anim.bigBangStart && now-anim.bigBangStart<anim.bigExplosionEnd-anim.explosionAt){
          const theta=Math.random()*Math.PI*2;
          const dist=spaceBoss.w*0.4+Math.random()*spaceBoss.w*0.3;
          const px=spaceBoss.x+Math.cos(theta)*dist;
          const py=spaceBoss.y+Math.sin(theta)*dist;
          spaceBossBursts.push({type:'spark',x:px,y:py,r0:0,r1:320,t0:now,life:900,color:'255,210,180'});
        }
        if(now>=anim.vanishAt){
          spaceBossPhase='defeated';
          spaceBossDefeatedAt=now;
          spaceBoss=null;
          spaceBossDeathAnim=null;
        }
      }
    }
    for(let i=spaceBossBursts.length-1;i>=0;i--){ const fx=spaceBossBursts[i]; const life=fx.life||1000; if(now>fx.t0+life){ spaceBossBursts.splice(i,1); } }
    updateSpaceBossAttack(now);
    updateSpaceBossBullets(now);
    updateSpaceBossPaddleRespawn(now);
  }

  function startSpaceBossAttack(mode, now){
    if(!spaceBoss) return;
    const pr=paddleRect();
    spaceBossNextAttackAt=0;
    if(mode===1){
      spaceBossAttack={
        mode:1,
        state:'countdown',
        start:now,
        countdownEnd:now+3000,
        fireStart:now+3000,
        fireEnd:now+3000+SPACE_BOSS_GUN_FIRE_DURATION,
        lastShot:0
      };
      spaceBossMarquee={text:'å±éšªï¼ å¤ªç©ºæˆ°è‰¦å³å°‡é€²è¡Œç«åŠ›å£“åˆ¶!', start:now, fadeStart:now+3000, end:now+3200, style:'alert', countdownDuration:3000};
      playSFX('spaceBossVolleyCharge');
    }else{
      const baseTarget={x:pr.x+pr.w/2, y:pr.y+pr.h/2};
      const movement=spaceBossLastPaddleCenter-spaceBossPrevPaddleCenter;
      let dir=0;
      if(Math.abs(movement)>1){ dir = movement>0?1:-1; }
      spaceBossAttack={
        mode:2,
        state:'countdown',
        start:now,
        countdownEnd:now+3000,
        sweepStart:now+3000,
        sweepEnd:now+3000+SPACE_BOSS_LASER_SWEEP_DURATION,
        baseTarget,
        sweepDir:dir,
        maxSweep:1100/3,
        currentTarget:{...baseTarget},
        hitApplied:false
      };
      spaceBossMarquee={text:'å±éšªï¼ å¤ªç©ºæˆ°è‰¦å³å°‡ä½¿å‡ºè‡´å‘½é›·å°„!', start:now, fadeStart:now+3000, end:now+3200, style:'alert', countdownDuration:3000};
      playSFX('spaceBossLaserCharge');
    }
  }

  function updateSpaceBossAttack(now){
    if(level!==5) return;
    if(spaceBossPhase!=='active' || !spaceBoss){
      spaceBossAttack=null;
      return;
    }
    if(!spaceBossAttack){
      if(spaceBossNextAttackAt && now>=spaceBossNextAttackAt){
        const mode = Math.random()<0.5 ? 1 : 2;
        startSpaceBossAttack(mode, now);
      }
      return;
    }
    const atk=spaceBossAttack;
    if(atk.state==='countdown'){
      if(now>=atk.countdownEnd){
        if(atk.mode===1){
          atk.state='firing';
          atk.lastShot=0;
        }else{
          atk.state='sweeping';
          atk.currentTarget={...atk.baseTarget};
          playSFX('spaceBossLaserSweep');
        }
        spaceBossMarquee=null;
      }
      return;
    }
    if(atk.mode===1){
      if(now>=atk.fireEnd){
        spaceBossAttack=null;
        spaceBossNextAttackAt=now+SPACE_BOSS_ATTACK_INTERVAL;
        return;
      }
      if(now-atk.lastShot>=SPACE_BOSS_GUN_FIRE_RATE){
        const pr=paddleRect();
        let tx=pr.x+pr.w/2;
        let ty=pr.y+pr.h/2;
        if(pr.w<=0 || pr.h<=0){
          tx = spaceBossLastPaddleCenter || 1100/2;
          ty = 700-50;
        }
        for(const gun of spaceBoss.guns){
          const originX=spaceBoss.x+gun.offsetX;
          const originY=spaceBoss.y+gun.offsetY;
          const ang=Math.atan2(ty-originY, tx-originX);
          const speed=11;
          spaceBossBullets.push({x:originX, y:originY, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, born:now});
          spaceBossBursts.push({type:'muzzle',x:originX,y:originY,r0:6,r1:60,t0:now,life:220,color:'255,210,120'});
        }
        atk.lastShot=now;
        playSFX('spaceBossVolleyShot');
      }
    }else if(atk.mode===2){
      const sweepProg = Math.min(1, Math.max(0,(now-atk.sweepStart)/SPACE_BOSS_LASER_SWEEP_DURATION));
      const offset = atk.sweepDir * atk.maxSweep * sweepProg;
      atk.currentTarget = {x: atk.baseTarget.x + offset, y: atk.baseTarget.y};
      if(!atk.hitApplied){
        const pr=paddleRect();
        if(pr.w>0 && pr.h>0){
          const mounts=spaceBoss.lasers || [];
          for(const laser of mounts){
            const originX = spaceBoss.x + laser.offsetX;
            const originY = spaceBoss.y + laser.offsetY;
            if(segmentIntersectsRect(originX, originY, atk.currentTarget.x, atk.currentTarget.y, pr)){
              atk.hitApplied=true;
              spaceBossLaserStrike();
              break;
            }
          }
        }
      }
      if(now>=atk.sweepEnd){
        spaceBossAttack=null;
        spaceBossNextAttackAt=now+SPACE_BOSS_ATTACK_INTERVAL;
      }
    }
  }

  function updateSpaceBossBullets(now){
    for(let i=spaceBossBullets.length-1;i>=0;i--){
      const b=spaceBossBullets[i];
      b.x+=b.vx;
      b.y+=b.vy;
      if(b.x<-40||b.x>1140||b.y<-40||b.y>760){ spaceBossBullets.splice(i,1); continue; }
      let removed=false;
      for(let j=bricks.length-1;j>=0;j--){
        const bk=bricks[j];
        if(!bk?.fallingTreasure) continue;
        if(b.x>=bk.x && b.x<=bk.x+bk.w && b.y>=bk.y && b.y<=bk.y+bk.h){
          spawnParticles(b.x, b.y, '#ffe08a', 14, 2.0, 3.0, 2.8);
          damageBrick(j,1,'laser');
          spaceBossBullets.splice(i,1);
          removed=true;
          break;
        }
      }
      if(removed) continue;
      if(now<paddleGoneUntil) continue;
      const pr=paddleRect();
      if(b.x>=pr.x && b.x<=pr.x+pr.w && b.y>=pr.y && b.y<=pr.y+pr.h){
        spaceBossBullets.splice(i,1);
        spaceBossBulletHit(pr);
      }
    }
  }

  function spaceBossBulletHit(pr){
    const centerX=pr.x+pr.w/2;
    const centerY=pr.y+pr.h/2;
    spawnParticles(centerX, centerY, '#ffdf9a', 26, 2.4, 3.6, 3.2);
    screenShake=Math.max(screenShake,4);
    const desired=desiredPaddleWidth();
    const effective=Math.max(SPACE_BOSS_PADDLE_MIN_WIDTH, desired - spaceBossPaddlePenalty);
    if(effective-SPACE_BOSS_PADDLE_MIN_WIDTH>0.5){
      spaceBossPaddlePenalty=Math.min(desired - SPACE_BOSS_PADDLE_MIN_WIDTH, spaceBossPaddlePenalty + 10);
      computePaddleWidth();
      return;
    }
    const now=performance.now();
    if(now<paddleGoneUntil) return;
    spaceBossPaddlePenalty=0;
    computePaddleWidth();
    paddleGoneUntil=now+3000;
    spaceBossPaddleRespawnAt=paddleGoneUntil;
    spaceBossSuppressLifeLossUntil = spaceBossPaddleRespawnAt + 200;
    spawnParticles(centerX, centerY, '#ffb347', 80, 3.0, 4.4, 4.2);
    spaceBossBursts.push({type:'ring',x:centerX,y:centerY,r0:20,r1:220,width:18,t0:now,life:600,color:'255,180,90'});
    screenShake=Math.max(screenShake,10);
    lives--; updateHUD();
    if(lives<=0){ running=false; paused=true; showGameOver(); return; }
    balls.length=0;
  }

  function updateSpaceBossPaddleRespawn(now){
    if(spaceBossPaddleRespawnAt && now>=spaceBossPaddleRespawnAt){
      spaceBossPaddleRespawnAt=0;
      if(lives>0 && !paused){ resetBalls(false); startCountdown(); }
      spaceBossSuppressLifeLossUntil=0;
    }
  }

  function spaceBossLaserStrike(){
    if(paddleGoneUntil>performance.now()) return;
    lives=Math.max(0, lives-1);
    updateHUD();
    screenShake=Math.max(screenShake,12);
    const pr=paddleRect();
    spawnParticles(pr.x+pr.w/2, pr.y+pr.h/2, '#ff6a88', 60, 3.0, 4.6, 4.0);
    if(lives<=0){ running=false; paused=true; showGameOver(); return; }
    balls.length=0;
    paddleGoneUntil=performance.now()+1500;
    spaceBossPaddleRespawnAt=paddleGoneUntil+1500;
    spaceBossSuppressLifeLossUntil = spaceBossPaddleRespawnAt + 200;
  }

  function segmentIntersectsRect(x1,y1,x2,y2, rect){
    const rx=rect.x, ry=rect.y, rw=rect.w, rh=rect.h;
    const left=rx, right=rx+rw, top=ry, bottom=ry+rh;
    if(x1>=left && x1<=right && y1>=top && y1<=bottom) return true;
    if(x2>=left && x2<=right && y2>=top && y2<=bottom) return true;
    if(segmentsIntersect(x1,y1,x2,y2,left,top,right,top)) return true;
    if(segmentsIntersect(x1,y1,x2,y2,right,top,right,bottom)) return true;
    if(segmentsIntersect(x1,y1,x2,y2,right,bottom,left,bottom)) return true;
    if(segmentsIntersect(x1,y1,x2,y2,left,bottom,left,top)) return true;
    return false;
  }

  function segmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4){
    const denom=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
    if(Math.abs(denom)<1e-6) return false;
    const pre=(x1*y2 - y1*x2);
    const post=(x3*y4 - y3*x4);
    const x=(pre*(x3-x4)-(x1-x2)*post)/denom;
    const y=(pre*(y3-y4)-(y1-y2)*post)/denom;
    if(x<Math.min(x1,x2)-1e-6 || x>Math.max(x1,x2)+1e-6) return false;
    if(x<Math.min(x3,x4)-1e-6 || x>Math.max(x3,x4)+1e-6) return false;
    if(y<Math.min(y1,y2)-1e-6 || y>Math.max(y1,y2)+1e-6) return false;
    if(y<Math.min(y3,y4)-1e-6 || y>Math.max(y3,y4)+1e-6) return false;
    return true;
  }

  function drawSpaceBossLayer(){
    if(spaceBossPhase==='inactive' && !spaceBossBursts.length) return;
    const now=performance.now();
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    for(const fx of spaceBossBursts){
      const life=fx.life||1000;
      const prog=Math.max(0, Math.min(1, (now-fx.t0)/life));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      if(fx.type==='ring'){
        const rad=(fx.r0||0)+((fx.r1||200)-(fx.r0||0))*easeOut(prog);
        const alpha=1-prog;
        ctx.strokeStyle=`rgba(${fx.color||'255,255,255'},${0.55*alpha})`;
        ctx.lineWidth=(fx.width||14)*((scaleX+scaleY)/2)*(1-prog*0.7);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2), 0, Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='flare'){
        const rad=(fx.r1||200)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(10, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0, `rgba(${fx.color||'200,220,255'},${0.35*(1-prog)})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='spark'){
        const rad=(fx.r1||80)*prog*((scaleX+scaleY)/2);
        ctx.strokeStyle=`rgba(${fx.color||'160,220,255'},${0.7*(1-prog)})`;
        ctx.lineWidth=2*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.moveTo(fx.x*scaleX-rad, fx.y*scaleY);
        ctx.lineTo(fx.x*scaleX+rad, fx.y*scaleY);
        ctx.moveTo(fx.x*scaleX, fx.y*scaleY-rad);
        ctx.lineTo(fx.x*scaleX, fx.y*scaleY+rad);
        ctx.stroke();
      }else if(fx.type==='halo'){
        const rad=(fx.r0||30)+((fx.r1||220)-(fx.r0||30))*prog;
        ctx.strokeStyle=`rgba(${fx.color||'140,200,255'},${0.25*(1-prog)})`;
        ctx.lineWidth=8*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='muzzle'){
        const rad=(fx.r0||6)+((fx.r1||60)-(fx.r0||6))*prog;
        const alpha=1-prog;
        ctx.fillStyle=`rgba(${fx.color||'255,200,120'},${0.6*alpha})`;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2), 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }
    if(spaceBoss && (spaceBossPhase==='active' || spaceBossPhase==='intro' || spaceBossPhase==='dying')){
      drawSpaceBossShip(spaceBoss, now);
      drawSpaceBossAttacks(now);
    }else if(spaceBossPhase==='intro' && spaceBossAnchor){
      const cx=(spaceBossAnchor.x+spaceBossAnchor.w/2)*scaleX;
      const cy=(spaceBossAnchor.y+spaceBossAnchor.h+60)*scaleY;
      const rad=Math.max(spaceBossAnchor.w, spaceBossAnchor.h)*1.2*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      g.addColorStop(0,'rgba(140,200,255,0.18)');
      g.addColorStop(1,'rgba(140,200,255,0)');
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }else if(spaceBossPhase==='active' && !spaceBoss && spaceBossAttack){
      drawSpaceBossAttacks(now);
    }
  }

  function drawSpaceBossAttacks(now){
    ctx.save();
    for(const b of spaceBossBullets){
      const r=4*((scaleX+scaleY)/2);
      const grad=ctx.createRadialGradient(b.x*scaleX,b.y*scaleY,0,b.x*scaleX,b.y*scaleY,r);
      grad.addColorStop(0,'rgba(255,255,255,0.95)');
      grad.addColorStop(0.6,'rgba(255,200,140,0.8)');
      grad.addColorStop(1,'rgba(255,120,60,0)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(b.x*scaleX,b.y*scaleY,r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    if(spaceBossAttack && spaceBossAttack.mode===2 && spaceBossAttack.state==='sweeping' && spaceBoss){
      const target=spaceBossAttack.currentTarget;
      const mounts=spaceBoss.lasers||[];
      for(const laser of mounts){
        const ox=(spaceBoss.x+laser.offsetX);
        const oy=(spaceBoss.y+laser.offsetY);
        drawSpaceBossLaserBeam(ox, oy, target.x, target.y, now);
      }
    }
  }

  function drawSpaceBossLaserBeam(x1,y1,x2,y2, now){
    const sx1=x1*scaleX, sy1=y1*scaleY, sx2=x2*scaleX, sy2=y2*scaleY;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const pulse=0.7+0.3*Math.sin(now/60);
    ctx.strokeStyle=`rgba(255,90,110,${0.35*pulse})`;
    ctx.lineWidth=10;
    ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    const grad=ctx.createLinearGradient(sx1,sy1,sx2,sy2);
    grad.addColorStop(0,'rgba(255,200,200,0.4)');
    grad.addColorStop(1,'rgba(255,80,120,0.9)');
    ctx.strokeStyle=grad;
    ctx.lineWidth=5;
    ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    ctx.restore();
  }

  function drawSpaceBossShip(sb, now){
    const s=(scaleX+scaleY)/2;
    ctx.save();
    ctx.translate(sb.x*scaleX, sb.y*scaleY);
    const bodyW=sb.w*scaleX;
    const bodyH=sb.h*scaleY;
    const grad=ctx.createLinearGradient(-bodyW*0.5, -bodyH*0.6, bodyW*0.5, bodyH*0.6);
    grad.addColorStop(0,'rgba(130,210,255,0.95)');
    grad.addColorStop(0.45,'rgba(90,110,220,0.95)');
    grad.addColorStop(1,'rgba(24,32,82,0.98)');
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.45, -bodyH*0.45);
    ctx.quadraticCurveTo(0, -bodyH*0.75, bodyW*0.45, -bodyH*0.45);
    ctx.quadraticCurveTo(bodyW*0.62, 0, bodyW*0.45, bodyH*0.5);
    ctx.quadraticCurveTo(0, bodyH*0.8, -bodyW*0.45, bodyH*0.5);
    ctx.quadraticCurveTo(-bodyW*0.62, 0, -bodyW*0.45, -bodyH*0.45);
    ctx.closePath();
    ctx.fillStyle=grad;
    ctx.shadowColor='rgba(90,150,255,'+(0.35+(sb.hitFlashUntil && now<sb.hitFlashUntil?0.45:0))+')';
    ctx.shadowBlur=32*s;
    ctx.fill();
    ctx.shadowBlur=0;
    ctx.strokeStyle='rgba(220,240,255,0.45)';
    ctx.lineWidth=4*s;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-bodyW*0.6, -bodyH*0.05);
    ctx.quadraticCurveTo(-bodyW*0.9, bodyH*0.05, -bodyW*0.5, bodyH*0.55);
    ctx.lineTo(-bodyW*0.35, bodyH*0.3);
    ctx.closePath();
    ctx.fillStyle='rgba(40,60,120,0.85)';
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(bodyW*0.6, -bodyH*0.05);
    ctx.quadraticCurveTo(bodyW*0.9, bodyH*0.05, bodyW*0.5, bodyH*0.55);
    ctx.lineTo(bodyW*0.35, bodyH*0.3);
    ctx.closePath();
    ctx.fill();

    const cockpitGrad=ctx.createRadialGradient(0,-bodyH*0.18,0,0,-bodyH*0.18,bodyW*0.28);
    cockpitGrad.addColorStop(0,'rgba(255,255,255,0.9)');
    cockpitGrad.addColorStop(1,'rgba(90,130,220,0.45)');
    ctx.beginPath();
    ctx.ellipse(0, -bodyH*0.1, bodyW*0.28, bodyH*0.24, 0, 0, Math.PI*2);
    ctx.fillStyle=cockpitGrad;
    ctx.fill();

    const thrusters=[{x:-bodyW*0.25,y:bodyH*0.55},{x:bodyW*0.25,y:bodyH*0.55}];
    const thrusterPhase=sb.thrusterPhase||0;
    for(let i=0;i<thrusters.length;i++){
      const t=thrusters[i];
      const radius=(28+6*Math.sin(thrusterPhase*4+i*Math.PI))*s;
      const tg=ctx.createRadialGradient(t.x,t.y,0,t.x,t.y,Math.max(radius,10));
      tg.addColorStop(0,'rgba(255,240,180,0.95)');
      tg.addColorStop(0.6,'rgba(255,180,60,0.75)');
      tg.addColorStop(1,'rgba(255,120,0,0)');
      ctx.fillStyle=tg;
      ctx.beginPath();
      ctx.arc(t.x,t.y,Math.max(radius,10),0,Math.PI*2);
      ctx.fill();
    }

    for(const gun of sb.guns){
      const gx=gun.offsetX*scaleX;
      const gy=gun.offsetY*scaleY;
      ctx.save();
      ctx.translate(gx, gy);
      ctx.rotate(gun.angle);
      const barrelLen=34*s;
      const barrelWidth=8*s;
      ctx.fillStyle='rgba(160,210,255,0.95)';
      ctx.fillRect(-barrelWidth/2, -barrelLen, barrelWidth, barrelLen);
      ctx.save();
      ctx.translate(0, -barrelLen);
      ctx.rotate(gun.spin||0);
      for(let k=0;k<3;k++){
        const ang=k*Math.PI*2/3;
        ctx.beginPath();
        ctx.fillStyle='rgba(255,255,255,0.9)';
        ctx.arc(Math.cos(ang)*4*s, Math.sin(ang)*4*s, 2.4*s, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      ctx.restore();
      ctx.save();
      ctx.translate(gx, gy);
      ctx.fillStyle='#1c2246';
      ctx.beginPath(); ctx.arc(0,0,12*s,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(120,180,255,0.8)';
      ctx.lineWidth=2*s; ctx.stroke();
      ctx.restore();
    }

    for(const laser of sb.lasers){
      const lx=laser.offsetX*scaleX;
      const ly=laser.offsetY*scaleY;
      ctx.save();
      ctx.translate(lx, ly);
      ctx.rotate(laser.angle);
      const towerW=14*s;
      const towerH=48*s;
      const lg=ctx.createLinearGradient(0,0,0,-towerH);
      lg.addColorStop(0,'rgba(90,150,255,0.9)');
      lg.addColorStop(1,'rgba(220,255,255,0.6)');
      ctx.fillStyle=lg;
      ctx.fillRect(-towerW/2, -towerH, towerW, towerH);
      ctx.beginPath();
      ctx.strokeStyle='rgba(200,240,255,0.5)';
      ctx.lineWidth=2*s;
      ctx.moveTo(0,-towerH);
      ctx.lineTo(0,-towerH-12*s);
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.translate(lx, ly);
      ctx.fillStyle='#121b36';
      ctx.beginPath(); ctx.arc(0,0,14*s,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(80,140,255,0.8)';
      ctx.lineWidth=2*s; ctx.stroke();
      ctx.restore();
    }

    ctx.restore();
  }

  function drawSpaceBossMarquee(){
    if(!spaceBossMarquee) return;
    const now=performance.now();
    const {start, fadeStart, end, text} = spaceBossMarquee;
    const style=spaceBossMarquee.style||'marquee';
    if(now>=end){ spaceBossMarquee=null; return; }
    let alpha=1;
    if(style!=='victory' && now>fadeStart){ alpha = Math.max(0, 1 - (now - fadeStart)/(end - fadeStart||1)); }
    const fallbackCanvasWidth = (typeof canvas!=='undefined' && canvas && canvas.clientWidth) ? canvas.clientWidth : 0;
    const viewW = (typeof window!=='undefined' && window.innerWidth) ? window.innerWidth : fallbackCanvasWidth;
    let deviceBoost=1;
    if(viewW && viewW<=600){ deviceBoost=1.4; }
    else if(viewW && viewW<=900){ deviceBoost=1.18; }
    const scaleAvg=(scaleX+scaleY)/2;
    const textScale=Math.max(0.6, scaleAvg*deviceBoost);
    const numberScale=Math.max(0.6, scaleAvg*(deviceBoost>1?deviceBoost+0.05:1));
    const marqueeScale=Math.max(0.6, scaleAvg*(deviceBoost>1?deviceBoost:1));
    const areaHeightBase=52;
    const areaHeight = deviceBoost>1 ? Math.round(areaHeightBase * 1.18) : areaHeightBase;
    const topBase=Math.max(12, layout().top - areaHeight - 14);
    const x=40;
    const width=1100-80;
    const radius=18;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, topBase, width, areaHeight, radius);
    if(style==='victory'){
      const grad=ctx.createLinearGradient(x*scaleX, topBase*scaleY, x*scaleX, (topBase+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(40,56,104,0.95)');
      grad.addColorStop(1,'rgba(18,28,70,0.95)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,220,180,0.8)';
      ctx.lineWidth=2.4;
      drawRoundedRect(x, topBase, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+12;
      const innerY=topBase+6;
      const innerW=width-24;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-8);
      ctx.save();
      ctx.clip();
      ctx.fillStyle='rgba(255,235,210,0.18)';
      ctx.fillRect(innerX*scaleX, innerY*scaleY, innerW*scaleX, innerH*scaleY);
      ctx.restore();
      ctx.fillStyle='#ffeede';
      const victoryFont=Math.max(24, Math.round(28*marqueeScale));
      ctx.font=`${victoryFont}px 'Playfair Display', serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,220,170,0.6)';
      ctx.shadowBlur=18*marqueeScale;
      ctx.fillText(text, (x+width/2)*scaleX, (topBase+areaHeight/2)*scaleY);
      ctx.shadowBlur=0;
      ctx.strokeStyle='rgba(255,220,170,0.45)';
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo((x+32)*scaleX, (topBase+areaHeight-10)*scaleY);
      ctx.lineTo((x+width-32)*scaleX, (topBase+areaHeight-10)*scaleY);
      ctx.stroke();
    }else{
      const grad=ctx.createLinearGradient(x*scaleX, topBase*scaleY, x*scaleX, (topBase+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(32,48,92,0.9)');
      grad.addColorStop(1,'rgba(16,28,60,0.92)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(160,200,255,0.85)';
      ctx.lineWidth=2;
      drawRoundedRect(x, topBase, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+10;
      const innerY=topBase+6;
      const innerW=width-20;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.save();
      ctx.clip();
      if(style==='alert'){
        const midY=(innerY+innerH/2)*scaleY;
        ctx.fillStyle='#f5f9ff';
        const alertFont=Math.max(18, Math.round(24*textScale));
        ctx.font=`${alertFont}px 'Noto Sans TC','Playfair Display',sans-serif`;
        ctx.textBaseline='middle';
        ctx.textAlign='left';
        ctx.shadowColor='rgba(120,200,255,0.45)';
        ctx.shadowBlur=10*textScale;
        ctx.fillText(text, (innerX+16)*scaleX, midY);
        const cd=spaceBossMarquee.countdownDuration;
        if(cd){
          const remain=Math.max(0, cd - (now-start));
          const num=Math.max(0, Math.ceil(remain/1000));
          if(num>0){
            ctx.shadowBlur=0;
            ctx.fillStyle='rgba(255,180,140,0.9)';
            const countdownFont=Math.max(22, Math.round(32*numberScale));
            ctx.font=`${countdownFont}px 'Playfair Display',serif`;
            ctx.textAlign='right';
            ctx.fillText(String(num), (innerX+innerW-16)*scaleX, midY);
          }
        }
      } else {
        const pxSpeed=180;
        const baseX=(innerX+innerW)*scaleX;
        const midY=(innerY+innerH/2)*scaleY;
        ctx.fillStyle='#f5f9ff';
        const marqueeFont=Math.max(18, Math.round(24*marqueeScale));
        ctx.font=`${marqueeFont}px 'Noto Sans TC','Playfair Display',sans-serif`;
        ctx.textBaseline='middle';
        ctx.shadowColor='rgba(120,200,255,0.55)';
        ctx.shadowBlur=12*marqueeScale;
        const repeated=`âœ¦  ${text}  âœ¦  `;
        const textWidth=Math.max(1, ctx.measureText(repeated).width);
        let drawX = baseX - ((now-start)/1000*pxSpeed % textWidth);
        while(drawX > (innerX- textWidth/scaleX)*scaleX){ drawX -= textWidth; }
        while(drawX < (innerX + innerW)*scaleX){ ctx.fillText(repeated, drawX, midY); drawX += textWidth; }
      }
    }
    ctx.restore();
    ctx.restore();
  }

  function drawBossNameplate(name, hp, maxHp, x, y, barW, barH, palette){
    const scaleAvg=(scaleX+scaleY)/2;
    const textPrimary=palette.textPrimary||'#f0f4ff';
    const textSecondary=palette.textSecondary||'#f7f9ff';
    const glow=palette.glow||'rgba(120,180,255,0.45)';
    const safeLeft=24*scaleAvg;
    const safeRight=canvas.width - 28*scaleAvg;
    const labelAnchor=(x - 18)*scaleX;
    ctx.save();
    ctx.textAlign='left';

    const nameFont=Math.max(10, Math.round(13*1.2*scaleAvg));
    ctx.font=`${nameFont}px 'Noto Sans TC','Playfair Display',sans-serif`;
    ctx.textBaseline='bottom';
    ctx.fillStyle=textPrimary;
    ctx.shadowColor=glow;
    ctx.shadowBlur=6*scaleAvg;
    const nameMetrics=ctx.measureText(name);
    let nameX=Math.max(safeLeft, Math.min(labelAnchor, safeRight - nameMetrics.width));
    ctx.fillText(name, nameX, (y - 8)*scaleY);
    ctx.shadowBlur=0;

    const hpFont=Math.max(12, Math.round(12*1.5*scaleAvg));
    ctx.font=`${hpFont}px 'Playfair Display','Noto Sans TC',sans-serif`;
    ctx.textBaseline='top';
    ctx.fillStyle=textSecondary;
    const hpText=`${hp.toLocaleString()}/${maxHp.toLocaleString()}`;
    const hpMetrics=ctx.measureText(hpText);
    let hpX=Math.max(safeLeft, Math.min(labelAnchor, safeRight - hpMetrics.width));
    ctx.fillText(hpText, hpX, (y + barH + 8)*scaleY);
    ctx.restore();
  }

  function drawSpaceBossHPBar(){
    if(spaceBossPhase!=='active' || !spaceBoss) return;
    const L=layout();
    const barW=32;
    const maxH = 700 - (L.top + 80);
    const barH=Math.max(180, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, spaceBoss.hp/spaceBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(34,56,104,0.95)');
    frameGrad.addColorStop(1,'rgba(18,26,62,0.9)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(170,210,255,0.55)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(10,18,42,0.92)');
    bg.addColorStop(1,'rgba(20,30,60,0.88)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(255,120,150,0.2)');
      fillGrad.addColorStop(0.4,'rgba(255,140,160,0.55)');
      fillGrad.addColorStop(1,'rgba(255,230,240,0.95)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    const segments=10;
    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - innerH*i/segments)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS å¤ªç©ºæˆ°è‰¦', spaceBoss.hp, spaceBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(32,52,92,0.94)',
      bgBottom:'rgba(18,28,60,0.9)',
      frame:'rgba(170,210,255,0.75)',
      glow:'rgba(140,200,255,0.6)',
      textPrimary:'#e9f2ff',
      textSecondary:'#f0f5ff'
    });
    ctx.restore();
  }

  function drawSpaceBossHUD(){
    drawSpaceBossMarquee();
    drawSpaceBossHPBar();
  }

  // === ç¬¬10é—œ æš—é»‘æ­»ç¥ Boss ===
  function startReaperReveal(){
    if(reaperPhase!=='awaiting') return;
    const now=performance.now();
    reaperPhase='intro';
    let anchor=reaperAnchor;
    if(reaperPlaceholder){
      anchor={x:reaperPlaceholder.x, y:reaperPlaceholder.y, w:reaperPlaceholder.w, h:reaperPlaceholder.h};
      const cx=anchor.x+anchor.w/2;
      const cy=anchor.y+anchor.h/2;
      spawnParticles(cx,cy,'#fdf0ff',140,3.2,5.2,5.6);
      spawnParticles(cx,cy,'#c4a6ff',110,2.8,4.4,4.8);
      spawnParticles(cx,cy,'#ff96cf',90,2.4,3.8,4.2);
      reaperBursts.push({type:'ring',x:cx,y:cy,r0:28,r1:420,width:18,t0:now,life:1400,color:'220,140,255'});
      reaperBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:260,t0:now,life:1200,color:'150,110,220'});
      reaperBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:180,t0:now,life:950,color:'255,160,220'});
      const idx=bricks.indexOf(reaperPlaceholder);
      if(idx>=0) bricks.splice(idx,1);
      reaperPlaceholder=null;
      reaperAnchor=anchor;
    }
    if(!reaperAnchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      const anchorW=brickW*2+L.pad;
      const anchorH=brickH*2+L.pad;
      const anchorX=L.pad + bx*(brickW+L.pad);
      reaperAnchor={x:anchorX,y:L.top,w:anchorW,h:anchorH};
    }
    reaperRevealScheduled = now + 900;
    reaperMarquee={text:'æœ‰ä¸€å¥—ï¼ è®“æˆ‘è¦ªè‡ªæœƒæœƒä½ !', start:now, fadeStart:now+5000, end:now+8000, style:'alert'};
    screenShake=Math.max(screenShake,8);
    playSFX('fireExplosion');
  }

  function activateReaperBoss(){
    if(reaperPhase!=='intro' || reaperBoss) return;
    let anchor=reaperAnchor;
    if(!anchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      anchor={x:L.pad + bx*(brickW+L.pad), y:L.top, w:brickW*2+L.pad, h:brickH*2+L.pad};
      reaperAnchor=anchor;
    }
    const cx=anchor.x+anchor.w/2;
    const baseY=anchor.y+anchor.h+140;
    const now=performance.now();
    reaperBoss={
      x:cx,
      y:baseY,
      baseY,
      w:160,
      h:220,
      vx:(Math.random()<0.5?-1:1)*1.6,
      hp:40,
      maxHp:40,
      hitCooldownUntil:0,
      hitFlashUntil:0,
      spawnAt:now,
      cloakPhase:Math.random()*Math.PI*2,
      hiddenUntil:0
    };
    reaperTeleportSchedule={
      nextSingle: now + 10000,
      nextBurst: now + 30000,
      burstRemaining: 0,
      burstInterval: 220,
      nextBurstTeleport: 0,
      burstActive:false
    };
    reaperPhase='active';
    reaperAttackState={nextAttack: now + 15000, current:null};
    reaperSlashZone=null;
    reaperBlackHoleAttack=null;
    reaperBursts.push({type:'halo',x:cx,y:baseY-40,r0:60,r1:320,t0:now,life:1700,color:'200,140,255'});
    screenShake=Math.max(screenShake,6);
    scheduleNextTreasureBrick(now);
  }

  function performReaperTeleport(rapid=false){
    if(!reaperBoss) return;
    const now=performance.now();
    const oldX=reaperBoss.x;
    const oldY=reaperBoss.y;
    reaperAfterimages.push({x:oldX,y:oldY,t0:now,life:700,scale:1});
    const L=layout();
    const minX=140, maxX=1100-140;
    const minY=L.top+90, maxY=L.top+320;
    reaperBursts.push({type:'ring',x:oldX,y:oldY,r0:30,r1:260,width:16,t0:now,life:800,color:'210,130,255'});
    reaperBursts.push({type:'flare',x:oldX,y:oldY,r0:0,r1:200,t0:now,life:720,color:'150,110,220'});
    const newX = minX + Math.random()*(maxX-minX);
    const newY = minY + Math.random()*(maxY-minY);
    reaperBoss.x = newX;
    reaperBoss.y = newY;
    reaperAfterimages.push({x:newX,y:newY,t0:now,life:520,scale:1.12,emerge:true});
    reaperBursts.push({type:'flare',x:newX,y:newY,r0:0,r1:240,t0:now,life:760,color:'255,150,210'});
    const freq=rapid?760:680;
    beep(freq,0.04,0.04);
    beep(freq-240,0.03,0.05);
    screenShake=Math.max(screenShake, rapid?4:3);
  }

  function reaperApplyLifeLoss(now, reason='reaper'){
    if(now<reaperLifeLossCooldownUntil) return;
    if(now<paddleGoneUntil) return;
    reaperLifeLossCooldownUntil = now + 600;
    if(stats.lifeStart){
      const dur=(now-stats.lifeStart)/1000;
      if(dur<stats.fastestDeath) stats.fastestDeath=dur;
      if(dur>stats.longestLife) stats.longestLife=dur;
    }
    stats.livesUsed++;
    if(buffs.BLACKHOLE.active){ buffs.BLACKHOLE.deaths=Math.min(8,(buffs.BLACKHOLE.deaths||0)+1); }
    if(buffs.ANNIHIL.active){ buffs.ANNIHIL.active=false; }
    lives=Math.max(0, lives-1);
    updateHUD();
    const pr=paddleRect();
    const cx=pr.x+pr.w/2;
    const cy=pr.y+pr.h/2;
    spawnParticles(cx, cy, '#ff6a9a', 70, 2.6, 3.8, 3.4);
    screenShake=Math.max(screenShake,12);
    playSFX('explosion');
    balls.length=0;
    if(lives<=0){ running=false; paused=true; showGameOver(); return; }
    resetBalls(false);
    startCountdown();
  }

  function startReaperSlash(now){
    const segment=Math.floor(Math.random()*3);
    const zoneWidth=1100/3;
    const zoneHeight=140;
    const zoneX=segment*zoneWidth;
    const zoneY=700-zoneHeight;
    reaperSlashZone={x:zoneX,y:zoneY,w:zoneWidth,h:zoneHeight,start:now,countdownEnd:now+3000};
    reaperMarquee={text:'å±éšªï¼ æš—é»‘æ­»ç¥å³å°‡ä½¿å‡ºæ­»ç¥æ–¬!', start:now, fadeStart:now+3000, end:now+3000, style:'alert'};
    return {
      type:'slash',
      stage:'countdown',
      start:now,
      countdownEnd:now+3000,
      area:{x:zoneX,y:zoneY,w:zoneWidth,h:zoneHeight},
      slashes:0,
      nextSlash:now+3000,
      vanishEnd:0,
      resolved:false,
      reappeared:false
    };
  }

  function spawnReaperSlashStrike(state, now){
    const area=state.area;
    const baseX=area.x + Math.random()*area.w;
    const len=area.h*1.8;
    const angle=-Math.PI/3 + Math.random()*(2*Math.PI/3);
    const cos=Math.cos(angle);
    const sin=Math.sin(angle);
    const centerY=area.y + area.h*0.4;
    const x1=baseX - cos*len;
    const y1=area.y + area.h - sin*len;
    const x2=baseX + cos*len;
    const y2=area.y + area.h + sin*len;
    reaperSlashEffects.push({x1,y1,x2,y2,start:now,life:240});
    reaperBursts.push({type:'flare',x:baseX,y:centerY,r0:0,r1:240,t0:now,life:240,color:'255,80,120'});
    spawnParticles(baseX, centerY, '#ff6a88', 20, 1.6, 2.6, 2.4);
    screenShake=Math.max(screenShake,8);
    playSFX('sword');
    const pr=paddleRect();
    if(pr.w>0 && segmentIntersectsRect(x1,y1,x2,y2, pr)){
      reaperApplyLifeLoss(now,'reaperSlash');
    }
    for(let j=bricks.length-1;j>=0;j--){
      const bk=bricks[j];
      if(!bk?.fallingTreasure) continue;
      if(segmentIntersectsRect(x1,y1,x2,y2, bk)){
        spawnParticles(bk.x+bk.w/2, bk.y+bk.h/2, '#ffd6ff', 16, 2.0, 3.2, 3.0);
        damageBrick(j,1,'sword');
      }
    }
  }

  function updateReaperSlash(state, now){
    if(state.stage==='countdown'){
      if(now>=state.countdownEnd){
        state.stage='slashing';
        state.nextSlash=now;
        state.vanishEnd=now+3000;
        if(reaperBoss){ reaperBoss.hiddenUntil = Math.max(reaperBoss.hiddenUntil||0, state.vanishEnd); }
        reaperSlashZone=null;
      }
    }else if(state.stage==='slashing'){
      if(state.slashes<30 && now>=state.nextSlash){
        spawnReaperSlashStrike(state, now);
        state.slashes++;
        state.nextSlash=now+100;
        if(state.slashes>=30){ state.stage='recover'; }
      }
      if(now>=state.vanishEnd){ state.stage='recover'; }
    }
    if(state.stage==='recover'){
      if(!state.reappeared && reaperBoss && now>=state.vanishEnd){
        state.reappeared=true;
        reaperBoss.hiddenUntil=0;
        reaperAfterimages.push({x:reaperBoss.x,y:reaperBoss.y,t0:now,life:520,scale:1.05,emerge:true});
      }
      if(now>=state.vanishEnd+400){ state.resolved=true; }
    }
    if(state.resolved){
      reaperAttackState.current=null;
      reaperAttackState.nextAttack = now + 15000;
    }
  }

  function startReaperBlackHole(now){
    const state={
      type:'blackhole',
      stage:'countdown',
      start:now,
      countdownEnd:now+3000,
      projectile:null,
      projectileTrail:[],
      hole:null,
      resolved:false,
      baseDesiredWidth:desiredPaddleWidth(),
      didKill:false
    };
    reaperMarquee={text:'å±éšªï¼ æš—é»‘æ­»ç¥å³å°‡ä½¿å‡ºé»‘æ´åå™¬!', start:now, fadeStart:now+3000, end:now+3000, style:'alert'};
    reaperBlackHoleAttack=state;
    return state;
  }

  function applyReaperHolePull(hole, now){
    const pr=paddleRect();
    const px=pr.x+pr.w/2;
    const py=pr.y+pr.h/2;
    const radius = hole?.radius || hole?.r || 0;
    const dx=hole.x - px;
    const dy=hole.y - py;
    const dist=Math.hypot(dx, dy);
    const influence = radius>0 ? Math.max(0, 1 - dist/(radius)) : 1;
    if(!orientLeft){
      paddle.x += dx*0.024*influence;
      paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x));
    }else{
      paddle.y += dy*0.028*influence;
      paddle.y=Math.max(0, Math.min(700-paddle.w, paddle.y));
    }
    const pullRange = radius>0 ? radius*1.35 : 220;
    for(const p of powerups){
      const cx=p.x + p.w/2;
      const cy=p.y + p.h/2;
      const pdx=hole.x - cx;
      const pdy=hole.y - cy;
      const pdist=Math.hypot(pdx, pdy);
      if(pdist>pullRange) continue;
      const weight = Math.max(0, 1 - pdist/pullRange);
      p.x += pdx * 0.06 * weight;
      p.y += pdy * 0.06 * weight;
      p.x = Math.max(-20, Math.min(1100 - p.w + 20, p.x));
      p.y = Math.max(-40, Math.min(720, p.y));
    }
  }

  function updateReaperBlackHole(state, now){
    if(state.stage==='countdown'){
      if(now>=state.countdownEnd){
        state.stage='projectile';
        if(reaperBoss){
          const pr=paddleRect();
          const targetX=pr.x+pr.w/2;
          const targetY=pr.y+pr.h/2;
          const startX=reaperBoss.x;
          const startY=reaperBoss.y-reaperBoss.h*0.2;
          const dx=targetX-startX;
          const dy=(targetY-startY);
          const dist=Math.hypot(dx,dy)||1;
          const speed=4.5;
          state.projectile={x:startX,y:startY,vx:(dx/dist)*speed,vy:(dy/dist)*speed,radius:22};
          state.projectileTrail=[];
          playSFX('blackhole');
        }else{
          state.resolved=true;
        }
      }
    }else if(state.stage==='projectile'){
      const proj=state.projectile;
      if(!proj){
        state.resolved=true;
      }else{
        proj.x+=proj.vx;
        proj.y+=proj.vy;
        state.projectileTrail.push({x:proj.x,y:proj.y,t:now});
        if(state.projectileTrail.length>18) state.projectileTrail.shift();
        if(proj.y>=700-100){
          const holeX=proj.x;
          const holeY=700-90;
          const holeRadius=Math.round(160*0.7);
          const spinDir=(Math.random()>0.5?1:-1);
          state.hole={x:holeX,y:holeY,start:now,end:now+3000,nextTick:now+1000,baseDesired:state.baseDesiredWidth,radius:holeRadius,spinDir,vortexPhase:Math.random()*Math.PI*2};
          reaperBursts.push({type:'ring',x:holeX,y:holeY-60,r0:40,r1:360,width:22,t0:now,life:1600,color:'210,170,255'});
          reaperBursts.push({type:'flare',x:holeX,y:holeY-40,r0:0,r1:320,t0:now,life:1400,color:'170,140,255'});
          blackHoles.push({x:holeX,y:holeY,r:holeRadius,until:now+3000,start:now,spinDir});
          state.stage='hole';
          state.projectile=null;
          state.projectileTrail=[];
        }
      }
    }else if(state.stage==='hole'){
      const hole=state.hole;
      if(!hole){
        state.resolved=true;
      }else{
        applyReaperHolePull(hole, now);
        if(now>=hole.nextTick){
          const prNow=paddleRect();
          const px=prNow.x+prNow.w/2;
          const py=prNow.y+prNow.h/2;
          const radius=hole.radius || hole.r || 0;
          const dist=Math.hypot((hole.x||0)-px, (hole.y||0)-py);
          const inRange = radius<=0 || dist<=radius;
          if(inRange){
            const desired=Math.max(hole.baseDesired||0, desiredPaddleWidth());
            hole.baseDesired=desired;
            const cap=Math.max(0, desired - REAPER_PADDLE_MIN_WIDTH);
            if(reaperPaddlePenalty < cap){
              const before=reaperPaddlePenalty;
              reaperPaddlePenalty=Math.min(cap, reaperPaddlePenalty + 40);
              if(reaperPaddlePenalty!==before){ computePaddleWidth(); }
            }else if(!state.didKill){
              reaperApplyLifeLoss(now,'blackhole');
              state.didKill=true;
            }
          }
          hole.nextTick = now + 1000;
        }
        if(now>=hole.end){ state.resolved=true; }
      }
    }
    if(state.resolved){
      reaperAttackState.current=null;
      reaperAttackState.nextAttack = now + 15000;
      reaperBlackHoleAttack=null;
    }
  }

  function updateReaperAttacks(now){
    if(reaperPhase!=='active' || !reaperBoss) return;
    if(!reaperAttackState){ reaperAttackState={nextAttack: now + 15000, current:null}; }
    if(reaperAttackState.current){
      const curr=reaperAttackState.current;
      if(curr.type==='slash'){ updateReaperSlash(curr, now); }
      else if(curr.type==='blackhole'){ updateReaperBlackHole(curr, now); }
      return;
    }
    if(now>=reaperAttackState.nextAttack){
      const modes=['slash','blackhole'];
      const pick=modes[Math.floor(Math.random()*modes.length)];
      if(pick==='slash'){ reaperAttackState.current=startReaperSlash(now); }
      else { reaperAttackState.current=startReaperBlackHole(now); }
    }
  }

  function damageReaperBoss(amount=1, source='generic', impact){
    if(reaperPhase!=='active' || !reaperBoss) return false;
    const now=performance.now();
    if(reaperBoss.hiddenUntil && now<reaperBoss.hiddenUntil) return false;
    if(reaperBoss.hitCooldownUntil && now<reaperBoss.hitCooldownUntil) return false;
    const dmg = amount>0?1:0;
    if(!dmg) return false;
    reaperBoss.hitCooldownUntil = now + 160;
    reaperBoss.hp = Math.max(0, reaperBoss.hp - dmg);
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    reaperBoss.hitFlashUntil = now + 260;
    const jitterX=(Math.random()-0.5)*reaperBoss.w*0.35;
    const jitterY=(Math.random()-0.5)*reaperBoss.h*0.25;
    const colorMap={
      laser:'240,190,255',
      missile:'255,200,200',
      gatling:'255,210,200',
      plasma:'200,230,255',
      blackhole:'210,220,255',
      phoenix:'255,180,210',
      sword:'255,200,220',
      holy:'255,240,220'
    };
    const burstColor=colorMap[source]||'210,150,255';
    reaperBursts.push({type:'spark',x:reaperBoss.x+jitterX,y:reaperBoss.y+jitterY,r0:0,r1:150,t0:now,life:720,color:burstColor});
    spawnParticles(reaperBoss.x+jitterX, reaperBoss.y+jitterY, '#d9c7ff', 20, 1.5, 2.6, 2.4);
    if(impact && impact.x!=null && impact.y!=null){
      spawnParticles(impact.x, impact.y, '#ff9bd0', 16, 1.4, 2.4, 2.2);
    }
    screenShake=Math.max(screenShake,5);
    const toneMap={laser:760, missile:680, gatling:720, plasma:780, blackhole:660, phoenix:820, sword:880, ball:800, holy:920};
    const freq=toneMap[source]||780;
    beep(freq,0.04,0.04);
    if(reaperBoss.hp<=0){ defeatReaperBoss(); }
    return true;
  }

  function defeatReaperBoss(){
    if(reaperPhase!=='active' || !reaperBoss) return;
    const now=performance.now();
    const rb=reaperBoss;
    addScore(BOSS_DEFEAT_SCORE.reaper);
    stats.bossKills++;
    updateHUD();
    reaperAttackState=null;
    reaperSlashZone=null;
    reaperSlashEffects=[];
    reaperBlackHoleAttack=null;
    reaperPaddlePenalty=0;
    reaperPenaltyLastUpdate=0;
    computePaddleWidth();
    reaperPhase='dying';
    reaperDefeatedAt=now;
    reaperTeleportSchedule=null;
    reaperDeathAnim={
      start:now,
      startY:rb.y,
      dropDistance:260,
      fallDuration:3000,
      bigExplosionStart:now+3000,
      bigExplosionEnd:now+5000,
      vanishAt:now+5000,
      finishAt:now+8000,
      lastBurst:now,
      smallBurstInterval:180,
      bigBang:false,
      lastX:rb.x,
      lastY:rb.y,
      lastW:rb.w,
      lastH:rb.h,
      dropSpawned:false
    };
    reaperBursts.push({type:'ring',x:rb.x,y:rb.y,r0:60,r1:560,width:26,t0:now,life:2200,color:'255,170,230'});
    reaperBursts.push({type:'flare',x:rb.x,y:rb.y,r0:0,r1:360,t0:now,life:1900,color:'210,140,255'});
    spawnParticles(rb.x, rb.y, '#ffe5ff', 180, 3.4, 5.6, 6.2);
    screenShake=Math.max(screenShake,14);
    playSFX('fireExplosion');
    reaperMarquee={text:'æˆåŠŸæ“Šæ®ºBoss: æš—é»‘æ­»ç¥!', start:now, fadeStart:now+5000, end:now+5000, style:'victorySolid'};
    nextTreasureBrickAt=0;
  }

  function updateReaperBoss(){
    if(level!==10) return;
    const now=performance.now();
    if(reaperPhase==='intro' && !reaperBoss && reaperRevealScheduled && now>=reaperRevealScheduled){ activateReaperBoss(); }
    if(reaperPhase==='active' && reaperBoss){
      reaperBoss.x += reaperBoss.vx;
      const margin=150;
      if(reaperBoss.x - reaperBoss.w/2 < margin){ reaperBoss.x = margin + reaperBoss.w/2; reaperBoss.vx = Math.abs(reaperBoss.vx); }
      if(reaperBoss.x + reaperBoss.w/2 > 1100 - margin){ reaperBoss.x = 1100 - margin - reaperBoss.w/2; reaperBoss.vx = -Math.abs(reaperBoss.vx); }
      reaperBoss.y = reaperBoss.baseY + Math.sin((now - reaperBoss.spawnAt)/780)*42;
      reaperBoss.cloakPhase += 0.03;
      const activeAttack=reaperAttackState && reaperAttackState.current;
      const teleportLocked = !!(activeAttack && activeAttack.stage && activeAttack.stage!=='countdown');
      if(reaperTeleportSchedule && !teleportLocked){
        if(reaperTeleportSchedule.burstActive){
          if(now>=reaperTeleportSchedule.nextBurstTeleport){
            performReaperTeleport(true);
            reaperTeleportSchedule.burstRemaining--;
            if(reaperTeleportSchedule.burstRemaining>0){
              reaperTeleportSchedule.nextBurstTeleport = now + reaperTeleportSchedule.burstInterval;
            }else{
              reaperTeleportSchedule.burstActive=false;
              reaperTeleportSchedule.nextSingle = now + 10000;
              reaperTeleportSchedule.nextBurst = now + 30000;
            }
          }
        }else if(now>=reaperTeleportSchedule.nextBurst){
          reaperTeleportSchedule.burstActive=true;
          reaperTeleportSchedule.burstRemaining=5;
          reaperTeleportSchedule.nextBurstTeleport=now;
          performReaperTeleport(true);
          reaperTeleportSchedule.burstRemaining--;
          if(reaperTeleportSchedule.burstRemaining>0){
            reaperTeleportSchedule.nextBurstTeleport = now + reaperTeleportSchedule.burstInterval;
          }else{
            reaperTeleportSchedule.burstActive=false;
            reaperTeleportSchedule.nextSingle = now + 10000;
            reaperTeleportSchedule.nextBurst = now + 30000;
          }
        }else if(now>=reaperTeleportSchedule.nextSingle){
          performReaperTeleport(false);
          reaperTeleportSchedule.nextSingle = now + 10000;
        }
      }
      updateReaperAttacks(now);
    }else if(reaperAttackState && reaperAttackState.current){
      updateReaperAttacks(now);
    }
    if(reaperPhase==='dying'){
      const anim=reaperDeathAnim;
      if(anim){
        const bossSprite=reaperBoss;
        const elapsed=now-anim.start;
        const prog=Math.max(0, Math.min(1, elapsed/anim.fallDuration));
        if(bossSprite){
          bossSprite.y = anim.startY + anim.dropDistance*prog;
          bossSprite.vx = 0;
          anim.lastX = bossSprite.x;
          anim.lastY = bossSprite.y;
          anim.lastW = bossSprite.w;
          anim.lastH = bossSprite.h;
        }
        if(now-anim.lastBurst>=(anim.smallBurstInterval||220) && now<anim.bigExplosionStart && bossSprite){
          anim.lastBurst=now;
          anim.smallBurstInterval=140+Math.random()*120;
          const sx=bossSprite.x + (Math.random()-0.5)*bossSprite.w*0.7;
          const sy=bossSprite.y + (Math.random()-0.5)*bossSprite.h*0.7;
          reaperBursts.push({type:'spark',x:sx,y:sy,r0:0,r1:200,t0:now,life:920,color:'255,170,220'});
          reaperBursts.push({type:'flare',x:sx,y:sy,r0:0,r1:280,t0:now,life:700,color:'200,120,255'});
          spawnParticles(sx, sy, '#ffd9f1', 34, 1.8, 3.2, 3.6);
        }
        if(!anim.bigBang && now>=anim.bigExplosionStart){
          anim.bigBang=true;
          const bx=anim.lastX;
          const by=anim.lastY;
          spawnParticles(bx, by, '#fff0ff', 280, 3.8, 6.2, 6.6);
          spawnParticles(bx, by, '#ffe0ff', 220, 3.4, 5.6, 6.0);
          reaperBursts.push({type:'ring',x:bx,y:by,r0:80,r1:640,width:34,t0:now,life:2200,color:'255,200,240'});
          reaperBursts.push({type:'flare',x:bx,y:by,r0:0,r1:480,t0:now,life:2000,color:'230,170,255'});
          reaperBursts.push({type:'halo',x:bx,y:by,r0:120,r1:720,t0:now,life:2400,color:'255,180,240'});
          screenShake=Math.max(screenShake,16);
          playSFX('fireExplosion');
          if(!anim.dropSpawned){
            spawnPower(bx-12, by, {forceType:'NINE'});
            anim.dropSpawned=true;
          }
        }
        if(anim.bigBang && now<anim.bigExplosionEnd){
          const theta=Math.random()*Math.PI*2;
          const spanW=(bossSprite?bossSprite.w:(anim.lastW||120));
          const dist=spanW*0.5 + Math.random()*spanW*0.5;
          const px=anim.lastX + Math.cos(theta)*dist;
          const py=anim.lastY + Math.sin(theta)*dist;
          reaperBursts.push({type:'spark',x:px,y:py,r0:0,r1:320,t0:now,life:860,color:'255,190,240'});
        }
        if(bossSprite && now>=anim.vanishAt){
          reaperBoss=null;
        }
        if(now>=anim.finishAt){
          reaperPhase='defeated';
          reaperDefeatedAt=now;
          reaperDeathAnim=null;
        }
      }
    }
    for(let i=reaperBursts.length-1;i>=0;i--){ const fx=reaperBursts[i]; const life=fx.life||1000; if(now>fx.t0+life) reaperBursts.splice(i,1); }
    for(let i=reaperAfterimages.length-1;i>=0;i--){ const af=reaperAfterimages[i]; if(now>af.t0+(af.life||600)) reaperAfterimages.splice(i,1); }
    for(let i=reaperSlashEffects.length-1;i>=0;i--){ const slash=reaperSlashEffects[i]; if(now>slash.start+(slash.life||200)){ reaperSlashEffects.splice(i,1); } }
    if(!reaperPenaltyLastUpdate) reaperPenaltyLastUpdate=now;
    const activeHole = reaperBlackHoleAttack && reaperBlackHoleAttack.stage==='hole';
    if(reaperPaddlePenalty>0){
      if(!activeHole){
        const dt=now - reaperPenaltyLastUpdate;
        if(dt>0){
          const recover=(dt/1000)*120;
          if(recover>0){
            const before=reaperPaddlePenalty;
            reaperPaddlePenalty=Math.max(0, reaperPaddlePenalty - recover);
            if(Math.abs(before-reaperPaddlePenalty)>0.5){ computePaddleWidth(); }
          }
        }
      }
    }
    reaperPenaltyLastUpdate=now;
  }

  function drawReaperBoss(rb, now){
    const s=(scaleX+scaleY)/2;
    ctx.save();
    ctx.translate(rb.x*scaleX, rb.y*scaleY);
    if(rb.hiddenUntil && now<rb.hiddenUntil){
      const fade=1-Math.max(0, Math.min(1,(rb.hiddenUntil-now)/3000));
      const radius=rb.w*0.9*s*(1+0.1*Math.sin(now/160));
      const grad=ctx.createRadialGradient(0,0,radius*0.2,0,0,radius);
      grad.addColorStop(0,`rgba(130,90,200,${0.18+0.22*fade})`);
      grad.addColorStop(1,'rgba(130,90,200,0)');
      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(0,0,radius,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
      return;
    }
    const float=Math.sin((now-rb.spawnAt)/520 + rb.cloakPhase*0.6)*8*s;
    ctx.translate(0, float);

    const bodyW=rb.w*0.58*s;
    const bodyH=rb.h*0.64*s;
    const flutterA=Math.sin(now/340 + rb.cloakPhase)*0.28;
    const flutterB=Math.sin(now/220 + rb.cloakPhase*1.4)*0.22;
    const flutterC=Math.sin(now/180 + rb.cloakPhase*0.8)*0.18;

    ctx.save();
    const cloakPath=new Path2D();
    cloakPath.moveTo(-bodyW*0.5, -bodyH*0.08);
    cloakPath.quadraticCurveTo(-bodyW*0.86, -bodyH*0.86, -bodyW*0.28, -bodyH*1.32);
    cloakPath.quadraticCurveTo(0, -bodyH*1.44, bodyW*0.28, -bodyH*1.32);
    cloakPath.quadraticCurveTo(bodyW*0.86, -bodyH*0.86, bodyW*0.5, -bodyH*0.08);
    const ragged=12;
    for(let i=0;i<=ragged;i++){
      const t=i/ragged;
      const offset=-bodyW*0.5 + t*bodyW;
      const sway=Math.sin(now/540 + rb.cloakPhase*0.7 + t*Math.PI)*bodyW*0.08;
      const drop=bodyH*(1.04 + 0.18*Math.sin(t*Math.PI + now/320));
      const wave=Math.sin(now/280 + rb.cloakPhase*0.6 + t*Math.PI*1.8)*bodyH*0.16;
      const crest=drop - bodyH*(0.16 + 0.12*Math.cos(t*Math.PI*2 + now/360));
      cloakPath.quadraticCurveTo(offset + sway*0.6, crest, offset + sway, drop + wave);
    }
    cloakPath.quadraticCurveTo(bodyW*0.7, bodyH*0.34 + flutterB*bodyH*0.36, bodyW*0.46, bodyH*0.94 + flutterC*bodyH*0.28);
    cloakPath.quadraticCurveTo(bodyW*0.18, bodyH*(1.04+flutterB*0.16), 0, bodyH*(0.88 + flutterA*0.3));
    cloakPath.quadraticCurveTo(-bodyW*0.18, bodyH*(1.04-flutterB*0.16), -bodyW*0.46, bodyH*0.94 - flutterC*bodyH*0.28);
    cloakPath.quadraticCurveTo(-bodyW*0.7, bodyH*0.34 - flutterB*bodyH*0.36, -bodyW*0.5, -bodyH*0.08);
    cloakPath.closePath();
    const cloakGrad=ctx.createLinearGradient(0,-bodyH*1.36,0,bodyH*1.2);
    cloakGrad.addColorStop(0,'rgba(34,18,50,0.98)');
    cloakGrad.addColorStop(0.42,'rgba(18,8,26,0.98)');
    cloakGrad.addColorStop(0.78,'rgba(10,6,20,0.96)');
    cloakGrad.addColorStop(1,'rgba(4,2,12,0.94)');
    ctx.fillStyle=cloakGrad;
    ctx.shadowColor='rgba(200,150,255,0.42)';
    ctx.shadowBlur=30*s;
    ctx.fill(cloakPath);
    ctx.shadowBlur=0;
    ctx.strokeStyle='rgba(150,120,220,0.36)';
    ctx.lineWidth=3.6*s;
    ctx.stroke(cloakPath);
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(255,180,240,0.18)';
    ctx.lineWidth=5*s;
    ctx.stroke(cloakPath);
    ctx.restore();
    if(rb.hitFlashUntil && now<rb.hitFlashUntil){
      ctx.strokeStyle='rgba(255,210,250,0.9)';
      ctx.lineWidth=4.8*s;
      ctx.stroke();
    }
    ctx.save();
    ctx.clip();
    const liningGrad=ctx.createLinearGradient(0,-bodyH,0,bodyH*1.18);
    liningGrad.addColorStop(0,'rgba(160,36,52,0.62)');
    liningGrad.addColorStop(0.52,'rgba(120,18,42,0.5)');
    liningGrad.addColorStop(1,'rgba(70,6,24,0.36)');
    ctx.globalAlpha=0.85;
    ctx.fillStyle=liningGrad;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.34, -bodyH*0.02);
    ctx.quadraticCurveTo(-bodyW*0.22, bodyH*0.56, -bodyW*0.32, bodyH*(0.92+flutterC*0.12));
    ctx.quadraticCurveTo(-bodyW*0.08, bodyH*(0.98+flutterA*0.16), 0, bodyH*(0.82 + flutterB*0.16));
    ctx.quadraticCurveTo(bodyW*0.08, bodyH*(0.98-flutterA*0.16), bodyW*0.32, bodyH*(0.9-flutterC*0.12));
    ctx.quadraticCurveTo(bodyW*0.22, bodyH*0.56, bodyW*0.34, -bodyH*0.02);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.restore();

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.42, -bodyH*0.18);
    ctx.quadraticCurveTo(-bodyW*0.64, -bodyH*0.76, -bodyW*0.18, -bodyH*1.24);
    ctx.quadraticCurveTo(0, -bodyH*1.36, bodyW*0.18, -bodyH*1.24);
    ctx.quadraticCurveTo(bodyW*0.64, -bodyH*0.76, bodyW*0.42, -bodyH*0.18);
    ctx.closePath();
    const hoodGrad=ctx.createLinearGradient(0,-bodyH*1.4,0,-bodyH*0.2);
    hoodGrad.addColorStop(0,'rgba(42,18,56,0.98)');
    hoodGrad.addColorStop(1,'rgba(16,8,28,0.98)');
    ctx.fillStyle=hoodGrad;
    ctx.fill();
    ctx.save();
    ctx.clip();
    const hoodInner=ctx.createRadialGradient(0,-bodyH*0.92, bodyW*0.08, 0,-bodyH*0.92, bodyW*0.46);
    hoodInner.addColorStop(0,'rgba(210,40,70,0.55)');
    hoodInner.addColorStop(1,'rgba(80,0,20,0.25)');
    ctx.fillStyle=hoodInner;
    ctx.fillRect(-bodyW*0.6, -bodyH*1.4, bodyW*1.2, bodyH*1.4);
    ctx.restore();
    ctx.restore();

    const headR=bodyW*0.26;
    const headY=-bodyH*0.84;
    const skullW=headR*2.05;
    const skullH=headR*1.78;
    ctx.save();
    ctx.translate(0, headY);
    ctx.shadowColor='rgba(255,200,240,0.45)';
    ctx.shadowBlur=16*s;
    const skullPath=new Path2D();
    skullPath.moveTo(-skullW*0.5, -skullH*0.05);
    skullPath.quadraticCurveTo(0, -skullH*0.86, skullW*0.5, -skullH*0.05);
    skullPath.quadraticCurveTo(skullW*0.62, skullH*0.44, skullW*0.28, skullH*0.78);
    skullPath.quadraticCurveTo(skullW*0.1, skullH*0.96, -skullW*0.1, skullH*0.96);
    skullPath.quadraticCurveTo(-skullW*0.28, skullH*0.78, -skullW*0.62, skullH*0.44);
    skullPath.closePath();
    const skullGrad=ctx.createLinearGradient(0,-skullH,0,skullH);
    skullGrad.addColorStop(0,'#fffafd');
    skullGrad.addColorStop(0.58,'#f1e6f5');
    skullGrad.addColorStop(1,'#e2d1e6');
    ctx.fillStyle=skullGrad;
    ctx.fill(skullPath);
    ctx.strokeStyle='rgba(110,80,150,0.45)';
    ctx.lineWidth=2.1*s;
    ctx.stroke(skullPath);

    ctx.fillStyle='#1a1325';
    ctx.beginPath();
    ctx.ellipse(-skullW*0.22, -skullH*0.1, skullW*0.2, skullH*0.3, -0.04, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(skullW*0.22, -skullH*0.1, skullW*0.2, skullH*0.3, 0.04, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle='rgba(255,255,255,0.16)';
    ctx.beginPath();
    ctx.ellipse(-skullW*0.28, -skullH*0.26, skullW*0.08, skullH*0.14, -0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(skullW*0.28, -skullH*0.26, skullW*0.08, skullH*0.14, 0.2, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle='#1f1528';
    ctx.beginPath();
    ctx.moveTo(0, skullH*0.12);
    ctx.lineTo(-skullW*0.08, skullH*0.38);
    ctx.lineTo(skullW*0.08, skullH*0.38);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle='rgba(140,100,170,0.65)';
    ctx.lineWidth=1.6*s;
    ctx.beginPath();
    ctx.moveTo(-skullW*0.3, skullH*0.54);
    ctx.lineTo(skullW*0.3, skullH*0.54);
    ctx.stroke();
    ctx.beginPath();
    for(let i=-2;i<=2;i++){
      const ratio=i/2;
      const tx=ratio*skullW*0.12;
      const ty=skullH*0.7 - Math.abs(ratio)*skullH*0.08;
      ctx.moveTo(tx, skullH*0.54);
      ctx.lineTo(tx, ty);
    }
    ctx.stroke();

    ctx.fillStyle='rgba(255,255,255,0.22)';
    ctx.beginPath();
    ctx.ellipse(0, -skullH*0.36, skullW*0.3, skullH*0.32, 0, 0, Math.PI);
    ctx.fill();

    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const skullGlow=ctx.createRadialGradient(0, headY, headR*0.2, 0, headY, headR*1.2);
    skullGlow.addColorStop(0,'rgba(255,210,250,0.45)');
    skullGlow.addColorStop(1,'rgba(255,210,250,0)');
    ctx.fillStyle=skullGlow;
    ctx.beginPath();
    ctx.arc(0, headY, headR*1.25, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    const handleSwing=-0.12 + Math.sin(now/520 + rb.cloakPhase)*0.05;
    ctx.rotate(handleSwing);
    ctx.translate(bodyW*0.32, -bodyH*0.12);
    const handleLen=bodyH*1.46;
    const handleGrad=ctx.createLinearGradient(0,-handleLen,0,bodyH*0.2);
    handleGrad.addColorStop(0,'#360208');
    handleGrad.addColorStop(0.48,'#821123');
    handleGrad.addColorStop(1,'#d12a3a');
    ctx.lineCap='round';
    ctx.lineJoin='round';
    ctx.strokeStyle=handleGrad;
    ctx.lineWidth=7.2*s;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.02,0);
    ctx.quadraticCurveTo(bodyW*0.08, -handleLen*0.32, bodyW*0.02, -handleLen*0.64);
    ctx.quadraticCurveTo(-bodyW*0.02, -handleLen*0.84, bodyW*0.04, -handleLen);
    ctx.stroke();

    ctx.strokeStyle='rgba(255,190,200,0.4)';
    ctx.lineWidth=1.6*s;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.015, -handleLen*0.14);
    ctx.quadraticCurveTo(bodyW*0.04, -handleLen*0.5, -bodyW*0.006, -handleLen*0.9);
    ctx.stroke();

    ctx.fillStyle='rgba(255,140,160,0.75)';
    ctx.beginPath();
    ctx.ellipse(0, -handleLen*0.3, bodyW*0.085, bodyW*0.05, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(0, -handleLen*0.56, bodyW*0.078, bodyW*0.044, 0, 0, Math.PI*2);
    ctx.fill();

    const clampH=bodyW*0.18;
    ctx.fillStyle='#741320';
    ctx.fillRect(-bodyW*0.05, -handleLen-clampH, bodyW*0.1, clampH);
    ctx.fillStyle='rgba(255,200,210,0.35)';
    ctx.fillRect(-bodyW*0.05, -handleLen-clampH, bodyW*0.1, clampH*0.32);

    ctx.save();
    ctx.translate(0, -handleLen-clampH);
    ctx.rotate(-Math.PI/12);
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.28, bodyW*0.08);
    ctx.quadraticCurveTo(bodyW*0.5, -bodyH*0.62, bodyW*0.84, bodyH*0.02);
    ctx.quadraticCurveTo(bodyW*0.34, bodyH*0.34, -bodyW*0.32, bodyH*0.18);
    ctx.quadraticCurveTo(-bodyW*0.12, -bodyH*0.02, -bodyW*0.28, bodyW*0.08);
    ctx.closePath();
    const bladeGrad=ctx.createLinearGradient(-bodyW*0.3, bodyH*0.25, bodyW*0.86, -bodyH*0.46);
    bladeGrad.addColorStop(0,'#fef5ff');
    bladeGrad.addColorStop(0.38,'#f38aa2');
    bladeGrad.addColorStop(0.76,'#7d1628');
    ctx.fillStyle=bladeGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(140,20,46,0.9)';
    ctx.lineWidth=2.6*s;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-bodyW*0.06, bodyW*0.02);
    ctx.quadraticCurveTo(bodyW*0.42, -bodyH*0.36, bodyW*0.68, bodyH*0.06);
    ctx.strokeStyle='rgba(255,240,250,0.78)';
    ctx.lineWidth=2*s;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-bodyW*0.24, bodyW*0.12);
    ctx.quadraticCurveTo(bodyW*0.22, bodyH*0.24, -bodyW*0.12, bodyH*0.24);
    ctx.strokeStyle='rgba(120,0,28,0.35)';
    ctx.lineWidth=3*s;
    ctx.stroke();
    ctx.restore();

    ctx.restore();

    ctx.strokeStyle='rgba(210,160,255,0.32)';
    ctx.lineWidth=2.4*s;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.44, -bodyH*0.08);
    ctx.quadraticCurveTo(-bodyW*0.28, -bodyH*0.64, -bodyW*0.12, -bodyH*1.04);
    ctx.quadraticCurveTo(0, -bodyH*1.18, bodyW*0.12, -bodyH*1.04);
    ctx.quadraticCurveTo(bodyW*0.28, -bodyH*0.64, bodyW*0.44, -bodyH*0.08);
    ctx.stroke();

    const auraGrad=ctx.createRadialGradient(0, bodyH*0.18, bodyW*0.2, 0, bodyH*0.18, bodyW*1.15);
    auraGrad.addColorStop(0,'rgba(150,100,220,0.32)');
    auraGrad.addColorStop(1,'rgba(150,100,220,0)');
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=auraGrad;
    ctx.beginPath();
    ctx.arc(0, bodyH*0.18, bodyW*1.15, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawReaperLayer(){
    if(level!==10) return;
    if(reaperPhase==='inactive' && !reaperBursts.length && !reaperAfterimages.length) return;
    const now=performance.now();
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    for(const fx of reaperBursts){
      const life=fx.life||1000;
      const prog=Math.max(0, Math.min(1, (now-fx.t0)/life));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      if(fx.type==='ring'){
        const rad=(fx.r0||0)+((fx.r1||220)-(fx.r0||0))*easeOut(prog);
        const alpha=1-prog;
        ctx.strokeStyle=`rgba(${fx.color||'220,150,255'},${0.55*alpha})`;
        ctx.lineWidth=(fx.width||16)*((scaleX+scaleY)/2)*(1-prog*0.7);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='flare'){
        const rad=(fx.r1||220)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(10, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0, `rgba(${fx.color||'200,140,255'},${0.36*(1-prog)})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='spark'){
        const rad=(fx.r1||90)*prog*((scaleX+scaleY)/2);
        ctx.strokeStyle=`rgba(${fx.color||'220,160,255'},${0.7*(1-prog)})`;
        ctx.lineWidth=2.4*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.moveTo(fx.x*scaleX-rad, fx.y*scaleY);
        ctx.lineTo(fx.x*scaleX+rad, fx.y*scaleY);
        ctx.moveTo(fx.x*scaleX, fx.y*scaleY-rad);
        ctx.lineTo(fx.x*scaleX, fx.y*scaleY+rad);
        ctx.stroke();
      }else if(fx.type==='halo'){
        const rad=(fx.r0||40)+((fx.r1||240)-(fx.r0||40))*prog;
        ctx.strokeStyle=`rgba(${fx.color||'200,150,255'},${0.25*(1-prog)})`;
        ctx.lineWidth=8*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }
    if(reaperSlashZone){
      const zone=reaperSlashZone;
      const pulse=0.5+0.5*Math.sin(now/140);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createLinearGradient(zone.x*scaleX, (zone.y+zone.h/2)*scaleY, (zone.x+zone.w)*scaleX, (zone.y+zone.h/2)*scaleY);
      grad.addColorStop(0,`rgba(255,70,100,${0.08+0.12*pulse})`);
      grad.addColorStop(0.5,`rgba(255,90,140,${0.22+0.25*pulse})`);
      grad.addColorStop(1,`rgba(255,70,100,${0.08+0.12*pulse})`);
      ctx.fillStyle=grad;
      ctx.fillRect(zone.x*scaleX, zone.y*scaleY, zone.w*scaleX, zone.h*scaleY);
      ctx.strokeStyle=`rgba(255,150,190,${0.35+0.3*pulse})`;
      ctx.lineWidth=3*((scaleX+scaleY)/2);
      ctx.strokeRect(zone.x*scaleX, zone.y*scaleY, zone.w*scaleX, zone.h*scaleY);
      ctx.restore();
    }
    for(const slash of reaperSlashEffects){
      const life=slash.life||240;
      const prog=Math.max(0, Math.min(1,(now-slash.start)/life));
      const alpha=1-prog;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createLinearGradient(slash.x1*scaleX, slash.y1*scaleY, slash.x2*scaleX, slash.y2*scaleY);
      grad.addColorStop(0,`rgba(255,120,160,${0.08*alpha})`);
      grad.addColorStop(0.5,`rgba(255,80,130,${0.85*alpha})`);
      grad.addColorStop(1,`rgba(255,120,160,${0.08*alpha})`);
      ctx.strokeStyle=grad;
      ctx.lineWidth=4*((scaleX+scaleY)/2)*(1+0.4*(1-prog));
      ctx.beginPath();
      ctx.moveTo(slash.x1*scaleX, slash.y1*scaleY);
      ctx.lineTo(slash.x2*scaleX, slash.y2*scaleY);
      ctx.stroke();
      ctx.restore();
    }
    const countdownAttack=reaperAttackState && reaperAttackState.current;
    if(countdownAttack && countdownAttack.stage==='countdown'){
      const remain=Math.ceil((countdownAttack.countdownEnd-now)/1000);
      if(remain>0){
        const L=layout();
        const anchorY=Math.max(L.top - 36, 68);
        const scaleAvg=(scaleX+scaleY)/2;
        const fontSize=Math.round(74*scaleAvg);
        if(countdownAttack.type==='slash'){
          ctx.save();
          ctx.globalCompositeOperation='lighter';
          const glow=ctx.createRadialGradient(canvas.width/2, anchorY*scaleY, 0, canvas.width/2, anchorY*scaleY, 140*scaleAvg);
          glow.addColorStop(0,'rgba(255,130,200,0.42)');
          glow.addColorStop(1,'rgba(255,130,200,0)');
          ctx.fillStyle=glow;
          ctx.beginPath();
          ctx.arc(canvas.width/2, anchorY*scaleY, 140*scaleAvg, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
        ctx.save();
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
        if(countdownAttack.type==='slash'){
          ctx.fillStyle='rgba(255,235,248,0.95)';
          ctx.shadowColor='rgba(255,160,210,0.85)';
        }else{
          ctx.fillStyle='rgba(230,230,255,0.92)';
          ctx.shadowColor='rgba(180,170,255,0.85)';
        }
        ctx.shadowBlur=(countdownAttack.type==='slash'?26:22)*scaleAvg;
        ctx.fillText(String(remain), canvas.width/2, anchorY*scaleY);
        ctx.restore();
      }
    }
    if(reaperBlackHoleAttack){
      const atk=reaperBlackHoleAttack;
      if(atk.projectile){
        const trail=atk.projectileTrail||[];
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        for(const t of trail){
          const age=Math.max(0, Math.min(1,(now-t.t)/400));
          const alpha=1-age;
          const r=atk.projectile.radius*((scaleX+scaleY)/2)*0.6*alpha;
          ctx.fillStyle=`rgba(150,90,220,${0.18*alpha})`;
          ctx.beginPath();
          ctx.arc(t.x*scaleX, t.y*scaleY, r, 0, Math.PI*2);
          ctx.fill();
        }
        const rad=atk.projectile.radius*((scaleX+scaleY)/2)*(1+0.15*Math.sin(now/120));
        const grad=ctx.createRadialGradient(atk.projectile.x*scaleX, atk.projectile.y*scaleY, rad*0.2, atk.projectile.x*scaleX, atk.projectile.y*scaleY, rad);
        grad.addColorStop(0,'rgba(20,10,40,0.9)');
        grad.addColorStop(0.4,'rgba(130,60,200,0.75)');
        grad.addColorStop(1,'rgba(255,140,220,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(atk.projectile.x*scaleX, atk.projectile.y*scaleY, rad, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      if(atk.stage==='hole' && atk.hole){
        const hole=atk.hole;
        const life=Math.max(1, (hole.end||now) - (hole.start||now));
        const age=Math.max(0, Math.min(1, (now - (hole.start||now))/life));
        const spinDir=hole.spinDir||1;
        const scaleAvg=(scaleX+scaleY)/2;
        const baseR=(hole.radius||160)*scaleAvg;
        const x=hole.x*scaleX;
        const y=hole.y*scaleY;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const warp=ctx.createRadialGradient(x,y,baseR*0.32,x,y,baseR*1.3);
        warp.addColorStop(0,`rgba(30,12,60,${0.85-0.35*age})`);
        warp.addColorStop(0.45,`rgba(110,60,200,${0.65-0.25*age})`);
        warp.addColorStop(0.78,'rgba(220,200,255,0.28)');
        warp.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=warp;
        ctx.beginPath();
        ctx.arc(x,y,baseR*1.3,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle=`rgba(230,210,255,${0.32*(1-age)+0.12*Math.sin(now/160)})`;
        ctx.lineWidth=5.2*scaleAvg;
        ctx.beginPath();
        ctx.arc(x,y,baseR*1.08,0,Math.PI*2);
        ctx.stroke();
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate((now/220 + (hole.vortexPhase||0))*spinDir);
        const armCount=5;
        for(let a=0;a<armCount;a++){
          const theta=a*(Math.PI*2/armCount);
          const armR=baseR*(0.46 + a*0.08);
          ctx.beginPath();
          ctx.strokeStyle=`rgba(255,230,255,${(0.18-0.02*a)*(1-age)})`;
          ctx.lineWidth=(2.4+a*0.6)*scaleAvg;
          ctx.arc(0,0,armR,theta,theta+Math.PI*0.55);
          ctx.stroke();
        }
        ctx.restore();
        ctx.restore();
      }
    }
    for(const af of reaperAfterimages){
      const life=af.life||600;
      const prog=Math.max(0, Math.min(1, (now-af.t0)/life));
      const alpha=(af.emerge?prog:1-prog)*0.4;
      const scale=(af.scale||1)*(1+(af.emerge?0.2*prog:0));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.translate(af.x*scaleX, af.y*scaleY);
      ctx.scale(scale, scale);
      ctx.globalAlpha=alpha;
      ctx.fillStyle='rgba(200,150,255,0.6)';
      ctx.beginPath();
      ctx.ellipse(0,0, reaperBoss?reaperBoss.w*0.28*((scaleX+scaleY)/2):70*((scaleX+scaleY)/2), reaperBoss?reaperBoss.h*0.36*((scaleX+scaleY)/2):90*((scaleX+scaleY)/2),0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    if(reaperBoss && (reaperPhase==='active' || reaperPhase==='intro' || reaperPhase==='dying')){
      drawReaperBoss(reaperBoss, now);
    }else if(reaperPhase==='intro' && reaperAnchor){
      const cx=(reaperAnchor.x+reaperAnchor.w/2)*scaleX;
      const cy=(reaperAnchor.y+reaperAnchor.h+80)*scaleY;
      const rad=Math.max(reaperAnchor.w, reaperAnchor.h)*1.3*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      g.addColorStop(0,'rgba(200,140,255,0.18)');
      g.addColorStop(1,'rgba(200,140,255,0)');
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    if(reaperTargetHighlightUntil && now<reaperTargetHighlightUntil){
      const bounds=getReaperBounds();
      if(bounds){
        const a=Math.max(0, Math.min(1,(reaperTargetHighlightUntil-now)/600));
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle=`rgba(255,160,230,${0.6*a})`;
        ctx.lineWidth=4;
        drawRoundedRect(bounds.x-6,bounds.y-6,bounds.w+12,bounds.h+12,16);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function drawReaperMarquee(){
    if(!reaperMarquee) return;
    const now=performance.now();
    const {start, fadeStart, end, text} = reaperMarquee;
    const style=reaperMarquee.style||'marquee';
    if(now>=end){ reaperMarquee=null; return; }
    let alpha=1;
    if(style!=='victorySolid' && now>fadeStart){ alpha = Math.max(0, 1 - (now - fadeStart)/(end - fadeStart||1)); }
    const scaleAvg=(scaleX+scaleY)/2;
    const textScale=Math.max(0.6, scaleAvg);
    const areaHeight=56;
    const top=Math.max(12, layout().top - areaHeight - 14);
    const x=40;
    const width=1100-80;
    const radius=18;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, top, width, areaHeight, radius);
    if(style==='victorySolid'){
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(46,32,84,0.96)');
      grad.addColorStop(1,'rgba(18,18,54,0.96)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,210,230,0.75)';
      ctx.lineWidth=2.2;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      ctx.fillStyle='#ffe9fa';
      const fontSize=Math.max(24, Math.round(30*textScale));
      ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,190,230,0.6)';
      ctx.shadowBlur=18*textScale;
      ctx.fillText(text, (x+width/2)*scaleX, (top+areaHeight/2)*scaleY);
      ctx.shadowBlur=0;
    }else{
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(34,26,70,0.92)');
      grad.addColorStop(1,'rgba(20,16,46,0.94)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(200,180,255,0.85)';
      ctx.lineWidth=2;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+12;
      const innerY=top+6;
      const innerW=width-24;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.save();
      ctx.clip();
      ctx.fillStyle='#fef7ff';
      const fontSize=Math.max(18, Math.round(24*textScale));
      ctx.font=`${fontSize}px 'Noto Sans TC','Playfair Display',sans-serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(200,160,255,0.5)';
      ctx.shadowBlur=12*textScale;
      ctx.fillText(text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawReaperHPBar(){
    if((reaperPhase!=='active' && reaperPhase!=='dying') || !reaperBoss) return;
    const L=layout();
    const barW=32;
    const maxH=700-(L.top+80);
    const barH=Math.max(200, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, reaperBoss.hp/reaperBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(40,20,60,0.96)');
    frameGrad.addColorStop(1,'rgba(24,12,42,0.92)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(210,160,255,0.6)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(12,10,26,0.92)');
    bg.addColorStop(1,'rgba(26,18,40,0.88)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(255,110,160,0.22)');
      fillGrad.addColorStop(0.35,'rgba(255,120,200,0.6)');
      fillGrad.addColorStop(1,'rgba(255,220,250,0.95)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    ctx.strokeStyle='rgba(255,255,255,0.14)';
    ctx.lineWidth=1;
    const segments=reaperBoss.maxHp;
    const step=innerH/segments;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - step*i)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS æš—é»‘æ­»ç¥', reaperBoss.hp, reaperBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(40,20,60,0.95)',
      bgBottom:'rgba(24,12,42,0.9)',
      frame:'rgba(210,160,255,0.7)',
      glow:'rgba(200,160,255,0.55)',
      textPrimary:'#eae0ff',
      textSecondary:'#f5ebff'
    });
    ctx.restore();
  }

  function drawReaperHUD(){
    drawReaperMarquee();
    drawReaperHPBar();
  }

  // === ç¬¬15é—œ æ¯€æ»…ä¹‹é¾ Boss ===
  function startDragonReveal(fromBrick){
    if(level!==15) return;
    if(dragonPhase!=='awaiting' && dragonPhase!=='intro') return;
    const now=performance.now();
    dragonPhase='intro';
    let source=fromBrick || dragonPlaceholder;
    if(fromBrick){
      const idx=bricks.indexOf(fromBrick);
      if(idx>=0) bricks.splice(idx,1);
    }else if(dragonPlaceholder){
      const idx=bricks.indexOf(dragonPlaceholder);
      if(idx>=0) bricks.splice(idx,1);
    }
    dragonPlaceholder=null;
    if(!source){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      const w=brickW*2 + L.pad;
      const h=brickH*2 + L.pad;
      source={x:L.pad + bx*(brickW+L.pad), y:L.top, w, h};
    }
    dragonAnchor={x:source.x, y:source.y, w:source.w, h:source.h};
    const cx=dragonAnchor.x+dragonAnchor.w/2;
    const cy=dragonAnchor.y+dragonAnchor.h/2;
    spawnParticles(cx,cy,'#fff2c7',120,2.8,4.2,4.5);
    spawnParticles(cx,cy,'#ffbc5e',90,2.4,3.8,4.0);
    spawnParticles(cx,cy,'#ffd36f',80,2.0,3.2,3.6);
    dragonBursts.push({type:'ring',x:cx,y:cy,r0:30,r1:460,width:22,t0:now,life:1600,color:'255,215,120'});
    dragonBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:320,t0:now,life:1400,color:'255,210,140'});
    dragonBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:220,t0:now,life:1200,color:'255,240,200'});
    playSFX('fireExplosion');
    screenShake=Math.max(screenShake,24);
    dragonRevealScheduled = now + 1000;
  }

  function activateDragonBoss(){
    if(level!==15) return;
    if(dragonPhase!=='intro' || dragonBoss) return;
    const L=layout();
    let anchor=dragonAnchor;
    if(!anchor){
      const bx=Math.floor(L.cols/2)-1;
      const w=brickW*2 + L.pad;
      const h=brickH*2 + L.pad;
      anchor={x:L.pad + bx*(brickW+L.pad), y:L.top, w, h};
      dragonAnchor=anchor;
    }
    const cx=anchor.x+anchor.w/2;
    const baseY=Math.max(L.top + 160, anchor.y + anchor.h + 140);
    const now=performance.now();
    dragonBoss={
      x:cx,
      y:baseY,
      baseY,
      w:120,
      h:75,
      hp:DRAGON_MAX_HP,
      maxHp:DRAGON_MAX_HP,
      wingPhase:Math.random()*Math.PI*2,
      hoverPhase:Math.random()*Math.PI*2,
      moveTarget:null,
      nextMove:now+800,
      pose:null,
      hitCooldownUntil:0,
      hitFlashUntil:0,
      lastUpdate:now,
      petrifyCharge:null
    };
    dragonPhase='active';
    dragonBursts.push({type:'halo',x:cx,y:baseY-20,r0:80,r1:420,t0:now,life:1800,color:'255,215,140'});
    dragonMarquee={text:'æ¯€æ»…ä¹‹é¾ç¾èº«äº†!', start:now, fadeStart:now+3200, end:now+3600, style:'alert'};
    scheduleNextTreasureBrick(now);
  }

  function dragonImpactPoint(fromX, fromY){
    if(!dragonBoss) return {x:fromX, y:fromY};
    const bounds=getDragonBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const dx=dragonBoss.x - fromX;
    const dy=dragonBoss.y - fromY;
    if(dx===0 && dy===0) return {x:dragonBoss.x, y:dragonBoss.y};
    const halfW=bounds.w/2;
    const halfH=bounds.h/2;
    const scale=Math.sqrt((dx*dx)/(halfW*halfW) + (dy*dy)/(halfH*halfH));
    if(!isFinite(scale) || scale===0) return {x:dragonBoss.x, y:dragonBoss.y};
    const t=1/scale;
    return {x:dragonBoss.x - dx*t, y:dragonBoss.y - dy*t};
  }

  function dragonClampPoint(x, y){
    const bounds=getDragonBounds();
    if(!bounds) return {x, y};
    return {
      x: Math.max(bounds.x, Math.min(x, bounds.x + bounds.w)),
      y: Math.max(bounds.y, Math.min(y, bounds.y + bounds.h))
    };
  }

  function damageDragonBoss(amount=1, source='generic', impact){
    if(dragonPhase!=='active' || !dragonBoss) return false;
    const now=performance.now();
    if(dragonBoss.hitCooldownUntil && now<dragonBoss.hitCooldownUntil) return false;
    dragonBoss.hitCooldownUntil=now+140;
    dragonBoss.hp=Math.max(0, dragonBoss.hp-amount);
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    dragonBoss.hitFlashUntil=now+220;
    const ix=(impact&&impact.x!=null)?impact.x:dragonBoss.x;
    const iy=(impact&&impact.y!=null)?impact.y:dragonBoss.y;
    dragonBursts.push({type:'ember',x:ix,y:iy,t0:now,life:600});
    spawnParticles(ix,iy,'#ffd97a',18,2.0,3.0,3.2);
    screenShake=Math.max(screenShake,4);
    if(dragonBoss.hp<=0){ defeatDragonBoss(); }
    return true;
  }

  function defeatDragonBoss(){
    if(dragonPhase==='dying' || dragonPhase==='defeated') return;
    const now=performance.now();
    dragonPhase='dying';
    dragonMarquee={text:'æˆåŠŸæ“Šæ®ºBoss: æ¯€æ»…ä¹‹é¾!', start:now, fadeStart:now+5000, end:now+5000, style:'victorySolid'};
    dragonDeathAnim={start:now, fallDuration:3000, bigExplosionStart:now+3000, bigExplosionEnd:now+5000, lastSmallBurst:0, bigExplosionTriggered:false, finished:false};
    dragonAttackState=null;
    dragonDeathRayOrbs.length=0;
    dragonDeathRayBeams.length=0;
    if(dragonBoss){
      dragonBoss.petrifyCharge=null;
      const cx=dragonBoss.x, cy=dragonBoss.y;
      dragonBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:360,t0:now,life:1500,color:'255,220,150'});
      dragonBursts.push({type:'ring',x:cx,y:cy,r0:60,r1:520,width:26,t0:now,life:1800,color:'255,210,130'});
    }
    addScore(BOSS_DEFEAT_SCORE.dragon);
    stats.bossKills++;
    updateHUD();
    screenShake=Math.max(screenShake,20);
    playSFX('fireExplosion');
    const dropX=(dragonBoss?dragonBoss.x:550)-12;
    const dropY=dragonBoss?dragonBoss.y:300;
    spawnPower(dropX, dropY, {forceType:'NINE'});
  }

  function updateDragonBoss(){
    if(level!==15) return;
    const now=performance.now();
    if(dragonPhase==='intro' && !dragonBoss && dragonRevealScheduled && now>=dragonRevealScheduled){
      activateDragonBoss();
    }
    if(dragonPhase==='active' && dragonBoss){
      const dt = now - (dragonBoss.lastUpdate||now);
      dragonBoss.lastUpdate=now;
      const handledMovement = updateDragonAttackState(now, dt);
      if(!handledMovement){
        if(!dragonBoss.moveTarget || now>=dragonBoss.nextMove){
          const L=layout();
          const minX=170;
          const maxX=930;
          const minY=L.top+140;
          const maxY=Math.min(L.top+300, dragonBoss.baseY+80);
          dragonBoss.moveTarget={x:minX+Math.random()*(maxX-minX), y:minY+Math.random()*(maxY-minY)};
          dragonBoss.nextMove=now+2200+Math.random()*1600;
        }
        if(dragonBoss.moveTarget){
          const speed=Math.min(0.18, (dt/1000)*0.6);
          dragonBoss.x += (dragonBoss.moveTarget.x - dragonBoss.x)*speed;
          dragonBoss.baseY += (dragonBoss.moveTarget.y - dragonBoss.baseY)*speed;
        }
      }
      dragonBoss.hoverPhase += dt*0.002;
      dragonBoss.y = dragonBoss.baseY + Math.sin(dragonBoss.hoverPhase)*10;
      dragonBoss.wingPhase += dt*0.0065;
    }else if(dragonPhase==='dying'){
      const anim=dragonDeathAnim;
      if(anim){
        if(dragonBoss){
          if(now<anim.bigExplosionStart){
            const dur=anim.fallDuration||3000;
            const prog=Math.max(0, Math.min(1,(now-anim.start)/dur));
            const drop=160;
            dragonBoss.y = dragonBoss.baseY + prog*drop;
            if(!anim.lastSmallBurst || now-anim.lastSmallBurst>140){
              anim.lastSmallBurst=now;
              const ox=(Math.random()-0.5)*dragonBoss.w*0.7;
              const oy=(Math.random()-0.4)*dragonBoss.h*0.7;
              const px=dragonBoss.x+ox;
              const py=dragonBoss.y+oy;
              dragonBursts.push({type:'spark',x:px,y:py,r0:0,r1:240,t0:now,life:900,color:'255,210,150'});
              spawnParticles(px,py,'#ffdd9b',24,2.2,3.4,3.6);
            }
          }else if(now<anim.bigExplosionEnd){
            if(!anim.bigExplosionTriggered){
              anim.bigExplosionTriggered=true;
              const cx=dragonBoss.x, cy=dragonBoss.y;
              dragonBursts.push({type:'mega',x:cx,y:cy,r0:140,r1:720,t0:now,life:2000});
              dragonBursts.push({type:'halo',x:cx,y:cy,r0:160,r1:680,t0:now,life:2400,color:'255,220,150'});
              spawnParticles(cx,cy,'#fff2d6',300,3.8,5.6,6.0);
              spawnParticles(cx,cy,'#ffe4a6',200,3.4,4.8,5.2);
              screenShake=Math.max(screenShake,32);
              playSFX('fireExplosion');
            }
          }else{
            dragonBoss=null;
          }
        }else if(!anim.finished && now>=anim.bigExplosionEnd){
          anim.finished=true;
          dragonDefeatedAt=now;
          dragonPhase='defeated';
          dragonDeathAnim=null;
        }
      }
    }
    for(let i=dragonBursts.length-1;i>=0;i--){ const fx=dragonBursts[i]; const life=fx.life||1200; if(now>fx.t0+life){ dragonBursts.splice(i,1); } }
    if(dragonMarquee && now>=dragonMarquee.end){ dragonMarquee=null; }
  }

  function renderDragonBody(boss, now){
    if(dragonAttackState && dragonAttackState.hideDragon){ return; }
    const scaleAvg=(scaleX+scaleY)/2;
    const bodyScale=boss.w/260;
    ctx.save();
    ctx.translate(boss.x*scaleX, boss.y*scaleY);
    ctx.scale(scaleAvg*bodyScale, scaleAvg*bodyScale);
    const wingCycle=boss.wingPhase;
    const sine=Math.sin(wingCycle);
    const downstroke=Math.pow(Math.max(0, sine), 1.6);
    const upstroke=Math.pow(Math.max(0, -sine), 1.2);
    const flap=(downstroke*0.65 - upstroke*0.42) + Math.sin(now*0.0032)*0.08;
    const flash = boss.hitFlashUntil && now<boss.hitFlashUntil;
    const wingLift = 26*flap;
    const wingSpread = 1.38 + flap*0.42;
    const metalGradient=(x0,y0,x1,y1)=>{
      const g=ctx.createLinearGradient(x0,y0,x1,y1);
      g.addColorStop(0, flash?'#fff9ed':'#fcefd6');
      g.addColorStop(0.35, flash?'#ffe4a4':'#f5c86f');
      g.addColorStop(0.7, flash?'#ffc660':'#d88d35');
      g.addColorStop(1, flash?'#ffad40':'#a95c18');
      return g;
    };
    const darkMetal=(alpha=1)=>`rgba(110,64,22,${(flash?0.55:0.38)*alpha})`;

    const tailSwing=Math.sin(now/340 + boss.wingPhase*1.6)*5.8;
    const charge=boss.petrifyCharge;
    let chargeProgress=0;
    if(charge){
      const duration=(charge.end||0)-(charge.start||0) || 1;
      chargeProgress=Math.max(0, Math.min(1,(now-charge.start)/duration));
    }
    if(chargeProgress>0){
      const pulse=0.55+Math.sin(now/140)*0.45;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.shadowColor=`rgba(255,210,160,${0.55+0.35*chargeProgress})`;
      ctx.shadowBlur=36+chargeProgress*32;

      const auraRadius=220 + 160*chargeProgress + pulse*30;
      const coreGlow=ctx.createRadialGradient(0,-32,0,0,-32,auraRadius);
      coreGlow.addColorStop(0,'rgba(255,244,222,0.95)');
      coreGlow.addColorStop(0.35,'rgba(255,208,150,0.8)');
      coreGlow.addColorStop(0.75,'rgba(255,150,60,0.36)');
      coreGlow.addColorStop(1,'rgba(255,90,30,0)');
      ctx.fillStyle=coreGlow;
      ctx.globalAlpha=0.55+0.4*chargeProgress;
      ctx.beginPath();
      ctx.ellipse(0,8,auraRadius*0.55,auraRadius*0.78,0,0,Math.PI*2);
      ctx.fill();

      const haloRadius=140 + 120*chargeProgress + pulse*18;
      ctx.globalAlpha=0.85;
      ctx.lineWidth=6.5 + chargeProgress*3.5;
      ctx.strokeStyle=`rgba(255,220,170,${0.55+0.3*pulse})`;
      ctx.beginPath();
      ctx.ellipse(0,-46,haloRadius*0.6,haloRadius*0.84,0,0,Math.PI*2);
      ctx.stroke();

      const filamentCount=6;
      for(let i=0;i<filamentCount;i++){
        const ang=(now/420) + i*(Math.PI*2/filamentCount);
        const reach=160 + chargeProgress*180 + pulse*20;
        ctx.save();
        ctx.rotate(ang);
        ctx.translate(0,-24);
        ctx.globalAlpha=0.55+0.35*chargeProgress;
        ctx.strokeStyle=`rgba(255,228,190,${0.45+0.25*pulse})`;
        ctx.lineWidth=4.5 + chargeProgress*2.8;
        ctx.beginPath();
        ctx.moveTo(0,-28);
        ctx.quadraticCurveTo(reach*0.28,-reach*0.62,reach,0);
        ctx.quadraticCurveTo(reach*0.36,reach*0.48,reach*0.08,reach*0.74);
        ctx.stroke();
        ctx.restore();
      }

      const sparkCount=12;
      ctx.globalAlpha=0.65;
      for(let i=0;i<sparkCount;i++){
        const ang=(now/260) + i*(Math.PI*2/sparkCount);
        const radius=haloRadius + 50 + Math.sin(now/180 + i)*26*chargeProgress;
        const sx=Math.cos(ang)*radius;
        const sy=Math.sin(ang)*radius*0.88 - 18;
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(ang);
        ctx.fillStyle='rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.ellipse(0,0,6 + chargeProgress*3.2,2.6 + chargeProgress*1.4,0,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }
    ctx.save();
    ctx.translate(0,62);
    const tailBaseSwing=tailSwing;
    const tailRipple=Math.sin(now/260 + boss.wingPhase*2.2)*3.6;
    ctx.rotate(tailBaseSwing*Math.PI/180);
    const tailSegments=12;
    const segmentSpacing=22;
    const tailLength=tailSegments*segmentSpacing;
    for(let i=0;i<tailSegments;i++){
      const prog=i/(tailSegments-1);
      const segOffset=i*segmentSpacing;
      const segWidth=42 - prog*18;
      const segHeight=28 - prog*10;
      ctx.save();
      ctx.translate(0,segOffset);
      ctx.rotate((tailRipple*prog)*Math.PI/180);
      if(i%2===0){
        const outerW=segWidth*0.52;
        const outerH=segHeight*0.5;
        const innerW=outerW*0.56;
        const innerH=outerH*0.58;
        ctx.fillStyle=metalGradient(-outerW, -outerH*0.6, outerW, outerH*1.2);
        ctx.beginPath();
        ctx.ellipse(0,0,outerW,outerH,0,0,Math.PI*2);
        ctx.ellipse(0,0,innerW,innerH,0,0,Math.PI*2,true);
        ctx.fill('evenodd');
        ctx.strokeStyle=`rgba(255,234,208,${flash?0.9:0.72})`;
        ctx.lineWidth=1.8;
        ctx.beginPath();
        ctx.ellipse(0,0,outerW,outerH,0,0,Math.PI*2);
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.85);
        ctx.lineWidth=1.2;
        ctx.beginPath();
        ctx.ellipse(0,0,innerW*1.02,innerH*1.02,0,0,Math.PI*2);
        ctx.stroke();
      }else{
        const bladeW=segWidth*0.6;
        const bladeH=segHeight*1.26;
        ctx.fillStyle=metalGradient(-bladeW*0.8, -bladeH*0.4, bladeW*0.9, bladeH*0.9);
        ctx.beginPath();
        ctx.moveTo(-bladeW*0.46,-bladeH*0.2);
        ctx.quadraticCurveTo(-bladeW*0.62,bladeH*0.38,-bladeW*0.2,bladeH*0.84);
        ctx.lineTo(bladeW*0.2,bladeH*0.84);
        ctx.quadraticCurveTo(bladeW*0.62,bladeH*0.34,bladeW*0.46,-bladeH*0.2);
        ctx.quadraticCurveTo(0,-bladeH*0.82,-bladeW*0.46,-bladeH*0.2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,238,214,${flash?0.92:0.76})`;
        ctx.lineWidth=1.9;
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.88);
        ctx.lineWidth=1.1;
        ctx.beginPath();
        ctx.moveTo(0,-bladeH*0.72);
        ctx.lineTo(0,bladeH*0.74);
        ctx.moveTo(-bladeW*0.24,-bladeH*0.12);
        ctx.lineTo(-bladeW*0.06,bladeH*0.62);
        ctx.moveTo(bladeW*0.24,-bladeH*0.12);
        ctx.lineTo(bladeW*0.06,bladeH*0.62);
        ctx.stroke();
      }
      ctx.restore();

      if(i<tailSegments-1){
        const nodeProg=(i+0.5)/(tailSegments-1);
        ctx.save();
        ctx.translate(0,segOffset+segmentSpacing*0.5);
        ctx.rotate((tailRipple*nodeProg)*Math.PI/180);
        const nodeGrad=metalGradient(-12,-8,12,14);
        ctx.fillStyle=nodeGrad;
        ctx.beginPath();
        ctx.ellipse(0,0,8.4,6.2,0,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle=`rgba(255,244,220,${flash?0.94:0.78})`;
        ctx.lineWidth=1.2;
        ctx.stroke();
        ctx.strokeStyle=`rgba(255,212,150,${flash?0.7:0.56})`;
        ctx.lineWidth=0.9;
        ctx.beginPath();
        ctx.ellipse(0,0,5.4,3.8,0,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.save();
    ctx.translate(0,tailLength+12);
    const spearAngle=tailBaseSwing*0.38 + Math.sin(now/320 + boss.wingPhase*2.6)*6;
    ctx.rotate(spearAngle*Math.PI/180);
    const spearGrad=metalGradient(-22,-36,22,68);
    ctx.fillStyle=spearGrad;
    ctx.beginPath();
    ctx.moveTo(-10,-12);
    ctx.quadraticCurveTo(-22,28,-6,74);
    ctx.lineTo(0,92);
    ctx.lineTo(6,74);
    ctx.quadraticCurveTo(22,28,10,-12);
    ctx.quadraticCurveTo(0,-42,-10,-12);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,236,210,${flash?0.92:0.76})`;
    ctx.lineWidth=2.2;
    ctx.stroke();
    ctx.strokeStyle=darkMetal(0.88);
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(0,-28);
    ctx.lineTo(0,76);
    ctx.stroke();
    for(const side of [-1,1]){
      ctx.beginPath();
      ctx.moveTo(side*4,42);
      ctx.lineTo(side*28,14);
      ctx.lineTo(side*10,68);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    ctx.strokeStyle=`rgba(255,246,228,${flash?0.92:0.8})`;
    ctx.lineWidth=1.1;
    ctx.beginPath();
    ctx.moveTo(-12,52);
    ctx.quadraticCurveTo(0,82,12,52);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    function drawWing(side){
      ctx.save();
      ctx.scale(side,1);
      ctx.translate(-42,-34);
      ctx.rotate((-32 + flap*18)*Math.PI/180);

      // wing root armor
      ctx.fillStyle=metalGradient(-68,-60,42,110);
      ctx.beginPath();
      ctx.moveTo(-60,-34);
      ctx.lineTo(16,-20);
      ctx.lineTo(22,36);
      ctx.lineTo(-48,68);
      ctx.lineTo(-82,30);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,235,210,${flash?0.9:0.74})`;
      ctx.lineWidth=2.6;
      ctx.stroke();

      const outerBlades=[
        {base:[-24,-14], ctrl:[-150,-148-wingLift*0.5], tip:[-304,-168-wingLift*0.74], width:54, curvature:34, tipWidth:20},
        {base:[-22,10], ctrl:[-188,-112-wingLift*0.32], tip:[-312,-94-wingLift*0.38], width:46, curvature:28, tipWidth:18},
        {base:[-18,36], ctrl:[-228,-52-wingLift*0.16], tip:[-298,26+wingLift*0.04], width:40, curvature:26, tipWidth:16},
        {base:[-14,60], ctrl:[-234,40+wingLift*0.22], tip:[-262,112+wingLift*0.28], width:36, curvature:24, tipWidth:14},
        {base:[-10,84], ctrl:[-202,104+wingLift*0.34], tip:[-226,168+wingLift*0.42], width:32, curvature:22, tipWidth:12}
      ];
      const innerBlades=[
        {base:[-18,4], ctrl:[-120,-46-wingLift*0.22], tip:[-182,-12-wingLift*0.18], width:28, curvature:18, tipWidth:10, serrations:4, serrationDepth:10},
        {base:[-16,24], ctrl:[-148,-4-wingLift*0.12], tip:[-190,42+wingLift*0.04], width:26, curvature:16, tipWidth:10, serrations:5, serrationDepth:9},
        {base:[-12,46], ctrl:[-162,48+wingLift*0.18], tip:[-188,106+wingLift*0.24], width:24, curvature:14, tipWidth:9, serrations:5, serrationDepth:8},
        {base:[-10,68], ctrl:[-150,96+wingLift*0.28], tip:[-174,150+wingLift*0.34], width:22, curvature:12, tipWidth:8, serrations:6, serrationDepth:7},
        {base:[-8,88], ctrl:[-138,138+wingLift*0.36], tip:[-158,188+wingLift*0.46], width:20, curvature:11, tipWidth:7, serrations:6, serrationDepth:6}
      ];

      function drawBladeLayer(blades, palette){
        for(const blade of blades){
          const baseX=blade.base[0];
          const baseY=blade.base[1];
          const ctrlX=blade.ctrl[0]*wingSpread;
          const ctrlY=blade.ctrl[1];
          const tipX=blade.tip[0]*wingSpread;
          const tipY=blade.tip[1];
          const angle=Math.atan2(tipY-baseY, tipX-baseX);
          const perpX=-Math.sin(angle);
          const perpY=Math.cos(angle);
          const leadingBaseX=baseX+perpX*blade.width*0.58;
          const leadingBaseY=baseY+perpY*blade.width*0.58;
          const trailingBaseX=baseX-perpX*blade.width*0.44;
          const trailingBaseY=baseY-perpY*blade.width*0.44;
          const leadingCtrlX=ctrlX+perpX*(blade.curvature||0);
          const leadingCtrlY=ctrlY+perpY*(blade.curvature||0);
          const trailingCtrlX=ctrlX-perpX*((blade.curvature||0)*0.74);
          const trailingCtrlY=ctrlY-perpY*((blade.curvature||0)*0.74);
          const leadingTipX=tipX+perpX*(blade.tipWidth||blade.width*0.32);
          const leadingTipY=tipY+perpY*(blade.tipWidth||blade.width*0.32);
          const trailingTipX=tipX-perpX*(blade.tipWidth||blade.width*0.22);
          const trailingTipY=tipY-perpY*(blade.tipWidth||blade.width*0.22);

          const grad=ctx.createLinearGradient(leadingBaseX, leadingBaseY, leadingTipX, leadingTipY);
          grad.addColorStop(0, palette.light);
          grad.addColorStop(0.45, palette.mid);
          grad.addColorStop(1, palette.edge);
          ctx.fillStyle=grad;

          ctx.beginPath();
          ctx.moveTo(leadingBaseX, leadingBaseY);
          ctx.quadraticCurveTo(leadingCtrlX, leadingCtrlY, leadingTipX, leadingTipY);
          if(blade.serrations){
            ctx.lineTo(trailingTipX, trailingTipY);
            for(let i=blade.serrations;i>=1;i--){
              const t=i/blade.serrations;
              const px=trailingTipX+(trailingBaseX-trailingTipX)*t;
              const py=trailingTipY+(trailingBaseY-trailingTipY)*t;
              const offset=(i%2===0?-1:1)*(blade.serrationDepth||6);
              ctx.lineTo(px+perpX*offset*0.6, py+perpY*offset*0.6);
            }
            ctx.lineTo(trailingBaseX, trailingBaseY);
          }else{
            ctx.quadraticCurveTo(trailingCtrlX, trailingCtrlY, trailingBaseX, trailingBaseY);
          }
          ctx.lineTo(baseX+perpX*blade.width*0.12, baseY+perpY*blade.width*0.12);
          ctx.closePath();
          ctx.fill();

          ctx.strokeStyle=palette.outline;
          ctx.lineWidth=2.2;
          ctx.stroke();

          ctx.strokeStyle=darkMetal();
          ctx.lineWidth=1.4;
          ctx.beginPath();
          ctx.moveTo(baseX, baseY);
          ctx.quadraticCurveTo(ctrlX, ctrlY+(palette.veinLift||0), tipX, tipY);
          ctx.stroke();

          ctx.strokeStyle=palette.highlight;
          ctx.lineWidth=1.1;
          ctx.beginPath();
          ctx.moveTo(leadingBaseX, leadingBaseY);
          ctx.quadraticCurveTo(leadingCtrlX, leadingCtrlY, leadingTipX, leadingTipY);
          ctx.stroke();
        }
      }

      const outerPalette={
        light: flash?'#fff3d8':'#f3d1a2',
        mid: flash?'#f6c98d':'#d9a05e',
        edge: flash?'#ca7e40':'#8f5224',
        outline: flash?'#ffe9cc':'#f2c8a0',
        highlight: flash?'#fff2df':'#f4d7b7',
        veinLift:12
      };
      drawBladeLayer(outerBlades, outerPalette);

      // metallic spars between layers
      ctx.save();
      ctx.strokeStyle=metalGradient(-42,4,-210*wingSpread,152+wingLift*0.36);
      ctx.lineWidth=5.4;
      ctx.beginPath();
      ctx.moveTo(-26,6);
      ctx.quadraticCurveTo(-182*wingSpread,-18-wingLift*0.24,-248*wingSpread,86+wingLift*0.28);
      ctx.quadraticCurveTo(-208*wingSpread,128+wingLift*0.32,-188*wingSpread,170+wingLift*0.4);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,204,148,${flash?0.86:0.52})`;
      ctx.lineWidth=3.6;
      ctx.shadowColor=`rgba(255,220,170,${flash?0.72:0.42})`;
      ctx.shadowBlur=18;
      ctx.beginPath();
      ctx.moveTo(-22,12);
      ctx.quadraticCurveTo(-176*wingSpread,-6-wingLift*0.18,-232*wingSpread,94+wingLift*0.3);
      ctx.quadraticCurveTo(-198*wingSpread,136+wingLift*0.34,-176*wingSpread,180+wingLift*0.46);
      ctx.stroke();
      ctx.restore();

      const innerPalette={
        light: flash?'#ffe9c8':'#ecc190',
        mid: flash?'#f0b272':'#c6864b',
        edge: flash?'#b96a32':'#7c3e19',
        outline: flash?'#ffe3c4':'#f0c09a',
        highlight: flash?'#ffeedf':'#f6dcbc',
        veinLift:18
      };
      drawBladeLayer(innerBlades, innerPalette);

      // trailing edge spikes
      ctx.fillStyle=metalGradient(-210*wingSpread,80+wingLift*0.2,-160*wingSpread,160+wingLift*0.4);
      ctx.beginPath();
      ctx.moveTo(-230*wingSpread,94+wingLift*0.32);
      ctx.lineTo(-190*wingSpread,106+wingLift*0.36);
      ctx.lineTo(-204*wingSpread,140+wingLift*0.42);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,230,200,${flash?0.82:0.7})`;
      ctx.lineWidth=1.8;
      ctx.stroke();
      ctx.restore();
    }
    drawWing(-1);
    drawWing(1);

    ctx.shadowColor='rgba(255,218,150,0.62)';
    ctx.shadowBlur=26;
    ctx.fillStyle=metalGradient(-70,-132,70,132);
    ctx.beginPath();
    ctx.moveTo(-70,108);
    ctx.lineTo(-96,36);
    ctx.quadraticCurveTo(-82,-96,0,-134);
    ctx.quadraticCurveTo(82,-96,96,36);
    ctx.lineTo(70,108);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur=0;
    ctx.strokeStyle=`rgba(255,240,212,${flash?0.94:0.8})`;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const chestSegments=[
      {y:-86, h:36, w0:70, w1:96},
      {y:-40, h:32, w0:66, w1:92},
      {y:6, h:32, w0:58, w1:82},
      {y:44, h:34, w0:52, w1:74}
    ];
    for(const seg of chestSegments){
      ctx.fillStyle=metalGradient(-seg.w1, seg.y-seg.h, seg.w1, seg.y+seg.h*1.4);
      ctx.beginPath();
      ctx.moveTo(-seg.w0, seg.y);
      ctx.lineTo(-seg.w1, seg.y+seg.h);
      ctx.quadraticCurveTo(0, seg.y+seg.h*1.32, seg.w1, seg.y+seg.h);
      ctx.lineTo(seg.w0, seg.y);
      ctx.quadraticCurveTo(0, seg.y-seg.h*0.75, -seg.w0, seg.y);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,232,205,${flash?0.9:0.74})`;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.6;
      ctx.beginPath();
      ctx.moveTo(-seg.w0*0.42, seg.y+seg.h*0.12);
      ctx.quadraticCurveTo(0, seg.y+seg.h*0.46, seg.w0*0.42, seg.y+seg.h*0.12);
      ctx.stroke();
    }

    ctx.save();
    ctx.translate(0,-8);
    ctx.fillStyle=metalGradient(-24,-42,24,52);
    ctx.beginPath();
    ctx.moveTo(-20,-12);
    ctx.lineTo(-34,28);
    ctx.quadraticCurveTo(0,52,34,28);
    ctx.lineTo(20,-12);
    ctx.quadraticCurveTo(0,-32,-20,-12);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,228,190,${flash?0.92:0.78})`;
    ctx.lineWidth=2.2;
    ctx.stroke();
    ctx.strokeStyle=`rgba(255,250,220,${flash?0.96:0.82})`;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(0,-20);
    ctx.lineTo(0,32);
    ctx.stroke();
    ctx.restore();

    // lower limbs
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.translate(44,96);
      const gaitPhase=now/420 + side*0.7;
      const legSwing=side*3 + Math.sin(gaitPhase)*5.4;
      const legLift=Math.sin(gaitPhase+Math.PI/2)*3.2;
      ctx.translate(0,-legLift);
      ctx.rotate(legSwing*Math.PI/180);

      const limbGradient=(x0,y0,x1,y1)=>{
        const g=ctx.createLinearGradient(x0,y0,x1,y1);
        g.addColorStop(0, flash?'#fff7e8':'#fbe8c8');
        g.addColorStop(0.38, flash?'#ffd99c':'#f3c27d');
        g.addColorStop(0.72, flash?'#f0a95a':'#d78a3f');
        g.addColorStop(1, flash?'#b86a28':'#8d4616');
        return g;
      };

      // segmented thigh armor
      ctx.fillStyle=limbGradient(-40,-36,42,96);
      ctx.beginPath();
      ctx.moveTo(-34,-26);
      ctx.lineTo(-56,32);
      ctx.lineTo(-24,96);
      ctx.lineTo(18,88);
      ctx.lineTo(38,24);
      ctx.lineTo(6,-32);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,236,210,${flash?0.92:0.76})`;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-24,-12,30,76);
      ctx.beginPath();
      ctx.moveTo(-16,-10);
      ctx.lineTo(-36,40);
      ctx.lineTo(-10,76);
      ctx.lineTo(18,62);
      ctx.lineTo(24,18);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,242,220,${flash?0.94:0.8})`;
      ctx.lineWidth=1.8;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.92);
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(-20,8);
      ctx.lineTo(14,60);
      ctx.moveTo(-32,34);
      ctx.lineTo(-4,82);
      ctx.stroke();

      // articulated knee and shin plates
      ctx.fillStyle=limbGradient(-16,66,36,132);
      ctx.beginPath();
      ctx.moveTo(-12,64);
      ctx.lineTo(-24,110);
      ctx.lineTo(12,126);
      ctx.lineTo(24,82);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,238,214,${flash?0.9:0.74})`;
      ctx.lineWidth=1.9;
      ctx.stroke();

      ctx.fillStyle=limbGradient(4,80,48,144);
      ctx.beginPath();
      ctx.moveTo(14,82);
      ctx.lineTo(46,114);
      ctx.lineTo(22,72);
      ctx.lineTo(6,68);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,246,226,${flash?0.94:0.82})`;
      ctx.lineWidth=1.4;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-20,106,30,174);
      ctx.beginPath();
      ctx.moveTo(-18,102);
      ctx.lineTo(-8,150);
      ctx.lineTo(14,162);
      ctx.lineTo(32,128);
      ctx.lineTo(10,108);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,234,208,${flash?0.88:0.72})`;
      ctx.lineWidth=1.8;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-10,124,26,182);
      ctx.beginPath();
      ctx.moveTo(-4,122);
      ctx.lineTo(-2,158);
      ctx.lineTo(16,156);
      ctx.lineTo(22,124);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,220,${flash?0.92:0.78})`;
      ctx.lineWidth=1.4;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.88);
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo(-8,110);
      ctx.lineTo(12,160);
      ctx.moveTo(-2,144);
      ctx.lineTo(20,138);
      ctx.stroke();

      // armored foot with toe blades
      ctx.fillStyle=limbGradient(-26,150,34,206);
      ctx.beginPath();
      ctx.moveTo(-24,148);
      ctx.lineTo(-16,198);
      ctx.lineTo(12,206);
      ctx.lineTo(40,168);
      ctx.lineTo(16,144);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,238,214,${flash?0.9:0.74})`;
      ctx.lineWidth=1.6;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-8,158,20,202);
      ctx.beginPath();
      ctx.moveTo(-6,154);
      ctx.lineTo(10,198);
      ctx.lineTo(26,180);
      ctx.lineTo(18,150);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,224,${flash?0.94:0.8})`;
      ctx.lineWidth=1.3;
      ctx.stroke();

      const toes=[
        {x:-14,y:186,rot:-16},
        {x:2,y:194,rot:0},
        {x:20,y:186,rot:18}
      ];
      for(const toe of toes){
        ctx.save();
        ctx.translate(toe.x,toe.y);
        ctx.rotate(toe.rot*Math.PI/180);
        ctx.fillStyle=limbGradient(-8,-6,22,48);
        ctx.beginPath();
        ctx.moveTo(-6,-2);
        ctx.quadraticCurveTo(-20,12,-14,36);
        ctx.lineTo(20,40);
        ctx.lineTo(14,4);
        ctx.quadraticCurveTo(4,-10,-6,-2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,246,226,${flash?0.94:0.8})`;
        ctx.lineWidth=1.2;
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.84);
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-2,0);
        ctx.lineTo(12,32);
        ctx.stroke();
        ctx.restore();
      }

      const knuckles=[{x:-18,y:172},{x:0,y:178},{x:18,y:170}];
      for(const node of knuckles){
        ctx.save();
        ctx.translate(node.x,node.y);
        const knuckleGrad=ctx.createRadialGradient(0,0,0,0,0,8);
        knuckleGrad.addColorStop(0, flash?'rgba(255,250,236,0.98)':'rgba(255,244,224,0.86)');
        knuckleGrad.addColorStop(1, flash?'rgba(255,204,150,0.4)':'rgba(240,184,120,0.34)');
        ctx.fillStyle=knuckleGrad;
        ctx.beginPath();
        ctx.ellipse(0,0,7,5,0,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }

    // upper arms and claws
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.translate(72,-12);
      const reachPhase=now/360 + side*0.6;
      const shoulderLift=Math.cos(reachPhase)*3.2;
      const armSwing=-6*side + Math.sin(reachPhase)*6.2;
      ctx.translate(0, shoulderLift);
      ctx.rotate(armSwing*Math.PI/180);

      const armGradient=(x0,y0,x1,y1)=>{
        const g=ctx.createLinearGradient(x0,y0,x1,y1);
        g.addColorStop(0, flash?'#fff9ec':'#fce9ce');
        g.addColorStop(0.3, flash?'#ffe0a8':'#f6c47e');
        g.addColorStop(0.68, flash?'#f0a868':'#d1843c');
        g.addColorStop(1, flash?'#b86a2c':'#823f18');
        return g;
      };

      // layered shoulder armor
      ctx.fillStyle=armGradient(-56,-42,44,118);
      ctx.beginPath();
      ctx.moveTo(-54,-24);
      ctx.lineTo(-80,36);
      ctx.lineTo(-46,116);
      ctx.lineTo(6,86);
      ctx.lineTo(34,18);
      ctx.lineTo(-8,-32);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,238,214,${flash?0.92:0.78})`;
      ctx.lineWidth=2.6;
      ctx.stroke();

      ctx.fillStyle=armGradient(-34,-12,32,74);
      ctx.beginPath();
      ctx.moveTo(-24,-8);
      ctx.lineTo(-48,46);
      ctx.lineTo(-18,90);
      ctx.lineTo(14,70);
      ctx.lineTo(26,18);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,224,${flash?0.94:0.82})`;
      ctx.lineWidth=1.9;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(-30,12);
      ctx.lineTo(8,74);
      ctx.moveTo(-44,40);
      ctx.lineTo(-10,92);
      ctx.stroke();

      // forearm plating
      ctx.fillStyle=armGradient(-30,72,34,152);
      ctx.beginPath();
      ctx.moveTo(-22,68);
      ctx.lineTo(-52,130);
      ctx.lineTo(-22,150);
      ctx.lineTo(8,104);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,240,220,${flash?0.92:0.8})`;
      ctx.lineWidth=1.8;
      ctx.stroke();

      ctx.fillStyle=armGradient(-10,108,28,178);
      ctx.beginPath();
      ctx.moveTo(-12,108);
      ctx.lineTo(-34,170);
      ctx.lineTo(-6,184);
      ctx.lineTo(14,132);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,226,${flash?0.94:0.82})`;
      ctx.lineWidth=1.5;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.86);
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo(-38,150);
      ctx.lineTo(-8,100);
      ctx.moveTo(-18,120);
      ctx.lineTo(6,162);
      ctx.stroke();

      // wrist ring and dorsal spike
      ctx.save();
      ctx.translate(-8,132);
      ctx.scale(1.08,1);
      ctx.fillStyle=armGradient(-28,118,28,150);
      ctx.beginPath();
      ctx.ellipse(0,0,24,10,0,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle=`rgba(255,248,232,${flash?0.96:0.84})`;
      ctx.lineWidth=1.4;
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle=armGradient(-6,120,26,186);
      ctx.beginPath();
      ctx.moveTo(10,138);
      ctx.lineTo(32,152);
      ctx.lineTo(18,116);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,248,230,${flash?0.96:0.84})`;
      ctx.lineWidth=1.2;
      ctx.stroke();

      // hand back spike
      ctx.fillStyle=armGradient(-4,150,30,210);
      ctx.beginPath();
      ctx.moveTo(0,160);
      ctx.lineTo(24,200);
      ctx.lineTo(-6,182);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,246,228,${flash?0.94:0.82})`;
      ctx.lineWidth=1.2;
      ctx.stroke();

      // claws with gleaming edges
      const clawOffsets=[-16,-2,12];
      for(const offset of clawOffsets){
        ctx.save();
        ctx.translate(offset,168);
        ctx.fillStyle=armGradient(-18,-4,18,46);
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.quadraticCurveTo(-16,18,-12,46);
        ctx.lineTo(12,38);
        ctx.lineTo(10,4);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,248,234,${flash?0.96:0.84})`;
        ctx.lineWidth=1.3;
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.84);
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-2,6);
        ctx.lineTo(8,36);
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
    }

    ctx.save();
    ctx.translate(0,-106);
    const neckSegments=4;
    for(let i=0;i<neckSegments;i++){
      const prog=i/(neckSegments-1);
      const segH=26- i*4;
      const segW=34 - prog*8;
      ctx.save();
      ctx.translate(0,i*16);
      ctx.fillStyle=metalGradient(-segW, -segH, segW, segH*1.4);
      ctx.beginPath();
      ctx.moveTo(-segW,-segH*0.4);
      ctx.lineTo(-segW*0.8,segH);
      ctx.lineTo(segW*0.8,segH);
      ctx.lineTo(segW,-segH*0.4);
      ctx.quadraticCurveTo(0,-segH*0.9,-segW,-segH*0.4);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,236,210,${flash?0.9:0.76})`;
      ctx.lineWidth=2;
      ctx.stroke();
      ctx.restore();
    }

    ctx.save();
    ctx.translate(0,-12);
    const headScaleX=0.41;
    const headScaleY=0.38;
    ctx.scale(headScaleX, headScaleY);

    const hornOuterFill=metalGradient(-96,-320,96,-120);
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.fillStyle=hornOuterFill;
      ctx.beginPath();
      ctx.moveTo(22,-188);
      ctx.quadraticCurveTo(88,-246,154,-338);
      ctx.lineTo(136,-356);
      ctx.quadraticCurveTo(90,-350,54,-290);
      ctx.lineTo(28,-188);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=flash?'rgba(255,236,214,0.96)':'rgba(255,214,176,0.82)';
      ctx.lineWidth=2.3;
      ctx.stroke();

      ctx.fillStyle=flash?'rgba(255,250,234,0.9)':'rgba(255,228,188,0.78)';
      ctx.beginPath();
      ctx.moveTo(32,-192);
      ctx.quadraticCurveTo(92,-250,134,-334);
      ctx.lineTo(110,-336);
      ctx.quadraticCurveTo(74,-296,44,-210);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(36,-200);
      ctx.quadraticCurveTo(98,-260,132,-342);
      ctx.stroke();

      ctx.strokeStyle=flash?'rgba(255,210,170,0.88)':'rgba(255,160,100,0.74)';
      ctx.lineWidth=1.1;
      ctx.beginPath();
      ctx.moveTo(50,-214);
      ctx.quadraticCurveTo(104,-274,124,-344);
      ctx.stroke();
      ctx.restore();
    }

    const crownGrad=metalGradient(-70,-188,70,36);
    ctx.fillStyle=crownGrad;
    ctx.beginPath();
    ctx.moveTo(0,-222);
    ctx.lineTo(-44,-198);
    ctx.quadraticCurveTo(-100,-132,-80,-56);
    ctx.quadraticCurveTo(-40,8,-12,40);
    ctx.lineTo(0,56);
    ctx.lineTo(12,40);
    ctx.quadraticCurveTo(40,8,80,-56);
    ctx.quadraticCurveTo(100,-132,44,-198);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,238,214,${flash?0.96:0.82})`;
    ctx.lineWidth=2.2;
    ctx.stroke();

    ctx.strokeStyle=darkMetal(0.92);
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(0,-210);
    ctx.lineTo(0,-34);
    ctx.moveTo(-28,-164);
    ctx.lineTo(-10,-48);
    ctx.moveTo(28,-164);
    ctx.lineTo(10,-48);
    ctx.stroke();

    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.fillStyle=metalGradient(-48,-160,96,-12);
      ctx.beginPath();
      ctx.moveTo(16,-176);
      ctx.lineTo(120,-128);
      ctx.lineTo(94,-62);
      ctx.quadraticCurveTo(46,-8,20,2);
      ctx.lineTo(4,-22);
      ctx.quadraticCurveTo(12,-86,16,-176);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,232,208,${flash?0.94:0.78})`;
      ctx.lineWidth=1.8;
      ctx.stroke();
      ctx.strokeStyle=darkMetal(0.88);
      ctx.lineWidth=1.1;
      ctx.beginPath();
      ctx.moveTo(20,-156);
      ctx.lineTo(78,-66);
      ctx.lineTo(26,-14);
      ctx.stroke();
      ctx.restore();
    }

    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.fillStyle=metalGradient(-36,-36,72,66);
      ctx.beginPath();
      ctx.moveTo(-2,-12);
      ctx.lineTo(46,12);
      ctx.lineTo(62,64);
      ctx.quadraticCurveTo(30,84,6,64);
      ctx.lineTo(-6,20);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,226,${flash?0.96:0.84})`;
      ctx.lineWidth=1.5;
      ctx.stroke();
      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.1;
      ctx.beginPath();
      ctx.moveTo(18,18);
      ctx.lineTo(46,58);
      ctx.stroke();
      ctx.restore();
    }

    ctx.fillStyle=metalGradient(-44,-76,44,52);
    ctx.beginPath();
    ctx.moveTo(-32,-4);
    ctx.lineTo(-68,-46);
    ctx.quadraticCurveTo(-76,-104,-28,-174);
    ctx.quadraticCurveTo(-6,-206,0,-216);
    ctx.quadraticCurveTo(6,-206,28,-174);
    ctx.quadraticCurveTo(76,-104,68,-46);
    ctx.lineTo(32,-4);
    ctx.quadraticCurveTo(0,20,-32,-4);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,240,220,${flash?0.94:0.8})`;
    ctx.lineWidth=2;
    ctx.stroke();

    ctx.strokeStyle=`rgba(255,228,200,${flash?0.9:0.76})`;
    ctx.lineWidth=1.4;
    ctx.beginPath();
    ctx.moveTo(-34,-54);
    ctx.quadraticCurveTo(0,-92,34,-54);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0,-188);
    ctx.quadraticCurveTo(0,-96,0,18);
    ctx.stroke();

    ctx.fillStyle=metalGradient(-32,6,32,78);
    ctx.beginPath();
    ctx.moveTo(-30,12);
    ctx.lineTo(-14,64);
    ctx.quadraticCurveTo(0,88,14,64);
    ctx.lineTo(30,12);
    ctx.lineTo(12,-18);
    ctx.lineTo(-12,-18);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,236,214,${flash?0.92:0.78})`;
    ctx.lineWidth=1.7;
    ctx.stroke();

    ctx.fillStyle='rgba(32,8,6,0.92)';
    ctx.beginPath();
    ctx.moveTo(-26,-6);
    ctx.quadraticCurveTo(0,-34,26,-6);
    ctx.quadraticCurveTo(10,16,0,24);
    ctx.quadraticCurveTo(-10,16,-26,-6);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle=metalGradient(-24,16,24,70);
    ctx.beginPath();
    ctx.moveTo(-20,10);
    ctx.lineTo(-4,56);
    ctx.quadraticCurveTo(0,64,4,56);
    ctx.lineTo(20,10);
    ctx.lineTo(10,-8);
    ctx.lineTo(-10,-8);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,240,224,${flash?0.94:0.82})`;
    ctx.lineWidth=1.3;
    ctx.stroke();

    ctx.fillStyle=flash?'#fffdf0':'#fdf1d2';
    for(const side of [-1,1]){
      for(let i=0;i<3;i++){
        const offset=-12 + i*8;
        ctx.beginPath();
        ctx.moveTo(offset*side,-6);
        ctx.lineTo((offset+3)*side,6);
        ctx.lineTo((offset+1.2)*side,0);
        ctx.closePath();
        ctx.fill();
      }
    }

    ctx.strokeStyle=darkMetal(0.88);
    ctx.lineWidth=1.1;
    ctx.beginPath();
    ctx.moveTo(-18,6);
    ctx.lineTo(-6,48);
    ctx.moveTo(18,6);
    ctx.lineTo(6,48);
    ctx.stroke();

    ctx.save();
    ctx.translate(0,-146);
    const gemGrad=ctx.createRadialGradient(0,0,0,0,0,18);
    gemGrad.addColorStop(0, flash?'#eaffff':'#9effff');
    gemGrad.addColorStop(0.5, flash?'rgba(120,252,255,0.95)':'rgba(60,228,250,0.92)');
    gemGrad.addColorStop(1,'rgba(0,140,180,0)');
    ctx.beginPath();
    ctx.ellipse(0,0,11,16,0,0,Math.PI*2);
    ctx.fillStyle=gemGrad;
    ctx.shadowColor=flash?'rgba(120,252,255,0.86)':'rgba(60,220,240,0.72)';
    ctx.shadowBlur=22;
    ctx.fill();
    ctx.restore();

    ctx.save();
    const eyeGlow=flash?'rgba(255,90,60,0.96)':'rgba(255,36,0,0.92)';

    const drawEyeBase=side=>{
      const isLeft=side<0;
      const tipX=62*side;
      const tipY=-106;
      const innerX=14*side;
      const innerY=-44;
      const lowerX=48*side;
      const lowerY=-18;
      let grad;
      if(isLeft){
        grad=ctx.createLinearGradient(tipX, tipY, innerX, innerY);
        grad.addColorStop(0, flash?'#ff7058':'#ff6a54');
        grad.addColorStop(0.45, flash?'#ff2a00':'#ff2100');
        grad.addColorStop(1, flash?'#a30000':'#450000');
      }else{
        grad=ctx.createLinearGradient(innerX, innerY, tipX, tipY);
        grad.addColorStop(0, flash?'#a30000':'#450000');
        grad.addColorStop(0.55, flash?'#ff2a00':'#ff2100');
        grad.addColorStop(1, flash?'#ff7058':'#ff6a54');
      }
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.moveTo(tipX, tipY);
      ctx.lineTo(innerX, innerY);
      ctx.lineTo(lowerX, lowerY);
      ctx.closePath();
      ctx.shadowColor=eyeGlow;
      ctx.shadowBlur=flash?36:34;
      ctx.fill();
      ctx.strokeStyle=flash?'rgba(255,224,210,0.84)':'rgba(255,120,90,0.66)';
      ctx.lineWidth=1.5;
      ctx.stroke();
      ctx.strokeStyle=flash?'rgba(255,198,184,0.92)':'rgba(255,88,66,0.74)';
      ctx.lineWidth=1.15;
      ctx.beginPath();
      ctx.moveTo(tipX - side*4, tipY+6);
      ctx.lineTo(innerX, innerY-6);
      ctx.stroke();
    };

    const drawEyeHighlights=side=>{
      const isLeft=side<0;
      ctx.shadowBlur=0;
      ctx.fillStyle='rgba(255,255,255,0.42)';
      ctx.beginPath();
      const tipX=62*side;
      const tipY=-106;
      const innerX=14*side;
      const innerY=-44;
      const lowerX=48*side;
      const lowerY=-18;
      const highlightAngle=isLeft?-0.42:0.42;
      const highlightX=tipX - side*10;
      const highlightY=tipY+26;
      ctx.ellipse(highlightX, highlightY, 5.4, 3.4, highlightAngle, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle='rgba(255,255,255,0.28)';
      ctx.beginPath();
      const lowerMidX=(innerX+lowerX)/2;
      const lowerMidY=(innerY+lowerY)/2 + 6;
      const innerHighlightX=innerX + side*6;
      const innerHighlightY=innerY + 8;
      const lowerHighlightX=lowerX + side*4;
      const lowerHighlightY=lowerY + 4;
      ctx.moveTo(lowerMidX, lowerMidY);
      ctx.lineTo(innerHighlightX, innerHighlightY);
      ctx.lineTo(lowerHighlightX, lowerHighlightY);
      ctx.closePath();
      ctx.fill();
    };

    drawEyeBase(-1);
    drawEyeBase(1);
    drawEyeHighlights(-1);
    drawEyeHighlights(1);
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=flash?'rgba(255,132,110,0.35)':'rgba(255,24,0,0.26)';
    ctx.beginPath();
    ctx.ellipse(-30,-46,18,11,-0.32,0,Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(30,-46,18,11,0.32,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.restore();

    ctx.restore();
    ctx.restore();
  }

  function drawDragonAttackVisuals(now){
    if(dragonAttackState && dragonAttackState.type==='deathRay'){
      for(const orb of dragonDeathRayOrbs){
        if(!orb.x || !orb.y) continue;
        const x=orb.x*scaleX;
        const y=orb.y*scaleY;
        const baseR=14*((scaleX+scaleY)/2);
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const grd=ctx.createRadialGradient(x,y,0,x,y,baseR*1.6);
        grd.addColorStop(0,'rgba(255,255,230,0.95)');
        grd.addColorStop(0.4,'rgba(255,236,160,0.85)');
        grd.addColorStop(1,'rgba(255,200,80,0.05)');
        ctx.fillStyle=grd;
        ctx.beginPath();
        ctx.arc(x,y,baseR*1.6,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    for(let i=dragonDeathRayBeams.length-1;i>=0;i--){
      const beam=dragonDeathRayBeams[i];
      if(now>=beam.end){ dragonDeathRayBeams.splice(i,1); continue; }
      const impactAt = beam.impactAt || beam.end;
      const travelSpan = Math.max(1, impactAt - beam.start);
      const travelProg = Math.max(0, Math.min(1, (now - beam.start)/travelSpan));
      const drawX = beam.hit ? beam.x2 : beam.x1 + (beam.x2 - beam.x1)*travelProg;
      const drawY = beam.hit ? beam.y2 : beam.y1 + (beam.y2 - beam.y1)*travelProg;
      const fadeSpan = Math.max(1, beam.end - impactAt);
      const fadeProg = beam.hit ? Math.max(0, Math.min(1, (now - impactAt)/fadeSpan)) : 0;
      const intensity = beam.hit ? 1 - fadeProg : Math.min(1, 0.4 + travelProg*0.6);
      const x1=beam.x1*scaleX, y1=beam.y1*scaleY;
      const x2=drawX*scaleX, y2=drawY*scaleY;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const outer=ctx.createLinearGradient(x1,y1,x2,y2);
      outer.addColorStop(0,'rgba(255,230,150,'+(0.18+0.42*intensity)+')');
      outer.addColorStop(1,'rgba(255,200,120,'+(0.45+0.4*intensity)+')');
      ctx.strokeStyle=outer;
      ctx.lineWidth=10;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      const core=ctx.createLinearGradient(x1,y1,x2,y2);
      core.addColorStop(0,'rgba(255,255,230,'+(0.32+0.52*intensity)+')');
      core.addColorStop(1,'rgba(255,240,180,'+(0.54+0.3*intensity)+')');
      ctx.strokeStyle=core;
      ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      if(!beam.hit){
        const tipR=8*((scaleX+scaleY)/2)*(0.6+travelProg*0.8);
        const tipGrad=ctx.createRadialGradient(x2,y2,0,x2,y2,tipR);
        tipGrad.addColorStop(0,'rgba(255,255,240,'+(0.7+0.3*intensity)+')');
        tipGrad.addColorStop(1,'rgba(255,200,100,0)');
        ctx.fillStyle=tipGrad;
        ctx.beginPath(); ctx.arc(x2,y2,tipR,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
    if(dragonAttackState && dragonAttackState.type==='annihilation'){
      const state=dragonAttackState;
      const L=layout();
      if(state.phase==='challenge'){
        const remain=Math.max(0, state.countdownEnd-now);
        const sec=Math.max(0, Math.ceil(remain/1000));
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.font=`${Math.round(72*((scaleX+scaleY)/2))}px 'Playfair Display',serif`;
        ctx.textAlign='center';
        ctx.textBaseline='top';
        ctx.fillStyle='rgba(255,236,190,0.92)';
        ctx.shadowColor='rgba(255,200,120,0.85)';
        ctx.shadowBlur=24*((scaleX+scaleY)/2);
        let anchorY=Math.max(20, (L.top-60));
        if(dragonMarquee){
          const marqueeHeight=60;
          const marqueeTop=Math.max(16, L.top - marqueeHeight - 14);
          anchorY=Math.max(anchorY, marqueeTop + marqueeHeight + 12, L.top + 12);
        }
        ctx.fillText(String(sec), (1100/2)*scaleX, anchorY*scaleY);
        ctx.restore();
      }else if(state.phase==='detonate'){
        const span=Math.max(1, state.explosionEnd - state.detonateStart);
        const prog=1-Math.max(0, (state.explosionEnd-now)/span);
        const centerX=550*scaleX;
        const L=layout();
        const stageHeight=L.rows*(brickH+L.pad) - L.pad;
        const centerY=(L.top + stageHeight/2)*scaleY;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const maxR=Math.max(canvas.width, canvas.height)*1.2;
        const radial=ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxR);
        radial.addColorStop(0,`rgba(255,255,240,${0.86 - 0.4*prog})`);
        radial.addColorStop(0.35,`rgba(255,240,190,${0.75 - 0.3*prog})`);
        radial.addColorStop(0.7,`rgba(255,210,120,${0.55 - 0.2*prog})`);
        radial.addColorStop(1,'rgba(255,160,60,0)');
        ctx.fillStyle=radial;
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
        ctx.save();
        ctx.globalAlpha=0.32 + 0.22*Math.sin(prog*Math.PI*3);
        ctx.fillStyle='rgba(255,200,120,0.95)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }
    }
  }

  function drawDragonLayer(){
    if(level!==15) return;
    const now=performance.now();
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    if(dragonPhase==='intro' && dragonAnchor){
      const cx=(dragonAnchor.x+dragonAnchor.w/2)*scaleX;
      const cy=(dragonAnchor.y+dragonAnchor.h+80)*scaleY;
      const rad=Math.max(dragonAnchor.w, dragonAnchor.h)*1.3*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      g.addColorStop(0,'rgba(255,220,160,0.18)');
      g.addColorStop(1,'rgba(255,220,160,0)');
      ctx.fillStyle=g;
      ctx.beginPath();
      ctx.arc(cx,cy,rad,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    for(const fx of dragonBursts){
      const life=fx.life||1200;
      const prog=Math.max(0, Math.min(1,(now-fx.t0)/life));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      if(fx.type==='ring'){
        const rad=(fx.r0||0)+((fx.r1||320)-(fx.r0||0))*easeOut(prog);
        ctx.strokeStyle=`rgba(${fx.color||'255,210,140'},${0.4*(1-prog)})`;
        ctx.lineWidth=(fx.width||20)*((scaleX+scaleY)/2)*(1-prog*0.6);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='flare'){
        const rad=(fx.r1||260)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(20, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0,`rgba(${fx.color||'255,215,160'},${0.5*(1-prog)})`);
        grad.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='spark'){
        const rad=(fx.r1||200)*prog*((scaleX+scaleY)/2);
        ctx.strokeStyle=`rgba(${fx.color||'255,210,150'},${0.75*(1-prog)})`;
        ctx.lineWidth=2.6*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.moveTo(fx.x*scaleX-rad, fx.y*scaleY);
        ctx.lineTo(fx.x*scaleX+rad, fx.y*scaleY);
        ctx.moveTo(fx.x*scaleX, fx.y*scaleY-rad*0.6);
        ctx.lineTo(fx.x*scaleX, fx.y*scaleY+rad*0.6);
        ctx.stroke();
      }else if(fx.type==='ember'){
        const size=14*((scaleX+scaleY)/2)*(1-prog);
        ctx.fillStyle=`rgba(255,200,110,${0.7*(1-prog)})`;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, size,0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='halo'){
        const rad=(fx.r0||40)+((fx.r1||320)-(fx.r0||40))*prog;
        ctx.strokeStyle=`rgba(${fx.color||'255,210,140'},${0.25*(1-prog)})`;
        ctx.lineWidth=8*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='mega'){
        const rad=(fx.r1||720)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(40, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0,'rgba(255,250,220,0.95)');
        grad.addColorStop(0.35,'rgba(255,210,140,0.55)');
        grad.addColorStop(1,'rgba(255,180,90,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='apocalypse'){
        const startR=fx.r0||120;
        const endR=fx.r1||900;
        const rad=startR + (endR-startR)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(60, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0,`rgba(255,255,250,${0.96 - prog*0.4})`);
        grad.addColorStop(0.25,`rgba(255,240,200,${0.82 - prog*0.3})`);
        grad.addColorStop(0.6,`rgba(255,214,130,${0.65 - prog*0.25})`);
        grad.addColorStop(1,'rgba(255,180,80,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='shockwave'){
        const startR=fx.r0||0;
        const endR=fx.r1||980;
        const rad=startR + (endR-startR)*easeOut(prog);
        const width=(fx.width||32)*((scaleX+scaleY)/2)*(1-prog*0.5);
        ctx.strokeStyle=`rgba(${fx.color||'255,230,190'},${0.55*(1-prog)})`;
        ctx.lineWidth=width;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='emberRain'){
        if(!fx.particles){
          const count=fx.count||70;
          fx.particles=Array.from({length:count},()=>({
            angle:Math.random()*Math.PI*2,
            radius:30+Math.random()*200,
            speed:220+Math.random()*320,
            size:9+Math.random()*16,
            drift:(Math.random()*0.6-0.3)
          }));
        }
        const flicker=0.5+0.5*Math.sin(prog*Math.PI*4);
        for(const p of fx.particles){
          const dist = p.radius + p.speed*prog;
          const px = fx.x + Math.cos(p.angle + p.drift*prog)*dist;
          const py = fx.y + Math.sin(p.angle + p.drift*prog)*dist*0.65;
          const size=p.size*((1-prog)*0.8+0.2)*((scaleX+scaleY)/2);
          ctx.fillStyle=`rgba(255,${205+Math.round(35*flicker)},${120+Math.round(25*(1-prog))},${0.55*(1-prog)})`;
          ctx.beginPath();
          ctx.arc(px*scaleX, py*scaleY, size,0,Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
    }
    if(dragonBoss && (dragonPhase==='active' || dragonPhase==='dying')){
      renderDragonBody(dragonBoss, now);
    }
    drawDragonAttackVisuals(now);
  }

  function drawDragonMarquee(){
    if(!dragonMarquee) return;
    const now=performance.now();
    const {start, fadeStart, end, text} = dragonMarquee;
    const style=dragonMarquee.style||'alert';
    if(now>=end){ dragonMarquee=null; return; }
    let alpha=1;
    if(style!=='victorySolid' && fadeStart && now>fadeStart){
      alpha=Math.max(0, 1 - (now - fadeStart)/(end - fadeStart||1));
    }
    const areaHeight=60;
    const top=Math.max(16, layout().top - areaHeight - 14);
    const width=Math.min(560, 1100-120);
    const x=(1100-width)/2;
    const radius=20;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, top, width, areaHeight, radius);
    if(style==='victorySolid'){
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(82,52,10,0.96)');
      grad.addColorStop(1,'rgba(48,26,6,0.96)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,220,160,0.85)';
      ctx.lineWidth=2.6;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      ctx.fillStyle='#fff4d4';
      const fontSize=Math.max(24, Math.round(28*((scaleX+scaleY)/2)));
      ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,200,120,0.6)';
      ctx.shadowBlur=18*((scaleX+scaleY)/2);
      ctx.fillText(text, (x+width/2)*scaleX, (top+areaHeight/2)*scaleY);
      ctx.shadowBlur=0;
    }else if(style==='elegant'){
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(48,22,10,0.9)');
      grad.addColorStop(1,'rgba(28,12,6,0.88)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,210,150,0.85)';
      ctx.lineWidth=2.4;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+10;
      const innerY=top+6;
      const innerW=width-20;
      const innerH=areaHeight-12;
      ctx.save();
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      const innerGrad=ctx.createLinearGradient(innerX*scaleX, innerY*scaleY, innerX*scaleX, (innerY+innerH)*scaleY);
      innerGrad.addColorStop(0,'rgba(140,70,30,0.45)');
      innerGrad.addColorStop(1,'rgba(80,34,14,0.35)');
      ctx.fillStyle=innerGrad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,220,180,0.45)';
      ctx.lineWidth=1.4;
      ctx.stroke();
      ctx.restore();
      ctx.save();
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.clip();
      ctx.fillStyle='#ffeedd';
      const fontSize=Math.max(20, Math.round(26*((scaleX+scaleY)/2)));
      ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,150,110,0.55)';
      ctx.shadowBlur=14*((scaleX+scaleY)/2);
      ctx.fillText(text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
      ctx.restore();
    }else{
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(60,32,6,0.95)');
      grad.addColorStop(1,'rgba(32,18,4,0.9)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,210,120,0.75)';
      ctx.lineWidth=2.2;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+12;
      const innerY=top+6;
      const innerW=width-24;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.save();
      ctx.clip();
      ctx.fillStyle='#fff5d8';
      const fontSize=Math.max(18, Math.round(24*((scaleX+scaleY)/2)));
      ctx.font=`${fontSize}px 'Noto Sans TC','Playfair Display',sans-serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,200,120,0.55)';
      ctx.shadowBlur=12*((scaleX+scaleY)/2);
      ctx.fillText(text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawDragonHPBar(){
    if((dragonPhase!=='active' && dragonPhase!=='dying') || !dragonBoss) return;
    const L=layout();
    const barW=32;
    const maxH=700-(L.top+80);
    const barH=Math.max(200, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, dragonBoss.hp/dragonBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(92,58,12,0.96)');
    frameGrad.addColorStop(1,'rgba(46,28,8,0.9)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(255,210,120,0.8)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(28,18,6,0.92)');
    bg.addColorStop(1,'rgba(42,26,8,0.9)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(255,180,90,0.25)');
      fillGrad.addColorStop(0.4,'rgba(255,210,120,0.65)');
      fillGrad.addColorStop(1,'rgba(255,240,200,0.96)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    const segments=10;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - innerH*i/segments)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS æ¯€æ»…ä¹‹é¾', dragonBoss.hp, dragonBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(92,58,12,0.95)',
      bgBottom:'rgba(46,28,8,0.9)',
      frame:'rgba(255,210,120,0.78)',
      glow:'rgba(255,200,120,0.55)',
      textPrimary:'#ffeccd',
      textSecondary:'#fff3da'
    });
    ctx.restore();
  }

  function drawDragonHUD(){
    drawDragonMarquee();
    drawDragonHPBar();
  }

  function drawDemonHUD(){
    if(level!==20) return;
    if((demonPhase!=='active' && demonPhase!=='dying') || !demonBoss) return;
    const L=layout();
    const barW=32;
    const maxH=700-(L.top+80);
    const barH=Math.max(200, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, demonBoss.hp/demonBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(70,24,120,0.95)');
    frameGrad.addColorStop(1,'rgba(38,12,80,0.9)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(230,190,255,0.65)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(24,12,40,0.92)');
    bg.addColorStop(1,'rgba(34,16,58,0.9)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(180,110,250,0.22)');
      fillGrad.addColorStop(0.45,'rgba(210,150,255,0.62)');
      fillGrad.addColorStop(1,'rgba(255,230,255,0.96)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    const segments=10;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - innerH*i/segments)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS é­”ç‹åŸƒé‡Œèµ«æ›¼', demonBoss.hp, demonBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(70,24,120,0.95)',
      bgBottom:'rgba(38,12,80,0.9)',
      frame:'rgba(230,190,255,0.7)',
      glow:'rgba(200,150,255,0.55)',
      textPrimary:'#f1e4ff',
      textSecondary:'#f9efff'
    });
    ctx.restore();
  }


  function isSpecialBossActive(){
    return isSpaceBossActive() || isReaperActive() || isDragonActive() || isDemonActive();
  }

  function activeBossCenter(){
    if(isSpaceBossActive()) return {x:spaceBoss.x, y:spaceBoss.y, type:'space'};
    if(isReaperActive() && reaperBoss) return {x:reaperBoss.x, y:reaperBoss.y, type:'reaper'};
    if(isDragonActive() && dragonBoss) return {x:dragonBoss.x, y:dragonBoss.y, type:'dragon'};
    if(isDemonActive() && demonBoss) return {x:demonBoss.x, y:demonBoss.y, type:'demon'};
    return null;
  }

  function getActiveBossBounds(){
    if(isSpaceBossActive()) return getSpaceBossBounds();
    if(isReaperActive()) return getReaperBounds();
    if(isDragonActive()) return getDragonBounds();
    if(isDemonActive()) return getDemonBounds();
    return null;
  }

  function activeBossImpactPoint(fromX, fromY){
    if(isSpaceBossActive()) return spaceBossImpactPoint(fromX, fromY);
    if(isReaperActive()) return reaperImpactPoint(fromX, fromY);
    if(isDragonActive()) return dragonImpactPoint(fromX, fromY);
    if(isDemonActive()) return demonImpactPoint(fromX, fromY);
    return {x:fromX, y:fromY};
  }

  function damageActiveBoss(amount=1, source='generic', impact){
    if(isSpaceBossActive()) return damageSpaceBoss(amount, source, impact);
    if(isReaperActive()) return damageReaperBoss(amount, source, impact);
    if(isDragonActive()) return damageDragonBoss(amount, source, impact);
    if(isDemonActive()) return damageDemonBoss(amount, source, impact);
    return false;
  }

  function circleIntersectsActiveBoss(cx, cy, radius){
    if(isSpaceBossActive()) return circleIntersectsSpaceBoss(cx, cy, radius);
    if(isReaperActive()) return circleIntersectsReaper(cx, cy, radius);
    if(isDragonActive()) return circleIntersectsDragon(cx, cy, radius);
    if(isDemonActive()) return circleIntersectsDemon(cx, cy, radius);
    return false;
  }

  function activeBossClampPoint(x, y){
    if(isDragonActive()) return dragonClampPoint(x, y);
    if(isDemonActive()) return demonClampPoint(x, y);
    const bounds=getActiveBossBounds();
    if(!bounds) return {x, y};
    return {
      x: Math.max(bounds.x, Math.min(x, bounds.x + bounds.w)),
      y: Math.max(bounds.y, Math.min(y, bounds.y + bounds.h))
    };
  }
  // === ä¿®æ­£ï¼šæ ¼é»å°é½Šåœ°æ­ç¤ºåº•åœ–ï¼Œé¿å…é»‘æ´èˆ‡æµ®é»èª¤å·® ===
  function revealBrickArea(brick){
    if(!brick || brick.fallingTreasure) return;
    const L = layout();
    const cellW = brickW, cellH = brickH;
    // ä»¥æ ¼é»å®šä½ï¼ˆå››æ¨äº”å…¥ï¼‰
    const c0 = Math.max(0, Math.min(GAME_CONFIG.bricks.cols-1, Math.round((brick.x - L.pad) / (cellW + L.pad)) ));
    const r0 = Math.max(0, Math.min(L.rows-1, Math.round((brick.y - L.top) / (cellH + L.pad)) ));
    // è¦†è“‹çš„æ ¼æ•¸ï¼ˆBoss/å¤§ç£šå¯èƒ½>1ï¼‰
    const cellsX = Math.max(1, Math.round((brick.w + L.pad) / (cellW + L.pad)));
    const cellsY = Math.max(1, Math.round((brick.h + L.pad) / (cellH + L.pad)));
    for(let rr=0; rr<cellsY; rr++){
      for(let cc=0; cc<cellsX; cc++){
        const c = Math.min(GAME_CONFIG.bricks.cols-1, c0 + cc);
        const r = Math.min(L.rows-1, r0 + rr);
        const rx = L.pad + c*(cellW + L.pad);
        const ry = L.top + r*(cellH + L.pad);
        revealRects.push({x:rx, y:ry, w:cellW, h:cellH});
      }
    }
  }
function generateLevel(lv, L){
    const cols=L.cols, rows=L.rows, pad=L.pad, top=L.top;
    const baseHP = 1 + Math.floor((lv-1)/3);
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // é—œå¡å€æ®µ
    const late = lv>=7;
    const later = lv>=11;
    const endgame = lv>=15;

    // Bossæ¯5é—œ
    const isBoss = (lv%5===0);
    if(isBoss){
      if(lv===5){
        const bx = Math.floor(cols/2)-1;
        const by = 0;
        const w = brickW*2 + pad;
        const h = brickH*2 + pad;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:1, colorIdx:0, boss:true, face:'ç…', strong:true, unbreakable:true});
        spaceBossPlaceholder = bricks[placeholderIndex];
        if(spaceBossPlaceholder){
          spaceBossPlaceholder.hp=0;
          spaceBossPlaceholder.placeholderBoss=true;
        }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(c>=bx && c<=bx+1 && r>=by && r<=by+1) continue;
            const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
          }
        }
        return;
      }else if(lv===10){
        const bx = Math.floor(cols/2)-1;
        const by = 0;
        const w = brickW*2 + pad;
        const h = brickH*2 + pad;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:1, colorIdx:0, boss:true, face:'å½±', strong:true, unbreakable:true});
        reaperPlaceholder = bricks[placeholderIndex];
        if(reaperPlaceholder){
          reaperPlaceholder.hp=0;
          reaperPlaceholder.placeholderBoss=true;
        }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(c>=bx && c<=bx+1 && r>=by && r<=by+1) continue;
            const isTopShield = (r===0 && (c%2===0));
            if(isTopShield){
              addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
              continue;
            }
            const moving = (r%3===0 && c%4===0);
            const hpBoost = baseHP + (r%2===0?1:0);
            const explosive = (!moving && Math.random()<GAME_CONFIG.bricks.explosiveChance*0.6);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:hpBoost, colorIdx:(r%4), moving, vx:moving?((Math.random()<0.5?-1:1)*0.7):0, explosive});
          }
        }
        return;
      }
      // ä¸­å¤®å¤§Bossï¼ˆ2x2ç£šå°ºå¯¸ä¸€å¡Šï¼‰
      const bx = Math.floor(cols/2)-1;
      const w = brickW*2 + pad;
      const h = brickH*2 + pad;
      const hpList=[10,20,30,40];
      const bossIdx = Math.floor(lv/5)-1;
      const bossHP = hpList[Math.max(0,Math.min(3,bossIdx))];
      const faces=['ç…','é¨','ç›®','é­”'];
      if(lv===15){
        const by=0;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:bossHP, colorIdx:0, boss:true, face:faces[bossIdx], strong:true, unbreakable:true, cyclops:true, cyclopsRevealed:false});
        dragonPlaceholder = bricks[placeholderIndex];
        if(dragonPlaceholder){ dragonPlaceholder.placeholderBoss=true; }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(r===0) continue;
            if(r===1 && c>=bx && c<=bx+1) continue;
            const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
          }
        }
        return;
      }else if(lv===20){
        const by = 0;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:Infinity, colorIdx:0, boss:true, face:faces[bossIdx], strong:true, unbreakable:true, demonShell:true, hideBossHP:true});
        demonShellBrick = bricks[placeholderIndex];
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(c>=bx && c<=bx+1 && r===by) continue;
            const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
          }
        }
        return;
      }
      const by = Math.max(1, Math.floor(rows/2)-1);
      addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:bossHP, colorIdx:0, boss:true, face:faces[bossIdx], strong:true, unbreakable:true});
      // å‘¨åœè­·è¡›ç£š
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(c>=bx && c<=bx+1 && r>=by && r<=by+1) continue; // ç•™ Boss æœ¬é«”
          const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
          addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
        }
      }
      // åŠ é»ä¸å¯ç ´å£é‚Šæ¡†
      for(let c=0;c<cols;c+=2) addBrick(bricks, xAt(c), yAt(0), brickW, brickH, {unbreakable:true});
      return;
    }

    // éBossé—œï¼šè¨­è¨ˆä¸åŒæ’åˆ—
    if(lv<=3){
      // åˆå­¸ï¼šæ»¿ç‰ˆ + å°‘é‡çˆ†ç‚¸
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance*0.7;
        addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
      }
    }else if(lv<=6){
      // V å½¢ï¼‹ä¸­é–“èµ°å»Š
      const mid=Math.floor(cols/2);
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(Math.abs(c-mid)===r%5 && r<rows-1){ // V
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+((r%2)?1:0), colorIdx:r%4});
          }else if(r===Math.floor(rows/2) && (c%3===0)){ // ä¸­ç·šçˆ†ç‚¸
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, explosive:true, colorIdx:r%4});
          }
        }
      }
    }else if(lv<=10){
      // åŠ å…¥ä¸å¯ç ´å£éš”æ¿èˆ‡å°‘é‡ç§»å‹•ç£š
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r%4===0 && c%3===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else{
            const moving = (r%3===0 && c%4===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, moving, vx: moving? ((Math.random()<0.5?-1:1)*0.6) : 0});
          }
        }
      }
    }else if(lv<=14){
      // äº¤éŒ¯æ£‹ç›¤ + å¼·åå½ˆå¸¶
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if((r+c)%2===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, strong:(r%4===1)});
          }else if(r%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, moving:true, vx: (Math.random()<0.5?-1:1)*0.8});
          }
        }
      }
    }else{
      // çµ‚ç›¤ï¼šéš§é“ã€ç§»å‹•éšŠå½¢ã€å¼·åå½ˆè­·ç‰†
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r===1 || r===rows-2){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%3===0 && (r%2===0)){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+2, strong:true});
          }else{
            const mv=(r%3===1 && c%2===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, moving:mv, vx: mv?((Math.random()<0.5?-1:1)*1.0):0});
          }
        }
      }
    }
  }


  function canDestroyBrick(b){ const now=performance.now(); if(b.unbreakable) return false; if(b.lockedUntil && now < b.lockedUntil) return false; return true; }
  function damageOrDestroy(i, amount=1){
    const b=bricks[i]; if(!b) return; if(b.unbreakable) return;
    if(b.elite && !b.prompted){ showPrompt('èè‹±ç£š'); b.prompted=true; }
    if(b.boss && !b.prompted){ showPrompt('Bossï¼'); b.prompted=true; }
    const now=performance.now();
    if(b.lockedUntil && now < b.lockedUntil) return;
    b.hp = (b.hp||1) - amount;
    if(b.hp<=0){
      if(b.elite){ stats.eliteKills++; }
      revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); updateHUD();
    }
  }

  function bossKillEffect(b, opts={}){
    const cx=b.x+b.w/2, cy=b.y+b.h/2;
    spawnParticles(cx,cy,'#fff5c0',60,2.5,4.0,4.5);
    spawnParticles(cx,cy,'#ff4d6d',40,2.0,3.5,3.5);
    screenShake=Math.max(screenShake,6);
    playSFX('fireExplosion');
    showComboNotice(`æˆåŠŸæ“Šæ®ºç¬¬${level}é—œBoss!`,5000,3000);
    const dropMode = opts.dropNineCat ?? 'never';
    if(dropMode==='always'){
      spawnPower(cx-12,cy,{forceType:'NINE'});
    } else if(dropMode==='default' || dropMode==='chance'){
      if(Math.random()<0.5){ spawnPower(cx-12,cy,{forceType:'NINE'}); }
    }
  }
  function destroyBrick(i, sfx='default'){
    const b=bricks[i]; if(!b) return; if(!canDestroyBrick(b)) return;
    if(b.elite && !b.prompted){ showPrompt('èè‹±ç£š'); b.prompted=true; }
    if(b.boss && !b.prompted){ showPrompt('Bossï¼'); b.prompted=true; }
    if(b.boss){
      b.hp-=1;
      if(b.hp<=0){
        bossKillEffect(b);
        revealBrickArea(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; updateHUD();
      }
      return;
    }
    if(b.elite){ stats.eliteKills++; }
    const bx=b.x+b.w/2, by=b.y+b.h/2;
    const color=b.treasure?'#ffdf6f':b.boss?'#ff4d6d':b.unbreakable?'#888':b.strong?'#bb7aff':b.moving?'#6ec6ff':b.explosive?getVar('--expl'):brickColor(b.colorIdx);
    spawnParticles(bx,by,color,30,2.0,3.2,3.5);
    if(b.treasure){
      spawnParticles(bx,by,'#ffe8a3',20,2.0,3.2,3.6);
      const rainbowBurst=['#ff6ec7','#ff9f43','#ffe066','#8ce99a','#74c0fc','#b197fc','#ff85f5'];
      for(const col of rainbowBurst){ spawnParticles(bx,by,col,8,1.8,3.0,3.2); }
    }
    if(sfx==='default'){ beep(420,0.06,0.08); setTimeout(()=>beep(620,0.05,0.06),40); }
    else if(sfx!=='none'){ playSFX(sfx); }
    revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); updateHUD();
  }
  function damageBrick(i, dmg, sfx='default'){ for(let k=0;k<dmg;k++){ if(!bricks[i]) break; destroyBrick(i, sfx); } }
  function destroyNeighbors(idx){ const b=bricks[idx]; if(!b) return; const L=layout(); const near=[]; for(let j=bricks.length-1;j>=0;j--){ if(j===idx) continue; const t=bricks[j]; const dx=Math.abs((t.x+t.w/2)-(b.x+b.w/2)); const dy=Math.abs((t.y+t.h/2)-(b.y+b.h/2)); const thx=brickW+L.pad+2, thy=brickH+L.pad+2; if(dx<=thx && dy<=thy){ // é„°è¿‘ä¸€æ ¼
        if(canDestroyBrick(t)){
          if(t.boss){
            t.hp-=1;
            if(t.hp<=0){
              bossKillEffect(t);
              revealBrickArea(t); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(t)); stats.bossKills++; }
          } else {
            revealBrickArea(t); maybeDropFromBrick(t); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(t)); if(t.elite) stats.eliteKills++;
          }
        }
      }
    }
    updateHUD();
  }

  function explodeAt(cx,cy){
    const radius=Math.max(brickW,brickH)*1.3;
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy);
      if(d<=radius){
        if(b.unbreakable){ continue; }
        // Bossï¼šåªæ‰£è¡€ï¼Œä¸ç§’æ®º
        if(b.boss){
          b.hp -= 1;
          if(b.hp<=0){ bossKillEffect(b); revealBrickArea(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; }
        }else{
          revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++;
        }
        spawnParticles(bx,by,'#ffdd99',14,1.7,2.6,3);
      }
    }
    if(circleIntersectsActiveBoss(cx,cy,radius)){
      const center=activeBossCenter();
      const impact=center?{x:center.x,y:center.y}:{x:cx,y:cy};
      damageActiveBoss(1,'fire',impact);
    }
    spawnParticles(cx,cy,'#ffbb55',24,2.1,3.2,4); updateHUD(); playSFX('explosion');
  }

  function fireExplosionAt(cx,cy,radius){
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy);
      if(d<=radius){
        if(canDestroyBrick(b)){
          if(b.boss){
            b.hp-=1;
            if(b.hp<=0){ bossKillEffect(b); revealBrickArea(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; updateHUD(); }
          }
          else {
            revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++; updateHUD();
          }
        }
        spawnParticles(bx,by,'#ffdd99',20,1.8,2.8,3.5);
      }
    }
    if(circleIntersectsActiveBoss(cx,cy,radius)){
      const center=activeBossCenter();
      const impact=center?{x:center.x,y:center.y}:{x:cx,y:cy};
      damageActiveBoss(1,'fire',impact);
    }
    fireExplosions.push({x:cx,y:cy,r:radius,t0:performance.now(),life:400});
    spawnParticles(cx,cy,'#ff5500',60,2.6,3.8,4.5);
    spawnParticles(cx,cy,'#ffaa33',40,2.8,4.0,3.8);
    spawnParticles(cx,cy,'#fff4cc',20,3.0,4.2,3.0);
    screenShake=Math.max(screenShake,6); updateHUD(); playSFX('fireExplosion');
  }

  function fireCollide(){ if(buffs.FIRE.active){ fireEnergy++; updateFireEnergy(); } }

  // === æ‰è½é“å…· ===
  const powerups=[];

  // === å¤©ç©ºéš¨æ©Ÿå¢ç›Šæ‰è½ï¼ˆç¬¬1é—œæ¯25ç§’ â†’ ç¬¬20é—œæ¯6ç§’ ç·šæ€§éæ¸›ï¼‰ ===
  let nextSkyDropAt = 0;
  function skyDropIntervalMs(lv){
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const s = 25*1000 * (1-t) + 6*1000 * t;
    return s;
  }
  function scheduleNextSkyDrop(){ nextSkyDropAt = performance.now() + skyDropIntervalMs(level); }
  function spawnBeneficialAtTop(){
    // å¾æ‰€æœ‰éæ¸›ç›Šçš„é“å…·ä¸­éš¨æ©ŸæŒ‘é¸ä¸€ç¨®ä½œç‚ºéš¨æ©Ÿæ‰è½å¢ç›Š
    // è‹¥ç•«é¢å·²æœ‰ç‰¹æ®Šé“å…·æ‰è½ï¼Œæš«æ™‚æ’é™¤ç‰¹æ®Šé“å…·
    const goodTypes = ALL_TYPES.filter(k => GAME_CONFIG.powers[k].type !== 'debuff' && k !== 'NINE');
    let pool = goodTypes;
    if(powerups.some(p=>p.isSpecial)){
      pool = pool.filter(k => {
        const t = GAME_CONFIG.powers[k].type;
        return t !== 'special';
      });
    }
    if(!pool.length) return;
    const type = pool[Math.floor(Math.random()*pool.length)];
    const def = GAME_CONFIG.powers[type];
    if(!def) return;
    const isSpecial = (def.type === 'special');
    // è¨­å®šé€Ÿåº¦ï¼šç‰¹æ®Šåæ…¢
    let speed = GAME_CONFIG.powerCapsule.fallVy;
    if(isSpecial) speed *= 0.75;
    // æ±ºå®šæ‰è½æ–¹å‘
    const horizontal = orientLeft;
    let px, py;
    if(horizontal){
      // æ°´å¹³æ‰è½ï¼šå¾å³å´éš¨æ©Ÿ y é–‹å§‹
      px = 1100 - 40;
      const L = layout();
      py = L.top + 20 + Math.random() * (700 - 60 - L.top);
    } else {
      // å‚ç›´æ‰è½ï¼šå¾ç•«é¢ä¸Šæ–¹éš¨æ©Ÿ x
      px = 40 + Math.random() * (1100 - 80);
      py = layout().top - 20;
    }
    powerups.push({
      x: px,
      y: py,
      w: GAME_CONFIG.powerCapsule.width,
      h: GAME_CONFIG.powerCapsule.height,
      speed: speed,
      horizontal: horizontal,
      type: type,
      isDebuff: false,
      isSpecial: isSpecial,
      phase: Math.random() * Math.PI * 2
    });
  }

  // é“å…·æ‰è½ç‡æŠ‘åˆ¶
  let burstStart=0, burstCount=0;
  let pendingGoodDrop=null;
  function activePowerCount(){
    const now=performance.now();
    let cnt=0;
    for(const k in buffs){
      const b=buffs[k];
      if(!b) continue;
      if(Array.isArray(b.stacks)){
        if(b.stacks.some(t=>t>now)) cnt++;
      }else if(b.active && (!b.until || b.until>now)){
        cnt++;
      }
    }
    return cnt;
  }
  function maybeDropFromBrick(b, rateMul=1){
    if(!b || b.unbreakable) return;
    if(b.treasure){
      spawnPower(b.x + b.w/2 - GAME_CONFIG.powerCapsule.width/2, b.y + b.h/2, {forceGood:true});
      return;
    }
    // Bossä¸æœƒæ‰è½ä¸€èˆ¬å¢ç›Šï¼ˆä¿æŒå¹³è¡¡ï¼‰
    if(b.boss) return;
    const now=performance.now();
    if(!burstStart || now-burstStart>500){
      burstStart=now; burstCount=1;
    }else{
      burstCount++;
    }
    const actives=activePowerCount();
    if(actives===0){
      if(!pendingGoodDrop){
        const px=b.x+b.w/2-12, py=b.y+b.h/2;
        pendingGoodDrop={x:px,y:py};
        setTimeout(()=>{
          if(pendingGoodDrop && burstCount===1){
            spawnPower(pendingGoodDrop.x, pendingGoodDrop.y, {forceGood:true});
          }
          pendingGoodDrop=null;
        },0);
        return;
      }
      // å·²æœ‰ä¿åº•æ‰è½ç­‰å¾…ç¢ºèªï¼Œå¾ŒçºŒç£šå¡Šèµ°ä¸€èˆ¬æ‰è½è¨ˆç®—
    }
    let rate=dropRateForLevel(level);
    if(actives>=5) rate*=0.3;
    if(burstCount>=3){
      let factor;
      if(burstCount===3) factor=0.7;
      else if(burstCount===4) factor=0.4;
      else factor=0.1;
      rate*=factor;
    }
    rate *= rateMul;
    if(Math.random()<rate) spawnPower(b.x + b.w/2 - 12, b.y + b.h/2);
  }

  function dropRateForLevel(lv){
    const diff = getDiff();
    const base = diff.dropRate || 0.5;
    const startBoostAt = 8; // ä¸­æœŸé–‹å§‹æå‡æ‰è½ç‡
    const incPerLv = 0.02;
    let inc = Math.max(0, (lv - startBoostAt) * incPerLv);
    let max = 0.9;
    const d = (typeof difficultySel!=='undefined') ? difficultySel.value : 'normal';
    if(d==='normal') max = 0.7;
    if(d==='hard') max = 0.5;
    return Math.min(max, base + inc);
  }

  function spawnPower(x,y,opts={}){
    // éš¨æ©ŸæŒ‘é¸ä¸€ç¨®é“å…·é¡å‹ï¼ˆæ™®é€šæˆ–ç‰¹æ®Šï¼‰ï¼Œä¸¦æ ¹æ“šé¡å‹è¨­å®šæ‰è½é€Ÿåº¦èˆ‡é¡è‰²æ¨™è¨˜
    const {forceGood=false, forceType=null} = opts;
    const existingSpecial = powerups.some(p=>p.isSpecial);
    let pool, type;
    if(forceType){
      type = forceType;
    }else{
      if(forceGood){
        pool = ALL_TYPES.filter(k => GAME_CONFIG.powers[k].type !== 'debuff');
        if(existingSpecial){
          pool = pool.filter(k => { const t = GAME_CONFIG.powers[k].type; return t !== 'special'; });
        }
      }else{
        pool = NORMAL_TYPES;
        if(existingSpecial){
          pool = pool.filter(k => { const t = GAME_CONFIG.powers[k].type; return t !== 'special'; });
        }
      }
      pool = pool.filter(k=>k!=='NINE');
      if(!pool.length) return;
      type = pool[Math.floor(Math.random()*pool.length)];
    }
    const def = GAME_CONFIG.powers[type];
    if(!def) return;
    // åˆ¤æ–·æ˜¯å¦ç‚ºç‰¹æ®Šï¼ˆspecialï¼‰æˆ–æ¸›ç›Š
    const isSpecial = (def.type === 'special');
    const isDebuff = (def.type === 'debuff');
    // è¨­å®šåŸºç¤é€Ÿåº¦ï¼šç‰¹æ®Šåæ…¢ï¼Œæ¸›ç›Šåå¿«
    let speed = GAME_CONFIG.powerCapsule.fallVy;
    if(isSpecial) speed *= 0.75;
    if(isDebuff) speed *= 1.4;
    // æ ¹æ“šç•¶å‰å¤©åœ°ç¿»è½‰ç‹€æ…‹æ±ºå®šæ‰è½æ–¹å‘èˆ‡èµ·å§‹ä½ç½®
    const horizontal = orientLeft;
    let px = x, py = y;
    if(horizontal){
      // æ°´å¹³æ‰è½ï¼šå¾å³å´éš¨æ©Ÿ y é–‹å§‹å¾€å·¦ç§»å‹•
      px = 1100 - 40;
      const L = layout();
      // é¿å…é è¿‘ä¸Šä¸‹é‚Šç•Œï¼Œé ç•™ 40 åƒç´ 
      py = L.top + 20 + Math.random() * (700 - 60 - L.top);
    }
    powerups.push({
      x: px,
      y: py,
      w: GAME_CONFIG.powerCapsule.width,
      h: GAME_CONFIG.powerCapsule.height,
      speed: speed,
      horizontal: horizontal,
      type: type,
      isDebuff: isDebuff,
      isSpecial: isSpecial,
      phase: Math.random() * Math.PI * 2
    });
  }

  function applyPower(type){
    const _defC=GAME_CONFIG.powers[type]; if(_defC){ if(_defC.type==='debuff') stats.debuffs++; else if(_defC.type) stats.buffs++; }
    const def=GAME_CONFIG.powers[type]; if(!def) return; const now=performance.now();
    const fullLabel = def.label + (def.desc ? `(${def.desc})` : '');
    let promptText='';
    if(def.type==='buff') promptText=`å¢ç›Šï¼š${fullLabel}`;
    else if(def.type==='debuff') promptText=`æ¸›ç›Šï¼š${fullLabel}`;
    else if(def.type==='special') promptText=`ç‰¹æ®Šï¼š${fullLabel}`;
    const exist=buffs[type];
    let active=false;
    if(type==='LONG'){ active = exist && exist.stacks && exist.stacks.some(t=>t>now); }
    else active = exist && exist.active && exist.until && exist.until>now;
    if(promptText && !active) showPrompt(promptText);
    // æ›´æ–°æœ€è¿‘å–å¾—å¢ç›Šçš„æ™‚é–“ï¼šéæ¸›ç›Šé¡å‹ï¼ˆå«ç‰¹æ®Šï¼‰çš†è¦–ç‚ºå¢ç›Š
    if(def.type !== 'debuff'){
      lastBeneficialPickupAt = now;
      nextAutoBeneficialDropAt = now + 10000;
      if(def.type === 'buff') addScore(10);
      else if(def.type === 'special') addScore(50);
      updateHUD();
    }
    // ç¬ç™¼ç‰¹æ®Šå¢ç›Š
    if(def.instant){
      if(type==='PHOENIX'){ // é³³å‡°é£›é + ç«ç„° + éš¨æ©Ÿä¸€åŠæ¶ˆé™¤ï¼ˆBossåªæ‰£1ï¼‰
        phoenixAnim={x:canvas.width+220,tEnd:now+1200};
        const keep=[]; for(const b of bricks){
          if(Math.random()<0.5){
            if(b.unbreakable){ keep.push(b); continue; }
            if(b.boss){
              b.hp -= 1;
              if(b.hp>0){ keep.push(b);} else { bossKillEffect(b); revealBrickArea(b); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; }
            }
            else {
              revealBrickArea(b); maybeDropFromBrick(b); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++;
            }
            fireBursts.push({x:b.x+b.w/2,y:b.y+b.h/2,life:400+Math.random()*400});
          } else keep.push(b);
        }
        bricks=keep; screenShake=6; playSFX('phoenix'); updateHUD();
        if(isSpecialBossActive()){
          const center=activeBossCenter();
          const impact=center?{x:center.x,y:center.y}:null;
          damageActiveBoss(1,'phoenix',impact);
        }
      } else if(type==='NINE'){ if(nineCatEaten>=2) return; lives=9; nineCatEaten++; updateHUD(); spawnParticles(550,350,'#ffd',40,2.2,3.5,4); beep(880,0.1,0.06); }
      return;
    }
    // å®šæ™‚é¡
    if(def.durationMs){ if(type!=='LONG'){ const b=buffs[type]||(buffs[type]={active:false,until:0}); b.active=true; b.until=now+def.durationMs; } }
    if(def.paddleWidthAdd){ buffs.WIDE.active=true; buffs.WIDE.until=now+def.durationMs; }
    if(def.longPerStackAdd){ const act=buffs.LONG.stacks.filter(t=>t>now); const max=def.stacksMax??2; if(act.length<max){ buffs.LONG.stacks.push(now+def.durationMs);} else { const earliest=Math.min(...act); const idx=buffs.LONG.stacks.indexOf(earliest); buffs.LONG.stacks[idx]=now+def.durationMs; } }
    if(def.sticky){ buffs.STICKY.active=true; buffs.STICKY.until=now+def.durationMs; }
    if(def.multiDuplicate){ if(balls.length<3){ const news=[]; for(const b of balls){ const b1={...b}; b1.trail=[]; news.push(b1);} balls=balls.concat(news); const cap=def.maxBalls??4; if(balls.length>cap) balls.length=cap; } }
    if(def.speedMul){ buffs.SLOW.active=true; buffs.SLOW.until=now+def.durationMs; }
    if(def.piercing){ buffs.PIERCE.active=true; buffs.PIERCE.until=now+def.durationMs; for(const b of balls) b.piercing=true; }
    if(def.oneShotShield){ buffs.SHIELD.active=true; }
    if(def.forcePiercing && def.rampageMs){ buffs.RAMPAGE.active=true; buffs.RAMPAGE.until=now+def.durationMs; for(const b of balls){ b.rampageUntil=now+def.rampageMs; b.piercing=true; } }
    if(def.globalSpeedMul){ buffs.FAST.active=true; buffs.FAST.until=now+def.durationMs; if(def.screenShakeOnApply) screenShake=def.screenShakeOnApply; }
    if(def.wavy){ buffs.WAVY.active=true; buffs.WAVY.until=now+def.durationMs; buffs.WAVY.start=now; }
    if(type==='PLASMA'){ buffs.PLASMA.active=true; buffs.PLASMA.until=now+def.durationMs; }
    if(type==='FREEZE'){ buffs.FREEZE.active=true; buffs.FREEZE.until=now+def.durationMs; }
    if(type==='HOLY'){ buffs.HOLY.active=true; buffs.HOLY.until=now+def.durationMs; }
    if(type==='FIRE'){ buffs.FIRE.active=true; buffs.FIRE.until=now+def.durationMs; fireEnergy=0; updateFireEnergy(); }
    if(type==='POISON'){ buffs.POISON.active=true; buffs.POISON.until=now+def.durationMs; }
    if(type==='BLINK'){ buffs.BLINK.active=true; buffs.BLINK.until=now+def.durationMs; }
    if(type==='COMBO'){ buffs.COMBO.active=true; buffs.COMBO.until=now+def.durationMs; }

    if(type==='TRACK'){ buffs.TRACK.active=true; buffs.TRACK.until=now+def.durationMs; }
    if(type==='MISSILE'){ buffs.MISSILE.active=true; buffs.MISSILE.until=now+def.durationMs; }
    if(type==='HELL'){ buffs.HELL.active=true; buffs.HELL.until=now+def.durationMs; }
    if(type==='MEGA'){ if(!buffs.MEGA.active){ for(const ball of balls){ ball.r*=GAME_CONFIG.powers.MEGA.mega.sizeMul; } buffs.MEGA.applied=true; } buffs.MEGA.active=true; buffs.MEGA.until=now+def.durationMs; }
    if(type==='CHAIN'){ buffs.CHAIN.active=true; buffs.CHAIN.until=now+def.durationMs; }
    if(type==='NARROW'){ buffs.NARROW.active=true; buffs.NARROW.until=now+def.durationMs; }
    if(type==='HOLE'){ buffs.HOLE.active=true; buffs.HOLE.until=now+def.durationMs; showComboNotice('æ³¨æ„çœ‹! ä½ ç ´æ´å•¦!',5000,3000); }
    if(type==='PADSPIN'){ buffs.PADSPIN.active=true; buffs.PADSPIN.until=now+def.durationMs; buffs.PADSPIN.start=now; }
    if(type==='PADBOOM'){ buffs.PADBOOM.active=true; buffs.PADBOOM.explodeAt=now+(def.explosion?.flashMs||3000); buffs.PADBOOM.returnAt=buffs.PADBOOM.explodeAt+(def.explosion?.goneMs||3000); buffs.PADBOOM.until=buffs.PADBOOM.returnAt; buffs.PADBOOM.exploded=false; }
    if(type==='GATLING'){ buffs.GATLING.active=true; buffs.GATLING.until=now+def.durationMs; const g=GAME_CONFIG.powers.GATLING.gatling; const pr=paddleRect(); gatling={x:pr.x+pr.w/2,y:pr.y,chargeUntil:now+(g.chargeMs||3000),fireStart:now+(g.chargeMs||3000),fireUntil:now+(g.chargeMs||3000)+(g.fireMs||8000),lastShot:0,angle:0}; }
    if(type==='FLIP'){
      // å¤©åœ°ç¿»è½‰ï¼šå»¶é²å•Ÿç”¨ä¸¦ç´€éŒ„èµ·æ­¢æ™‚é–“ã€‚å•Ÿç”¨åŠçµæŸå‡ç”± update ä¸­åˆ¤æ–·ã€‚
      const delay = 2000;
      // åˆå§‹åŒ– FLIP buff ç‹€æ…‹
      if(!buffs.FLIP) buffs.FLIP = {};
      const f = buffs.FLIP;
      f.pending = true;
      f.active = false;
      f.startAt = now + delay;
      f.endAt = f.startAt + def.durationMs;
      // ä½¿ç”¨ until é¡¯ç¤ºå‰©é¤˜æ™‚é–“æ¢
      f.until = f.endAt;
      return;
    }
    if(type==='GODSPEED'){ buffs.GODSPEED.active=true; buffs.GODSPEED.until=now+def.durationMs; }
    if(type==='LASER'){ buffs.LASER.active=true; buffs.LASER.until=now+def.durationMs; buffs.LASER.lastShot=0; }
    if(type==='SWORD'){ buffs.SWORD.active=true; buffs.SWORD.until=now+def.durationMs; swordFireStart=0; }
    if(type==='STORM'){ buffs.STORM.active=true; buffs.STORM.until=now+def.durationMs; const pr=paddleRect(); stormTurret={x:pr.x+pr.w/2,y:pr.y,chargeUntil:now+3000,fireAt:now+4000,shots:Math.max(0,21-lives),lastShot:0}; }
    if(type==='BLACKHOLE'){ buffs.BLACKHOLE.active=true; buffs.BLACKHOLE.until=now+def.durationMs; buffs.BLACKHOLE.deaths=0; }
    if(type==='ANNIHIL'){ buffs.ANNIHIL.active=true; buffs.ANNIHIL.start=now; buffs.ANNIHIL.next=now+1000; buffs.ANNIHIL.until=0; }

    updateBuffBadges();
  }

  function drawPower(p){ const base=p.isDebuff?getVar('--debuff'):getVar('--power'); const gold1='#f6d365', gold2='#fda085'; const color = p.isSpecial ? gold1 : base; const x=p.x*scaleX, y=p.y*scaleY, w=p.w*scaleX, h=p.h*scaleY; const wobble=Math.sin(p.phase)*1.5; p.phase+=0.04;
    ctx.save(); ctx.translate(0,wobble); const grd=ctx.createLinearGradient(x,y,x,y+h); grd.addColorStop(0,color); grd.addColorStop(1,p.isSpecial?gold2:(p.isDebuff?'#a33':'#3a56a8')); ctx.fillStyle=grd; roundedRect(x,y,w,h,8); ctx.fill(); ctx.strokeStyle=p.isSpecial?'rgba(255,220,150,.8)':'rgba(255,255,255,.25)'; ctx.stroke();
    ctx.fillStyle=p.isSpecial?'#402a00':'#fff'; ctx.font=`${Math.max(10,Math.round(12*scaleY))}px ui-monospace, monospace`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.type[0], x+w/2, y+h/2+0.5); ctx.restore(); }

  function updateFireEnergy(){
    if(!fireEnergyEl) return;
    if(buffs.FIRE?.active || fireEnergy>0){
      fireEnergyEl.style.display='inline-block';
      fireEnergyEl.textContent=`ğŸ”¥${fireEnergy}`;
    }else{
      fireEnergyEl.style.display='none';
    }
  }

  function updateHUD(){
    // æ›´æ–°åˆ†æ•¸ã€é—œå¡ã€ç”Ÿå‘½èˆ‡æ„›å¿ƒé¡¯ç¤º
    scoreEl.textContent = Math.max(0 | score, 0);
    // é¡¯ç¤ºç›®å‰é—œå¡æ•¸ï¼ˆlevel å…ƒç´ ï¼‰å’Œç¸½é—œå¡æ•¸ï¼ˆtotalLevels å…ƒç´ ï¼‰
    levelEl.textContent = level;
    if (totalLevelsEl) totalLevelsEl.textContent = GAME_CONFIG.totalLevels;
    if (levelJumpSel){
      levelJumpSel.value = String(level);
      if(typeof refreshLevelJumpVisual==='function') refreshLevelJumpVisual();
    }
    // æ›´æ–°ç”Ÿå‘½æ–‡å­—èˆ‡æ„›å¿ƒ
    livesEl.textContent = lives;
    if (heartsEl) {
      heartsEl.innerHTML = '';
      // ä¾æ“šç”Ÿå‘½æ•¸é‡æ–°å¢æ„›å¿ƒåœ–ç¤º
      for (let i = 0; i < lives; i++) {
        const span = document.createElement('span');
        const icon = (window.currentSkin && window.currentSkin.lifeIcon) || 'â¤ï¸';
        if (typeof icon === 'string' && icon.trim().startsWith('<')) {
          span.innerHTML = icon;
        } else {
          span.textContent = icon;
        }
        span.className = 'life-icon';
        heartsEl.appendChild(span);
      }
      // éå¤šç”Ÿå‘½æ™‚æ¡ç”¨ compact é¢¨æ ¼
      heartsEl.classList.toggle('compact', lives > 5);
    }
    if (catsEl) {
      catsEl.innerHTML = '';
      for (let i = 0; i < nineCatEaten; i++) {
        const span = document.createElement('span');
        span.textContent = 'ğŸ±';
        span.className = 'cat-icon';
        catsEl.appendChild(span);
      }
      catsEl.style.display = nineCatEaten ? 'flex' : 'none';
    }
    updateFireEnergy();
  }
  window.updateHUD = updateHUD;
  function showCenter(t, txt){
    noteTitle.textContent = t;
    noteText.innerHTML = txt || '';
    centerNote.style.display = 'flex';
  }
  function showGameOver(){
    paused = true; running = false; gameOver = true;
    hideCenter();
    resetCombo();
    const fs2 = document.getElementById('finalScore2'); if(fs2) fs2.textContent = String(Math.max(0|score,0));
    const so  = document.getElementById('statsOver'); if(so)  so.innerHTML = renderStatsHtml();
    gameover?.classList.add('show');
    playSFX('lose');
  }
  function hideCenter(){ centerNote.style.display='none'; }

  function resetGame(load=false){ diff=getDiff(); level=load?level:1; score=load?score:0; lives=load?lives:3; nineCatEaten=load?nineCatEaten:0; scoreUploaded=false; updateHUD(); initBricks(); resetBalls(); paused=true; running=false; resetCombo();
    stats={catches:0,buffs:0,debuffs:0,eliteKills:0,bossKills:0,lifeStart:0,fastestDeath:Infinity,longestLife:0,livesUsed:0,maxCombo:0};
    for(const k of Object.keys(buffs)){
      if(k!=='LONG'){
        buffs[k].active=false;
        buffs[k].until=0;
      }
    }
    // é‡ç½® LONG buff stacks
    buffs.LONG.stacks=[];
    powerups.length=0;
    particles.length=0;
    plasmas.length=0;
    holyFlashes.length=0;
    phoenixAnim=null;
    fireBursts.length=0;
    fireEnergy=0; updateFireEnergy();
    // å›å¾©å¤©åœ°ç¿»è½‰ç‹€æ…‹åŠæš«åœè¨ˆæ™‚å™¨
    orientLeft=false;
    pauseStartedAt=null;
    // åˆå§‹åŒ–å¢ç›Šæ‰è½è¨ˆæ™‚
    lastBeneficialPickupAt = performance.now();
    nextAutoBeneficialDropAt = lastBeneficialPickupAt + 10000;
    updateBuffBadges();
    computePaddleWidth();
    paddle.x = 1100/2 - paddle.w/2;
    // ç¢ºä¿ paddle åœ¨æ°´å¹³æ–¹å‘æ™‚ä½æ–¼åº•éƒ¨
    paddle.y = 700 - 50;
    showCenter('æŒ‰ Space æˆ–é»ç•«é¢é–‹å§‹','ç”¨ â†/â†’ æˆ– A/D ç§»å‹•ï¼›æ‰‹æŒ‡æ‹–æ›³ç•«é¢ä¹Ÿå¯ã€‚');
    countdownShow=0;
    scheduleNextSkyDrop();
  }

  // === å­˜è®€æª”ï¼ˆå«éŸ³æ•ˆ/BGMèˆ‡å½±åƒé¸æ“‡ï¼‰ ===
  function saveProgress(){ try{
      const data={level,score,lives,difficulty:difficultySel.value, imageChoice, soundsOn, bgmOn, bgmVol: parseFloat(bgmVol.value)};
      localStorage.setItem('breakout_save_v_final_cfg', JSON.stringify(data)); alert('å·²å­˜æª”ï¼');
    }catch(e){ alert('å­˜æª”å¤±æ•—ï¼š'+e); } }
  function loadProgress(){ try{ const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4'); if(!raw){ alert('æ²’æœ‰å­˜æª”'); return; } const data=JSON.parse(raw);
      difficultySel.value=data.difficulty||'normal'; level=data.level||1; score=data.score||0; lives=data.lives||3; if(Array.isArray(data.imageChoice)) imageChoice=data.imageChoice;
      soundsOn=!!data.soundsOn; soundBtn.textContent=`éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`;
      if(typeof data.bgmOn==='boolean'){ bgmOn=data.bgmOn; } if(typeof data.bgmVol==='number'){ bgmVol.value=String(data.bgmVol); if(bgmGain) bgmGain.gain.value=data.bgmVol; localStorage.setItem('bgm_vol', data.bgmVol); }
      resetGame(true); updateHUD(); alert(`å·²è®€æª”ï¼šç­‰ç´š ${level}ï¼Œåˆ†æ•¸ ${score}ï¼Œç”Ÿå‘½ ${lives}`);}catch(e){ alert('è®€æª”å¤±æ•—ï¼š'+e); } }
  function clearSave(){ localStorage.removeItem('breakout_save_v_final_cfg'); localStorage.removeItem('gallery_unlocks'); localStorage.removeItem('dialog_unlocks'); alert('å·²æ¸…é™¤å­˜æª”'); }

  // === è¼¸å…¥ï¼ˆå«è§¸æ§ï¼‰ ===
  let keyL=false, keyR=false; let touchActive=false;
  window.addEventListener('keydown',(e)=>{ if(gameOver){ e.preventDefault(); return; }
    if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=true;
    if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=true;
    if(e.code==='Space'){ // é–‹å§‹ / æš«åœ / å€’æ•¸
      if(!running){ startGameWithCountdown(); } else { togglePause(); }
      return;
    }
    if((e.code==='ArrowUp' || e.key==='Shift') && !paused && running){
      let released=false;
      for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy = -Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
    if(e.key==='r'||e.key==='R'){ resetGame(); }
    if(e.key==='f'||e.key==='F'){ toggleFullscreen(); }
  });
  window.addEventListener('keyup',(e)=>{ if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=false; if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=false; });
  canvas.addEventListener('mousemove',(e)=>{ const rect=canvas.getBoundingClientRect(); if(performance.now()<=paddleStunUntil) return; if(!orientLeft){ const x=(e.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(e.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } });
  canvas.addEventListener('click',()=>{ if(gameOver){ return; }
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  });
  canvas.addEventListener('touchstart',(e)=>{ if(gameOver){ e.preventDefault(); return; } touchActive=true; 
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  }, {passive:false});
  canvas.addEventListener('touchmove',(e)=>{ if(!touchActive) return; if(performance.now()<=paddleStunUntil) return; const t=e.touches[0]; const rect=canvas.getBoundingClientRect(); if(!orientLeft){ const x=(t.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(t.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } }, {passive:true});
  canvas.addEventListener('touchend',()=>{ touchActive=false; }, {passive:true});
  pauseBtn.addEventListener('click',()=>togglePause()); resetBtn.addEventListener('click',()=>resetGame()); fsBtn.addEventListener('click',()=>toggleFullscreen());
  soundBtn.addEventListener('click',()=>{ soundsOn=!soundsOn; localStorage.setItem('sfx_on', soundsOn?'1':'0'); soundBtn.textContent=`éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`; ensureAudio(); audioCtx?.resume?.(); beep(880,0.06,0.05); });
  difficultySel.addEventListener('change',()=>{ resetGame(); });
  if(ledStyleSel){ ledStyleSel.value = ledStyle; ledStyleSel.addEventListener('change', ()=>{ ledStyle = ledStyleSel.value; localStorage.setItem('led_style', ledStyle); }); }
  saveBtn.addEventListener('click',saveProgress); loadBtn.addEventListener('click',loadProgress); clearSaveBtn.addEventListener('click',clearSave);
  if(levelJumpSel){
    const updateLevelJumpVisual = ()=>{
      const current=levelJumpSel.options[levelJumpSel.selectedIndex]||null;
      const isBoss=!!current && current.classList.contains('boss-level');
      levelJumpSel.classList.toggle('boss-selected', isBoss);
    };
    refreshLevelJumpVisual = updateLevelJumpVisual;
    const populateLevelJumpOptions = ()=>{
      levelJumpSel.innerHTML = '';
      for(let i=1;i<=GAME_CONFIG.totalLevels;i++){
        const option=document.createElement('option');
        const isBoss = i%5===0;
        option.value=String(i);
        option.textContent=isBoss ? `ç¬¬ ${i} é—œ â˜… Boss` : `ç¬¬ ${i} é—œ`;
        if(isBoss){
          option.classList.add('boss-level');
          option.style.color='#ffb347';
          option.style.fontWeight='800';
          option.style.background='rgba(255,155,74,.22)';
        }
        levelJumpSel.appendChild(option);
      }
      updateLevelJumpVisual();
    };
    populateLevelJumpOptions();
    levelJumpSel.value = String(level);
    updateLevelJumpVisual();
    levelJumpSel.addEventListener('change',()=>{
      updateLevelJumpVisual();
      const target=parseInt(levelJumpSel.value,10);
      if(Number.isNaN(target)) return;
      level = Math.max(1, Math.min(GAME_CONFIG.totalLevels, target));
      gameOver = false;
      gameover?.classList.remove('show');
      paused = true;
      running = false;
      resetCombo();
      initBricks();
      resetBalls();
      applyBGMThemeForLevel();
      updateHUD();
      showCenter(`æš«æ™‚è·³è‡³ç¬¬ ${level} é—œ`,`æŒ‰ Space æˆ–é»ç•«é¢é–‹å§‹`);
    });
  }
  tutorBtn.addEventListener('click', ()=> toggleHelp('tutor'));
  effectsBtn.addEventListener('click', ()=> toggleHelp('effects'));
  againBtn.addEventListener('click', ()=>{ win.classList.remove('show'); resetGame(); });

  // BGM UI
  bgmBtn.addEventListener('click', ()=>{
    bgmOn=!bgmOn; localStorage.setItem('bgm_on', bgmOn?'1':'0'); bgmBtn.textContent= bgmOn?'é–‹':'é—œ';
    if(bgmOn){ ensureAudio(); startBGM(); } else { stopBGM(); }
  });
  bgmVol.addEventListener('input', ()=>{
    ensureAudio(); const v=parseFloat(bgmVol.value||'0.5'); if(bgmGain) bgmGain.gain.value=v; localStorage.setItem('bgm_vol', v);
  });

  function togglePause(){
    if(!running){ startGameWithCountdown(); return; }
    paused = !paused;
    if(paused){
      // è¨˜éŒ„æš«åœé–‹å§‹æ™‚é–“ï¼Œä¸¦é¡¯ç¤ºæš«åœè¨Šæ¯
      onPauseStart();
      showCenter('å·²æš«åœ','æŒ‰ Space / é»ç•«é¢ç¹¼çºŒ');
    } else {
      // æ¢å¾©å‰å…ˆèª¿æ•´è¨ˆæ™‚å™¨ï¼Œå†é€²å…¥å€’æ•¸
      onResumeFromPause();
      startCountdown();
    }
  }

  function startGameWithCountdown(){
    onResumeFromPause();
    running=true; paused=true; hideCenter();
    if(pendingUnlockNotice){ showComboNotice(pendingUnlockNotice); pendingUnlockNotice=null; }
    ensureAudio(); audioCtx?.resume?.();
    // éŸ³æ•ˆèˆ‡BGMè¨­å®šè¼‰å…¥
    // å¾ localStorage è¼‰å…¥éŸ³æ•ˆèˆ‡ BGM è¨­å®š
    soundsOn = (localStorage.getItem('sfx_on')||'0') === '1';
    // åŒæ­¥èˆŠç‰ˆæŒ‰éˆ•èˆ‡æ–° UI è¤‡é¸æ¡†
    soundBtn.textContent = `éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`;
    if (sfxOnEl) sfxOnEl.checked = soundsOn;
    bgmOn = (localStorage.getItem('bgm_on')||'0') === '1';
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.7');
    bgmVol.value = String(v);
    ensureAudio(); if (bgmGain) bgmGain.gain.value = v;
    bgmBtn.textContent = bgmOn ? 'é–‹' : 'é—œ';
    if (bgmOnEl) bgmOnEl.checked = bgmOn;
    if (bgmOn) startBGM(); applyBGMThemeForLevel();
    startCountdown();
  }

  // === æ•™å­¸/æ•ˆæœèªªæ˜ ===
  let helpMode=null; // 'tutor' | 'effects' | null
  function toggleHelp(mode){
    if(helpMode===mode){
      // é—œé–‰èªªæ˜ï¼Œæ¢å¾©éŠæˆ²
      helpMode=null;
      hideCenter();
      if(menusOpen()) return;
      if(running){
        onResumeFromPause();
        startCountdown();
      } else {
        startGameWithCountdown();
      }
      return;
    }
    helpMode = mode;
    paused = true;
    // æ‰“é–‹èªªæ˜æ™‚é–‹å§‹æš«åœè¨ˆæ™‚
    onPauseStart();
    if(mode==='tutor'){
      showCenter('æ•™å­¸ï¼ˆæŒ‰éˆ•å†æŒ‰ä¸€æ¬¡é—œé–‰ï¼‰', `
        <div class="cols">
          <div>
            <strong>æ“ä½œ</strong><br>
            é›»è…¦ï¼š<kbd>â†</kbd>/<kbd>â†’</kbd> æˆ– <kbd>A</kbd>/<kbd>D</kbd> ç§»å‹•ï¼›<kbd>Space</kbd> é–‹å§‹/æš«åœã€‚<br>
            é‡‹æ”¾é»ä½çš„çƒï¼š<kbd>â†‘</kbd> æˆ– <kbd>Shift</kbd>ã€‚<br>
            æ‰‹æ©Ÿï¼šæ‰‹æŒ‡æ‹–æ›³æ“‹æ¿ä½ç½®å³å¯ã€‚<br>
            å…¨è¢å¹•ï¼š<kbd>F</kbd>ã€‚
          </div>
          <div>
            <strong>ç›®æ¨™</strong><br>
            æ‰“ç ´æ‰€æœ‰å¯ç ´å£ç£šé€²å…¥ä¸‹ä¸€é—œã€‚æ¯ 5 é—œæœ‰ Bossï¼ˆåªæ‰£è¡€ä¸æœƒè¢«ç§’æ®ºï¼‰ã€‚<br>
            ç¬¬ 1~10 é—œèˆ‡ 11~20 é—œæœƒåˆ†åˆ¥é¡¯ç¤ºåŒçµ„ç…§ç‰‡çš„ä¸åŒå¼µï¼Œ20 é—œçµæŸæ’­æ”¾é€šé—œç•«é¢ã€‚
          </div>
          <div>
            <strong>å­˜è®€æª”</strong><br>
            å¯å„²å­˜é—œå¡/åˆ†æ•¸/ç”Ÿå‘½ã€é›£åº¦ã€ç…§ç‰‡é¸æ“‡ã€éŸ³æ•ˆ/BGM è¨­å®šã€‚
          </div>
        </div>`);
    }else{
      // æ•ˆæœèªªæ˜ï¼šåˆ†é¡è¼¸å‡ºå¢ç›Šã€ç‰¹æ®Šå¢ç›Šã€æ¸›ç›Šèˆ‡ç‰¹æ®Šç£š
      let html = '<div class="cols">';
      // å¢ç›Šï¼ˆbuffï¼‰
      html += '<div><strong>å¢ç›Š</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'buff'){
          const label = p.label + (p.desc ? `(${p.desc})` : '');
          html += `${badgeIcon(k)} <em>${k}</em>ï¼š${label}<br>`;
        }
      }
      html += '</div>';
      // ç‰¹æ®Šå¢ç›Š
      html += '<div><strong>ç‰¹æ®Šå¢ç›Š</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'special'){
          const label = p.label + (p.desc ? `(${p.desc})` : '');
          if(unlockedSpecials.has(k)){
            html += `${badgeIcon(k)} <em>${k}</em>ï¼š${label}<br>`;
          }else{
            const req = SPECIAL_UNLOCK_LEVELS[k];
            const hint = req ? `<small class="unlockHint">ç¬¬${req}é—œè§£é–</small>` : '';
            html += `<span class="sealed">${badgeIcon(k)} <em>${k}</em>ï¼š${label}${hint}</span><br>`;
          }
        }
      }
      html += '</div>';
      // æ¸›ç›Šï¼ˆdebuffï¼‰
      html += '<div><strong>æ¸›ç›Š</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'debuff'){
          const label = p.label + (p.desc ? `(${p.desc})` : '');
          html += `${badgeIcon(k)} <em>${k}</em>ï¼š${label}<br>`;
        }
      }
      html += '</div>';
      // ç‰¹æ®Šç£šèªªæ˜
      html += '<div><strong>ç‰¹æ®Šç£š</strong><br>';
      html += 'ä¸å¯ç ´å£ç£šï¼šåªåå½ˆä¸æœƒå£ï¼›<br>';
      html += 'ç§»å‹•ç£šï¼šæ°´å¹³ç§»å‹•ï¼›<br>';
      html += 'å¼·åå½ˆç£šï¼šåå½ˆæ™‚åŠ é€Ÿæ›´å¼·ï¼›<br>';
      html += 'Bossç£šï¼šå¤§å°ºå¯¸ã€åªæ‰£è¡€ï¼Œçˆ†ç‚¸/ç¥è–/é³³å‡°ä¹Ÿä¸æœƒè¢«ç§’æ®ºã€‚';
      html += '</div>';
      html += '</div>';
      showCenter('æ•ˆæœèªªæ˜ï¼ˆæŒ‰éˆ•å†æŒ‰ä¸€æ¬¡é—œé–‰ï¼‰', html);
    }
  }

  /* ---------------- HUD äº’å‹•ï¼ˆç§»æ¤è‡ª index_skin.htmlï¼‰ ---------------- */
  (function(){
    const hud = document.querySelector('.hud');
    const sentinel = document.querySelector('.hud-sentinel');
    const sndBtn = document.getElementById('sndBtn');
    const optBtn = document.getElementById('optBtn');
    const soundMenu = document.getElementById('soundMenu');
    const optMenu = document.getElementById('optMenu');
    let scheduled = false;
    function schedule(){ if(scheduled) return; scheduled = true; requestAnimationFrame(() => { scheduled = false; placeHUD(); }); }
    function placeHUD(){
      const rect = (sentinel || hud).getBoundingClientRect();
      const top = Math.max(0, Math.ceil(rect.top)) + 6;
      document.documentElement.style.setProperty('--hudBottom', top + 'px');
    }
    function toggle(menu, btn){
      const show = !menu.classList.contains('show');
      [soundMenu, optMenu].forEach(m => m.classList.remove('show'));
      document.querySelectorAll('[aria-expanded="true"]').forEach(b => b.setAttribute('aria-expanded', 'false'));
      if(show){
        menu.classList.add('show');
        btn.setAttribute('aria-expanded', 'true');
      }
      // Pause game when any menu is open; resume when none open
      const anyOpen = menusOpen();
      if (typeof window.__setMenuPause === 'function') window.__setMenuPause(anyOpen);
      schedule();
    }
    if(sndBtn) sndBtn.addEventListener('click', (e) => { e.stopPropagation(); toggle(soundMenu, sndBtn); }, {passive:true});
    if(optBtn) optBtn.addEventListener('click', (e) => { e.stopPropagation(); toggle(optMenu, optBtn); }, {passive:true});
    document.addEventListener('click', (e) => {
      if(!e.target.closest('.menu') && !e.target.closest('#optBtn') && !e.target.closest('#sndBtn')){
        const anyOpen = soundMenu.classList.contains('show') || optMenu.classList.contains('show');
        if(anyOpen){
          [soundMenu, optMenu].forEach(m => m.classList.remove('show'));
          if(!menusOpen() && typeof window.__setMenuPause === 'function') window.__setMenuPause(false);
          schedule();
        }
      }
    }, {passive:true});
    ['resize','orientationchange'].forEach(ev => window.addEventListener(ev, schedule, {passive:true}));
    if(document.fonts && document.fonts.ready){ document.fonts.ready.then(schedule); }
    schedule();
  })();

  // === å…¨è¢å¹• ===
  async function toggleFullscreen(){
    const elem = document.documentElement;
    try{
      if(!document.fullscreenElement){
        await elem.requestFullscreen();
      }else{
        await document.exitFullscreen();
      }
    }catch(e){
      console.warn('Fullscreen failed:', e);
    }
  }

  // === æ“‹æ¿å¯¬åº¦ ===
  function desiredPaddleWidth(){
    const now=performance.now();
    buffs.LONG.stacks=buffs.LONG.stacks.filter(t=>t>now);
    const longStacks=Math.min(GAME_CONFIG.powers.LONG.stacksMax, buffs.LONG.stacks.length);
    const addLong=longStacks*(GAME_CONFIG.powers.LONG.longPerStackAdd||0);
    const addWide=(buffs.WIDE.active?(GAME_CONFIG.powers.WIDE.paddleWidthAdd||0):0);
    const base=getDiff().paddleBaseW;
    let width=Math.min(GAME_CONFIG.caps.paddleMaxW, base+addWide+addLong);
    if(buffs.NARROW?.active) width = Math.max(60, width*0.5);
    return width;
  }

  function computePaddleWidth(){
    let desired = desiredPaddleWidth();
    const center=paddle.x+paddle.w/2;
    const reaperCap=Math.max(0, desired - REAPER_PADDLE_MIN_WIDTH);
    if(reaperPaddlePenalty>reaperCap){ reaperPaddlePenalty = reaperCap; }
    let widthAfterReaper=Math.max(REAPER_PADDLE_MIN_WIDTH, desired - reaperPaddlePenalty);
    const penaltyCap=Math.max(0, widthAfterReaper - SPACE_BOSS_PADDLE_MIN_WIDTH);
    if(spaceBossPaddlePenalty>penaltyCap){ spaceBossPaddlePenalty = penaltyCap; }
    let newW=Math.max(SPACE_BOSS_PADDLE_MIN_WIDTH, widthAfterReaper - spaceBossPaddlePenalty);
    paddle.w=newW;
    paddle.x=Math.max(0, Math.min(1100-paddle.w, center - paddle.w/2));
  }

  // æ“‹æ¿åœ¨ä¸åŒæœå‘ä¸‹çš„å¯¦éš›çŸ©å½¢
  function paddleRect(){
    const now = performance.now();
    if(now < paddleGoneUntil){ return {x:-1000,y:-1000,w:0,h:0}; }
    // æ©«å‘ï¼šx,y,w,hï¼›ç¸±å‘ï¼šä»¥ h ç‚ºåšåº¦ã€w ç‚ºé•·åº¦
    if(!orientLeft){
      return {x:paddle.x, y:paddle.y, w:paddle.w, h:paddle.h};
    }else{
      // å·¦å´ï¼šå›ºå®šé å·¦ 40px
      const thick = paddle.h;
      const len = paddle.w;
      const x = 40; // èˆ‡ç‰†è·
      return {x:x, y:Math.max(0, Math.min(700-len, paddle.y)), w:thick, h:len};
    }
  }
  // === èƒŒæ™¯è£é£¾ & LED ç‡ˆæ¢ ===
  function ledColor(){
    if(buffs.GODSPEED.active) return '#ffe066';
    if(buffs.HOLY.active) return '#ffe08a';
    if(buffs.HELL.active) return '#a08cff';
    if(buffs.PLASMA.active) return '#9fe8ff';
    if(buffs.FREEZE.active) return '#cfe9ff';
    if(buffs.RAMPAGE.active || buffs.PIERCE.active || buffs.TRACK.active) return '#7fd8ff';
    if(buffs.FAST.active) return '#ffb37a';
    if(buffs.WAVY.active) return '#ba8fff';
    const led = window.currentSkin && window.currentSkin.canvas && window.currentSkin.canvas.effects && window.currentSkin.canvas.effects.ledStrip;
    if(led){
      const hi = led.hi || window.currentSkin.canvas.hi || [255,255,255];
      const lo = led.lo || window.currentSkin.canvas.base || [92,136,255];
      const period = led.period || window.currentSkin.canvas.period || 2000;
      const t = performance.now();
      const ph = (t % period) / period;
      const blend = 0.5 + 0.5*Math.sin(ph*2*Math.PI);
      const rgb = hi.map((h,i)=>Math.round(h*blend + (lo[i]||0)*(1-blend)));
      return '#' + rgb.map(v=>{const h=v.toString(16);return h.length===1?'0'+h:h;}).join('');
    }
    // Fallback colour when no special buff is active.  If a skin is
    // currently selected and defines a base colour, derive the border
    // colour from it; otherwise revert to the original blue tint.
    if (window.currentSkin && window.currentSkin.canvas && Array.isArray(window.currentSkin.canvas.base)) {
      const arr = window.currentSkin.canvas.base;
      // Convert RGB triplet to a hex string.  Values are clamped to 0â€“255.
      const hex = '#' + arr.map((v) => {
        const n = Math.max(0, Math.min(255, Math.round(v)));
        const h = n.toString(16);
        return h.length === 1 ? '0' + h : h;
      }).join('');
      return hex;
    }
    return '#8fb3ff';
  }

  function drawBGDecor(){ const w=canvas.width,h=canvas.height; bgTime+=0.003;
    const isCyborg = window.currentSkin && window.currentSkin.cssSkin === 'ç§‘æŠ€ï¼è³½åšæ ¼ç¶ ';
    const isPhantom = window.currentSkin && window.currentSkin.cssSkin === 'ç§‘æŠ€ï¼é­…å½±å¹»å½©';
    if(isCyborg){
      ctx.save();
      const bg=ctx.createLinearGradient(0,0,0,h); bg.addColorStop(0,'#00140a'); bg.addColorStop(1,'#000b08'); ctx.fillStyle=bg; ctx.fillRect(0,0,w,h);
      const step=40; const offX=(bgTime*20)%step, offY=(bgTime*15)%step; ctx.strokeStyle='rgba(0,255,150,0.15)'; ctx.lineWidth=1;
      for(let x=-step;x<w+step;x+=step){ const xx=x+offX; ctx.beginPath(); ctx.moveTo(xx,0); ctx.lineTo(xx,h); ctx.stroke(); }
      for(let y=-step;y<h+step;y+=step){ const yy=y+offY; ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(w,yy); ctx.stroke(); }
      ctx.fillStyle='rgba(0,255,150,0.15)';
      for(let x=-step;x<w+step;x+=step){ const xx=x+offX; for(let y=-step;y<h+step;y+=step){ const yy=y+offY; ctx.beginPath(); ctx.arc(xx,yy,1.2,0,Math.PI*2); ctx.fill(); } }
      const glow=ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h)*0.7); glow.addColorStop(0,'rgba(0,255,150,0.12)'); glow.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=glow; ctx.fillRect(0,0,w,h);
      ctx.restore();
      if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    } else if(isPhantom){
      ctx.save();
      const grad=ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h));
      const shift=(Math.sin(bgTime*0.4)+1)/2;
      grad.addColorStop(0,`rgba(60,0,90,${0.55+0.25*shift})`);
      grad.addColorStop(1,'#000');
      ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
      ctx.globalCompositeOperation='lighter';
      const cols=['#ff66ff','#ffb366','#fff466','#66ffb3','#66d1ff','#6666ff','#cc66ff'];
      for(let i=0;i<cols.length;i++){
        ctx.save();
        const ang=i/cols.length*Math.PI*2+bgTime*0.2;
        const x=w/2+Math.cos(ang)*w;
        const y=h/2+Math.sin(ang)*h;
        const beam=ctx.createLinearGradient(w/2,h/2,x,y);
        beam.addColorStop(0,'rgba(0,0,0,0)');
        beam.addColorStop(1,cols[i]);
        ctx.strokeStyle=beam; ctx.globalAlpha=0.25; ctx.lineWidth=60;
        ctx.beginPath(); ctx.moveTo(w/2,h/2); ctx.lineTo(x,y); ctx.stroke();
        ctx.restore();
      }
      ctx.globalCompositeOperation='source-over';
      ctx.restore();
      if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    } else {
      ctx.save(); ctx.globalAlpha=0.12; ctx.translate(Math.sin(bgTime)*8, Math.cos(bgTime*0.7)*6); const step=40;

      for(let x=0;x<w;x+=step){ ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(x,0,1,h);} for(let y=0;y<h;y+=step){ ctx.fillStyle='rgba(255,255,255,.025)'; ctx.fillRect(0,y,w,1);} ctx.restore();
      const grad=ctx.createRadialGradient(w/2,h*0.2,0,w/2,h*0.5,Math.max(w,h)); grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
      if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    }

    // é³³å‡°ç«ç„°æ®˜ç•™
    for(let i=fireBursts.length-1;i>=0;i--){ const f=fireBursts[i]; f.life-=16; if(f.life<=0){ fireBursts.splice(i,1); continue; } const a=Math.min(1, f.life/600); const rx= (f.x*scaleX), ry=(f.y*scaleY); const r=60*((scaleX+scaleY)/2); const g=ctx.createRadialGradient(rx,ry,1,rx,ry,r); g.addColorStop(0,`rgba(255,180,0,${0.6*a})`); g.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(rx,ry,r,0,Math.PI*2); ctx.fill(); }

    // ç«ç„°çƒçˆ†ç‚¸ç¯„åœç‰¹æ•ˆ
    for(let i=fireExplosions.length-1;i>=0;i--){
      const ex = fireExplosions[i];
      const age = performance.now() - ex.t0;
      const prog = age / ex.life;
      if(prog>=1){ fireExplosions.splice(i,1); continue; }
      const alpha = 1 - prog;
      const x = ex.x * scaleX;
      const y = ex.y * scaleY;
      const r = ex.r * ((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = `rgba(255,80,0,${0.25*alpha})`;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = `rgba(255,200,50,${alpha})`;
      ctx.lineWidth = 4 + 6*(1-prog);
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }


    // LED ç‡ˆæ¢æ¡†ï¼ˆå¤šé¢¨æ ¼ï¼Œè½çƒå€åŸŸç„¡ç‡ˆæ¢ï¼‰
    const c=ledColor();
    let spAvg=0; for(const b of balls){ spAvg += Math.hypot(b.vx,b.vy); } spAvg = balls.length? spAvg/balls.length : 8;
    const nowT = performance.now();
    // For the classic LED breathing effect, prefer the period defined by the
    // current skin (if available).  When a skin is selected its period
    // defines the full cycle (in ms).  Otherwise fall back to the original
    // behaviour based on ball speed.
    let __periodClassic;
    if (window.currentSkin && window.currentSkin.canvas && typeof window.currentSkin.canvas.period === 'number') {
      __periodClassic = window.currentSkin.canvas.period;
    } else {
      // Preserve the old dynamic period based on average ball speed (spAvg).
      __periodClassic = (180 - Math.min(120, spAvg * 6));
    }
    // Compute a phase between 0 and 1, wrapping around __periodClassic.
    const __phaseClassic = ((__periodClassic > 0) ? ((nowT % __periodClassic) / __periodClassic) : 0);
    const breathClassic = (Math.sin(__phaseClassic * Math.PI * 2) + 1) / 2;
    const breath5 = (Math.sin(nowT / (5000 / (2*Math.PI)))+1)/2;  // 5s
    const breath3 = (Math.sin(nowT / (3000 / (2*Math.PI)))+1)/2;  // 3s
    const breath8 = (Math.sin(nowT / (8000 / (2*Math.PI)))+1)/2;  // 8s

    function pathThreeSides(){
      ctx.beginPath();
      if(!orientLeft){
        ctx.moveTo(3,3); ctx.lineTo(w-3,3);
        ctx.moveTo(3,3); ctx.lineTo(3,h-3);
        ctx.moveTo(w-3,3); ctx.lineTo(w-3,h-3);
      }else{
        ctx.moveTo(3,3); ctx.lineTo(w-3,3);
        ctx.moveTo(w-3,3); ctx.lineTo(w-3,h-3);
        ctx.moveTo(3,h-3); ctx.lineTo(w-3,h-3);
      }
    }

    ctx.save();
    if(isPhantom){
      const rainbow=['#ff66ff','#ffb366','#fff466','#66ffb3','#66d1ff','#6666ff','#cc66ff'];
      const periodColor=(window.currentSkin&&window.currentSkin.canvas&&window.currentSkin.canvas.period)||2400;
      const step=Math.floor(nowT/periodColor)%rainbow.length;
      const c1=rainbow[step];
      const c2=rainbow[(step+1)%rainbow.length];
      const grad=ctx.createLinearGradient(0,0,w,0);
      grad.addColorStop(0,c1);
      grad.addColorStop(1,c2);
      ctx.globalAlpha=0.55+0.35*breathClassic;
      ctx.strokeStyle=grad; ctx.lineWidth=6;
      ctx.shadowColor=c2; ctx.shadowBlur=24+12*breathClassic;
      pathThreeSides(); ctx.stroke();
      ctx.restore();
    } else switch(ledStyle){
      case 'tech': {
        ctx.globalAlpha = 0.55 + 0.35*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=8; ctx.shadowColor=c; ctx.shadowBlur=28 + 10*breath5;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'arc': {
        ctx.globalAlpha = 0.5 + 0.25*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=5; ctx.shadowColor=c; ctx.shadowBlur=16 + 6*breath5;
        pathThreeSides(); ctx.setLineDash([14,10]); ctx.lineDashOffset = -(nowT/20); ctx.stroke();
        ctx.setLineDash([]); ctx.globalAlpha = 0.3 + 0.2*breath8; ctx.lineWidth=2.5; ctx.shadowBlur=0;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'steel': {
        ctx.globalAlpha = 0.65 + 0.25*breath5;
        const g = ctx.createLinearGradient(0,0,w,0);
        g.addColorStop(0, 'rgba(220,230,255,0.85)');
        g.addColorStop(0.5, 'rgba(120,140,180,0.85)');
        g.addColorStop(1, 'rgba(200,210,240,0.85)');
        ctx.strokeStyle=g; ctx.lineWidth=7.5; ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=12;
        pathThreeSides(); ctx.stroke();
        ctx.shadowBlur=0; ctx.fillStyle=c;
        const ends = !orientLeft ? [[3,3],[w-3,3]] : [[w-3,3],[w-3,h-3]];
        for(const [ex,ey] of ends){ ctx.beginPath(); ctx.arc(ex,ey,6 + 2*breath5, 0, Math.PI*2); ctx.fill(); }
        break;
      }
      case 'vivid': {
        ctx.globalAlpha = 0.5 + 0.5*breath3;
        const grad = ctx.createLinearGradient(0,0,w,0);
        grad.addColorStop(0, 'rgba(255,255,255,0.85)');
        grad.addColorStop(1, c);
        ctx.strokeStyle=grad; ctx.lineWidth=4.5;
        for(const off of [-4,0,4]){ ctx.save(); ctx.translate(0,off); pathThreeSides(); ctx.stroke(); ctx.restore(); }
        break;
      }
      default: {
        ctx.globalAlpha = 0.6 + 0.3*breathClassic;
        if(window.currentSkin && window.currentSkin.cssSkin === 'ç§‘æŠ€ï¼è³½åšæ ¼ç¶ '){
          const g = ctx.createLinearGradient(0,0,w,0);
          g.addColorStop(0,'#00ff99');
          g.addColorStop(1,'#00cc66');
          ctx.strokeStyle=g; ctx.lineWidth=6;
          ctx.shadowColor='#00ff99'; ctx.shadowBlur=20 + 10*breathClassic; pathThreeSides(); ctx.stroke();
        }else{
          ctx.strokeStyle=c; ctx.lineWidth=6; ctx.shadowColor=c; ctx.shadowBlur=20 + 10*breathClassic; pathThreeSides(); ctx.stroke();
        }
        break;
      }
    }
    ctx.restore();}

  // åªåœ¨ç£šå¡Šå€åŸŸæ­ç¤ºåœ–ç‰‡åˆ‡ç‰‡ï¼ˆä¾æœ¬é—œå½±åƒï¼‰
  function drawRevealTiles(){
    const img=getLevelImage(level);
    if(!img || !(img.naturalWidth>0 && img.naturalHeight>0)) return;
    const L=layout();
    const area={x:L.pad,y:L.top,w:1100-L.pad*2,h:L.rows*(brickH+L.pad)-L.pad};
    const rImg=img.naturalWidth/img.naturalHeight;
    const rArea=area.w/area.h;
    let dw,dh;
    if(rImg>rArea){ dh=area.h; dw=dh*rImg; } else { dw=area.w; dh=dw/rImg; }
    const dx=area.x+(area.w-dw)/2;
    const dy=area.y+(area.h-dh)/2;
    ctx.save();
    ctx.scale(scaleX,scaleY);
    for(const r of revealRects){
      let sx=(r.x-dx)/dw*img.naturalWidth;
      let sy=(r.y-dy)/dh*img.naturalHeight;
      let sw=r.w/dw*img.naturalWidth;
      let sh=r.h/dh*img.naturalHeight;
      const sx0=Math.max(0, Math.min(img.naturalWidth, sx));
      const sy0=Math.max(0, Math.min(img.naturalHeight, sy));
      const sw0=Math.max(0, Math.min(img.naturalWidth - sx0, sw));
      const sh0=Math.max(0, Math.min(img.naturalHeight - sy0, sh));
      if(sw0>0 && sh0>0){
        ctx.drawImage(img, sx0,sy0,sw0,sh0, r.x, r.y, r.w, r.h);
      }
    }
    ctx.restore();
  }

  function drawPlasmas(){ const now=performance.now(); ctx.save(); for(let i=plasmas.length-1;i>=0;i--){ const P=plasmas[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.995; P.vy*=0.995; P.phase=(P.phase||0)+0.2; if(now>P.until){ plasmas.splice(i,1); continue; }
      const x=P.x*scaleX, y=P.y*scaleY, r=P.radius*((scaleX+scaleY)/2); const grd=ctx.createRadialGradient(x,y,0,x,y,r); grd.addColorStop(0,'rgba(200,255,255,0.9)'); grd.addColorStop(0.3,'rgba(150,200,255,0.6)'); grd.addColorStop(0.6,'rgba(120,150,255,0.3)'); grd.addColorStop(1,'rgba(120,150,255,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.save(); ctx.globalCompositeOperation='lighter'; for(let k=0;k<3;k++){ const a=P.phase+k*Math.PI*2/3; ctx.strokeStyle='rgba(180,240,255,0.6)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,r*0.8,a,a+Math.PI/3); ctx.stroke(); } ctx.restore();
      // æ²¿é€”æ¸…é™¤ç£šå¡Šï¼ˆBoss/ä¸å¯ç ´å£è±å…ï¼‰
      for(let j=bricks.length-1;j>=0;j--){ const b=bricks[j]; const bx=b.x+b.w/2, by=b.y+b.h/2; if(Math.hypot(P.x-bx,P.y-by)<=P.radius){
          if(b.unbreakable) continue;
          if(b.boss){
            b.hp-=1;
            if(b.hp<=0){ bossKillEffect(b); revealBrickArea(b); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; updateHUD(); }
          }
          else {
            revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++; updateHUD(); playSFX('plasmaHit');
          }
        }
      }
      if(circleIntersectsActiveBoss(P.x,P.y,P.radius)){
        const impact=activeBossClampPoint(P.x, P.y);
        damageActiveBoss(1,'plasma',impact);
      }
    } ctx.restore(); }

  function drawHoly(){ const now=performance.now(); for(let i=holyFlashes.length-1;i>=0;i--){ const H=holyFlashes[i]; if(now>H.until){ holyFlashes.splice(i,1); continue; } const a=Math.max(0, (H.until-now)/300); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle=`rgba(255,240,180,${0.6*a})`; ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(0, H.y*scaleY); ctx.lineTo(canvas.width, H.y*scaleY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(H.x*scaleX, 0); ctx.lineTo(H.x*scaleX, canvas.height); ctx.stroke(); ctx.restore(); } }

  function drawPhoenix(){ if(!phoenixAnim) return; const now=performance.now(); const t=phoenixAnim; const prog=1-Math.max(0,(t.tEnd-now)/1200); const logicW=1100; const xLogic=(1-prog)*(logicW+200)-200; const x=xLogic*scaleX;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    // èº«å½¢å…‰ç¾½
    const grad=ctx.createLinearGradient((x+120),220*scaleY,x,260*scaleY); grad.addColorStop(0,'rgba(255,180,0,0.9)'); grad.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=grad;
    ctx.beginPath(); ctx.moveTo((x+180), 220*scaleY); ctx.quadraticCurveTo((x+60), 180*scaleY, (x), 230*scaleY); ctx.quadraticCurveTo((x-40), 260*scaleY, (x+120), 260*scaleY); ctx.closePath(); ctx.fill();
    // ç¾½æ¯›ç²’å­
    for(let i=0;i<3;i++){ fireBursts.push({x:(x-40)+Math.random()*120,y:220+Math.random()*60,life:300+Math.random()*400}); }
    ctx.restore(); if(now>=t.tEnd) phoenixAnim=null; }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(screenShake>0){ const s=screenShake*0.6; ctx.save(); ctx.translate((Math.random()-0.5)*s,(Math.random()-0.5)*s); screenShake*=0.9; }
    const now=performance.now();
    drawBGDecor();
    drawDemonWave(now);
    if(buffs.ANNIHIL.active){ if(Math.random()<0.5) annihilSparks.push({x:Math.random()*1100,y:0,v:1+Math.random()*1.5}); for(let i=annihilSparks.length-1;i>=0;i--){ const sp=annihilSparks[i]; sp.y+=sp.v; ctx.fillStyle='rgba(255,220,150,0.8)'; ctx.fillRect(sp.x*scaleX, sp.y*scaleY,2*scaleX,2*scaleY); if(sp.y>700) annihilSparks.splice(i,1); } }
    drawRevealTiles();

    // ç£šå¡Š
    for(const b of bricks){
      // ç§»å‹•ç£šæ›´æ–°
      if(b.moving){
        b.x += b.vx;
        if(b.x<8){ b.x=8; b.vx=Math.abs(b.vx); }
        if(b.x+b.w>1100-8){ b.x=1100-8-b.w; b.vx=-Math.abs(b.vx); }
      }
      // ç¹ªè£½
      let fillStyle;
      if(b.treasure){
        const gold=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
        gold.addColorStop(0,'#fff5d6');
        gold.addColorStop(0.18,'#ffe38a');
        gold.addColorStop(0.45,'#ffd042');
        gold.addColorStop(0.78,'#d9a326');
        gold.addColorStop(1,'#9f7012');
        fillStyle=gold;
      }else{
        let base = b.boss ? '#ff4d6d' : b.unbreakable ? '#888' : b.strong ? '#bb7aff' : b.moving ? '#6ec6ff' : b.explosive ? getVar('--expl') : brickColor(b.colorIdx);
        const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
        g.addColorStop(0,base);
        g.addColorStop(1,'#1a1f3a');
        fillStyle=g;
      }
      ctx.fillStyle=fillStyle;
      drawRoundedRect(b.x,b.y,b.w,b.h,6);
      ctx.fill();
      if(b.treasure){
        const now=performance.now();
        const sheenPos=(now%1400)/1400;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const sheen=ctx.createLinearGradient((b.x-12)*scaleX,(b.y-12)*scaleY,(b.x+b.w+12)*scaleX,(b.y+b.h+12)*scaleY);
        const start=Math.max(0,sheenPos-0.2);
        const peak=sheenPos;
        const end=Math.min(1,sheenPos+0.2);
        sheen.addColorStop(0,'rgba(255,255,255,0)');
        sheen.addColorStop(start,'rgba(255,255,255,0)');
        sheen.addColorStop(peak,'rgba(255,255,255,0.85)');
        sheen.addColorStop(end,'rgba(255,255,255,0)');
        sheen.addColorStop(1,'rgba(255,255,255,0)');
        ctx.globalAlpha=0.55;
        ctx.fillStyle=sheen;
        drawRoundedRect(b.x-4,b.y-4,b.w+8,b.h+8,9);
        ctx.fill();

        const glowPulse=0.65+0.35*Math.sin(now/320);
        const rainbow=ctx.createLinearGradient((b.x-10)*scaleX,(b.y-10)*scaleY,(b.x+b.w+10)*scaleX,(b.y+b.h+10)*scaleY);
        const rainbowColors=['#ff6ec7','#ff9f43','#ffe066','#8ce99a','#74c0fc','#b197fc','#ff85f5'];
        rainbowColors.forEach((col,i)=>rainbow.addColorStop(i/(rainbowColors.length-1),col));
        ctx.globalAlpha=0.8+0.2*Math.sin(now/360);
        ctx.strokeStyle=rainbow;
        ctx.lineWidth=3.5+1.5*glowPulse;
        ctx.shadowBlur=20;
        ctx.shadowColor=`rgba(255,210,120,${0.3+0.25*glowPulse})`;
        drawRoundedRect(b.x-5,b.y-5,b.w+10,b.h+10,10);
        ctx.stroke();
        ctx.restore();
      }
      if(b.placeholderBoss){
        const pulse=0.5+0.5*Math.sin(performance.now()/200);
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle=`rgba(255,210,150,${0.35+0.35*pulse})`;
        ctx.lineWidth=6;
        drawRoundedRect(b.x-6,b.y-6,b.w+12,b.h+12,10);
        ctx.stroke();
        ctx.restore();
      }
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.shadowColor='rgba(120,220,255,0.7)'; ctx.shadowBlur=15; const eg=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x+b.w)*scaleX,(b.y+b.h)*scaleY); eg.addColorStop(0,'rgba(0,255,255,0.9)'); eg.addColorStop(1,'rgba(120,180,255,0.2)'); ctx.strokeStyle=eg; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.shadowBlur=0; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); }
      if(b.poisonUntil && performance.now()<b.poisonUntil){ ctx.fillStyle='rgba(0,255,0,0.25)'; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill(); }
      // é–éˆè¦†è“‹
      if(b.lockedUntil && performance.now() < b.lockedUntil){ ctx.fillStyle='rgba(90,0,120,0.35)'; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill();
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.shadowColor='rgba(120,220,255,0.7)'; ctx.shadowBlur=15; const eg=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x+b.w)*scaleX,(b.y+b.h)*scaleY); eg.addColorStop(0,'rgba(0,255,255,0.9)'); eg.addColorStop(1,'rgba(120,180,255,0.2)'); ctx.strokeStyle=eg; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.shadowBlur=0; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); } }
      // èè‹±èšæ°£å…‰
      if(b.elite && b.eliteChargeUntil && performance.now()<b.eliteChargeUntil){ const a=0.5+0.5*Math.sin(performance.now()/80); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,220,255,'+(0.6*a)+')'; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.restore(); }
      // è¡€æ¢ / é¢å­”
      if(b.boss){
        drawBossEmblem(b);
        if(!b.cyclops && !b.hideBossHP){
          // è¡€æ¢
          ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*scaleX,6*scaleY);
          const ratio=Math.max(0, b.hp/40);
          const hpGrad=ctx.createLinearGradient((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.x+b.w-8)*scaleX,(b.y+b.h-8)*scaleY);
          hpGrad.addColorStop(0,'rgba(255,150,150,.95)'); hpGrad.addColorStop(1,'rgba(255,240,240,.95)');
          ctx.fillStyle=hpGrad; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*ratio*scaleX,6*scaleY);
        }
      }else if(b.hp>1 && b.hp<99 && b.hp<Infinity){
        ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*scaleX,4*scaleY);
        ctx.fillStyle='rgba(255,255,255,.75)'; const ratio=Math.max(0,(b.hp-1))/3; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*ratio*scaleX,4*scaleY);
      }
    }

    for(const d of demonFallingDebris){
      ctx.save();
      const cx=(d.x + d.w/2)*scaleX;
      const cy=(d.y + d.h/2)*scaleY;
      ctx.translate(cx, cy);
      ctx.rotate(d.angle);
      const w=d.w*scaleX;
      const h=d.h*scaleY;
      const grad=ctx.createLinearGradient(0,-h/2,0,h/2);
      grad.addColorStop(0,d.color||'#ffffff');
      grad.addColorStop(1,'rgba(26,31,58,0.85)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.moveTo(-w/2,-h/2);
      ctx.lineTo(w/2,-h/2);
      ctx.lineTo(w/2,h/2);
      ctx.lineTo(-w/2,h/2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    drawSpaceBossLayer();
    drawReaperLayer();
    drawDragonLayer();
    drawDemonLayer(now);
    drawDemonCloakWraps(now,'behind');
    drawPlasmas(); drawHoly(); drawPhoenix(); drawSwords();

      // Boss wind-up glow
      if(bossChargeUntil && performance.now()<bossChargeUntil){
      const nowCharge = performance.now();
      const a = 0.5 + 0.5*Math.sin(nowCharge/80);
      const dragonCharging = isDragonActive() && dragonBoss && dragonBoss.petrifyCharge && nowCharge < dragonBoss.petrifyCharge.end;
      for(const b of bricks){ if(b.boss){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba('+bossChargeColor+','+(0.6*a)+')'; ctx.lineWidth=4; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke(); ctx.restore(); } }
      if(isDragonActive() && dragonBoss){ const bounds=getDragonBounds(); if(bounds && !dragonCharging){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba('+bossChargeColor+','+(0.6*a)+')'; ctx.lineWidth=4; drawRoundedRect(bounds.x, bounds.y, bounds.w, bounds.h, 18); ctx.stroke(); ctx.restore(); } }
    }


    // æ“‹æ¿
    const pr=paddleRect();
    const nowPad=performance.now();
    if(nowPad>=paddleGoneUntil){
      const padGlow=buffs.STICKY.active?'rgba(120,230,220,.6)':((buffs.WIDE.active||buffs.LONG.stacks.length)?'rgba(120,170,255,.6)':'rgba(200,210,255,.4)');
      ctx.shadowColor=padGlow; ctx.shadowBlur=20;
      const padW=pr.w*scaleX, padH=pr.h*scaleY;
      ctx.save();
      ctx.translate((pr.x+pr.w/2)*scaleX,(pr.y+pr.h/2)*scaleY);
      let ang=0;
      if(buffs.PADSPIN.active){ const period=GAME_CONFIG.powers.PADSPIN.spin.periodMs||8000; ang=((nowPad-(buffs.PADSPIN.start||nowPad))%period)/period*2*Math.PI; }
      ctx.rotate(ang);
      ctx.fillStyle='#9aaeff';
      if(buffs.PADBOOM.active && !buffs.PADBOOM.exploded){ ctx.globalAlpha=0.5+0.5*Math.sin(nowPad/100); }
      const r=8*Math.min(scaleX,scaleY);
      ctx.beginPath();
      ctx.moveTo(-padW/2 + r, -padH/2);
      ctx.arcTo(padW/2, -padH/2, padW/2, padH/2, r);
      ctx.arcTo(padW/2, padH/2, -padW/2, padH/2, r);
      ctx.arcTo(-padW/2, padH/2, -padW/2, -padH/2, r);
      ctx.arcTo(-padW/2, -padH/2, padW/2, -padH/2, r);
      ctx.closePath();
      ctx.fill();
      if(buffs.HOLE.active){
        if(!orientLeft){ const gapW=padW/3; ctx.clearRect(-padW/2+padW/3, -padH/2, gapW, padH); }
        else { const gapH=padH/3; ctx.clearRect(-padW/2, -padH/2+padH/3, padW, gapH); }
      }
      ctx.restore();
      ctx.shadowBlur=0;
      if(buffs.SHIELD.active && !orientLeft){ const g=ctx.createLinearGradient(0,(700-10)*scaleY,0,700*scaleY); g.addColorStop(0,'rgba(120,220,255,0.35)'); g.addColorStop(1,'rgba(120,220,255,0.05)'); ctx.fillStyle=g; ctx.fillRect(0,(700-10)*scaleY,canvas.width,10*scaleY); }
      if(nowPad<=paddleStunUntil){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(255,230,160,0.35)'; drawRoundedRect(pr.x,pr.y,pr.w,pr.h,8); ctx.fill(); ctx.restore(); }
    }
    // é›·å°„ç ²å±•ç¤º
    if(buffs.LASER.active){ ctx.fillStyle='rgba(120,255,120,0.8)'; if(!orientLeft){ ctx.fillRect((pr.x-6)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); ctx.fillRect((pr.x+pr.w+2)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); } else { ctx.fillRect((pr.x-4)*scaleX, (pr.y-6)*scaleY, (pr.w+8)*scaleX, 4*scaleY); ctx.fillRect((pr.x-4)*scaleX, (pr.y+pr.h+2)*scaleY, (pr.w+8)*scaleX, 4*scaleY); } }
    if(stormTurret){ const t=stormTurret; ctx.save(); ctx.fillStyle='rgba(200,255,200,0.8)'; ctx.fillRect((t.x-10)*scaleX,(t.y-20)*scaleY,20*scaleX,20*scaleY); if(performance.now()<t.chargeUntil){ const prog=1-(t.chargeUntil-performance.now())/3000; ctx.globalCompositeOperation='lighter'; ctx.fillStyle=`rgba(120,255,200,${0.3+0.7*prog})`; ctx.beginPath(); ctx.arc(t.x*scaleX,(t.y-20)*scaleY,30*prog*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); } ctx.restore(); }
    if(gatling){
      const t=gatling;
      ctx.save();
      const grad=ctx.createLinearGradient((t.x-8)*scaleX,(t.y-20)*scaleY,(t.x+8)*scaleX,t.y*scaleY);
      grad.addColorStop(0,'#444');
      grad.addColorStop(0.5,'#bbb');
      grad.addColorStop(1,'#444');
      ctx.fillStyle=grad;
      ctx.fillRect((t.x-8)*scaleX,(t.y-20)*scaleY,16*scaleX,20*scaleY);
      ctx.fillStyle='#333';
      ctx.fillRect((t.x-3)*scaleX,(t.y-24)*scaleY,6*scaleX,4*scaleY);
      if(performance.now()<t.chargeUntil){
        const prog=1-(t.chargeUntil-performance.now())/(GAME_CONFIG.powers.GATLING.gatling.chargeMs||3000);
        ctx.globalCompositeOperation='lighter';
        ctx.fillStyle=`rgba(255,200,100,${0.3+0.7*prog})`;
        ctx.beginPath();
        ctx.arc(t.x*scaleX,(t.y-24)*scaleY,20*prog*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    // çƒèˆ‡æ‹–å°¾
    const nowT=performance.now();
    for(const b of balls){
      b.trail.push({x:b.x,y:b.y,t:nowT}); while(b.trail.length>12) b.trail.shift();
      for(let i=b.trail.length-1;i>=0;i--){ const p=b.trail[i]; const age=(nowT-p.t)/200; if(age>1) continue; const alpha=(1-age)*0.6;
        let color=( (b.rampageUntil&&nowT<b.rampageUntil)||b.piercing )?`rgba(120,220,255,${alpha})`:(buffs.FAST.active?`rgba(255,140,90,${alpha})`:`rgba(255,255,255,${alpha*0.6})`);
        if(buffs.PLASMA.active) color=`rgba(160,240,255,${alpha})`; if(buffs.FREEZE.active) color=`rgba(200,230,255,${alpha})`; if(buffs.HOLY.active) color=`rgba(255,240,180,${alpha})`; if(buffs.FIRE.active) color=`rgba(255,150,50,${alpha})`; if(buffs.POISON.active) color=`rgba(120,255,120,${alpha})`; if(buffs.BLINK.active) color=`rgba(180,200,255,${alpha})`; if(buffs.SWORD.active) color=`rgba(${150+100*Math.sin(nowT/80)},${120+60*Math.sin(nowT/60)},255,${alpha})`; if(buffs.BLACKHOLE.active) color=`rgba(80,80,120,${alpha})`; if(buffs.ANNIHIL.active) color=`rgba(255,200,80,${alpha})`;
        if(buffs.TRACK.active) color=`rgba(${Math.floor(128+127*Math.sin(nowT/80))},${Math.floor(128+127*Math.sin(nowT/95+2))},${Math.floor(128+127*Math.sin(nowT/110+4))},${alpha})`;
        if(buffs.GODSPEED.active) color=`rgba(255,224,102,${alpha})`;
        ctx.fillStyle=color; ctx.beginPath(); ctx.arc(p.x*scaleX,p.y*scaleY,(b.r*0.7)*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill();
      }
      const bx=b.x*scaleX, by=b.y*scaleY, br=b.r*((scaleX+scaleY)/2); const grad=ctx.createRadialGradient(bx-3,by-4,2,bx,by,br);
      let edge=(b.piercing||(b.rampageUntil&&nowT<b.rampageUntil))?'#9ff':(buffs.FAST.active?'#ff9a66':'#cbd4ff');
      if(buffs.PLASMA.active) edge='#aff'; if(buffs.FREEZE.active) edge='#e8f8ff'; if(buffs.HOLY.active) edge='#fff0a0'; if(buffs.FIRE.active) edge='#ff6600'; if(buffs.POISON.active) edge='#55ff55'; if(buffs.BLINK.active) edge='#a0b0ff'; if(buffs.GODSPEED.active) edge='#ffe066'; if(buffs.SWORD.active) edge='#d0bbff'; if(buffs.BLACKHOLE.active) edge='#444'; if(buffs.ANNIHIL.active) edge='#ffb347';
      if(b.demonCloakState==='captured') edge='#ff758b';
      grad.addColorStop(0,'#fff'); grad.addColorStop(1, edge); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();
      if(buffs.WAVY.active){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; const r1=br+2+2*Math.sin((nowT/100)+b.x*0.02); ctx.beginPath(); ctx.arc(bx,by,r1,0,Math.PI*2); ctx.stroke(); }
      if(b.stuck && !orientLeft){ ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect((paddle.x+paddle.w/2-12)*scaleX,(paddle.y-6)*scaleY,24*scaleX,4*scaleY); }
    }
    drawDemonCloakWraps(nowT,'front');

    // é»‘æ´ç‰¹æ•ˆ
    for(let i=blackHoles.length-1;i>=0;i--){
      const h=blackHoles[i];
      const nowH=performance.now();
      if(nowH>h.until){ blackHoles.splice(i,1); continue; }
      if(h.spinPhase==null){ h.spinPhase=Math.random()*Math.PI*2; }
      const baseR=h.r||40;
      const start=h.start!=null?h.start:(h.until-600);
      const life=Math.max(1, h.until-start);
      const age=Math.max(0, Math.min(1, (nowH-start)/life));
      const spinDir=h.spinDir||1;
      const scaleAvg=(scaleX+scaleY)/2;
      const pulse=0.82+0.18*Math.sin(nowH/150 + h.spinPhase);
      const x=h.x*scaleX, y=h.y*scaleY;
      const coreR=baseR*scaleAvg*pulse;
      const coronaR=coreR*1.5;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createRadialGradient(x,y,0,x,y,coronaR);
      grad.addColorStop(0,'rgba(5,0,10,0.96)');
      grad.addColorStop(0.32,`rgba(50,0,80,${0.92-0.25*age})`);
      grad.addColorStop(0.6,`rgba(140,70,220,${0.65-0.28*age})`);
      grad.addColorStop(0.86,'rgba(220,180,255,0.22)');
      grad.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(x,y,coronaR,0,Math.PI*2);
      ctx.fill();
      const horizonR=coreR*1.18;
      ctx.strokeStyle=`rgba(220,190,255,${0.22+0.22*Math.sin(nowH/210 + age*Math.PI)})`;
      ctx.lineWidth=4*scaleAvg*(1-age*0.5);
      ctx.beginPath();
      ctx.arc(x,y,horizonR,0,Math.PI*2);
      ctx.stroke();
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate((nowH/240 + h.spinPhase)*spinDir);
      const swirlLayers=4;
      for(let layer=0; layer<swirlLayers; layer++){
        const theta=layer*(Math.PI/2);
        const rr=coreR*(0.46 + layer*0.12);
        ctx.beginPath();
        ctx.strokeStyle=`rgba(255,230,255,${0.14*(1-layer*0.18)})`;
        ctx.lineWidth=(1.6+layer*0.7)*scaleAvg;
        ctx.arc(0,0,rr,theta,theta+Math.PI*0.65);
        ctx.stroke();
      }
      ctx.restore();
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate((-nowH/320 + h.spinPhase*1.4)*spinDir);
      ctx.strokeStyle=`rgba(160,110,255,${0.2*(1-age)})`;
      ctx.lineWidth=3.6*scaleAvg;
      ctx.beginPath();
      ctx.arc(0,0,coreR*1.32,-Math.PI*0.35,Math.PI*0.35);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    
    // é›·å°„å…‰æŸï¼ˆå¼·åŒ–è³ªæ„Ÿï¼‰
    for(let i=laserBeams.length-1;i>=0;i--){
      const b=laserBeams[i];
      const nowP=performance.now();
      if(nowP>b.until){ laserBeams.splice(i,1); continue; }
      const x1=b.x1*scaleX, y1=b.y1*scaleY, x2=b.x2*scaleX, y2=b.y2*scaleY;
      const t = Math.max(0, Math.min(1, (b.until-nowP)/200));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      // Outer glow
      ctx.strokeStyle='rgba(120,255,180,'+(0.25*t)+')';
      ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Mid beam
      const grd = ctx.createLinearGradient(x1,y1,x2,y2);
      grd.addColorStop(0,'rgba(160,255,220,'+(0.7*t)+')');
      grd.addColorStop(1,'rgba(255,255,255,'+(0.9*t)+')');
      ctx.strokeStyle=grd; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Core
      ctx.strokeStyle='rgba(255,255,255,'+(1*t)+')'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    }
    // Boss æŠ•å°„ç‰©
    drawAndStepBossProjectiles();

    // é›·å°„å‘½ä¸­æ•£é–‹ç‰¹æ•ˆ
    for(let i=laserImpacts.length-1;i>=0;i--){
      const it=laserImpacts[i]; const nowI=performance.now();
      if(nowI>it.tEnd){ laserImpacts.splice(i,1); continue; }
      const prog = 1 - Math.max(0, (it.tEnd - nowI)/ (it.tEnd - it.t0));
      const x = it.x*scaleX, y = it.y*scaleY;
      // expanding ring
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='rgba(160,255,200,'+(0.8*(1-prog))+')';
      ctx.lineWidth = 2 + 6*prog;
      ctx.beginPath(); ctx.arc(x,y, 6 + 26*prog, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
      // sparks
      for(let s=0;s<6;s++){
        const ang = (s/6)*Math.PI*2;
        const len = 8 + prog*24;
        ctx.save(); ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle='rgba(180,255,220,'+(0.7*(1-prog))+')';
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(x,y);
        ctx.lineTo(x+Math.cos(ang)*len, y+Math.sin(ang)*len);
        ctx.stroke(); ctx.restore();
      }
    }
    // ç«åŠ›å£“åˆ¶å­å½ˆ
    for(const b of gatlingBullets){
      ctx.save();
      const r=4*((scaleX+scaleY)/2);
      const g=ctx.createRadialGradient(b.x*scaleX,b.y*scaleY,0,b.x*scaleX,b.y*scaleY,r);
      g.addColorStop(0,'#fff');
      g.addColorStop(0.3,'#ffec99');
      g.addColorStop(1,'#ff8800');
      ctx.fillStyle=g;
      ctx.shadowBlur=8*((scaleX+scaleY)/2);
      ctx.shadowColor='#ffb347';
      ctx.beginPath(); ctx.arc(b.x*scaleX,b.y*scaleY,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    // é£›å½ˆ
    for(const m of missiles){ for(const tr of (m.trail||[])){ const a=Math.max(0,1-(performance.now()-tr.t)/300); ctx.fillStyle=`rgba(255,180,90,${0.6*a})`; ctx.beginPath(); ctx.arc(tr.x*scaleX,tr.y*scaleY,2*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); } ctx.fillStyle='#ddd'; ctx.beginPath(); ctx.arc(m.x*scaleX,m.y*scaleY,4*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    // æ‰è½é“å…·

    for(const p of powerups) drawPower(p);

    // é–å®šæ¡†
    drawLockBoxes();

    // ç²’å­
    for(let i=particles.length-1;i>=0;i--){ const P=particles[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.98; P.vy*=0.98; P.life-=16; if(P.life<=0){ particles.splice(i,1); continue; }
      const a=Math.max(0, Math.min(1, P.life/500)); ctx.fillStyle=P.color||`rgba(255,220,180,${a*0.6})`; ctx.beginPath(); ctx.arc(P.x*scaleX,P.y*scaleY,P.size*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    drawSpaceBossHUD();
    drawReaperHUD();
    drawDragonHUD();
    drawDemonHUD();
    drawDemonMarquee(now);

    // å€’æ•¸æç¤º
    if(countdownShow>0){
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.font=`${Math.round(96*((scaleX+scaleY)/2))}px system-ui, sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(countdownShow), canvas.width/2, canvas.height/2);
      ctx.restore();
    }

    // å¤©åœ°ç¿»è½‰æç¤ºï¼šå•Ÿå‹•å‰ 2 ç§’èˆ‡çµæŸå‰ 2 ç§’é¡¯ç¤ºæ—‹è½‰ç¬¦è™Ÿï¼Œä¸é®æ“‹çƒ/æ–¹å¡Š/å¹³å°
    {
      const f = buffs.FLIP;
      const nowT = performance.now();
      let showFlip = false;
      if(f){
        if(f.pending && f.startAt && nowT >= f.startAt - 2000 && nowT < f.startAt){ showFlip = true; }
        if(f.active && f.endAt && nowT >= f.endAt - 2000 && nowT < f.endAt){ showFlip = true; }
      }
      if(showFlip){
        ctx.save();
        // é®ç½©è¼•å¾®æš—åŒ–èƒŒæ™¯
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        // ç•«æ—‹è½‰ç¬¦è™Ÿï¼ˆä½¿ç”¨ Unicode ç¬¦è™Ÿ â†»ï¼‰
        ctx.fillStyle = '#aaffaa';
        ctx.font = `${Math.round(80*((scaleX+scaleY)/2))}px system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('â†»', canvas.width/2, canvas.height/2);
        ctx.restore();
      }
    }

    if(screenShake>0){ ctx.restore(); }
  }

  function drawSwords(){ const now=performance.now(); const pr=paddleRect(); for(let i=swords.length-1;i>=0;i--){ const s=swords[i]; if(s.state==='wander'){ s.x+=s.vx; s.y+=s.vy; if(s.x<20||s.x>1080) s.vx*=-1; if(s.y<500||s.y>680) s.vy*=-1; if(!buffs.SWORD.active){ s.state='gather'; s.t0=now; s.tx=pr.x+pr.w/2+ (i-swords.length/2)*20; s.ty=pr.y-40; } } else if(s.state==='gather'){ const prog=Math.min(1,(now-s.t0)/2000); s.x += (s.tx-s.x)*0.15; s.y += (s.ty-s.y)*0.15; if(prog>=1){ s.state='ready'; } } else if(s.state==='fire'){ s.x+=s.vx; s.y+=s.vy; const idx=s.target; if(idx==='boss'){ const bounds=getActiveBossBounds(); if(!isSpecialBossActive() || !bounds){ swords.splice(i,1); continue; } if(s.x>bounds.x && s.x<bounds.x+bounds.w && s.y>bounds.y && s.y<bounds.y+bounds.h){ playSFX('sword'); damageActiveBoss(1,'sword',{x:s.x,y:s.y}); swords.splice(i,1); continue; } } else { const bk=bricks[idx]; if(bk && s.x>bk.x && s.x<bk.x+bk.w && s.y>bk.y && s.y<bk.y+bk.h){ playSFX('sword'); damageBrick(idx,3,'none'); swords.splice(i,1); continue; } } if(s.x<0||s.x>1100||s.y<0||s.y>700){ swords.splice(i,1); continue; } }
      ctx.save();
      ctx.translate(s.x*scaleX, s.y*scaleY);
      ctx.rotate(Math.atan2(s.vy||0.1, s.vx||0.1));
      const bladeGrad = ctx.createLinearGradient(-12, 0, 14, 0);
      bladeGrad.addColorStop(0, '#fdfbff');
      bladeGrad.addColorStop(1, '#c8a8ff');
      ctx.fillStyle = bladeGrad;
      ctx.beginPath();
      ctx.moveTo(-12, -2);
      ctx.lineTo(14, 0);
      ctx.lineTo(-12, 2);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#b090ff';
      ctx.fillRect(-14, -3, 4, 6); // guard
      ctx.fillStyle = '#6c4bb3';
      ctx.fillRect(-18, -1, 4, 2); // handle
      ctx.restore(); }
    if(!buffs.SWORD.active && swords.length && !swordFireStart){ swordFireStart=now+2000; nextSwordFire=swordFireStart; }
    if(swordFireStart && now>=swordFireStart){
      if(now>=nextSwordFire){
        const s=swords.find(z=>z.state==='ready');
        if(s){
          const idx=randomBrick(true);
          if(idx!=null){
            let tx=null, ty=null;
            if(idx==='boss'){
              if(isSpecialBossActive()){
                const center=activeBossCenter();
                if(center){ tx=center.x; ty=center.y; }
                highlightSpaceBossTarget();
              }
            }else{
              const t=bricks[idx];
              if(t){ tx=t.x+t.w/2; ty=t.y+t.h/2; }
            }
            if(tx!=null && ty!=null){
              const ang=Math.atan2(ty-s.y,tx-s.x);
              s.vx=Math.cos(ang)*8;
              s.vy=Math.sin(ang)*8;
              s.state='fire';
              s.target=idx;
            }
          }
        }
        nextSwordFire=now+300;
        if(!swords.some(z=>z.state==='ready')) swordFireStart=0;
      }
    }
  }

  function randomBrick(includeBoss=false){
    const arr=bricks.map((b,i)=>({b,i})).filter(x=>canDestroyBrick(x.b));
    if(includeBoss && isSpecialBossActive()){ arr.push({boss:true}); }
    if(!arr.length) return null;
    const r=arr[Math.floor(Math.random()*arr.length)];
    return r.boss ? 'boss' : r.i;
  }

  
  function speedForLevel(lv){
    // æ›´å¹³æ»‘çš„çƒé€Ÿæ›²ç·šï¼šå¾ baseSpeed ç·©æ…¢å¢é•·åˆ° +~3.2
    const base = getDiff().baseSpeed;
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const ease = t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2; // easeInOutQuad
    const extra = 0.6 + 2.6 * ease; // 0.6 -> 3.2
    return base + extra;
  }

  function paddleHitSpeedMul(lv){
    const maxLevel=20;
    const l=Math.min(Math.max(lv,1),maxLevel);
    const t=(l-1)/(maxLevel-1);
    return 1.04 + 0.02 * t; // 1.04 -> 1.06
  }

  function resetBalls(center=true){ balls=[makeBall(false)]; const base=getDiff().baseSpeed; const speed=speedForLevel(level); const angle=(-60-Math.random()*60)*Math.PI/180;
    balls[0].x=center?1100/2:paddle.x+paddle.w/2; balls[0].y=700-70; balls[0].vx=Math.cos(angle)*speed; balls[0].vy=Math.sin(angle)*speed; balls[0].piercing=buffs.PIERCE.active; }

  function startCountdown(restart=true){
    // æ¸…é™¤å…ˆå‰çš„å€’æ•¸è¨ˆæ™‚ä»¥é¿å…åœ¨é¸å–®é–‹å•Ÿæ™‚ä»ç¹¼çºŒå€’æ•¸
    if(countdownTimer){ clearTimeout(countdownTimer); countdownTimer=null; }
    paused=true;
    if(restart || countdownShow<=0){ countdownShow=3; }
    showCenter('', ''); centerNote.style.display='none'; // ç”¨ç•«é¢å€’æ•¸
    resumePending=true;
    const tick=()=>{
      if(countdownShow<=0){
        resumePending=false; paused=false; stats.lifeStart=performance.now(); countdownTimer=null; return;
      }
      beep(600 + (3-countdownShow)*100, 0.07, 0.05);
      countdownTimer = setTimeout(()=>{ countdownShow--; tick(); }, 450);
    };
    tick();
  }


  function update(){
    const now=performance.now();
    if(cyclopsShakeUntil && now<cyclopsShakeUntil){ screenShake=Math.max(screenShake,6); }
    if(comboEl) comboEl.classList.toggle('star', buffs.COMBO.active);
    if(combo>0){
      const elapsed=now-comboLastTime;
      const mul=buffs.COMBO.active?GAME_CONFIG.powers.COMBO.combo.timeMul:1;
      const fadeStart=3000*mul, resetTime=5000*mul;
      if(elapsed>fadeStart && elapsed<resetTime){ comboEl.style.opacity=1-((elapsed-fadeStart)/(resetTime-fadeStart)); }
      else if(elapsed>=resetTime){ resetCombo(); }
      else { comboEl.style.opacity=1; }
    }
    // Buff éæœŸ
    for(const key of Object.keys(GAME_CONFIG.powers)){
      if(key==='LONG' || key==='FLIP') continue;
      const b=buffs[key];
      if(b?.active && b.until && now>b.until){
        if(key==='BLACKHOLE') continue;
        b.active=false;
        if(key==='GODSPEED'){
          for(const ball of balls){
            const ang=Math.atan2(ball.vy,ball.vx);
            const sp=ball.speedCap*0.5;
            ball.vx=Math.cos(ang)*sp;
            ball.vy=Math.sin(ang)*sp;
          }
        }
        if(key==='PIERCE'){ for(const ball of balls) ball.piercing=false; }
        if(key==='STICKY'){ for(const ball of balls){ if(ball.stuck){ ball.stuck=false; ball.vy = -Math.abs(ball.vy||6); } } }
        if(key==='MEGA' && buffs.MEGA.applied){ for(const ball of balls){ ball.r/=GAME_CONFIG.powers.MEGA.mega.sizeMul; } buffs.MEGA.applied=false; }
        if(key==='FIRE'){
          if(fireEnergy>0 && balls.length){
            const b0=balls[0];
            const e=fireEnergy;
            const radius = e<=3?100:e<=8?150:e<=14?200:300;
            fireExplosionAt(b0.x,b0.y,radius);
          }
          fireEnergy=0; updateFireEnergy();
        }
        if(key==='COMBO' && comboEl){ comboEl.classList.remove('star'); }
        if(key==='GATLING'){ gatling=null; gatlingBullets.length=0; }
      }
    }
    computePaddleWidth(); updateBuffBadges();
    updateSpaceBoss();
    updateReaperBoss();
    updateDragonBoss();
    updateDemonEvent(now);
    updateDemonBoss();

    if(isTrueBossFightActive()){
      if(!nextTreasureBrickAt){
        scheduleNextTreasureBrick(now);
      }else if(now>=nextTreasureBrickAt){
        spawnBossTreasureBrick();
        scheduleNextTreasureBrick(now);
      }
    }else{
      nextTreasureBrickAt=0;
    }

    let treasureRemoved=false;
    for(let i=bricks.length-1;i>=0;i--){
      const bk=bricks[i];
      if(!bk?.fallingTreasure) continue;
      const vy=bk.vy || GAME_CONFIG.powerCapsule.fallVy || 2.2;
      bk.y += vy;
      if(bk.y>710){ bricks.splice(i,1); treasureRemoved=true; }
    }
    if(treasureRemoved){ updateHUD(); }

    for(let i=demonFallingDebris.length-1;i>=0;i--){
      const d=demonFallingDebris[i];
      d.vy += d.gravity;
      d.y += d.vy;
      if(d.vx){ d.x += d.vx; d.vx*=0.99; }
      d.angle += d.spin;
      if(d.y>720){ demonFallingDebris.splice(i,1); }
    }

    // åŠ‡æ¯’ç£šæŒçºŒæ‰£è¡€
    for(let i=bricks.length-1;i>=0;i--){
      const bk=bricks[i];
      if(!bk.poisonUntil) continue;
      if(now>=bk.poisonUntil){ delete bk.poisonUntil; delete bk.poisonTick; continue; }
      if(!bk.poisonTick) bk.poisonTick = now + (GAME_CONFIG.powers.POISON.poison.tickMs||2000);
      if(now >= bk.poisonTick){
        bk.poisonTick += (GAME_CONFIG.powers.POISON.poison.tickMs||2000);
        if(canDestroyBrick(bk)){
          if(bk.boss){
            bk.hp-=1;
            if(bk.hp<=0){ bossKillEffect(bk); revealBrickArea(bk); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(bk)); stats.bossKills++; updateHUD(); }
          }
          else {
            bk.hp=(bk.hp||1)-1;
            if(bk.hp<=0){ revealBrickArea(bk); maybeDropFromBrick(bk); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(bk)); if(bk.elite) stats.eliteKills++; updateHUD(); }
          }
          spawnParticles(bk.x+bk.w/2,bk.y+bk.h/2,'rgba(120,255,120,0.9)',10,1.5,2.4,2);
        }
      }
    }

    // === å¤©åœ°ç¿»è½‰ç‹€æ…‹è™•ç† ===
    if(buffs.FLIP){
      const f = buffs.FLIP;
      // å•Ÿå‹•ç¿»è½‰ï¼špending ç‹€æ…‹é€²å…¥ active
      if(f.pending && f.startAt && now >= f.startAt){
        f.pending = false;
        f.active = true;
        // æ›´æ–° until ä¾› HUD é¡¯ç¤º
        if(f.endAt) f.until = f.endAt;
        // åˆ‡æ›ç‚ºå·¦å´æ¨¡å¼
        orientLeft = true;
        // å°‡æ“‹æ¿ç½®æ–¼ç•«é¢ä¸­å¤®ï¼ˆå‚ç›´æ¨¡å¼ï¼‰
        paddle.y = (700 - paddle.w) / 2;
        paddle.x = 0;
        // å°‡ç¾æœ‰æ‰è½é“å…·æ”¹ç‚ºæ°´å¹³ç§»å‹•
        for(const p of powerups){ p.horizontal = true; }
        // é‡æ–°é–å®šæ‰€æœ‰çƒä»¥ç„æº–æ“‹æ¿ä¸­å¿ƒ
        const pr = paddleRect();
        const tx = pr.x + pr.w/2;
        const ty = pr.y + pr.h/2;
        for(const b of balls){
          const sp = Math.max(6, Math.hypot(b.vx, b.vy));
          const ang = Math.atan2(ty - b.y, tx - b.x);
          b.vx = Math.cos(ang) * sp;
          b.vy = Math.sin(ang) * sp;
        }
        // åŠ å…¥é–å®šæ¡†æç¤ºæ“‹æ¿ä½ç½®
        pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
      }
      // çµæŸç¿»è½‰ï¼šactive ç‹€æ…‹åˆ°æœŸå¾Œæ¢å¾©æ­£å¸¸
      if(f.active && f.endAt && now >= f.endAt){
        f.active = false;
        // é‡ç½® until
        f.until = 0;
        // æ¢å¾©æ°´å¹³æ–¹å‘
        orientLeft = false;
        // æ“‹æ¿ç½®æ–¼åº•éƒ¨ä¸­å¤®
        paddle.y = 700 - 50;
        paddle.x = 1100/2 - paddle.w/2;
        // å°‡ç¾æœ‰æ‰è½é“å…·æ”¹ç‚ºå‚ç›´ç§»å‹•
        for(const p of powerups){ p.horizontal = false; }
        // çƒé‡æ–°ç„æº–æ“‹æ¿ä¸­å¿ƒ
        const pr2 = paddleRect();
        const tx2 = pr2.x + pr2.w/2;
        const ty2 = pr2.y + pr2.h/2;
        for(const b of balls){
          const sp = Math.max(6, Math.hypot(b.vx, b.vy));
          const ang = Math.atan2(ty2 - b.y, tx2 - b.x);
          b.vx = Math.cos(ang) * sp;
          b.vy = Math.sin(ang) * sp;
        }
        // é¡¯ç¤ºé–å®šæ¡†
        pushLockBox(pr2.x, pr2.y, pr2.w, pr2.h, 'paddle');
      }
    }


    if(buffs.PADBOOM.active){
      if(!buffs.PADBOOM.exploded && now >= buffs.PADBOOM.explodeAt){
        const pr = paddleRect();
        const cx = pr.x+pr.w/2, cy = pr.y+pr.h/2;
        spawnParticles(cx, cy, '#ffdd99', 80, 3.5, 5.0, 5);
        spawnParticles(cx, cy, '#ffeeaa', 60, 3.8, 4.8, 4.5);
        spawnParticles(cx, cy, '#ffffff', 40, 3.2, 4.2, 3.5);
        screenShake = Math.max(screenShake,10);
        playSFX('explosion');
        showComboNotice('å“ˆå“ˆä½ çˆ†æ‰å•¦? é“å…·ä¸èƒ½äº‚åƒå‘€!',5000,3000);
        paddleGoneUntil = buffs.PADBOOM.returnAt;
        buffs.PADBOOM.exploded = true;
      }
      if(buffs.PADBOOM.exploded && now >= buffs.PADBOOM.returnAt){
        buffs.PADBOOM.active = false;
        buffs.PADBOOM.until = 0;
        paddleGoneUntil = 0;
      }
    }

    // èè‹±ç£šæŠ€èƒ½ï¼šæ¯30ç§’ç™¼å°„ï¼Œç™¼å°„å‰èšæ°£2ç§’
    for(const b of bricks){ if(!b.elite) continue; if(b.eliteChargeUntil && now<b.eliteChargeUntil){ /* charging */ } else { if(!b.eliteNext) b.eliteNext = now+30000; if(now>=b.eliteNext){ b.eliteChargeUntil = now+2000; b.eliteNext = now+30000; setTimeout(()=>{ const idx = bricks.indexOf(b); if(idx!==-1){ spawnLionBeamFrom(b.x+b.w/2, b.y+b.h/2); } }, 2000); } } }
// éµç›¤ç§»å‹•ï¼šå¤©åœ°ç¿»è½‰æ™‚æ”¹ç‚ºä¸Šä¸‹ç§»å‹•ï¼ˆä»ä½¿ç”¨å·¦å³éµï¼‰
    if(!orientLeft){ if(performance.now()>paddleStunUntil){ if(keyL) paddle.x-=paddle.speed; if(keyR) paddle.x+=paddle.speed; } paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x)); }
    else{ if(performance.now()>paddleStunUntil){ if(keyL) paddle.y-=paddle.speed; if(keyR) paddle.y+=paddle.speed; } paddle.y=Math.max(0, Math.min(700-paddle.w, paddle.y)); }

    // é›·å°„ç™¼å°„
    if(buffs.LASER.active){
      const interval = GAME_CONFIG.powers.LASER.laser.intervalMs;
      if(!buffs.LASER.lastShot || now - buffs.LASER.lastShot >= interval){
        buffs.LASER.lastShot = now;
        const pr=paddleRect();
        const barrels = !orientLeft ? [{x:pr.x, y:pr.y+pr.h/2},{x:pr.x+pr.w, y:pr.y+pr.h/2}] : [{x:pr.x+pr.w/2, y:pr.y},{x:pr.x+pr.w/2, y:pr.y+pr.h}];
        for(const s of barrels){
          let target=null;
          let best=-1;
          for(let i=0;i<bricks.length;i++){
            const bk=bricks[i];
            if(!canDestroyBrick(bk)) continue;
            const dx=(bk.x+bk.w/2)-s.x;
            const dy=(bk.y+bk.h/2)-s.y;
            const d=dx*dx+dy*dy;
            if(d>best){ best=d; target={type:'brick', idx:i, x:bk.x+bk.w/2, y:bk.y+bk.h/2}; }
          }
          const bossCenter = isSpecialBossActive() ? activeBossCenter() : null;
          if(bossCenter){
            const dx=bossCenter.x - s.x;
            const dy=bossCenter.y - s.y;
            const d=dx*dx+dy*dy;
            if(d>best){
              best=d;
              target={type:'boss', x:bossCenter.x, y:bossCenter.y};
              highlightSpaceBossTarget();
            }
          }
          if(target){
            const impact = target.type==='boss' ? activeBossImpactPoint(s.x,s.y) : {x:target.x, y:target.y};
            laserBeams.push({x1:s.x,y1:s.y,x2:impact.x,y2:impact.y,until:now+200});
            laserImpacts.push({x:impact.x, y:impact.y, t0:now, tEnd:now+320});
            spawnParticles(impact.x,impact.y,'rgba(160,255,200,0.9)',10,1.8,2.2,2.6);
            if(target.type==='boss'){
              damageActiveBoss(1,'laser',impact);
            }else{
              destroyBrick(target.idx,'laser');
            }
          }
        }
      }
    }

    if(gatling){
      const pr=paddleRect();
      gatling.x=pr.x+pr.w/2; gatling.y=pr.y;
      if(now>=gatling.fireStart){
        if(now>=gatling.fireUntil){ gatling=null; buffs.GATLING.active=false; }
        else if(now-gatling.lastShot>=(GAME_CONFIG.powers.GATLING.gatling.intervalMs||100)){
          gatling.lastShot=now;
          gatling.angle=(gatling.angle||0)+0.3;
          const cfg=GAME_CONFIG.powers.GATLING.gatling;
          const x=gatling.x+Math.cos(gatling.angle)*5;
          const vx=Math.cos(gatling.angle)*0.5;
          gatlingBullets.push({x:x,y:gatling.y-10,vx:vx,vy:-(cfg.bulletSpeed||10)});
          spawnParticles(x, gatling.y-10, '#ffbb55', 8, 1.2, 2.5, 2);
          playSFX('gatlingShoot');
        }
      }
    }
    for(let i=gatlingBullets.length-1;i>=0;i--){
      const bl=gatlingBullets[i];
      bl.x+=bl.vx; bl.y+=bl.vy;
      if(bl.y<0){ gatlingBullets.splice(i,1); continue; }
      let removed=false;
      for(let j=bricks.length-1;j>=0;j--){
        const bk=bricks[j];
        if(bl.x>bk.x && bl.x<bk.x+bk.w && bl.y>bk.y && bl.y<bk.y+bk.h){
          spawnParticles(bl.x, bl.y, '#ffdd77', 8, 1.6, 3.2, 2.5);
          playSFX('gatlingHit');
          if(canDestroyBrick(bk) && !(bk.lockedUntil && now<bk.lockedUntil)){
            bk.hp=(bk.hp||1)-1; incrementCombo();
            if(bk.hp<=0){
              addScore(scoreForBrick(bk)); updateHUD();
              const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
              revealBrickArea(bk); maybeDropFromBrick(bk);
              spawnParticles(cx, cy, '#eeeeee', 24, 2.4, 4.0, 3.5);
              if(bk.explosive){ explodeAt(cx,cy); } else { bricks.splice(j,1); }
            } else updateHUD();
          }
          gatlingBullets.splice(i,1);
          removed=true;
          break;
        }
      }
      if(!removed && isSpecialBossActive()){
        const bounds=getActiveBossBounds();
        if(bounds && bl.x>bounds.x && bl.x<bounds.x+bounds.w && bl.y>bounds.y && bl.y<bounds.y+bounds.h){
          spawnParticles(bl.x, bl.y, '#ffdd77', 8, 1.6, 3.2, 2.5);
          playSFX('gatlingHit');
          damageActiveBoss(1,'gatling',{x:bl.x,y:bl.y});
          gatlingBullets.splice(i,1);
        }
      }
    }

    if(stormTurret){ if(now>=stormTurret.fireAt){ if(stormTurret.shots<=0){ stormTurret=null; buffs.STORM.active=false; } else if(now-stormTurret.lastShot>=200){ const idx=randomBrick(true); if(idx!=null){ if(idx==='boss' && isSpecialBossActive()){ const impact=activeBossImpactPoint(stormTurret.x,stormTurret.y); highlightSpaceBossTarget(); laserBeams.push({x1:stormTurret.x,y1:stormTurret.y,x2:impact.x,y2:impact.y,until:now+200}); laserImpacts.push({x:impact.x,y:impact.y,t0:now,tEnd:now+320}); damageActiveBoss(1,'laser',impact); } else { const t=bricks[idx]; if(t){ const tx=t.x+t.w/2, ty=t.y+t.h/2; laserBeams.push({x1:stormTurret.x,y1:stormTurret.y,x2:tx,y2:ty,until:now+200}); laserImpacts.push({x:tx,y:ty,t0:now,tEnd:now+320}); destroyBrick(idx,'laser'); } } stormTurret.shots--; stormTurret.lastShot=now; } } } }

    if(buffs.BLACKHOLE.active && now>buffs.BLACKHOLE.until){ const d=Math.min(8,buffs.BLACKHOLE.deaths||0); const dmg=1+(d/8)*(40-1); const rad=200+(d/8)*(800-200); const pr=paddleRect(); const cx=pr.x+pr.w/2, cy=pr.y-rad; const spinDir=(Math.random()>0.5?1:-1); blackHoles.push({x:cx,y:cy,r:rad,until:now+3000,start:now,spinDir}); for(let i=bricks.length-1;i>=0;i--){ const bk=bricks[i]; const bx=bk.x+bk.w/2, by=bk.y+bk.h/2; if(Math.hypot(bx-cx,by-cy)<=rad){ damageBrick(i,dmg,'none'); } } if(circleIntersectsActiveBoss(cx,cy,rad)){ const impact=activeBossCenter(); damageActiveBoss(1,'blackhole',impact?{x:impact.x,y:impact.y}:{x:cx,y:cy}); } playSFX('blackhole'); buffs.BLACKHOLE.active=false; }

    if(buffs.ANNIHIL.active && now>=buffs.ANNIHIL.next){ let cand=bricks.filter(b=>canDestroyBrick(b)&&!b.boss); if(!cand.length) cand=bricks.filter(b=>canDestroyBrick(b)); if(cand.length){ const target=cand[Math.floor(Math.random()*cand.length)]; const idx=bricks.indexOf(target); destroyBrick(idx,'annihil'); } else if(isSpecialBossActive()){ const center=activeBossCenter(); damageActiveBoss(1,'annihil',center?{x:center.x,y:center.y}:null); } buffs.ANNIHIL.next+=1000; }

    // å…¨å±€é€Ÿåº¦å€ç‡ï¼ˆGODSPEED æ™‚å¿½ç•¥å…¶å®ƒï¼‰
    function effectiveMul(){
      if(buffs.GODSPEED.active) return 1.0;
      let mul=1.0;
      if(buffs.SLOW.active){ mul*=(GAME_CONFIG.powers.SLOW.speedMul??1.0); }
      if(buffs.FAST.active){ mul*=(GAME_CONFIG.powers.FAST.globalSpeedMul??1.0); }
      if(buffs.WAVY.active){ const w=GAME_CONFIG.powers.WAVY.wavy||{amp:0.6,base:1.2,periodMs:200}; const phase=(now-(buffs.WAVY.start||now))/(w.periodMs); mul*=(w.base+w.amp*Math.sin(phase)); }
      if(buffs.HELL.active){ mul*=(GAME_CONFIG.powers.HELL.hell.speedMul); }
      if(buffs.MEGA.active){ mul*=(GAME_CONFIG.powers.MEGA.mega.speedMul); }
      if(buffs.ANNIHIL.active){
        const t=Math.min(1,(now-buffs.ANNIHIL.start)/10000);
        const maxMul=GAME_CONFIG.powers.ANNIHIL.annihil.speedMul||3;
        mul*=1+t*(maxMul-1);
      }

      // å¤©åœ°ç¿»è½‰ï¼šå•Ÿå‹•å‰ 2 ç§’èˆ‡çµæŸå‰ 2 ç§’æœŸé–“ç•¥å¾®æ¸›é€Ÿï¼ˆé™ä½ä¸é©æ„Ÿï¼‰
      const f = buffs.FLIP;
      if(f){
        // å‰å»¶é²
        if(f.pending && f.startAt && now >= f.startAt - 2000 && now < f.startAt){
          mul *= 0.8;
        }
        // çµæŸå‰
        if(f.active && f.endAt && now >= f.endAt - 2000 && now < f.endAt){
          mul *= 0.8;
        }
      }
      return mul;
    }

    const mulGlobal=effectiveMul();

    // Boss èƒ½åŠ›æ’ç¨‹
    updateBossAbilities();
    updateCyclopsEvent();
    for(const b of balls){
      if(b.rampageUntil && now>b.rampageUntil){ b.rampageUntil=0; if(!buffs.PIERCE.active) b.piercing=false; }

      // FREEZE ç‹€æ…‹
      if(b.freeze.state==='delay'){
        if(now - b.freeze.t0 >= b.freeze.delay){
          b.freeze.state = 'stopped';
          b.freeze.until = now + b.freeze.stop;
          b.vx = 0; b.vy = 0;
          spawnParticles(b.x,b.y,'rgba(230,247,255,0.9)',16,1.2,1.0,2.5);
        }
      }
      if(b.freeze.state==='stopped'){
        if(now < b.freeze.until){
          continue;
        }else{
          b.freeze.state = 'idle';
          let vx = b.freeze.oldVX, vy = b.freeze.oldVY;
          const tiny = Math.abs(vx)+Math.abs(vy) < 0.2;
          if(tiny){ vx = (Math.random()<0.5?-1:1) * 4; vy = -Math.max(4, speedForLevel(level)*0.8); }
          const sp = Math.max(4, Math.hypot(vx, vy));
          const ang = Math.atan2(vy, vx);
          b.vx = Math.cos(ang)*sp;
          b.vy = Math.sin(ang)*sp;
        }
      }

      if(handleDemonCloakState(b, now)){
        continue;
      }

      if(b.blinkAt && now>=b.blinkAt){
        spawnParticles(b.x,b.y,'rgba(180,200,255,0.8)',20,1.8,2.6,2.5);
        b.y=b.r+0.1; b.vy=Math.abs(b.vy)||Math.abs(speedForLevel(level));
        spawnParticles(b.x,b.y,'rgba(180,200,255,0.8)',20,1.8,2.6,2.5);
        b.blinkAt=0;
      }

      if(b.stuck){ if(!orientLeft){ b.x=paddle.x+paddle.w/2+b.offsetX; b.y=paddle.y-b.r-0.1; } else { const pr=paddleRect(); b.x=pr.x+pr.w+b.r+0.1; b.y=pr.y+pr.h/2; } continue; }
      // ç§»å‹•
      let speedMul = mulGlobal;
      b.x+=b.vx*speedMul; b.y+=b.vy*speedMul;

      // GODSPEEDï¼šé€Ÿåº¦é–å®šåˆ°ä¸Šé™
      if(buffs.GODSPEED.active){
        const sp=Math.hypot(b.vx,b.vy); const cap=b.speedCap;
        if(sp<cap*0.98){ const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*cap; b.vy=Math.sin(ang)*cap; }
      }

      // ç‰†å£
      const r=b.r;
      if(!orientLeft){
        if(b.x-r<0){ b.x=r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
        if(b.y-r<0){ b.y=r; b.vy*=-1; beep(700,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); fireCollide(); noteCeilingBounce(b, now); noteBounce(b,b.x,b.y,'y',now); }
        if(b.y-r>700){
          // åº•éƒ¨ï¼šGODSPEED ä¸è½åœ° / SHIELD æ“‹ä¸€æ¬¡
          if(buffs.GODSPEED.active){ b.y=700-r; b.vy=-Math.abs(b.vy); noteBounce(b,b.x,b.y,'y',now); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.y=700-r-1; b.vy=-Math.abs(b.vy); noteBounce(b,b.x,b.y,'y',now); }
          else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; }
        }
      }else{
        // å·¦å´æ¨¡å¼ï¼šä¸Šä¸‹ç‚ºç‰†ï¼Œå·¦å´ç‚ºè½é»ï¼›GODSPEED ç„¡è½åœ°
        if(b.y-r<0){ b.y=r; b.vy*=-1; fireCollide(); noteCeilingBounce(b, now); noteBounce(b,b.x,b.y,'y',now); }
        if(b.y+r>700){ b.y=700-r; b.vy*=-1; fireCollide(); noteBounce(b,b.x,b.y,'y',now); }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
        if(b.x-r<0){
          if(buffs.GODSPEED.active){ b.x=r; b.vx=Math.abs(b.vx); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.x=r+1; b.vx=Math.abs(b.vx); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
          else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; }
        }
      }

      // æ“‹æ¿ç¢°æ’
      const pr=paddleRect();
      // æ“‹æ¿æœ‰ç©ºæ´ï¼šæ‹†æˆå…©æ®µ
      let hitPaddle=false;
      if(!orientLeft){
        const gap = buffs.HOLE.active ? pr.w/3 : 0;
        const l1=pr.x, r1=pr.x+pr.w*(gap?1/3:1);
        const l2=pr.x+pr.w*(gap?2/3:1), r2=pr.x+pr.w;
        const inSeg1 = (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l1 && b.x<=r1);
        const inSeg2 = gap? (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l2 && b.x<=r2):false;
        hitPaddle = inSeg1 || inSeg2;
      }else{
        const gap = buffs.HOLE.active ? pr.h/3 : 0;
        const t1=pr.y, b1=pr.y+pr.h*(gap?1/3:1);
        const t2=pr.y+pr.h*(gap?2/3:1), b2=pr.y+pr.h;
        const inSeg1 = (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t1 && b.y<=b1);
        const inSeg2 = gap? (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t2 && b.y<=b2):false;
        hitPaddle = inSeg1 || inSeg2;
      }
      if(hitPaddle){ stats.catches++;
        const baseSpeed=Math.hypot(b.vx,b.vy);
        const speedMul = isSpeedSuppressed(b, now) ? 1 : paddleHitSpeedMul(level);
        const sp=Math.min(baseSpeed*speedMul, b.speedCap);
        if(!orientLeft){
          const hitPos=(b.x-(pr.x+pr.w/2))/(pr.w/2); const angle=hitPos*(Math.PI/3);
          b.vx=Math.sin(angle)*sp; b.vy=-Math.cos(angle)*sp; b.y=pr.y-b.r-0.1;
          noteBounce(b,b.x,b.y,'y',now);
        }else{
          const hitPos=(b.y-(pr.y+pr.h/2))/(pr.h/2); const angle=hitPos*(Math.PI/3);
          b.vx=Math.cos(angle)*sp; b.vy=Math.sin(angle)*sp; b.x=pr.x+pr.w+b.r+0.1;
          noteBounce(b,b.x,b.y,'x',now);
        }
        if(b.demonCloakState==='launched'){
          const restore=Math.min(b.demonCloakStoredSpeed||Math.hypot(b.vx,b.vy), b.speedCap);
          const ang=Math.atan2(b.vy,b.vx);
          b.vx=Math.cos(ang)*restore;
          b.vy=Math.sin(ang)*restore;
          b.demonCloakState=null;
          b.demonCloakStoredSpeed=0;
          b.demonCloakAnchor=null;
          b.demonCloakStayStart=0;
        }
        beep(880,0.03); spawnParticles(b.x,b.y,'#caddff',8,1.3,1.5,2.5); fireCollide();
        screenShake=Math.max(screenShake, orientLeft?4:3);
        if(buffs.STICKY.active){ b.stuck=true; b.offsetX= (!orientLeft) ? (b.x-(paddle.x+paddle.w/2)) : 0; }
        if(buffs.BLINK.active){ b.blinkAt=performance.now()+ (GAME_CONFIG.powers.BLINK.blink.delayMs||1000); }

        // MISSILEï¼šæ“‹æ¿å½ˆå‡ºæ™‚ç™¼å°„ä¸‰æš
        if(buffs.MISSILE.active){
          // å–æœ€è¿‘/ä¸­è·é›¢/æœ€é 
          const src={x:b.x,y:b.y};
          const candidates = bricks.map((bk,idx)=>({idx, type:'brick', d: (bk.x+bk.w/2-src.x)**2 + (bk.y+bk.h/2-src.y)**2 })).sort((a,b)=>a.d-b.d);
          const bossCenter = isSpecialBossActive() ? activeBossCenter() : null;
          if(bossCenter){
            const d = (bossCenter.x-src.x)**2 + (bossCenter.y-src.y)**2;
            candidates.push({idx:'boss', type:'boss', d});
            candidates.sort((a,b)=>a.d-b.d);
          }
          const pickIdxs = [0, Math.floor(candidates.length/2), candidates.length-1].filter(i=>i>=0 && i<candidates.length);
          for(const i of pickIdxs){
            const entry = candidates[i];
            if(!entry) continue;
            const ang=Math.random()*Math.PI*2;
            missiles.push({x:src.x,y:src.y,vx:Math.cos(ang)*2,vy:Math.sin(ang)*2,targetId:entry.idx,targetType:entry.type||'brick',lifeUntil:now+GAME_CONFIG.powers.MISSILE.missile.lifeMs,trail:[]});
            if(entry.type==='boss'){ highlightSpaceBossTarget(); }
            else {
              const ttt = bricks[entry.idx];
              if(ttt){ pushLockBox(ttt.x, ttt.y, ttt.w, ttt.h, 'target'); }
            }
          }
        }

        // è¿½è¹¤çƒï¼šæ“‹æ¿å½ˆå‡ºå¾Œç„æº–ç›®æ¨™ç£šï¼ˆç¨ç«‹å„ªå…ˆï¼‰
        if(buffs.TRACK.active){
          function neighborCount(t){
            let cnt=0; const L=layout(); for(const o of bricks){ if(o===t) continue; const dx=Math.abs((o.x+o.w/2)-(t.x+t.w/2)); const dy=Math.abs((o.y+o.h/2)-(t.y+t.h/2)); const thx=brickW+L.pad+2, thy=brickH+L.pad+2; if(dx<=thx && dy<=thy) cnt++; } return cnt;
          }
          let best=null;
          for(const t of bricks){ if(t.unbreakable) continue; const iso=neighborCount(t); const d=Math.hypot((t.x+t.w/2)-b.x,(t.y+t.h/2)-b.y); const score=iso*1000 + d; if(best==null || score<best.score) best={t,score,type:'brick'}; }
          const bossTarget = isSpecialBossActive() ? activeBossCenter() : null;
          if(!best && bossTarget){
            best={type:'boss', score:-Infinity};
          }
          const targetX = best? (best.type==='boss'? (bossTarget?bossTarget.x:1100/2) : best.t.x+best.t.w/2) : (1100/2);
          const targetY = best? (best.type==='boss'? (bossTarget?bossTarget.y:layout().top) : best.t.y+best.t.h/2) : (layout().top);
          const sp=Math.hypot(b.vx,b.vy); const ang=Math.atan2(targetY-b.y, targetX-b.x); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;

          if(best){
            if(best.type==='boss'){ highlightSpaceBossTarget(); }
            else { pushLockBox(best.t.x, best.t.y, best.t.w, best.t.h, 'target'); }
          }
        }
        if(buffs.SWORD.active){ swords.push({x:Math.random()*1100,y:650,vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*0.5,state:'wander'}); }
      }

      // ç¢°ç£š
      const inRampage = !!(b.rampageUntil && now<b.rampageUntil);
      let collidedWithBrick=false;
      let hit=-1; for(let i=0;i<bricks.length;i++){ const bk=bricks[i]; if(b.x+r>bk.x && b.x-r<bk.x+bk.w && b.y+r>bk.y && b.y-r<bk.y+bk.h){ hit=i; break; } }
      if(hit>=0){
        const bk=bricks[hit];
        collidedWithBrick=true;
        fireCollide();
        if((inRampage || b.piercing) && bk.unbreakable){
          if(b.loopBrick===bk){ b.loopHits++; } else { b.loopBrick=bk; b.loopHits=1; }
          if(b.loopHits>=20){
            const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
            const dx=b.x-cx, dy=b.y-cy;
            const len=Math.hypot(dx,dy)||1;
            const pushDist=Math.max(bk.w,bk.h)/2 + b.r + 4;
            b.x=cx + (dx/len)*pushDist;
            b.y=cy + (dy/len)*pushDist;
            const sp=Math.max(4, Math.hypot(b.vx,b.vy));
            const jitter=(Math.random()>0.5?1:-1)*(Math.PI/12);
            const ang=Math.atan2(b.vy,b.vx)+jitter;
            b.vx=Math.cos(ang)*sp || (Math.random()>0.5?4:-4);
            b.vy=Math.sin(ang)*sp || (Math.random()>0.5?4:-4);
            b.loopBrick=null;
            b.loopHits=0;
          }
        }else{ b.loopBrick=null; b.loopHits=0; }
        let suppressBrickAccel=false;
        let shouldSuppressSpeedBoost=false;
        if(bk.id!=null){
          const prevId=b.lastBrickId;
          const prevTime=b.lastBrickHitTime||0;
          if(prevId===bk.id && now-prevTime<=1000){
            b.sameBrickHits=(b.sameBrickHits||1)+1;
            if(b.sameBrickHits>=2){ suppressBrickAccel=true; shouldSuppressSpeedBoost=true; }
          }else{
            b.sameBrickHits=1;
          }
          b.lastBrickId=bk.id;
          b.lastBrickHitTime=now;
        }else{
          b.sameBrickHits=0;
          b.lastBrickId=null;
          b.lastBrickHitTime=0;
        }
        if(b.loopBrick===bk && b.loopHits>=3){ suppressBrickAccel=true; shouldSuppressSpeedBoost=true; }
        if(shouldSuppressSpeedBoost){ suppressSpeedBoost(b, now); }
        // åå½ˆ
        let bounceAxis=null;
        const oL=(b.x+r)-bk.x, oR=(bk.x+bk.w)-(b.x-r), oT=(b.y+r)-bk.y, oB=(bk.y+bk.h)-(b.y-r); const m=Math.min(oL,oR,oT,oB);
        if(!inRampage && !b.piercing){
          if(m===oL){ b.x=bk.x-r; b.vx=-Math.abs(b.vx); bounceAxis='x'; } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=Math.abs(b.vx); bounceAxis='x'; } else if(m===oT){ b.y=bk.y-r; b.vy=-Math.abs(b.vy); bounceAxis='y'; } else { b.y=bk.y+bk.h+r; b.vy=Math.abs(b.vy); bounceAxis='y'; }
        }else{
          if(m===oL){ b.x=bk.x-r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; } else if(m===oT){ b.y=bk.y-r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; } else { b.y=bk.y+bk.h+r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
          b.piercing=true;
        }
        if(bounceAxis){ noteBounce(b,b.x,b.y,bounceAxis,now); }

        // å¼·åå½ˆåŠ é€Ÿ
        if(bk.strong){ const skipAccel = suppressBrickAccel || isSpeedSuppressed(b, now); if(!skipAccel){ const sp=Math.min(Math.hypot(b.vx,b.vy)*1.08, b.speedCap); const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp; } screenShake=Math.max(screenShake,3); }

        // ç‰¹æ•ˆè§¸ç™¼
        if(buffs.PLASMA.active){ const cfg=GAME_CONFIG.powers.PLASMA.plasma; const ang=Math.random()*Math.PI*2; plasmas.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,vx:Math.cos(ang)*cfg.drift,vy:Math.sin(ang)*cfg.drift,until:now+cfg.lifeMs,radius:cfg.radius,phase:Math.random()*Math.PI*2}); playSFX('plasma'); }
        if(buffs.FREEZE.active && (b.freeze.state==='idle' || !b.freeze.state)){ const f=GAME_CONFIG.powers.FREEZE.freeze; b.freeze.state = 'delay'; b.freeze.t0 = now; b.freeze.delay = f.delayMs; b.freeze.stop = f.stopMs; b.freeze.oldVX = b.vx; b.freeze.oldVY = b.vy; }
        if(buffs.HOLY.active){ playSFX('holy'); holyFlashes.push({x:bk.x+bk.w/2, y:bk.y+bk.h/2, until:now+350}); for(let i=bricks.length-1;i>=0;i--){ const t=bricks[i]; const sameRow=Math.abs(t.y-bk.y)<1; const sameCol=Math.abs(t.x-bk.x)<1; if(sameRow||sameCol){ destroyBrick(i,'none'); } } if(isSpecialBossActive()){ const bounds=getActiveBossBounds(); const rowY=bk.y+bk.h/2; const colX=bk.x+bk.w/2; let bossHit=false; if(bounds && rowY>=bounds.y && rowY<=bounds.y+bounds.h){ const cx=bounds.x+bounds.w/2; damageActiveBoss(1,'holy',{x:cx,y:rowY}); bossHit=true; } if(bounds && !bossHit && colX>=bounds.x && colX<=bounds.x+bounds.w){ const cy=bounds.y+bounds.h/2; damageActiveBoss(1,'holy',{x:colX,y:cy}); } } screenShake=Math.max(screenShake,4); }
        if(buffs.CHAIN.active){ bk.lockedUntil = now + GAME_CONFIG.powers.CHAIN.chain.lockMs; }
        if(buffs.HELL.active){ const holeSpin=(Math.random()>0.5?1:-1); blackHoles.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,r:40,until:now+GAME_CONFIG.powers.HELL.hell.haloMs,start:performance.now(),spinDir:holeSpin}); playSFX('blackhole'); destroyNeighbors(hit); destroyBrick(hit,'none'); }
        if(buffs.POISON.active){ bk.poisonUntil = now + (GAME_CONFIG.powers.POISON.durationMs||12000); bk.poisonTick = now + (GAME_CONFIG.powers.POISON.poison?.tickMs||2000); }

        // ç•¶å‰ç£šæ‰£è¡€ï¼ˆè‹¥å·²åœ¨ä¸Šé¢è¢«è™•ç†å‰‡ç•¥éï¼‰
        if(!buffs.HELL.active && !buffs.HOLY.active){
          // ä¸å¯ç ´å£ï¼é–éˆç‹€æ…‹ä¸‹ä¸æ‰£è¡€
          if(bk.unbreakable || (bk.lockedUntil && now<bk.lockedUntil)){
            if(bk.boss){ updateHUD(); }
          }else{
            bk.hp=(bk.hp||1)-1; incrementCombo();
            if(bk.hp<=0){
              const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
              if(!bk.explosive){
                if(bk.boss){ bossKillEffect(bk); stats.bossKills++; addScore(scoreForBrick(bk)); }
                else { if(bk.elite) stats.eliteKills++; addScore(scoreForBrick(bk)); }
              } else {
                addScore(scoreForBrick(bk));
              }
              revealBrickArea(bk);
              if(inRampage || b.piercing) playSFX('pierce');
              if(!bk.boss) maybeDropFromBrick(bk);
              if(bk.explosive){ explodeAt(cx,cy); }
              else { bricks.splice(hit,1); updateHUD(); }
            } else updateHUD();
          }
        }

        // è¿½è¹¤çƒï¼šæ’ç£šå¾Œç„æº–æ“‹æ¿ä¸­å¿ƒ
        if(buffs.TRACK.active){
          const pr=paddleRect(); const tx = pr.x + (orientLeft? (pr.w + 60) : pr.w/2); const ty = pr.y + pr.h/2;
          const sp=Math.hypot(b.vx,b.vy); const ang=Math.atan2(ty-b.y, tx-b.x); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        
          pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
}

        beep(520+Math.random()*200,0.03,0.05);
      }

      if(!collidedWithBrick && isSpecialBossActive()){
        if(isDragonActive() && dragonBoss){
          const result=resolveDragonBallCollision(b, r, inRampage);
          if(result){
            fireCollide();
            if(result.bounceAxis){ noteBounce(b,b.x,b.y,result.bounceAxis,now); }
            spawnParticles(result.impactX, result.impactY, '#b8d6ff', 20, 1.4, 2.4, 2.2);
            triggerBallBuffEffectsOnBossHit(b, result.impactX, result.impactY, now);
            damageActiveBoss(1,'ball',{x:result.impactX,y:result.impactY});
            if(buffs.TRACK.active){
              const pr=paddleRect();
              const tx = pr.x + (orientLeft? (pr.w + 60) : pr.w/2);
              const ty = pr.y + pr.h/2;
              const sp=Math.hypot(b.vx,b.vy);
              const ang=Math.atan2(ty-b.y, tx-b.x);
              b.vx=Math.cos(ang)*sp;
              b.vy=Math.sin(ang)*sp;
              pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
            }
            beep(520+Math.random()*200,0.03,0.05);
            collidedWithBrick=true;
          }
        }else if(isDemonActive() && demonBoss){
          const result=resolveDemonBallCollision(b, r);
          if(result){
            const zone=result.zone;
            let bounceAxis=null;
            if(!inRampage && !b.piercing){
              if(result.penetration===result.oL){ b.x=zone.x-r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
              else if(result.penetration===result.oR){ b.x=zone.x+zone.w+r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
              else if(result.penetration===result.oT){ b.y=zone.y-r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
              else { b.y=zone.y+zone.h+r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
            }else{
              if(result.penetration===result.oL){ b.x=zone.x-r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
              else if(result.penetration===result.oR){ b.x=zone.x+zone.w+r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
              else if(result.penetration===result.oT){ b.y=zone.y-r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
              else { b.y=zone.y+zone.h+r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
              b.piercing=true;
            }
            if(bounceAxis){ noteBounce(b,b.x,b.y,bounceAxis,now); }
            const impactX=Math.max(zone.x, Math.min(b.x, zone.x+zone.w));
            const impactY=Math.max(zone.y, Math.min(b.y, zone.y+zone.h));
            spawnParticles(impactX, impactY, '#dcb6ff', 20, 1.6, 2.6, 2.4);
            fireCollide();
            damageActiveBoss(1,'ball',{x:impactX,y:impactY});
            collidedWithBrick=true;
          }
        }else{
          const bounds=getActiveBossBounds();
          if(bounds){
            const rx=bounds.x, ry=bounds.y, rw=bounds.w, rh=bounds.h;
            if(b.x+r>rx && b.x-r<rx+rw && b.y+r>ry && b.y-r<ry+rh){
              const oL=(b.x+r)-rx, oR=(rx+rw)-(b.x-r), oT=(b.y+r)-ry, oB=(ry+rh)-(b.y-r);
              const m=Math.min(oL,oR,oT,oB);
              let bounceAxis=null;
              if(!inRampage && !b.piercing){
                if(m===oL){ b.x=rx-r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
                else if(m===oR){ b.x=rx+rw+r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
                else if(m===oT){ b.y=ry-r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
                else { b.y=ry+rh+r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
              }else{
                if(m===oL){ b.x=rx-r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
                else if(m===oR){ b.x=rx+rw+r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
                else if(m===oT){ b.y=ry-r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
                else { b.y=ry+rh+r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
                b.piercing=true;
              }
              if(bounceAxis){ noteBounce(b,b.x,b.y,bounceAxis,now); }
              const impactX = Math.max(rx, Math.min(b.x, rx+rw));
              const impactY = Math.max(ry, Math.min(b.y, ry+rh));
              spawnParticles(impactX, impactY, '#b8d6ff', 20, 1.4, 2.4, 2.2);
              fireCollide();
              damageActiveBoss(1,'ball',{x:impactX,y:impactY});
              collidedWithBrick=true;
            }
          }
        }
      }

      // å®‰å…¨ä¿åº•é€Ÿåº¦
      const sp2 = Math.hypot(b.vx,b.vy);
      if(sp2 < 0.2 && !b.stuck && b.freeze.state==='idle'){
        b.vx = (Math.random()<0.5?-1:1) * 4;
        b.vy = -Math.max(4, speedForLevel(level)*0.8);
      }
    }

    // é£›å½ˆæ›´æ–°
    for(let i=missiles.length-1;i>=0;i--){
      const m=missiles[i];
      if(now>m.lifeUntil){ missiles.splice(i,1); continue; }
      let tx,ty, rect=null;
      if(m.targetType==='boss'){
        if(!isSpecialBossActive()){ missiles.splice(i,1); continue; }
        const bounds=getActiveBossBounds();
        const center=activeBossCenter();
        if(!bounds || !center){ missiles.splice(i,1); continue; }
        rect=bounds;
        tx=center.x; ty=center.y;
      }else{
        const t=bricks[m.targetId];
        if(!t){ missiles.splice(i,1); continue; }
        tx=t.x+t.w/2; ty=t.y+t.h/2;
        rect={x:t.x,y:t.y,w:t.w,h:t.h};
      }
      const ang=Math.atan2(ty-m.y, tx-m.x);
      const sp=GAME_CONFIG.powers.MISSILE.missile.speed;
      // è½‰å‘
      const curAng=Math.atan2(m.vy, m.vx);
      let diff=ang-curAng; while(diff>Math.PI) diff-=2*Math.PI; while(diff<-Math.PI) diff+=2*Math.PI;
      const maxTurn=GAME_CONFIG.powers.MISSILE.missile.turn;
      const newAng = curAng + Math.max(-maxTurn, Math.min(maxTurn, diff));
      m.vx=Math.cos(newAng)*sp; m.vy=Math.sin(newAng)*sp;
      m.x+=m.vx; m.y+=m.vy;
      (m.trail||(m.trail=[])).push({x:m.x,y:m.y,t:now}); if(m.trail.length>20) m.trail.shift();
      // å‘½ä¸­åˆ¤å®š
      if(rect && m.x>rect.x && m.x<rect.x+rect.w && m.y>rect.y && m.y<rect.y+rect.h){
        if(m.targetType==='boss'){ damageActiveBoss(1,'missile',{x:m.x,y:m.y}); }
        else { destroyBrick(m.targetId,'missile'); }
        missiles.splice(i,1); spawnParticles(m.x,m.y,'#ffbb66',12,1.8,2.2,3);
      }
    }

    // çƒå…¨æ²’äº†
    if(balls.length===0){
      const nowL=performance.now();
      if(nowL<=spaceBossSuppressLifeLossUntil){
        // skip automatic life loss triggered by Space Boss abilities
      }else{
        if(stats.lifeStart){ const dur=(nowL-stats.lifeStart)/1000; if(dur<stats.fastestDeath) stats.fastestDeath=dur; if(dur>stats.longestLife) stats.longestLife=dur; }
        stats.livesUsed++;
      if(buffs.BLACKHOLE.active){ buffs.BLACKHOLE.deaths=Math.min(8,(buffs.BLACKHOLE.deaths||0)+1); }
      if(buffs.ANNIHIL.active){ buffs.ANNIHIL.active=false; }
      lives--; updateHUD();
      if(lives<=0){ running=false; paused=true; showGameOver(); return; }
      else { resetBalls(false); startCountdown(); return; }
      }
    }

    // æ‰è½é“å…·ç§»å‹•/æ’¿å–
    for(let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      // æ ¹æ“šæ–¹å‘æ›´æ–°ä½ç½®
      if(p.horizontal){
        p.x -= p.speed;
      } else {
        p.y += p.speed;
      }
      const pr = paddleRect();
      // å‘½ä¸­æª¢æŸ¥ï¼šæ ¹æ“šæ“‹æ¿æ–¹å‘æª¢æŸ¥ç¢°æ’
      const hit = (!orientLeft)
        ? (p.y + p.h >= pr.y && p.x + p.w >= pr.x && p.x <= pr.x + pr.w && p.y <= pr.y + pr.h)
        : (p.x + p.w >= pr.x && p.x <= pr.x + pr.w && p.y + p.h >= pr.y && p.y <= pr.y + pr.h);
      if(hit){
        applyPower(p.type);
        // æ’¿åˆ°å¢ç›Š/ç‰¹æ®Šå¢ç›Šæ™‚æ›´æ–°æœ€å¾Œæ‹¾å–æ™‚é–“ï¼Œä»¥ä¾¿è‡ªå‹•æ‰è½è¨ˆæ™‚
        const def = GAME_CONFIG.powers[p.type];
        if(def && def.type !== 'debuff'){
          lastBeneficialPickupAt = performance.now();
          nextAutoBeneficialDropAt = lastBeneficialPickupAt + 10000;
        }
        powerups.splice(i,1);
        continue;
      }
      // è¶…å‡ºç•«é¢å‰‡ç§»é™¤
      if(p.horizontal){
        if(p.x + p.w < 0){ powerups.splice(i,1); }
      } else {
        if(p.y > 710){ powerups.splice(i,1); }
      }
    }

    {
      const prNow = paddleRect();
      spaceBossPrevPaddleCenter = spaceBossLastPaddleCenter;
      spaceBossLastPaddleCenter = prNow.x + prNow.w/2;
    }

        // å¤©ç©ºå®šæ™‚æ‰è½
    if(performance.now() >= nextSkyDropAt){ spawnBeneficialAtTop(); scheduleNextSkyDrop(); }
    // è‹¥è·ä¸Šæ¬¡å–å¾—å¢ç›Šå·²é€¾ 10 ç§’ï¼Œå‰‡è‡ªå‹•å¾å¤©ç©ºæ‰è½ä¸€å€‹å¢ç›Š
    if(running && !paused && !resumePending && !gameOver){
      const nowAuto = performance.now();
      if(nowAuto >= nextAutoBeneficialDropAt){
        spawnBeneficialAtTop();
        lastBeneficialPickupAt = nowAuto;
        nextAutoBeneficialDropAt = lastBeneficialPickupAt + 10000;
      }
    }

    // æ¸…é—œï¼ˆé€²å…¥ç•«å»Šæˆ–é€šé—œï¼‰
    if(!hasBreakables()){
      unlockSpecials(level);
      const idx=((level-1)%10);
      const type = (level<=10 ? (imageChoice[idx]===0?'bg':'cg') : (imageChoice[idx]===0?'cg':'bg'));
      markImageUnlocked(type, idx);
      paused=true; running=false; onPauseStart();
      if(level>=GAME_CONFIG.totalLevels){
        finalScore.textContent=String(score);
          const el=document.getElementById('statsWin'); if(el) el.innerHTML = renderStatsHtml();
        ring.innerHTML='';
        for(let i=1;i<=GAME_CONFIG.totalLevels;i++){
          const im=getLevelImage(i);
          const th=document.createElement('img'); th.src=im.src; ring.appendChild(th);
        }
        win.classList.add('show');
        playSFX('win');
        resetCombo();
      }else{
        const key = getLevelImageKey(level);
        galleryImg.src=getLevelImage(level).src;
        galleryDialog.style.display='none';
        if(galleryHint) galleryHint.textContent='é»ä¸€ä¸‹é¡¯ç¤ºå°è© â–¶';
        gallery.style.display='flex'; requestAnimationFrame(()=>gallery.classList.add('show'));
        const proceed=()=>{ gallery.classList.remove('show'); setTimeout(()=>{ gallery.style.display='none'; gallery.removeEventListener('click',proceed); },200); galleryDialog.style.display='none'; level++; updateHUD(); initBricks(); resetBalls(); paused=true; running=false; applyBGMThemeForLevel(); showCenter(`é€²å…¥é—œå¡ ${level}`,'æŒ‰ Space æˆ–é»ç•«é¢é–‹å§‹'); };
        const showLine=()=>{ const dlg=getRandomDialog(key); unlockDialog(key, dlg.idx); galleryDialog.textContent=dlg.text; galleryDialog.style.display='block'; if(galleryHint) galleryHint.textContent='é»ä¸€ä¸‹é€²å…¥ä¸‹ä¸€é—œ â–¶'; gallery.removeEventListener('click',showLine); gallery.addEventListener('click',proceed,{once:true}); };
        gallery.addEventListener('click',showLine); return;
      }
    }
  }


  function loop(){ if(!paused && running) update(); draw(); requestAnimationFrame(loop); }
  
  // èœå–®æš«åœæ§åˆ¶ï¼šç•¶éŸ³æ•ˆæˆ–é¸é …èœå–®é–‹å•Ÿæ™‚åœä½éŠæˆ²ï¼Œé—œé–‰æ™‚æ¢å¾©ï¼ˆä¸å½±éŸ¿ Game Over / å€’æ•¸é‚è¼¯ï¼‰
  (function(){
    let menuPaused = false;
    window.__setMenuPause = function(flag){
      menuPaused = !!flag;
      if(menuPaused){
        // é–‹å•Ÿé¸å–®ï¼šç«‹å³æš«åœéŠæˆ²ä¸¦è¨˜éŒ„æš«åœé–‹å§‹æ™‚é–“
        paused = true;
        // è‹¥æ­£åœ¨å€’æ•¸ï¼Œåœæ­¢è¨ˆæ™‚ä»¥å…åœ¨é¸å–®é–‹å•ŸæœŸé–“è‡ªå‹•æ¢å¾©
        if(countdownTimer){ clearTimeout(countdownTimer); countdownTimer=null; }
        onPauseStart();
      } else {
        // é—œé–‰é¸å–®ï¼šåªè¦éŠæˆ²å°šåœ¨é€²è¡Œä¸”æœª Game Overï¼Œç«‹å³ä¿®æ­£è¨ˆæ™‚ä¸¦é‡æ–°å€’æ•¸
        if(running && !gameOver){
          // ç¢ºä¿å³ä¾¿å…ˆå‰å·²æœ‰å€’æ•¸æ’ç¨‹ä¹Ÿèƒ½æ­£ç¢ºæ¢å¾©
          resumePending = false;
          onResumeFromPause();
          // ç¹¼çºŒå…ˆå‰çš„å€’æ•¸è€Œéé‡ç½®
          startCountdown(false);
        }
      }
    };
    // ä¿è­·æ€§ï¼šè‹¥ UI åœ¨å°å°ºå¯¸ä¸‹é‡æ’å°è‡´ç‹€æ…‹ä¸åŒæ­¥ï¼Œå®šæ™‚æ ¡æ­£
    setInterval(()=>{
      const anyOpen = menusOpen();
      if(anyOpen !== menuPaused){ window.__setMenuPause(anyOpen); }
    }, 400);
  })();
function boot(){
    resetGame(); updateHUD(); loop();
    // è‡ªå‹•è®€å–éŸ³æ•ˆ/BGMåå¥½
    soundsOn = (localStorage.getItem('sfx_on')||'0')==='1'; soundBtn.textContent=`éŸ³æ•ˆï¼š${soundsOn?'é–‹':'é—œ'}`;
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.7'); bgmVol.value=String(v);
    bgmOn = (localStorage.getItem('bgm_on')||'0')==='1'; bgmBtn.textContent = bgmOn?'é–‹':'é—œ';
    // è‹¥æœ‰å­˜æª”çµ¦æç¤º
    const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4');
    if(raw){ setTimeout(()=>{ if(confirm('åµæ¸¬åˆ°å­˜æª”ï¼Œè¦è®€å–é€²åº¦å—ï¼Ÿ')) loadProgress(); }, 400); }
  }
  boot();
  // Ensure audio context unlock on first user gesture (mobile safe)
  try{ document.addEventListener('pointerdown', function(){ try{ ensureAudio(); }catch(e){} }, { once:true, passive:true}); }catch(_e){}
})();
</script>


<script>
(function(){
  const $ = sel => document.querySelector(sel);
  const skinSel = $('#skinSel');
  const skinTitle = $('#skinTitle');
  const skinDesc = $('#skinDesc');

  function populateSkinOptions(){
    if (!skinSel || !window.SKINS) return;
    while (skinSel.firstChild) skinSel.removeChild(skinSel.firstChild);
    const order = Object.keys(window.SKINS);
    for (const key of order){
      const def = window.SKINS[key];
      if (!def) continue;
      const opt = document.createElement('option');
      opt.value = key;
      opt.textContent = def.selectLabel || def.label || key;
      skinSel.appendChild(opt);
    }
  }

  window.updateSkinUI = function(skin){
    if (skinTitle) skinTitle.textContent = skin.label || skin.selectLabel || 'ç¶“å…¸é¢¨æ ¼';
    if (skinDesc) skinDesc.textContent = skin.desc || '';
  };

  function restoreAndApply(){
    let key = 'classic';
    try {
      const saved = localStorage.getItem('selected_skin');
      if (saved && window.SKINS && window.SKINS[saved]) key = saved;
    } catch(e){}
    if (skinSel) skinSel.value = key;
    if (typeof window.applySkin === 'function') window.applySkin(key);
  }

  function init(){
    if (!window.SKINS) { console.warn('[skin] SKINS not ready yet.'); return; }
    populateSkinOptions();
    restoreAndApply();
  }

  // ç›£è½é¸æ“‡
  if (skinSel) {
    skinSel.addEventListener('change', function(){
      const key = skinSel.value;
      if (typeof window.applySkin === 'function') window.applySkin(key);
    }, { passive: true });
  }

  // è‹¥ skin.js è¼ƒæ™šè¼‰å…¥ï¼Œé€™è£¡ç”¨ DOMContentLoaded å¾Œå† initï¼Œå¤šæ¬¡å‘¼å«ä¹Ÿå®‰å…¨
  document.addEventListener('DOMContentLoaded', init, { once:true });
  // å¦‚æœå·²é DOMContentLoadedï¼Œç›´æ¥ init
  if (document.readyState === 'interactive' || document.readyState === 'complete') { init(); }
})();
</script>


<script>
// === Prism / Rainbow FX å¼•æ“ ===
(function(){
  let rafId = 0, ctx = null, cvs = null;
  let t0 = 0, prevTs = 0;
  let stars=[], snows=[], clouds=[], embers=[], sparks=[], shards=[], slicers=[], flames=[], gears=[], balloons=[];
  let hexagram=null, scriptRing=null, pulse=null, sunOpt=null, flameOpt=null, ruins=[], webOpt=null, balloonOpt=null;
  let nukeAt=0, nukeEnd=0, diffusePhase=0;

  function resize(){
    if (!cvs) return;
    const parent = cvs.parentElement;
    const rect = parent.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    cvs.width  = Math.max(1, Math.floor(rect.width  * ratio));
    cvs.height = Math.max(1, Math.floor((parent.querySelector('#game')?.getBoundingClientRect().height || rect.width*0.56) * ratio));
    cvs.style.height = (cvs.height/ratio)+'px';
  }

  function drawRainbowWash(w, h, time){
    const g = ctx.createLinearGradient(0,0,w,0);
    const hueShift = (time*0.02)%360;
    for(let i=0;i<=6;i++){
      const hue = (hueShift + i*60)%360;
      g.addColorStop(i/6, `hsla(${hue},80%,60%,0.035)`);
    }
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
  }

  function initEffects(eff){
    const w=cvs.width, h=cvs.height;
    stars=[]; snows=[]; clouds=[]; embers=[]; sparks=[]; shards=[]; slicers=[]; flames=[]; balloons=[]; ruins=[]; gears=[];
    hexagram=scriptRing=pulse=null; sunOpt=null; flameOpt=null; balloonOpt=null; nukeAt=0; nukeEnd=0; diffusePhase=0; webOpt=null;
    if(!eff) return;
    if(eff.web) webOpt=eff.web;
    if(eff.stars){
      const count = Math.round( (eff.stars.countScale||1) * 140 );
      for(let i=0;i<count;i++) stars.push({x:Math.random()*w,y:Math.random()*h,r:(eff.stars.sizeMin||1)+Math.random()*((eff.stars.sizeMax||3)-(eff.stars.sizeMin||1)),ph:Math.random()*Math.PI*2});
    }
    if(eff.snow){
      const count = eff.snow.countScale||100;
      for(let i=0;i<count;i++) snows.push({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*0.3,vy:(eff.snow.speed||0.3)+Math.random()*((eff.snow.speedMax||0.8)-(eff.snow.speed||0.3)),ph:Math.random()*Math.PI*2});
    }
    if(eff.clouds){
      for(let i=0;i<eff.clouds.count;i++) clouds.push({x:Math.random()*w,y:Math.random()*h,sz:eff.clouds.sizePx||200,ph:Math.random()*Math.PI*2});
    }
    if(eff.balloons){
      balloonOpt = Object.assign({intervalMs:10000, lifeMs:40000, colors:['#ff8aa0','#ffd966','#9ad0f5','#cfa0ff','#ffe599'], last:0}, eff.balloons);
    }
    if(eff.embers){
      const N = eff.embers.count||200;
      for(let i=0;i<N;i++) embers.push({x:Math.random()*w,y:Math.random()*h,ph:Math.random()*Math.PI*2});
    }
    if(eff.shards){
      for(let i=0;i<eff.shards.count;i++) shards.push({x:Math.random()*w,y:Math.random()*h,ang:(eff.shards.angleDeg||-28)*Math.PI/180});
    }
    if(eff.sparks){
      for(let i=0;i<eff.sparks.count;i++) sparks.push({x:Math.random()*w,y:Math.random()*h});
    }
    if(eff.flames){
      flameOpt=eff.flames;
      const N=flameOpt.count||40;
      for(let i=0;i<N;i++){
        flames.push({
          x:Math.random()*w,
          y:h*(flameOpt.baseY||0.8)+Math.random()*h*0.2,
          size:(flameOpt.sizeMin||2)+Math.random()*((flameOpt.sizeMax||6)-(flameOpt.sizeMin||2)),
          alpha:0.5+Math.random()*0.5,
          speed:(flameOpt.speedMin||0.3)+Math.random()*((flameOpt.speedMax||0.8)-(flameOpt.speedMin||0.3)),
          ph:Math.random()*Math.PI*2
        });
      }
    }
    if(eff.gears){
      const period=eff.gears.rotationMs||30000;
      if(eff.gears.layout){
        const minDim=Math.min(w,h);
        gears=eff.gears.layout.map((g,i)=>{
          const r=g.r*minDim;
          const x=g.x*w;
          const y=g.y*h;
          const inner=g.inner||0.6;
          const dir=g.dir!=null?g.dir:(i%2? -1:1);
          const teeth=g.teeth||12;
          return {x,y,r,teeth,inner,rot:0,omega:dir*2*Math.PI/period};
        });
      }else{
        for(let i=0;i<eff.gears.count;i++){
          const r=(eff.gears.sizeMin||40)+Math.random()*((eff.gears.sizeMax||120)-(eff.gears.sizeMin||40));
          const omega=(Math.random()<0.5?-1:1)*2*Math.PI/period;
          const x=Math.random()*w;
          const y=h*0.55 + Math.random()*h*0.45; // avoid upper brick area
          const inner=0.55+Math.random()*0.2;
          gears.push({x,y,r,teeth:8+Math.floor(Math.random()*5),inner,rot:Math.random()*Math.PI*2,omega});
        }
      }
    }
    if(eff.sun) sunOpt=eff.sun;
    if(eff.hexagram) hexagram=eff.hexagram;
    if(eff.scriptRing) scriptRing=eff.scriptRing;
    if(eff.pulse) pulse=eff.pulse;
    if(eff.ruins){
      for(let i=0;i<eff.ruins.layers;i++) ruins.push({off:Math.random()*w});
    }
    if(eff.nuke) nukeAt=performance.now()+ (eff.nuke.intervalMs||12000);
    if(eff.slicer){
      // start immediately
      slicers.push({t:0});
    }
  }

  function drawPrismBeams(w,h,time,opt){
    const beams=opt.beams||6;const speed=opt.speed||0.0005;const alpha=opt.alpha||0.1;const spread=opt.spread||0.85;const hueShift=opt.hueShift||40;
    const cx=w*0.5,cy=h*0.2;const r=Math.hypot(w,h);const base=time*speed*2*Math.PI;
    for(let i=0;i<beams;i++){
      const a=base+i*(2*Math.PI/beams);const hue=(hueShift+i*(360/beams))%360;const x2=cx+Math.cos(a)*r;const y2=cy+Math.sin(a)*r;
      const grad=ctx.createLinearGradient(cx,cy,x2,y2);
      grad.addColorStop(0,`hsla(${hue},95%,65%,0)`);grad.addColorStop(0.15,`hsla(${hue},95%,65%,${alpha})`);grad.addColorStop(spread,`hsla(${hue},95%,65%,0)`);
      ctx.strokeStyle=grad;ctx.lineWidth=Math.max(1,r*0.012);ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(x2,y2);ctx.stroke();
    }
  }

  function drawCobweb(w,h,time,opt){
    const period = opt.period || 30000;
    const phase = (time % period) / period;
    const rMax = Math.hypot(w,h)*0.6;
    const r = phase * rMax;
    const flash = Math.pow(Math.sin(time*0.0002), 8);
    const shimmer = 0.1 + 0.9*flash;
    const alpha = (opt.alpha || 0.05) * shimmer * (1 - phase);
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.strokeStyle = opt.color || '#e0e0e0';
    ctx.globalAlpha = alpha;
    ctx.lineWidth = opt.lineWidth || 1.2;
    const radials = opt.radials || 12;
    for(let i=0;i<radials;i++){
      const ang = i*(2*Math.PI/radials);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
      ctx.stroke();
    }
    const rings = opt.rings || 6;
    for(let j=1;j<=rings;j++){
      const rr = r*(j/rings);
      ctx.beginPath();
      ctx.arc(0,0,rr,0,Math.PI*2);
      ctx.stroke();
    }
    if(opt.dew){
      const count = opt.dew.count || 20;
      const radius = opt.dew.radius || 2;
      const dewColor = opt.dew.color || '#ffffff';
      const spin = opt.dew.spin || 0.0004;
      for(let i=0;i<count;i++){
        const ang = i*(2*Math.PI/count) + time*spin;
        const rr = r*((i%rings)+1)/(rings+1);
        ctx.save();
        const a = (0.4+0.6*Math.sin(time*0.002+i))*(opt.dew.alpha||0.8)*(1-phase);
        ctx.globalAlpha = a;
        ctx.fillStyle = dewColor;
        ctx.beginPath();
        ctx.arc(Math.cos(ang)*rr, Math.sin(ang)*rr, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    ctx.restore();
  }

  function drawSun(w,h,time,opt){
    const rot=(time%(opt.rotationPeriodMs||30000))/(opt.rotationPeriodMs||30000)*2*Math.PI;
    const scalePeriod=opt.scalePeriodMs||120000;
    const frac=(time%scalePeriod)/scalePeriod;
    const prog=frac<0.5?frac*2:(1-frac)*2;
    const r=Math.min(w,h)*((opt.sizeMin||0.05)+prog*((opt.sizeMax||0.3)-(opt.sizeMin||0.05)));
    const cx=w/2,cy=h*(opt.centerY||0.55);
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(rot);

    if(opt.scatter){
      const count = opt.scatter.count || 16;
      const far = Math.hypot(w,h);
      const near = r;
      const wNear = near * (opt.scatter.widthNear || 0.02);
      const wFar = far * (opt.scatter.widthFar || 0.1);
      const alpha = opt.scatter.alpha || 0.05;
      ctx.globalAlpha = alpha;
      for(let i=0;i<count;i++){
        const ang = i * (2*Math.PI/count);
        const angNear = wNear/near;
        const angFar = wFar/far;
        ctx.beginPath();
        ctx.moveTo(Math.cos(ang-angNear/2)*near, Math.sin(ang-angNear/2)*near);
        ctx.lineTo(Math.cos(ang-angFar/2)*far, Math.sin(ang-angFar/2)*far);
        ctx.lineTo(Math.cos(ang+angFar/2)*far, Math.sin(ang+angFar/2)*far);
        ctx.lineTo(Math.cos(ang+angNear/2)*near, Math.sin(ang+angNear/2)*near);
        ctx.closePath();
        const grad = ctx.createLinearGradient(
          Math.cos(ang)*near, Math.sin(ang)*near,
          Math.cos(ang)*far, Math.sin(ang)*far
        );
        grad.addColorStop(0,'rgba(255,240,200,0)');
        grad.addColorStop(0.2,'rgba(255,240,200,1)');
        grad.addColorStop(1,'rgba(255,240,200,0)');
        ctx.fillStyle = grad;
        ctx.fill();
      }
    }

    ctx.globalAlpha=opt.alpha||0.4;

    const rayCount=opt.rayCount||20;
    const inner=r*0.6;
    const outerLong=r;
    const outerShort=r*0.8;
    ctx.fillStyle='rgba(255,200,80,0.35)';
    ctx.beginPath();
    for(let i=0;i<rayCount*2;i++){
      const ang=i*Math.PI/rayCount;
      let rad;
      if(i%2===0){
        rad = i%4===0?outerLong:outerShort;
      }else{
        rad = inner;
      }
      const x=Math.cos(ang)*rad;
      const y=Math.sin(ang)*rad;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();

    const g=ctx.createRadialGradient(0,0,0,0,0,inner);
    g.addColorStop(0,'rgba(255,255,220,0.9)');
    g.addColorStop(0.7,'rgba(255,180,40,0.4)');
    g.addColorStop(1,'rgba(255,140,0,0)');
    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.arc(0,0,inner,0,Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function loop(ts){
    if(!ctx||!cvs)return;
    if(!t0){ t0=ts; prevTs=ts; }
    const t=ts-t0;
    const dt=ts-prevTs; prevTs=ts;
    const w=cvs.width,h=cvs.height; ctx.clearRect(0,0,w,h);
    const eff=window.currentSkin&&window.currentSkin.canvas&&window.currentSkin.canvas.effects;
    drawRainbowWash(w,h,t);
    if(eff){
      ctx.globalCompositeOperation='screen';
      if(webOpt) drawCobweb(w,h,t,webOpt);
      if(eff.prism) drawPrismBeams(w,h,t,eff.prism);
      if(stars.length){for(const s of stars){const tw=eff.stars&&eff.stars.twinkle?0.5+0.5*Math.sin(t*0.002+s.ph):1;ctx.fillStyle=`rgba(255,255,255,${0.6*tw})`;ctx.beginPath();ctx.arc(s.x,s.y,s.r,0,Math.PI*2);ctx.fill();}}
      if(snows.length){for(const f of snows){f.y+=f.vy;f.x+=f.vx;f.x+=Math.sin(f.ph+t*0.001)*(eff.snow.sway||0.5);if(f.y>h)f.y=-10;if(f.x>w)f.x=0;if(f.x<0)f.x=w;ctx.fillStyle='rgba(255,255,255,0.8)';ctx.beginPath();ctx.arc(f.x,f.y,2,0,Math.PI*2);ctx.fill();}}
      if(clouds.length){
        ctx.globalAlpha = eff.clouds.alpha || 0.25;
        for(const c of clouds){
          c.x += Math.sin(t*0.00005 + c.ph) * (eff.clouds.speed || 0.002) * 50;
          if(c.x > w + c.sz) c.x = -c.sz;
          const grad = ctx.createRadialGradient(c.x, c.y, c.sz*0.2, c.x, c.y, c.sz);
          grad.addColorStop(0,'#ffffff');
          grad.addColorStop(1,'#ffe6f5');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(c.x - c.sz*0.4, c.y, c.sz*0.6, 0, Math.PI*2);
          ctx.arc(c.x, c.y - c.sz*0.2, c.sz*0.7, 0, Math.PI*2);
          ctx.arc(c.x + c.sz*0.4, c.y, c.sz*0.6, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
        if(balloonOpt){
          const interval = balloonOpt.intervalMs || 10000;
          if(t - balloonOpt.last >= interval){
            balloonOpt.last = t;
            const cols = balloonOpt.colors || ['#ff8aa0','#ffd966','#9ad0f5','#cfa0ff','#ffe599'];
            const col = cols[Math.floor(Math.random()*cols.length)];
            balloons.push({x:Math.random()*w,y:h+30,color:col});
          }
          for(let i=balloons.length-1;i>=0;i--){
            const b=balloons[i];
            const life=balloonOpt.lifeMs||40000;
            b.y -= h*dt/life;
            ctx.fillStyle=b.color;
            ctx.beginPath();
            ctx.ellipse(b.x,b.y,20,26,0,0,Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(b.x,b.y+26);
            ctx.lineTo(b.x,b.y+40);
            ctx.strokeStyle='rgba(0,0,0,0.15)';
            ctx.lineWidth=2;
            ctx.stroke();
            if(b.y<-30) balloons.splice(i,1);
          }
        }
      if(embers.length){const cx=w*(eff.embers.center?eff.embers.center[0]:0.5), cy=h*(eff.embers.center?eff.embers.center[1]:0.5);for(const p of embers){p.ph+=eff.embers.omega||0.002;const r=Math.hypot(p.x-cx,p.y-cy);const ang=Math.atan2(p.y-cy,p.x-cx)+ (eff.embers.omega||0.002);p.x=cx+Math.cos(ang)*r; p.y=cy+Math.sin(ang)*r; ctx.fillStyle='rgba(255,120,40,0.8)';ctx.beginPath();ctx.arc(p.x,p.y,2,0,Math.PI*2);ctx.fill();}}
      if(gears.length){
        for(const g of gears){
          g.rot+=g.omega*dt;
          ctx.save();
          ctx.translate(g.x,g.y);
          ctx.rotate(g.rot);
          ctx.globalAlpha=0.6;
          const step=2*Math.PI/g.teeth;
          // è®“é½’æ§½å¯¬åº¦èˆ‡è¼ªé½’å¯¬åº¦ä¸€è‡´ï¼Œå› æ­¤æ¯é½’ä½”ä¸€åŠè§’åº¦
          const tooth=step*0.5;
          const root=g.r*0.75;
          ctx.beginPath();
          ctx.moveTo(root,0);
          for(let i=0;i<g.teeth;i++){
            const a=i*step;
            ctx.lineTo(root*Math.cos(a), root*Math.sin(a));
            ctx.lineTo(g.r*Math.cos(a), g.r*Math.sin(a));
            ctx.lineTo(g.r*Math.cos(a+tooth), g.r*Math.sin(a+tooth));
            ctx.lineTo(root*Math.cos(a+tooth), root*Math.sin(a+tooth));
          }
          ctx.closePath();
          const grad=ctx.createRadialGradient(0,0,g.r*0.2,0,0,g.r);
          grad.addColorStop(0,'rgba(255,240,220,0.1)');
          grad.addColorStop(0.6,'rgba(200,170,120,0.05)');
          grad.addColorStop(1,'rgba(90,70,50,0.03)');
          ctx.fillStyle=grad;
          ctx.fill();
          ctx.lineWidth=g.r*0.04;
          ctx.strokeStyle='rgba(255,220,170,0.15)';
          ctx.stroke();
          ctx.globalCompositeOperation='destination-out';
          ctx.beginPath();
          ctx.arc(0,0,g.r*0.4,0,Math.PI*2);
          ctx.fill();
          ctx.globalCompositeOperation='source-over';
          ctx.beginPath();
          ctx.arc(0,0,g.r*0.4,0,Math.PI*2);
          ctx.lineWidth=g.r*0.025;
          ctx.strokeStyle='rgba(255,220,170,0.1)';
          ctx.stroke();
          ctx.restore();
        }
      }
      if(sparks.length){for(const sp of sparks){ctx.fillStyle='rgba(255,210,122,0.8)';ctx.fillRect(sp.x,sp.y,2,2);}}
      if(flames.length){for(const f of flames){f.y-=f.speed;f.x+=Math.sin(t*0.002+f.ph)*(flameOpt?.drift||0.3);f.alpha-=0.004;f.size*=0.98;if(f.alpha<=0||f.y<h*(flameOpt?.dieY||0.55)){f.x=Math.random()*w;f.y=h*(flameOpt?.baseY||0.8)+Math.random()*h*0.2;f.size=(flameOpt?.sizeMin||2)+Math.random()*((flameOpt?.sizeMax||6)-(flameOpt?.sizeMin||2));f.alpha=0.5+Math.random()*0.5;f.speed=(flameOpt?.speedMin||0.3)+Math.random()*((flameOpt?.speedMax||0.8)-(flameOpt?.speedMin||0.3));f.ph=Math.random()*Math.PI*2;}ctx.fillStyle=`rgba(255,220,150,${f.alpha})`;ctx.beginPath();ctx.arc(f.x,f.y,f.size,0,Math.PI*2);ctx.fill();}}
      if(sunOpt) drawSun(w,h,t,sunOpt);
      if(hexagram){const R=Math.min(w,h)*(hexagram.radiusMul||0.44);const rot=(t%(hexagram.rotationPeriodMs||24000))/(hexagram.rotationPeriodMs||24000)*2*Math.PI;ctx.save();ctx.translate(w/2,h*0.48);ctx.rotate(rot);ctx.strokeStyle=hexagram.color||'#FFD27A';ctx.lineWidth=(hexagram.strokePx||2);ctx.beginPath();for(let i=0;i<6;i++){const a=i*Math.PI/3;ctx.lineTo(Math.cos(a)*R,Math.sin(a)*R);}ctx.closePath();ctx.stroke();ctx.restore();}
      if(scriptRing){const R=Math.min(w,h)*(scriptRing.radiusMul||0.58);const rot=-(t%(scriptRing.rotationPeriodMs||24000))/(scriptRing.rotationPeriodMs||24000)*2*Math.PI;ctx.save();ctx.translate(w/2,h*0.48);ctx.rotate(rot);ctx.strokeStyle=scriptRing.strokeColor||'#FFD27A';ctx.lineWidth=(scriptRing.strokePx||1.6);ctx.globalAlpha=scriptRing.alpha||0.7;ctx.beginPath();ctx.arc(0,0,R,0,Math.PI*2);ctx.stroke();ctx.restore();}
      if(pulse){const cx=w/2,cy=h*0.48;const r=(t%(pulse.intervalMul?skin.canvas.period*(pulse.intervalMul):skin.canvas.period))/ (skin.canvas.period||2000);const rad=r*Math.min(w,h);ctx.strokeStyle=`rgba(${pulse.color.join(',')},0.3)`;ctx.lineWidth=pulse.thickness||4;ctx.beginPath();ctx.arc(cx,cy,rad,0,Math.PI*2);ctx.stroke();}
      if(ruins.length){ctx.fillStyle='rgba(0,0,0,'+(eff.ruins.haze||0.2)+')';for(const r0 of ruins){ctx.fillRect((r0.off+t*0.01)%w - w,h*0.6,w,h*0.4);}}
      if(eff.nuke){const now=performance.now(); if(now>nukeAt){nukeEnd=now+(eff.nuke.flashMs||200); nukeAt=now+(eff.nuke.intervalMs||12000);} if(now<nukeEnd){ctx.fillStyle='rgba(255,255,255,0.3)';ctx.fillRect(0,0,w,h);} }
      if(eff.diffuse){
        diffusePhase=(diffusePhase+0.001)%1;
        const rr=Math.max(w,h)*diffusePhase;
        const col=eff.diffuse.color||[255,69,0];
        const alpha=eff.diffuse.alpha||0.05;
        const g=ctx.createRadialGradient(w/2,h/2,rr*0.2,w/2,h/2,rr);
        g.addColorStop(0,`rgba(${col[0]},${col[1]},${col[2]},${alpha})`);
        g.addColorStop(1,`rgba(${col[0]},${col[1]},${col[2]},0)`);
        ctx.fillStyle=g;
        ctx.fillRect(0,0,w,h);
      }
      if(eff.slicer){const now=performance.now(); if(!slicers.length||now-slicers[slicers.length-1].t>(eff.slicer.intervalMs||3000)){slicers.push({t:now,x:Math.random()*w});}
        ctx.strokeStyle=eff.slicer.color||'rgba(190,0,30,0.35)';ctx.lineWidth=(eff.slicer.widthMul||0.3)*10; for(let i=slicers.length-1;i>=0;i--){const s=slicers[i]; const age=now-s.t; if(age>(eff.slicer.lifeMs||500)){slicers.splice(i,1);continue;} const y=age*0.5; ctx.beginPath(); ctx.moveTo(s.x,y); ctx.lineTo(s.x+w,y+h); ctx.stroke();}}
      ctx.globalCompositeOperation='source-over';
    }
    rafId=requestAnimationFrame(loop);
  }

  function start(skin){
    if(!cvs){cvs=document.getElementById('fx'); if(!cvs) return; ctx=cvs.getContext('2d',{alpha:true}); window.addEventListener('resize',resize);} resize(); cancelAnimationFrame(rafId); t0=0; initEffects(skin.canvas&&skin.canvas.effects); rafId=requestAnimationFrame(loop);
  }
  function stop(){ cancelAnimationFrame(rafId); if(ctx&&cvs){ctx.clearRect(0,0,cvs.width,cvs.height);} }
  window.fxStart=start; window.fxStop=stop;
})();
</script>

</body>
</html>
