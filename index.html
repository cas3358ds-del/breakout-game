<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rock打磚塊 Breakout（最終增強版）</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' ry='12' fill='%230b1633'/%3E%3Cpath d='M16 44l16-24 16 24' stroke='%23eaf2ff' stroke-width='6' stroke-linecap='round' stroke-linejoin='round' fill='none'/%3E%3Ccircle cx='32' cy='40' r='6' fill='%23ffb347'/%3E%3C/svg%3E">
  <style>
    /* 全面換用全新 UI 風格（取自 index_skin.html） */
    :root{
      --ink:#eaf2ff; --muted:#b8c7ea;
      --glass-1:rgba(255,255,255,.08); --glass-2:rgba(255,255,255,.06);
      --stroke:rgba(140,180,255,.28);
      --bg1:#13224a; --bg2:#081022;
      --hudGrad1:rgba(20,25,44,.62); --hudGrad2:rgba(12,20,42,.44);
      --stageGlass:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
      --panelPattern:none;
      --btnGlow:0 0 0 rgba(0,0,0,0);
      --hudBottom:96px;
      --heartGlow: rgba(0,0,0,0);
      /* 保留原本磚塊與道具顏色 */
      --brick1:#ff6b6b; --brick2:#ffd166; --brick3:#06d6a0; --brick4:#4cc9f0;
      --expl:#ff8c00; --power:#7aa2ff; --debuff:#ff6aa3;
      --glass-stroke:rgba(255,255,255,.12);
    }
    html,body{
      height:100%; margin:0; color:var(--ink);
      background: radial-gradient(140% 140% at 50% -12%, var(--bg1) 0%, #0e1a3a 50%, #0b1633 75%, var(--bg2) 100%);
      font-family: ui-sans-serif, -apple-system, system-ui, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:calc(8px + env(safe-area-inset-top)) 12px 24px}
    .small{font-size:12px;color:var(--muted)}

    /* HUD 與 UI */
    .hud{
      position:sticky;top:0;z-index:30;
      display:grid;gap:8px;align-items:center;
      grid-template-columns:1fr;max-width:min(1080px,96vw);margin:8px auto 0;
      border:1px solid var(--stroke);
      border-radius:18px;padding:10px;
      background:linear-gradient(180deg,var(--hudGrad1),var(--hudGrad2));
      backdrop-filter: blur(8px);
      box-shadow:0 6px 28px rgba(0,0,0,.28)
    }
    .stats{display:grid;grid-template-columns:auto auto auto 1fr;grid-auto-rows:minmax(36px,auto);gap:8px 10px;align-items:center}
    .stats .wide{grid-column:1 / -1}
    .pill{
      padding:8px 18px;border:1px solid var(--stroke);
      background:var(--glass-2);border-radius:999px;
      min-height:36px;display:flex;align-items:center;gap:10px;
      color:#d7e3ff;font-weight:650;font-size:15px
    }
    .pill b{color:#fff;font-variant-numeric:tabular-nums}
    .inline-controls{justify-self:end;display:flex;gap:8px;align-items:center;position:relative}
    .ic-btn{
      width:48px;height:36px;border-radius:12px;border:1px solid var(--stroke);
      background:radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.16), rgba(255,255,255,0) 58%), var(--glass-1);
      display:grid;place-items:center;cursor:pointer;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.05), 0 8px 20px rgba(0,0,0,.28), var(--btnGlow);
      color:#fff
    }
    .ic-btn:active{transform:translateY(1px)}
    .ic-btn .ico{font-size:18px;line-height:1}
    .menu{
      position:absolute;top:46px;right:0;min-width:280px;padding:10px;
      border:1px solid var(--stroke);border-radius:14px;
      background:rgba(12,18,36,.96);backdrop-filter:blur(10px);
      transform:scale(.96);opacity:0;pointer-events:none;transition:.16s ease;z-index:60
    }
    .menu.show{transform:scale(1);opacity:1;pointer-events:auto}
    .menu .item{display:flex;align-items:center;gap:10px;padding:10px;border:1px solid var(--stroke);border-radius:10px;background:var(--glass-2);margin-bottom:8px}
    .menu h4{margin:6px 0 8px;font-size:13px;color:#cfe0ff}
    .btn{
      padding:8px 12px;border-radius:10px;border:1px solid var(--stroke);cursor:pointer;
      background:var(--glass-2);color:#fff;box-shadow:var(--btnGlow)
    }
    .level-select{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .level-select select{
      min-width:120px;
      color:#d7e3ff;
    }
    .level-select select option{
      background:#0b1633;
      color:#d7e3ff;
    }
    .level-select select option.locked,
    .level-select select option:disabled{
      color:rgba(215,227,255,0.12) !important;
      background:rgba(11,22,51,0.14);
      font-weight:450;
      letter-spacing:0.2px;
      text-shadow:none;
    }
    .level-select select option.locked.boss-level{
      color:rgba(255,179,71,0.18) !important;
      background:rgba(255,155,74,0.04);
    }
    .level-select select option.boss-level{
      color:#ffb347;
      font-weight:800;
      background:rgba(255,155,74,.22);
    }
    .level-select select.boss-selected{
      color:#ffb347;
      font-weight:700;
    }
    select,input[type="range"]{background:var(--glass-2);color:#fff;border:1px solid var(--stroke);border-radius:8px;padding:6px 10px}
    @media (max-width: 520px){
      .hud{padding:8px 10px;border-radius:16px;max-width:calc(100vw - 20px)}
      .stats{gap:6px 8px;grid-auto-rows:minmax(30px,auto)}
      .pill{padding:6px 12px;min-height:30px;font-size:13px;gap:6px}
      .pill b{font-size:1em}
      .inline-controls{gap:6px}
      .ic-btn{width:40px;height:32px;border-radius:10px}
      .ic-btn .ico{font-size:16px}
    }
    /* Buffs & Prompts */
    #buffs{
      position:sticky;z-index:22;
      top:calc(var(--hudBottom) + 6px);
      display:flex;align-items:center;
      max-width:min(1080px,96vw);margin:6px auto 0;padding-left:6px;
      overflow:auto;scrollbar-width:none;
      --buff-scale:1;
      font-size:calc(12px * var(--buff-scale));
      gap:calc(8px * var(--buff-scale));
    }
    #buffs::-webkit-scrollbar{display:none}
    #buffs .badge{
      display:inline-flex;align-items:center;
      gap:calc(8px * var(--buff-scale));
      padding:calc(6px * var(--buff-scale)) calc(10px * var(--buff-scale));
      border:1px solid var(--stroke);border-radius:999px;
      background:var(--glass-1);font-size:1em;white-space:nowrap;color:#cfe0ff
    }
    #playArea{
      position:relative;
      max-width:min(1080px,96vw);
      margin:8px auto 0;
      padding-top:56px;
    }
    #promptsDock{
      position:absolute;left:0;right:0;top:0;z-index:20;
      display:flex;gap:8px;justify-content:center;padding:0 6px;
      overflow:hidden;
    }
    #promptsDock .prompt{
      flex:1 1 calc((100% - 16px)/3);
      max-width:calc((100% - 16px)/3);
      min-width:0;height:38px;
      padding:6px 8px;border:1px solid var(--stroke);border-radius:12px;
      background:linear-gradient(180deg,var(--glass-1),var(--glass-2));
      backdrop-filter:blur(6px);
      box-shadow:0 8px 20px rgba(0,0,0,.3);
      font-size:calc(12px * 0.8);line-height:1.45;color:#eaf2ff;white-space:normal;
      word-break:break-word;overflow-wrap:anywhere;
      display:flex;align-items:center;justify-content:center;text-align:center;
      opacity:1;transition:opacity .4s
    }
    #promptsDock .prompt.fade{opacity:0}
    @media (min-width:768px){
      #playArea{padding-top:0;display:flex;gap:12px;align-items:flex-start;}
      #promptsDock{
        position:absolute;top:0;left:-200px;right:auto;width:180px;
        flex-direction:column;justify-content:flex-start;
      }
      #promptsDock .prompt{
        width:100%;height:48px;flex:none;
      }
    }
    /* Stage */
    .stage{position:relative;margin:0 auto 0;max-width:100%;border-radius:18px;padding:12px;box-sizing:border-box;background:var(--stageGlass);background-image:var(--panelPattern);background-blend-mode:overlay;}
    canvas#game{background:linear-gradient(180deg,#0d132a,#0b1226 55%, #091223);border:1px solid rgba(80,110,170,.45);border-radius:16px;display:block;width:100%;height:auto;margin:0 auto;box-shadow:inset 0 0 160px rgba(255,255,255,.03), 0 28px 90px rgba(0,0,0,.46);touch-action:none;}
    .legend{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;font-size:12px;color:#cfe0ff;margin-top:6px}
    .legend .item{padding:4px 8px;border-radius:10px;background:rgba(255,255,255,.05);border:1px solid var(--stroke);display:flex;align-items:center;gap:4px}
    .legend .box{width:14px;height:14px;border-radius:3px;display:inline-block;vertical-align:middle}
    .sealed{opacity:0.4;filter:grayscale(100%)}
    .unlockHint{font-size:0.8em;color:#f88;margin-left:4px;}
    #combo{
      position:absolute;
      top:8px;
      right:12px;
      font-size:19px;
      font-family:'Playfair Display',serif;
      font-weight:700;
      text-transform:none;
      font-variant-caps:normal;
      pointer-events:none;
      opacity:0;
      transform-origin:top right;
      transition:opacity .4s,transform .2s;
      text-shadow:0 1px 0 rgba(0,0,0,.6),0 2px 0 rgba(0,0,0,.6),0 3px 0 rgba(0,0,0,.5),0 4px 3px rgba(0,0,0,.7);
    }
    #combo.show{opacity:1}
    #combo.tier1{color:#ffffff}
    #combo.tier2{color:#00ff7f}
    #combo.tier3{color:#00bfff}
    #combo.tier4{color:#8a2be2}
    #combo.tier5{color:#ff69b4}
    #combo.tier6{color:#ffd700}
    #combo.glow{animation:goldBlink 1s infinite}
    #combo.pop{animation:comboPop .5s}
    #combo.glow.pop{animation:goldBlink 1s infinite,comboPop .5s}
    #combo.star{animation:comboStarGlow 1s linear infinite}
    #combo.star.pop{animation:comboStarGlow 1s linear infinite,comboPop .5s}
    @keyframes comboStarGlow{
      0%{color:#ff4d6d;text-shadow:0 0 8px #ff4d6d,0 0 16px #ff4d6d}
      25%{color:#ffd166;text-shadow:0 0 8px #ffd166,0 0 16px #ffd166}
      50%{color:#06d6a0;text-shadow:0 0 8px #06d6a0,0 0 16px #06d6a0}
      75%{color:#4cc9f0;text-shadow:0 0 8px #4cc9f0,0 0 16px #4cc9f0}
      100%{color:#ff4d6d;text-shadow:0 0 8px #ff4d6d,0 0 16px #ff4d6d}
    }
    #comboNotice{
      position:absolute;left:0;right:0;top:0;z-index:30;
      overflow:hidden;pointer-events:none;
      font-family:'Playfair Display',serif;font-weight:700;font-size:24px;
      color:#fff;text-shadow:0 2px 4px rgba(0,0,0,.6);
      opacity:0;transition:opacity 3s;
      display:flex;align-items:center;justify-content:center;
    }
    #comboNotice.show{opacity:1}
    #comboNotice.fade{opacity:0}
    #comboNotice .marqueeText{white-space:nowrap;display:inline-block;animation:comboMarquee 5s linear;}
    @keyframes comboPop{0%{transform:scale(.3) rotate(-15deg);}60%{transform:scale(1.4) rotate(10deg);}80%{transform:scale(.9) rotate(-5deg);}100%{transform:scale(1) rotate(0);}}
    @keyframes goldBlink{0%{text-shadow:0 0 6px rgba(255,215,0,.7);}50%{text-shadow:0 0 18px rgba(255,215,0,1);}100%{text-shadow:0 0 6px rgba(255,215,0,.7);}}
    @keyframes comboMarquee{0%{transform:translateX(100%);}100%{transform:translateX(-100%);}}
    /* Hearts and Nine-cat history */
    .hearts{filter:drop-shadow(0 0 10px var(--heartGlow));display:inline-block;position:relative}
    .hearts.compact .life-icon{width:14px;height:14px}
    .fire-energy{margin-left:6px;display:none;color:#ffb347;font-weight:700;filter:drop-shadow(0 0 6px #ff8c00)}
    .cats{display:flex;margin-left:auto;gap:4px}
    .cats .cat-icon{width:14px;height:14px;display:inline-block}
    .life-blood-burst{
      position:absolute;
      width:36px;
      height:36px;
      pointer-events:none;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%) scale(0.4) rotate(var(--burst-rot,0deg));
      opacity:0;
      background:
        radial-gradient(circle at 50% 45%, rgba(255,230,230,0.85) 0%, rgba(255,110,130,0.65) 45%, rgba(160,20,40,0.0) 70%),
        radial-gradient(circle at 50% 70%, rgba(150,10,40,0.85) 0%, rgba(90,0,20,0.0) 70%);
      filter:drop-shadow(0 0 18px rgba(255,120,150,0.6));
      border-radius:50%;
      animation:lifeBloodBurst 560ms ease-out forwards;
    }
    .life-blood-burst::before,
    .life-blood-burst::after{
      content:"";
      position:absolute;
      inset:-4px;
      border-radius:50%;
      background:conic-gradient(from 0deg,
        rgba(255,200,210,0.0) 0deg,
        rgba(255,220,230,0.45) 40deg,
        rgba(255,150,180,0.75) 120deg,
        rgba(160,30,50,0.0) 220deg,
        rgba(255,220,230,0.3) 320deg,
        rgba(255,200,210,0.0) 360deg);
      transform:scale(0.65);
      opacity:0.85;
      animation:lifeBloodSpill 560ms ease-out forwards;
      mix-blend-mode:screen;
    }
    .life-blood-burst::after{
      inset:-10px;
      transform:scale(0.5) rotate(32deg);
      opacity:0.65;
    }
    @keyframes lifeBloodBurst{
      0%{opacity:0;transform:translate(-50%,-50%) scale(0.25) rotate(var(--burst-rot,0deg));}
      35%{opacity:1;transform:translate(-50%,-50%) scale(1.05) rotate(var(--burst-rot,0deg));}
      100%{opacity:0;transform:translate(-50%,-50%) scale(1.45) rotate(var(--burst-rot,0deg));}
    }
    @keyframes lifeBloodSpill{
      0%{opacity:0.9;transform:scale(0.45) rotate(0deg);} 
      40%{opacity:0.8;transform:scale(0.95) rotate(18deg);} 
      100%{opacity:0;transform:scale(1.35) rotate(32deg);} 
    }
    /* Gallery and overlay (retain original styles) */
    .overlay{position:fixed;inset:0;z-index:40;pointer-events:none}
    .gallery{position:absolute;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;z-index:4;pointer-events:auto}
    .gallery .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.75);opacity:0;transition:opacity .6s;}
    .gallery img{max-width:min(94vw,1040px);max-height:min(88vh,680px);border-radius:16px;box-shadow:0 30px 120px rgba(0,0,0,.6);opacity:0;transform:translateY(12px) scale(.98);transition:opacity .6s, transform .6s;}
    .gallery .hint{position:absolute;bottom:24px;color:#fff;font-size:16px;opacity:0;text-shadow:0 2px 10px rgba(0,0,0,.6);}
    .gallery.show .backdrop{opacity:1;}
    .gallery.show img{opacity:1;transform:translateY(0) scale(1);} 
    .gallery.show .hint{opacity:.9;}
    .gallery .dialog,
    .gallery-page .viewer .dialog{position:absolute;left:50%;transform:translateX(-50%);bottom:60px;background:rgba(0,0,0,.6);color:#fff;padding:12px 20px;border-radius:12px;font-size:18px;max-width:90%;text-align:center;display:none;z-index:2;}
    .gallery-page .viewer .options{position:absolute;left:50%;transform:translateX(-50%);bottom:20px;display:flex;gap:8px;z-index:2;}
    .gallery-page .viewer .options button.locked{filter:grayscale(1);opacity:0.5;cursor:default;}
    .codex-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:80;pointer-events:auto;}
    .codex-overlay.show{display:flex;}
    .codex-overlay .backdrop{position:absolute;inset:0;background:rgba(0,0,0,0.75);backdrop-filter:blur(8px);}
    .codex-panel{position:relative;z-index:2;width:min(640px,95vw);max-height:90vh;display:flex;flex-direction:column;gap:16px;padding:24px;border-radius:18px;background:linear-gradient(160deg,rgba(18,26,52,0.92),rgba(12,18,36,0.88));border:1px solid rgba(130,170,250,0.35);box-shadow:0 26px 80px rgba(0,0,0,0.55);}
    .codex-close{position:absolute;top:16px;right:16px;background:transparent;border:none;color:#f0f6ff;font-size:22px;cursor:pointer;line-height:1;}
    .codex-subtitle{margin:0;color:#9fb4ff;font-size:14px;letter-spacing:0.4px;}
    .codex-list{flex:1 1 auto;overflow:auto;display:flex;flex-direction:column;gap:12px;padding-right:12px;scrollbar-width:thin;scrollbar-color:rgba(142,176,255,0.75) rgba(16,24,46,0.45);}
    .codex-list::-webkit-scrollbar{width:12px;}
    .codex-list::-webkit-scrollbar-thumb{
      background:linear-gradient(180deg, rgba(124,168,255,0.85), rgba(96,140,232,0.92));
      border-radius:999px;
      border:2px solid rgba(8,16,34,0.55);
      box-shadow:0 2px 10px rgba(8,16,34,0.45);
    }
    .codex-list::-webkit-scrollbar-thumb:hover{
      background:linear-gradient(180deg, rgba(148,188,255,0.9), rgba(118,158,242,0.98));
      box-shadow:0 4px 12px rgba(8,16,34,0.55);
    }
    .codex-list::-webkit-scrollbar-track{
      background:linear-gradient(180deg, rgba(16,24,46,0.65), rgba(16,24,46,0.35));
      border-radius:999px;
      box-shadow:inset 0 0 6px rgba(4,10,24,0.55);
    }
    .codex-entry{display:grid;grid-template-columns:64px 1fr;gap:12px;padding:12px;border-radius:14px;border:1px solid rgba(130,170,250,0.25);background:rgba(15,22,44,0.6);box-shadow:inset 0 0 0 1px rgba(255,255,255,0.04);align-items:center;}
    .codex-entry.codex-empty{grid-template-columns:1fr;justify-items:center;color:#cfe0ff;font-size:14px;}
    .codex-entry .codex-icon{width:64px;height:64px;border-radius:12px;overflow:hidden;border:2px solid rgba(130,170,250,0.4);display:flex;align-items:center;justify-content:center;background:rgba(12,18,36,0.55);}
    .codex-entry .codex-icon img{width:100%;height:100%;object-fit:contain;display:block;}
    .codex-entry .codex-info{display:flex;flex-direction:column;gap:6px;}
    .codex-entry .codex-header{display:flex;align-items:baseline;gap:10px;flex-wrap:wrap;}
    .codex-entry .codex-number{font-size:13px;font-weight:650;color:#8ea0d8;letter-spacing:0.5px;text-transform:uppercase;}
    .codex-entry .codex-meta{display:flex;flex-wrap:wrap;gap:8px;font-size:12px;color:#9fb4ff;}
    .codex-entry .codex-meta span{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:999px;background:rgba(20,32,68,0.65);border:1px solid rgba(120,160,240,0.28);}
    .codex-entry .codex-title{margin:0;font-size:20px;font-weight:750;letter-spacing:0.8px;color:#f0f6ff;line-height:1.2;}
    .codex-entry .codex-id{font-size:12px;color:#8ea0d8;letter-spacing:0.4px;}
    .codex-entry .codex-desc{margin:0;font-size:13px;line-height:1.55;color:#d4defc;}
    .codex-pagination{display:flex;align-items:center;justify-content:center;gap:12px;font-size:14px;color:#dbe4ff;}
    .codex-overlay .btn{min-width:120px;justify-content:center;}
    .codex-entry.grade-S{border-color:rgba(255,224,138,0.65);box-shadow:0 0 24px rgba(255,224,138,0.18);}
    .codex-entry.grade-A{border-color:rgba(255,106,130,0.55);box-shadow:0 0 22px rgba(255,106,130,0.16);}
    .codex-entry.grade-B{border-color:rgba(105,173,255,0.55);box-shadow:0 0 20px rgba(105,173,255,0.16);}
    .codex-entry.grade-C{border-color:rgba(95,214,160,0.55);box-shadow:0 0 20px rgba(95,214,160,0.16);}
    .codex-entry.grade-S .codex-title{color:#ffe08a;}
    .codex-entry.grade-A .codex-title{color:#ff6a82;}
    .codex-entry.grade-B .codex-title{color:#69adff;}
    .codex-entry.grade-C .codex-title{color:#5fd6a0;}

    /* Gallery page overlay */
    .gallery-page{position:fixed;inset:0;display:none;z-index:70;align-items:center;justify-content:center;pointer-events:auto}
    .gallery-page .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.8)}
    .gallery-page .content{position:relative;z-index:2;width:min(96vw,1080px);max-height:92vh;display:flex;flex-direction:column;background:linear-gradient(180deg,rgba(10,14,30,.95),rgba(10,14,30,.88));border:1px solid var(--glass-stroke);border-radius:16px;padding:12px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .gallery-page .close{align-self:flex-end;cursor:pointer;font-size:24px;line-height:1}
    .gallery-page .thumbs{flex:1 1 auto;display:grid;grid-template-columns:repeat(5,1fr);gap:8px;overflow:auto;padding:4px}
    .gallery-page .thumb{position:relative;border:1px solid var(--stroke);border-radius:10px;overflow:hidden;cursor:pointer;aspect-ratio:1/1}
    .gallery-page .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .gallery-page .thumb.locked{cursor:default;filter:grayscale(1) brightness(.3)}
    .gallery-page .thumb.locked::after{content:'\1F512';position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:32px;background:rgba(0,0,0,.6)}
    .gallery-page .nav{display:flex;gap:12px;justify-content:center;padding-top:8px}
    .gallery-page .viewer{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.85);z-index:3}
    .gallery-page .viewer img{max-width:94vw;max-height:88vh;border-radius:16px;box-shadow:0 30px 120px rgba(0,0,0,.6)}

    /* === 武器商店 === */
    body.modal-open{overflow:hidden;}
    #storeOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:90;padding:24px;box-sizing:border-box;overflow:auto;-webkit-overflow-scrolling:touch;touch-action:pan-y;pointer-events:auto;}
    #storeOverlay.show{display:flex;}
    #storeOverlay .backdrop{position:absolute;inset:0;background:rgba(6,12,28,0.82);backdrop-filter:blur(12px);}
    #storeOverlay .store-panel{position:relative;z-index:2;display:grid;grid-template-columns:minmax(0,320px) minmax(0,1fr);grid-template-areas:"hero content";gap:24px;align-items:stretch;width:min(1000px,100%);max-height:calc(100vh - 48px);padding:24px;border:1px solid rgba(140,180,255,0.32);border-radius:22px;background:linear-gradient(140deg,rgba(16,24,48,0.92),rgba(12,18,34,0.88));box-shadow:0 30px 120px rgba(0,0,0,0.55);overflow:auto;-webkit-overflow-scrolling:touch;touch-action:pan-y;}
    #storeOverlay .store-left{grid-area:hero;position:relative;display:flex;flex-direction:column;justify-content:flex-end;border-radius:20px;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.45);}
    #storeOverlay .store-left img{width:100%;height:100%;object-fit:cover;display:block;}
    #storeOverlay .store-hero-label{position:absolute;left:16px;bottom:16px;padding:10px 16px;border-radius:999px;background:rgba(12,22,44,0.78);backdrop-filter:blur(8px);font-weight:650;letter-spacing:2px;text-transform:uppercase;font-size:12px;color:#dbe6ff;box-shadow:0 8px 26px rgba(0,0,0,0.32);}
    #storeOverlay .store-content{grid-area:content;display:grid;grid-template-rows:auto 1fr auto;gap:18px;min-height:0;}
    #storeOverlay .store-header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;}
    #storeOverlay .store-balance{margin-left:auto;padding:8px 14px;border-radius:12px;border:1px solid rgba(130,170,250,0.3);background:rgba(16,26,52,0.72);color:#dfe6ff;font-size:14px;font-weight:650;letter-spacing:0.4px;display:flex;align-items:center;gap:6px;}
    #storeOverlay .store-balance span{color:#fff;font-weight:720;font-variant-numeric:tabular-nums;}
    #storeOverlay .store-title{font-size:24px;font-weight:750;letter-spacing:1px;color:#f0f6ff;margin:0;}
    #storeOverlay .store-title small{display:block;font-size:13px;font-weight:500;color:var(--muted);letter-spacing:0.5px;margin-top:2px;}
    #storeOverlay .store-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));align-content:flex-start;gap:12px;overflow-y:auto;padding-right:4px;padding-bottom:4px;scrollbar-width:thin;scrollbar-color:rgba(120,160,240,0.45) transparent;}
    #storeOverlay .store-grid::-webkit-scrollbar{width:6px;}
    #storeOverlay .store-grid::-webkit-scrollbar-thumb{background:rgba(120,160,240,0.45);border-radius:999px;}
    #storeOverlay .shop-item{position:relative;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:12px 12px 10px;border-radius:14px;border:1px solid rgba(140,180,255,0.22);background:linear-gradient(160deg,rgba(24,34,66,0.85),rgba(20,30,62,0.7));box-shadow:inset 0 0 0 1px rgba(255,255,255,0.05);cursor:pointer;transition:transform .18s ease, box-shadow .18s ease, border-color .18s ease;min-height:0;gap:6px;text-align:center;}
    #storeOverlay .shop-item:hover{transform:translateY(-3px);box-shadow:0 18px 40px rgba(0,0,0,0.4);}
    #storeOverlay .shop-item.selected{border-color:rgba(215,226,255,0.82);box-shadow:0 22px 50px rgba(64,110,255,0.28);}
    #storeOverlay .shop-thumb{width:100%;aspect-ratio:1/1;border-radius:14px;overflow:hidden;position:relative;background:rgba(12,18,38,0.4);display:flex;align-items:center;justify-content:center;padding:6px;margin-top:2px;}
    #storeOverlay .shop-thumb img{width:100%;height:100%;object-fit:contain;display:block;}
    #storeOverlay .tier-badge{position:absolute;right:10px;bottom:10px;font-weight:700;font-size:18px;color:#f2f6ff;letter-spacing:1px;text-shadow:0 2px 6px rgba(0,0,0,0.45);}
    #storeOverlay .shop-name{margin:0;font-size:12px;font-weight:700;letter-spacing:0.6px;}
    #storeOverlay .shop-price{font-size:calc(13px * 0.9);color:#d0dcff;letter-spacing:0.35px;}
    #storeOverlay .store-detail{display:flex;flex-direction:column;gap:12px;padding:14px 16px;border-radius:16px;background:linear-gradient(150deg,rgba(15,22,46,0.84),rgba(12,20,38,0.78));border:1px solid rgba(130,170,250,0.28);box-shadow:inset 0 0 0 1px rgba(255,255,255,0.04);min-height:0;}
    #storeOverlay .store-headline{display:flex;align-items:center;justify-content:space-between;gap:12px;}
    #storeOverlay .store-detail h3{margin:0;font-size:20px;font-weight:760;letter-spacing:0.8px;color:#f4f8ff;}
    #storeOverlay .store-price-tag{font-size:15px;font-weight:680;color:#f4f8ff;letter-spacing:0.6px;white-space:nowrap;}
    #storeOverlay .store-meta{display:flex;flex-wrap:wrap;gap:8px;font-size:12px;color:#d0dcff;letter-spacing:0.35px;}
    #storeOverlay .store-meta span{display:inline-flex;align-items:center;gap:4px;padding:5px 9px;border-radius:999px;background:rgba(20,32,68,0.6);border:1px solid rgba(120,160,240,0.2);}
    #storeOverlay .store-desc{margin:0;font-size:13px;line-height:1.55;color:#c9d4f6;letter-spacing:0.28px;}
    #storeOverlay .store-feedback{min-height:0;font-size:12px;color:#9bb4ff;letter-spacing:0.28px;}
    #storeOverlay .store-feedback:empty{display:none;}
    #storeOverlay .store-actions{display:flex;flex-wrap:wrap;gap:10px;margin-top:auto;}
    #storeOverlay .store-actions .btn{min-width:140px;justify-content:center;font-weight:650;letter-spacing:0.6px;}
    #storeOverlay .store-actions .btn.primary{background:linear-gradient(135deg,#3d6bff,#6c9dff);border-color:rgba(120,170,255,0.8);box-shadow:0 12px 30px rgba(60,110,255,0.45);}
    #storeOverlay .store-actions .btn.primary:disabled{background:rgba(30,42,68,0.8);border-color:rgba(80,110,150,0.4);box-shadow:none;cursor:not-allowed;}
    #storeOverlay .store-actions .btn.secondary{background:rgba(18,28,52,0.8);}

    .grade-S{--grade-color:#ffe08a;}
    .grade-A{--grade-color:#ff6a82;}
    .grade-B{--grade-color:#69adff;}
    .grade-C{--grade-color:#5fd6a0;}
    #storeOverlay .shop-item{--grade-color:rgba(130,160,255,0.5);--grade-shadow:0 8px 24px rgba(0,0,0,0.38);}
    #storeOverlay .shop-thumb{border:2px solid var(--grade-color);box-shadow:var(--grade-shadow);}
    #storeOverlay .shop-item.grade-S{--grade-color:#ffe08a;--grade-shadow:0 0 20px rgba(255,224,138,0.55);}
    #storeOverlay .shop-item.grade-A{--grade-color:#ff6a82;--grade-shadow:0 0 18px rgba(255,106,130,0.45);}
    #storeOverlay .shop-item.grade-B{--grade-color:#69adff;--grade-shadow:0 0 16px rgba(105,173,255,0.4);}
    #storeOverlay .shop-item.grade-C{--grade-color:#5fd6a0;--grade-shadow:0 0 16px rgba(95,214,160,0.38);}
    .grade-S .shop-name,.grade-S .equip-name{color:#ffe08a;}
    .grade-A .shop-name,.grade-A .equip-name{color:#ff6a82;}
    .grade-B .shop-name,.grade-B .equip-name{color:#69adff;}
    .grade-C .shop-name,.grade-C .equip-name{color:#5fd6a0;}

    #slotModal{display:none;margin-bottom:6px;padding:14px 16px;border-radius:14px;border:1px solid rgba(130,170,250,0.38);background:linear-gradient(150deg,rgba(18,26,52,0.92),rgba(12,18,36,0.86));box-shadow:0 16px 40px rgba(0,0,0,0.42);width:100%;max-width:420px;align-self:center;}
    #slotModal.show{display:block;}
    #slotModal h4{margin:0 0 10px;font-size:18px;font-weight:700;color:#f0f6ff;letter-spacing:0.6px;text-align:center;}
    #slotModal .slot-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;}
    #slotModal .slot-choice{display:flex;flex-direction:column;gap:4px;padding:10px;border-radius:12px;border:1px solid rgba(120,160,240,0.32);background:rgba(20,30,58,0.88);cursor:pointer;transition:border-color .18s ease, transform .18s ease;min-height:0;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.04);}
    #slotModal .slot-choice:hover{border-color:rgba(204,220,255,0.85);transform:translateY(-1px);}
    #slotModal .slot-choice .slot-name{font-size:13px;font-weight:650;color:#dce6ff;}
    #slotModal .slot-choice .slot-note{font-size:11px;color:var(--muted);line-height:1.4;}
    #slotModal .slot-choice.empty .slot-name{color:#86a3d6;}
    #slotModal .slot-confirm{display:none;flex-direction:column;gap:10px;margin-top:12px;padding-top:10px;border-top:1px solid rgba(110,150,240,0.22);}
    #slotModal .slot-confirm.show{display:flex;}
    #slotModal .slot-confirm p{margin:0;font-size:13px;color:#dfe7ff;line-height:1.6;text-align:center;}
    #slotModal .slot-confirm .actions{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;}
    #slotModal .slot-confirm .btn{min-width:104px;}

    /* === 裝備列 === */
    .equipment-bar{max-width:min(720px,96vw);margin:12px auto 0;padding:10px 14px;border-radius:18px;border:1px solid rgba(120,160,240,0.32);background:linear-gradient(160deg,rgba(14,22,46,0.82),rgba(12,20,40,0.74));backdrop-filter:blur(10px);box-shadow:0 14px 46px rgba(0,0,0,0.38);display:flex;flex-direction:column;gap:8px;}
    .equipment-slots{display:flex;justify-content:center;gap:10px;}
    .equip-slot{position:relative;flex:0 0 clamp(82px,22vw,112px);display:flex;flex-direction:column;align-items:center;gap:4px;padding:6px 4px;border-radius:14px;--equip-border-color:rgba(130,160,255,0.5);--equip-slot-border:rgba(120,160,240,0.28);--equip-border-glow:0 0 0 rgba(0,0,0,0);border:1px solid var(--equip-slot-border);background:linear-gradient(160deg,rgba(18,26,50,0.9),rgba(16,24,46,0.74));box-shadow:inset 0 0 0 1px rgba(255,255,255,0.04);cursor:pointer;transition:border-color .18s ease, transform .18s ease;text-align:center;min-height:0;}
    .equip-slot:hover{border-color:rgba(205,224,255,0.7);transform:translateY(-1px);}
    .equip-slot.empty{border-style:dashed;border-color:rgba(110,150,210,0.3);background:rgba(14,22,40,0.6);box-shadow:none;}
    .equip-slot.empty:hover{border-color:rgba(180,210,255,0.45);}
    .equip-slot .equip-label{display:none;}
    .equip-slot .equip-name{font-size:12px;font-weight:650;letter-spacing:0.5px;color:#dce6ff;min-height:16px;}
    .equip-slot .equip-type{font-size:10.5px;color:#8fa5da;letter-spacing:0.4px;}
    .equip-slot .equip-button{position:relative;display:flex;align-items:center;justify-content:center;width:54px;height:54px;border-radius:16px;border:2px solid var(--equip-border-color);overflow:hidden;box-shadow:0 10px 24px rgba(0,0,0,0.45), var(--equip-border-glow);background:rgba(12,18,36,0.6);isolation:isolate;}
    .equip-slot .equip-button img{width:100%;height:100%;object-fit:contain;display:block;pointer-events:none;user-select:none;position:relative;z-index:2;}
    .equip-slot.empty .equip-button{border-style:dashed;border-color:rgba(110,150,210,0.4);background:rgba(14,22,40,0.52);color:#7f95c6;font-size:26px;font-weight:500;}
    .equip-slot.empty .equip-button::after{content:'+';}
    .equip-slot .equip-status{font-size:10px;color:#98acd9;letter-spacing:0.4px;min-height:14px;}
    .equip-slot .equip-effect{display:none;font-size:11px;line-height:1.4;color:#cfd8ff;margin-top:2px;padding:0 4px;}
    .equip-slot.show-effect .equip-effect{display:block;}
    .equip-slot .tier-badge{position:absolute;top:6px;right:10px;font-size:16px;font-weight:700;color:#f0f6ff;text-shadow:0 2px 6px rgba(0,0,0,0.5);z-index:4;}
    .equip-slot.grade-S{--equip-border-color:#ffe08a;--equip-slot-border:rgba(255,224,138,0.45);--equip-border-glow:0 12px 28px rgba(255,224,138,0.35);}
    .equip-slot.grade-A{--equip-border-color:#ff6a82;--equip-slot-border:rgba(255,106,130,0.38);--equip-border-glow:0 12px 28px rgba(255,106,130,0.32);}
    .equip-slot.grade-B{--equip-border-color:#69adff;--equip-slot-border:rgba(105,173,255,0.34);--equip-border-glow:0 12px 28px rgba(105,173,255,0.32);}
    .equip-slot.grade-C{--equip-border-color:#5fd6a0;--equip-slot-border:rgba(95,214,160,0.34);--equip-border-glow:0 12px 28px rgba(95,214,160,0.32);}
    .equip-slot.active{--equip-slot-border:rgba(255,214,150,0.55);--equip-border-color:rgba(255,222,170,0.95);--equip-border-glow:0 14px 36px rgba(255,214,150,0.45);box-shadow:inset 0 0 0 1px rgba(255,255,255,0.06),0 16px 46px rgba(255,184,100,0.32);}
    .equip-slot.active .equip-name,.equip-slot.active .equip-type{color:#ffe9c0;}
    .equip-slot.active .equip-status{color:#ffdeb0;}
    .equipment-bar.selecting{box-shadow:0 22px 80px rgba(80,120,255,0.28);}
    .equipment-status{display:flex;flex-wrap:wrap;gap:12px;font-size:12px;color:#c6d6ff;letter-spacing:0.4px;}
    .equipment-message{min-height:16px;}
    .equipment-message.tone-info{color:#c6d6ff;}
    .equipment-message.tone-success{color:#8fe4ff;}
    .equipment-message.tone-warning{color:#ff9fb3;}
    .shield-status{padding:6px 12px;border-radius:999px;background:rgba(40,120,255,0.18);border:1px solid rgba(80,140,255,0.45);color:#dbe6ff;font-size:12px;letter-spacing:0.6px;box-shadow:0 0 18px rgba(80,140,255,0.2);}
    .equipment-bar.shielding{border-color:rgba(120,190,255,0.6);box-shadow:0 24px 80px rgba(70,130,255,0.32);}
    @keyframes equipActivePulse{
      0%,100%{box-shadow:0 10px 24px rgba(0,0,0,0.45),0 0 16px rgba(255,212,150,0.28);}
      50%{box-shadow:0 10px 24px rgba(0,0,0,0.45),0 0 24px rgba(255,228,180,0.55);}
    }
    .equip-slot.active .equip-button{animation:equipActivePulse 1.4s ease-in-out infinite;border-color:rgba(255,222,170,0.95);}
    .equip-slot.active .equip-button img{filter:drop-shadow(0 0 8px rgba(255,224,170,0.65));}
    .equip-slot.cooldown{opacity:0.88;}
    .equip-slot .equip-cooldown-cover{
      position:absolute;
      inset:0;
      border-radius:inherit;
      --cooldown-progress:1;
      background:radial-gradient(circle at 50% 45%, rgba(18,28,52,0.75) 0%, rgba(8,16,32,0.88) 70%, rgba(6,12,24,0.94) 100%);
      backdrop-filter:blur(1.2px);
      opacity:0;
      transition:opacity .2s ease;
      pointer-events:none;
      z-index:1;
      overflow:hidden;
    }
    .equip-slot .equip-cooldown-cover::before{
      content:"";
      position:absolute;
      inset:-6%;
      border-radius:inherit;
      background:radial-gradient(circle at 50% 50%, rgba(64,104,188,0.62) 0%, rgba(48,82,150,0.6) 38%, rgba(22,34,62,0.78) 68%, rgba(12,20,40,0.9) 100%);
      box-shadow:inset 0 0 20px rgba(8,16,34,0.65);
      transform-origin:50% 50%;
      transform:scale(var(--cooldown-progress));
      transition:transform .14s linear;
    }
    .equip-slot .equip-cooldown-cover::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      border:1.2px solid rgba(120,170,255,0.42);
      box-shadow:0 0 14px rgba(90,150,255,0.35);
      opacity:calc(0.35 + 0.65 * var(--cooldown-progress));
      transition:opacity .14s linear;
      pointer-events:none;
    }
    .equip-slot .equip-active-overlay{
      position:absolute;
      inset:-6px;
      border-radius:inherit;
      background:radial-gradient(circle at 50% 50%, rgba(255,228,170,0.38) 0%, rgba(255,188,110,0.28) 45%, rgba(255,158,80,0) 100%);
      opacity:0;
      transform:scale(calc(0.88 + 0.12 * var(--active-progress,1)));
      transition:opacity .22s ease, transform .28s ease;
      pointer-events:none;
      filter:blur(calc(0.5px + 3px * var(--active-progress,1)));
      z-index:0;
    }
    .equip-slot .equip-active-overlay::after{
      content:"";
      position:absolute;
      inset:14%;
      border-radius:inherit;
      border:1.2px solid rgba(255,220,168,0.46);
      box-shadow:0 0 16px rgba(255,210,150,0.36);
      opacity:calc(0.3 + 0.7 * var(--active-progress,1));
      transition:opacity .22s ease;
    }
    .equip-slot.active .equip-active-overlay{opacity:1;}
    .equip-slot .equip-active-label{
      position:absolute;
      bottom:6px;
      right:8px;
      padding:2px 8px;
      border-radius:999px;
      background:linear-gradient(120deg,rgba(255,216,150,0.95),rgba(255,176,90,0.85));
      color:#321f0d;
      font-size:10.5px;
      font-weight:700;
      letter-spacing:0.6px;
      opacity:0;
      transform:translateY(4px);
      transition:opacity .2s ease, transform .2s ease;
      pointer-events:none;
      z-index:4;
      text-shadow:none;
    }
    .equip-slot.active .equip-active-label{opacity:1;transform:translateY(0);}
    .equip-slot .equip-active-ring{position:absolute;top:50%;left:50%;width:calc(100% - 4px);height:calc(100% - 4px);pointer-events:none;transform:translate(-50%,-50%) rotate(-90deg);transform-origin:50% 50%;opacity:0;transition:opacity .2s ease;z-index:3;}
    .equip-slot .equip-active-ring circle{fill:none;stroke:rgba(255,210,150,0.92);stroke-width:3.2;stroke-linecap:round;stroke-dasharray:1;stroke-dashoffset:1;filter:drop-shadow(0 0 10px rgba(255,200,140,0.6));transition:stroke-dashoffset .12s linear;}
    .equip-slot.active .equip-active-ring{opacity:1;}
    .equip-slot .equip-cooldown-label{position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#f5f8ff;text-shadow:0 0 10px rgba(0,0,0,0.7);letter-spacing:0.5px;opacity:0;transition:opacity .2s ease;pointer-events:none;z-index:2;}
    .equip-slot .equip-cooldown-ring{position:absolute;top:50%;left:50%;width:calc(100% - 8px);height:calc(100% - 8px);pointer-events:none;transform:translate(-50%,-50%) rotate(-90deg);transform-origin:50% 50%;opacity:0;transition:opacity .2s ease;z-index:3;}
    .equip-slot .equip-cooldown-ring circle{fill:none;stroke:rgba(130,180,255,0.9);stroke-width:3.2;stroke-linecap:round;stroke-dasharray:1;stroke-dashoffset:1;filter:drop-shadow(0 0 6px rgba(90,150,255,0.55));transition:stroke-dashoffset .1s linear;transform-origin:50% 50%;}
    .equip-slot.cooldown .equip-cooldown-cover,
    .equip-slot.cooldown .equip-cooldown-label,
    .equip-slot.cooldown .equip-cooldown-ring{opacity:1;}

    @media (max-width: 900px){
      #storeOverlay{padding:18px;}
      #storeOverlay .store-panel{grid-template-columns:1fr;grid-template-areas:"hero" "content";max-height:calc(100vh - 36px);width:100%;padding:20px;gap:20px;}
      #storeOverlay .store-left{min-height:220px;}
      #storeOverlay .store-content{grid-template-rows:auto 1fr auto;}
      #storeOverlay .store-grid{grid-template-columns:repeat(3,minmax(0,1fr));}
    }
    @media (max-width: 640px){
      #storeOverlay{padding:14px;align-items:flex-start;}
      #storeOverlay .store-panel{padding:18px;gap:18px;border-radius:20px;max-height:none;width:100%;min-height:calc(100vh - 28px);}
      #storeOverlay .store-left{min-height:200px;}
      #storeOverlay .store-hero-label{left:12px;bottom:12px;font-size:11px;padding:8px 14px;}
      #storeOverlay .store-title{font-size:22px;}
      #storeOverlay .store-grid{grid-template-columns:repeat(3,minmax(0,1fr));gap:10px;padding-right:2px;}
      #storeOverlay .shop-item{padding:10px 10px 9px;border-radius:12px;gap:6px;}
      #storeOverlay .store-detail{padding:12px 14px;gap:10px;}
      #storeOverlay .store-detail h3{font-size:18px;}
      #storeOverlay .store-price-tag{font-size:14px;}
      #storeOverlay .shop-thumb{border-radius:12px;padding:6px;}
      #storeOverlay .store-actions{width:100%;flex-direction:column;}
      #storeOverlay .store-actions .btn{width:100%;}
      .equipment-slots{justify-content:space-between;gap:8px;}
      .equip-slot{flex:0 0 calc((100% - 16px)/3);}
      .equipment-bar{padding:10px 12px;}
    }

    /* Leaderboard overlay */
    .rank-page{position:fixed;inset:0;display:none;z-index:75;align-items:center;justify-content:center;pointer-events:auto}
    .rank-page .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.8)}
    .rank-page .content{position:relative;z-index:2;width:min(96vw,960px);max-height:92vh;display:flex;flex-direction:column;background:linear-gradient(180deg,rgba(10,14,30,.95),rgba(10,14,30,.88));border:1px solid var(--glass-stroke);border-radius:16px;padding:12px;box-shadow:0 20px 90px rgba(0,0,0,.5);overflow:auto;min-width:0}
    .rank-page .close{align-self:flex-end;cursor:pointer;font-size:24px;line-height:1}
    .rank-page table{width:100%;border-collapse:collapse;font-size:14px;margin-top:4px}
    .rank-page th,.rank-page td{border:1px solid var(--stroke);padding:4px 6px;text-align:center}
    @media (max-width: 600px){
      .rank-page table{font-size:12px;}
      .rank-page th,.rank-page td{padding:2px 4px;}
    }
    @media (max-width: 420px){
      .rank-page table{font-size:10px;}
    }

    /* Win and Game Over overlays */
    .win{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:6;pointer-events:auto}
    .win.show{display:flex;}
    .gameover{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:8;pointer-events:auto}
    .gameover.show{display:flex;}
    .gameover .backdrop{position:absolute;inset:0;background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .gameover .center{position:relative;z-index:2;text-align:center;background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75));padding:18px 22px;border:1px solid var(--glass-stroke);border-radius:16px;box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .win .backdrop{position:absolute;inset:0;background:linear-gradient(180deg, rgba(4,8,20,.62), rgba(6,10,24,.82));}
    .thumb-ring{
      --ring-cols:5;
      --ring-rows:4;
      --ring-gap:clamp(0px,0.2vw,1.5px);
      --thumb-scale:0.62;
      position:absolute;
      inset:0;
      padding:calc(env(safe-area-inset-top) + clamp(8px,4vw,22px))
              calc(env(safe-area-inset-right) + clamp(8px,4vw,22px))
              calc(env(safe-area-inset-bottom) + clamp(8px,4vw,22px))
              calc(env(safe-area-inset-left) + clamp(8px,4vw,22px));
      box-sizing:border-box;
      pointer-events:none;
      display:grid;
      width:100%;
      height:100%;
      grid-template-columns:repeat(var(--ring-cols),minmax(0,1fr));
      grid-auto-rows:calc((100% - (var(--ring-rows) - 1) * var(--ring-gap)) / var(--ring-rows));
      gap:var(--ring-gap);
      opacity:.95;
      align-content:stretch;
      align-items:stretch;
      justify-items:stretch;
    }
    .thumb-ring img{
      width:calc(100% / var(--thumb-scale));
      height:calc(100% / var(--thumb-scale));
      max-width:none;
      max-height:none;
      object-fit:cover;
      object-position:center 32%;
      border-radius:12px;
      box-shadow:0 12px 36px rgba(0,0,0,.45);
      transform:scale(var(--thumb-scale));
      transform-origin:center;
      transition:transform .4s ease, box-shadow .4s ease;
      background:rgba(14,20,34,.35);
    }
    @media (max-width:640px){
      .thumb-ring{
        --ring-gap:clamp(0px,0.3vw,1.5px);
        --thumb-scale:0.66;
        padding:calc(env(safe-area-inset-top) + clamp(10px,6vw,30px))
                calc(env(safe-area-inset-right) + clamp(10px,6vw,30px))
                calc(env(safe-area-inset-bottom) + clamp(10px,6vw,30px))
                calc(env(safe-area-inset-left) + clamp(10px,6vw,30px));
        opacity:.94;
        left:50%;
        right:auto;
        transform:translateX(-50%);
        width:min(92vw,520px);
        justify-content:center;
        align-content:center;
        justify-items:center;
        align-items:center;
      }
      .thumb-ring::after{content:none;}
      .thumb-ring img{
        border-radius:clamp(8px,3vw,16px);
        box-shadow:0 14px 32px rgba(0,0,0,.45);
        background:rgba(14,20,34,.32);
      }
    }
    @media (max-width:640px){
      .win{flex-direction:column;justify-content:center;align-items:center;padding:clamp(18px,6vh,34px) 0;}
      .win .center{order:2;max-width:min(320px,82vw);padding:16px 18px;margin:0 auto;}
      .thumb-note{display:block;order:3;margin:16px auto 0;font-size:12px;color:#dbe7ff;opacity:0.85;text-align:center;max-width:min(440px,92vw);line-height:1.5;padding:0 18px;text-shadow:0 1px 2px rgba(0,0,0,.6);}
      #statsWin{font-size:12px;line-height:1.6;}
    }
    @media (max-width:480px){
      .win .center{max-width:min(304px,80vw);padding:14px 16px;}
      .win h2{font-size:26px;}
      #statsWin{font-size:11.5px;}
      .thumb-ring{--ring-gap:clamp(0px,0.25vw,1.2px);--thumb-scale:0.7;
        padding:calc(env(safe-area-inset-top) + clamp(12px,7vw,34px))
                calc(env(safe-area-inset-right) + clamp(12px,7vw,34px))
                calc(env(safe-area-inset-bottom) + clamp(12px,7vw,34px))
                calc(env(safe-area-inset-left) + clamp(12px,7vw,34px));
      }
      .thumb-ring img{border-radius:clamp(6px,3vw,14px);}
    }
    @media (max-width:380px){
      .win{padding:clamp(14px,7vh,28px) 0;}
    }
    .win .center{position:relative;z-index:2;text-align:center;background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75));padding:18px 20px;border:1px solid var(--glass-stroke);border-radius:16px;box-shadow:0 20px 90px rgba(0,0,0,.5);max-width:min(360px,84vw);margin:0 auto}
    .win h2{margin:4px 0 6px;font-size:28px;letter-spacing:2px}
    .win .small{opacity:.8;font-size:12px;margin-top:6px}
    .win .again{margin-top:10px}
    .thumb-note{display:none;}
    /* Note box */
    .center-note{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:auto;z-index:3}
    .note-box{background:linear-gradient(180deg, rgba(8,12,28,.9), rgba(8,12,28,.85));border:1px solid var(--glass-stroke);padding:16px 18px;border-radius:14px;text-align:center;max-width:min(90vw,860px);max-height:90vh;overflow:auto;box-shadow:0 12px 60px rgba(0,0,0,.5);font-size:14px;position:relative}
    .note-box h2{margin:0 0 8px 0;font-size:18px}
    .note-box p{margin:6px 0;line-height:1.6}
    @media (max-width:480px){
      .note-box{font-size:12px;}
      .note-box h2{font-size:16px;}
    }
    kbd{background:#0e1836;border:1px solid #2a356a;border-radius:6px;padding:2px 6px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:90%}
    .note-close{
      position:absolute;top:8px;right:8px;width:28px;height:28px;border-radius:999px;
      display:grid;place-items:center;cursor:pointer;user-select:none;
      border:1px solid var(--glass-stroke);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), rgba(255,255,255,.02));
      box-shadow: 0 6px 16px rgba(0,0,0,.25);
      color:#d7dcff;font-weight:800;line-height:1;
    }
    .note-close:hover{filter:brightness(1.1);}
    .note-close:active{transform:translateY(1px);}
    @media (max-width:390px){
      .pill{font-size:14px;padding:7px 14px}
      .ic-btn{width:44px;height:36px}
    }

  

/* === 修正下拉選單：避免全白看不到選項文字 === */
select { color: #fff; background: var(--glass-2); }
/* 強制下拉清單的選項可見（不同瀏覽器可能各自處理，但這能改善多數情況） */
select option { color: #0b1022; background: #eaf2ff; }
select optgroup { color: #0b1022; }
/* 菜單內的 select 維持深色外觀，但選單展開的選項仍是深字淺底 */
.menu select { color: #eaf2ff; background: rgba(20,28,52,.6); border:1px solid var(--stroke); }
.menu select option { color: #0b1022; background: #eaf2ff; }


/* === Canvas FX 層：在遊戲畫布下層繪製霓虹光束與彩虹暈 === */
.stage{position:relative}
.stage #fx{
  position:absolute; inset:12px; border-radius:16px; display:block; width:calc(100% - 24px); height:auto;
  pointer-events:none; filter: blur(0.2px);
}
.stage{--fxViz:0}

    /* === 科技．魅影幻彩（朦朧紫黑七彩霓虹） === */
    body[data-skin="科技．魅影幻彩"]{ 
      --ink:#f3e8ff;
      --muted:#d6c3ff;
      --stroke:rgba(200,160,255,.4);
      --bg1:#140022;
      --bg2:#05000c;
      --hudGrad1:rgba(30,10,60,.62);
      --hudGrad2:rgba(20,6,40,.44);
      --glass-1:rgba(255,255,255,.1);
      --glass-2:rgba(255,255,255,.07);
      --stageGlass:linear-gradient(180deg, rgba(80,40,120,.04), rgba(0,0,0,0));
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(160,80,255,.25);
    }
    body[data-skin="科技．魅影幻彩"] .stage{--fxViz:0}

    /* === 科技．賽博格綠（高質感賽博特效） === */
    body[data-skin="科技．賽博格綠"]{
      --ink:#eafff3;
      --muted:#aee4c8;
      --stroke:rgba(180,255,200,.4);
      --bg1:#02190f;
      --bg2:#00150a;
      --hudGrad1:rgba(0,40,20,.62);
      --hudGrad2:rgba(0,30,15,.44);
      --glass-1:rgba(255,255,255,.1);
      --glass-2:rgba(255,255,255,.07);
      --stageGlass:linear-gradient(180deg, rgba(0,50,30,.05), rgba(0,0,0,0));
      --panelPattern:none;
      --btnGlow:0 0 20px rgba(30,200,100,.25);
    }
    body[data-skin="科技．賽博格綠"] .stage{--fxViz:0}
    body[data-skin="科技．賽博格綠"] .hearts .life-icon,
    body[data-skin="科技．賽博格綠"] .hearts .life-icon svg{ width:22px; height:22px; }

    body[data-skin="科技．魅影幻彩"] .hearts .life-icon,
    body[data-skin="科技．魅影幻彩"] .hearts .life-icon svg{ width:24px; height:24px; }

    /* === 宇宙．星辰絮語 === */
    body[data-skin="宇宙．星辰絮語"]{ --ink:#eef0ff; --muted:#c9c9ff; --stroke:rgba(160,140,255,.34); --bg1:#0c0b24; --bg2:#09081a; --hudGrad1:rgba(30,24,70,.58); --hudGrad2:rgba(20,18,50,.44); --glass-1:rgba(200,180,255,.10); --glass-2:rgba(160,140,255,.08); --stageGlass:linear-gradient(180deg, rgba(160,140,255,.05), rgba(0,0,0,0)); --panelPattern:radial-gradient(120px 80px at 20% 10%, rgba(110,80,255,.08), transparent 60%), radial-gradient(160px 120px at 80% 20%, rgba(180,100,255,.08), transparent 60%); --btnGlow:0 0 22px rgba(150,120,255,.25); }

    /* === 冰雪．極光絲綢 === */
    body[data-skin="冰雪．極光絲綢"]{ --ink:#f6fbff; --muted:#d7e9ff; --stroke:rgba(190,220,255,.38); --bg1:#0b1626; --bg2:#060b14; --hudGrad1:rgba(18,28,60,.56); --hudGrad2:rgba(10,20,44,.42); --glass-1:rgba(220,245,255,.12); --glass-2:rgba(210,235,255,.09); --stageGlass:linear-gradient(180deg, rgba(230,245,255,.04), transparent); --panelPattern:conic-gradient(from 0deg at 60% 40%, rgba(180,220,255,.06), rgba(160,210,255,.05), rgba(180,230,255,.06)); --btnGlow:0 0 20px rgba(180,220,255,.26); }
    body[data-skin="冰雪．極光絲綢"] .hearts .life-icon{ width:24px; height:24px; }
    body[data-skin="冰雪．極光絲綢"] .hearts .life-icon svg{ width:24px; height:24px; }

    /* === 烈陽．炙金幻焰 === */
    body[data-skin="烈陽．炙金幻焰"]{
      --ink:#fff6e8;
      --muted:#ffd3a6;
      --stroke:rgba(255,180,120,.36);
      --bg1:#3a1000;
      --bg2:#1a0400;
      --hudGrad1:rgba(90,30,0,.58);
      --hudGrad2:rgba(60,20,0,.44);
      --glass-1:rgba(255,170,80,.12);
      --glass-2:rgba(255,130,40,.09);
      --stageGlass:linear-gradient(180deg, rgba(255,160,40,.05), transparent);
      --panelPattern:none;
      --btnGlow:0 0 22px rgba(255,160,80,.28);
    }

    /* === 機械．齒輪騎士 === */
    body[data-skin="機械．齒輪騎士"]{
      --ink:#fff4e6;
      --muted:#e6cfa6;
      --stroke:rgba(200,150,80,.4);
      --bg1:#3d2b1f;
      --bg2:#1b120b;
      --hudGrad1:rgba(80,60,40,.6);
      --hudGrad2:rgba(50,40,30,.44);
      --glass-1:rgba(255,200,120,.12);
      --glass-2:rgba(200,150,90,.08);
      --stageGlass:linear-gradient(180deg, rgba(120,80,40,.05), transparent);
      --panelPattern:radial-gradient(40px 40px at 20% 30%, rgba(120,80,40,.1), transparent 60%),
                      radial-gradient(50px 50px at 80% 60%, rgba(160,110,50,.1), transparent 60%);
      --btnGlow:0 0 18px rgba(255,190,90,.25);
    }
    /* === 和風．無限之城 === */
    body[data-skin="和風．無限之城"]{
      --ink:#ffe8d4;
      --muted:#d5b097;
      --stroke:rgba(214,102,86,.38);
      --bg1:#1a050c;
      --bg2:#070106;
      --hudGrad1:rgba(94,20,32,.62);
      --hudGrad2:rgba(52,8,20,.5);
      --glass-1:rgba(148,30,46,.24);
      --glass-2:rgba(70,12,26,.32);
      --stageGlass:linear-gradient(180deg, rgba(140,26,38,.08), rgba(0,0,0,0));
      --panelPattern:repeating-linear-gradient(90deg, rgba(116,24,36,.10) 0 18px, rgba(116,24,36,0) 18px 36px),
                      repeating-linear-gradient(0deg, rgba(74,14,24,.08) 0 16px, rgba(74,14,24,0) 16px 32px);
      --btnGlow:0 0 22px rgba(220,72,84,.32);
      --heartGlow:rgba(255,148,122,.35);
    }
    body[data-skin="和風．無限之城"] #game{
      /* 修正背景位置屬性拼寫錯誤，確保圖片正常顯示 */
      background:url("images/d1.JPG") center/cover no-repeat;
    }
    body[data-skin="和風．無限之城"] .hud,
    body[data-skin="和風．無限之城"] #buffs .badge,
    body[data-skin="和風．無限之城"] .pill,
    body[data-skin="和風．無限之城"] #promptsDock .prompt,
    body[data-skin="和風．無限之城"] .ic-btn,
    body[data-skin="和風．無限之城"] .btn,
    body[data-skin="和風．無限之城"] select,
    body[data-skin="和風．無限之城"] input[type="range"]{
      color:var(--ink);
      border-color:var(--stroke);
      background:linear-gradient(160deg, rgba(180,38,50,.26), rgba(58,10,18,.38));
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.04), 0 10px 26px rgba(0,0,0,.34), var(--btnGlow);
    }
    body[data-skin="和風．無限之城"] .menu{
      background:rgba(30,6,12,.94);
      border-color:var(--stroke);
    }
    body[data-skin="和風．無限之城"] .menu .item{
      background:linear-gradient(160deg, rgba(160,30,44,.28), rgba(50,8,18,.4));
      border-color:var(--stroke);
    }
    body[data-skin="和風．無限之城"] .level-select select option{
      background:#2c0610;
      color:var(--ink);
    }
    body[data-skin="和風．無限之城"] .level-select select option.locked,
    body[data-skin="和風．無限之城"] .level-select select option:disabled{
      color:rgba(255,236,221,0.12) !important;
      background:rgba(44,6,16,0.14);
      font-weight:450;
      letter-spacing:0.2px;
      text-shadow:none;
    }
    body[data-skin="和風．無限之城"] .level-select select option.locked.boss-level{
      color:rgba(255,191,120,0.18) !important;
      background:rgba(255,132,77,0.04);
    }
    body[data-skin="和風．無限之城"] .hearts .life-icon{
      width:26px;
      height:26px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      margin:0 2px;
      filter:drop-shadow(0 0 6px rgba(255,196,150,0.45));
    }
    body[data-skin="和風．無限之城"] .hearts .life-icon svg{
      width:26px;
      height:26px;
      display:block;
    }

/* HUD/按鍵的霓虹語彙（按鍵邊緣流光＋心形光暈） */

    /* 上傳排行榜進度提示 */
    #uploadOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #uploadOverlay .box {
      background: var(--bg1);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      width: 260px;
    }
    #uploadOverlay .progress {
      width: 100%;
      height: 10px;
      background: var(--glass-2);
      border-radius: 5px;
      overflow: hidden;
      margin-top: 12px;
    }
    #uploadOverlay .progress > div {
      height: 100%;
      width: 0%;
      background: var(--ink);
      transition: width 0.1s;
    }
    #uploadOverlay .percent {
      margin-top: 8px;
      font-size: 14px;
    }


/* === Mobile scaling & LED alignment tweaks (Game Director standard) === */
@media (max-width: 600px) {
  .codex-panel { padding: 18px; gap: 12px; }
  .codex-entry { grid-template-columns:56px 1fr; padding:10px; }
  .codex-entry .codex-icon { width:56px; height:56px; }
  .codex-entry .codex-header { gap:6px; }
  .codex-entry .codex-title { font-size:17px; }
  .codex-entry .codex-number { font-size:12px; }
  .codex-overlay .btn { min-width:100px; }
}
@media (max-width: 430px) {
  .wrap { padding: 8px; }
  .stage { max-width: 100vw; padding: 8px; }
  .stage #fx { inset: 8px; border-radius: 18px; }
  canvas#game { border-radius: 18px; }
  .legend { transform: scale(0.92); transform-origin: top center; }
  #buffs { --buff-scale: 0.9; }
}
</style>
</head>
<body>
  <!-- 新增 UI 包裝 -->
  <div class="wrap" id="app">
    <!-- 頂部 HUD -->
    <section class="hud" aria-label="遊戲 HUD">
      <div class="stats">
        <div class="pill">分數 <b id="score">0</b></div>
        <div class="pill">關卡 <b id="level">1</b>/<span id="totalLevels">20</span></div>
        <div class="pill">銀幣 <b id="silverCoins">0</b></div>
        <div class="inline-controls">
          <button class="ic-btn" id="sndBtn" aria-haspopup="true" aria-expanded="false" aria-controls="soundMenu" title="聲音"><span class="ico">🔊</span></button>
          <div class="menu" id="soundMenu">
            <div class="item"><span>🎵</span><label><input type="checkbox" id="bgmOn"> BGM 開關</label></div>
            <div class="item"><span>🎚</span><label style="width:100%">BGM 音量 <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.7" style="width:60%" aria-label="BGM 音量"></label></div>
            <div class="item"><span>🔈</span><label><input type="checkbox" id="sfxOn" checked> 音效開關</label></div>
            <!-- 隱藏的舊版按鈕，用於腳本維持邏輯 -->
            <button id="soundBtn" style="display:none;"></button>
            <button id="bgmBtn" style="display:none;"></button>
          </div>
          <button class="ic-btn" id="optBtn" aria-haspopup="true" aria-expanded="false" aria-controls="optMenu" title="選項">⋯</button>
          <div class="menu" id="optMenu">
            <h4>遊戲</h4>
            <div class="item"><span>🎮</span>難度 <select id="difficulty" aria-label="難度">
              <option value="easy">簡單</option>
              <option value="normal" selected>一般</option>
              <option value="hard">困難</option>
            </select></div>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn" id="pauseBtn" style="display:none;">暫停/繼續</button>
              <button class="btn" id="resetBtn">重新開始</button>
              <button class="btn" id="saveBtn">存檔</button>
              <button class="btn" id="loadBtn">讀檔</button>
              <button class="btn" id="clearSaveBtn">清除存檔</button>
              <label class="btn level-select" id="levelJumpLabel">跳至關卡
                <select id="levelJumpSel" aria-label="跳至關卡"></select>
              </label>
            </div>
            <h4>其他</h4>
            <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn" id="fsBtn">全螢幕</button>
              <button class="btn" id="tutorBtn">教學</button>
              <button class="btn" id="effectsBtn">效果說明</button>
              <button class="btn" id="codexBtn">圖鑑</button>
              <button class="btn" id="galleryBtn">畫廊</button>
              <button class="btn" id="rankBtn">排行榜</button>
            </div>
            <div class="item"><span>🎨</span>Skin <select aria-label="Skin" id="skinSel">
              <option>經典．冷藍玻璃</option>
            </select></div>
          </div>
        </div>
        <div class="pill wide">生命 <b id="lives">9</b> <span class="hearts" id="hearts">❤️❤️❤️❤️❤️❤️❤️❤️❤️</span> <span id="fireEnergy" class="fire-energy"></span> <span class="cats" id="cats" style="display:none"></span></div>
      </div>
    </section>
    <div class="hud-sentinel" style="height:0"></div>
    <!-- Buffs / 提示 -->
    <div id="buffs" class="badges"></div>
    <div id="playArea">
      <div id="promptsDock"></div>
      <!-- 遊戲區域 -->
      <div class="stage">
        <canvas id="fx"></canvas>
        <canvas id="game" width="1100" height="700"></canvas>
        <div id="combo" class="combo"></div>

      </div>
      <div class="equipment-bar" id="equipmentBar" aria-label="裝備欄">
        <div class="equipment-slots" id="equipmentSlots" role="list">
          <!-- 動態填入裝備欄位 -->
        </div>
        <div class="equipment-status">
          <span class="equipment-message" id="equipmentMessage">尚未裝備任何武器。</span>
          <span class="shield-status" id="shieldStatus" hidden>防護罩剩餘 <span id="shieldStatusTime">0.0</span>s</span>
        </div>
      </div>
    </div>

    <!-- 覆蓋層/畫廊/勝利/結束/提示 -->
    <div class="overlay">
      <div class="store-overlay" id="storeOverlay" aria-hidden="true">
        <div class="backdrop"></div>
        <div class="store-panel" role="dialog" aria-labelledby="storeTitle">
          <div class="store-left">
            <img id="storeHeroImg" src="images/S01.jpg" alt="武器商店店員" loading="lazy" />
            <div class="store-hero-label">ASTRA ARMORY</div>
          </div>
          <div class="store-content">
            <div class="store-header">
              <h2 class="store-title" id="storeTitle">星光武裝商會 <small>整備下一場戰鬥吧</small></h2>
              <div class="store-balance">持有銀幣: <span id="storeSilverCoins">0</span></div>
            </div>
            <div class="store-grid" id="storeGrid" role="list"></div>
            <div class="store-detail">
              <div class="slot-modal" id="slotModal" aria-hidden="true">
                <h4 id="slotModalTitle">選擇要安裝的裝備欄位</h4>
                <div class="slot-grid" id="slotGrid"></div>
                <div class="slot-confirm" id="slotConfirm">
                  <p id="slotConfirmText"></p>
                  <div class="actions">
                    <button class="btn primary" id="slotConfirmYes" type="button">是</button>
                    <button class="btn secondary" id="slotConfirmNo" type="button">否</button>
                  </div>
                </div>
              </div>
              <div class="store-headline">
                <h3 id="storeItemName">選擇一件裝備</h3>
                <span class="store-price-tag" id="storeItemPrice">—</span>
              </div>
              <div class="store-meta" id="storeItemMeta"></div>
              <p class="store-desc" id="storeItemDesc">完成關卡後可使用銀幣購買裝備，打造專屬打法。</p>
              <div class="store-feedback" id="storeFeedback"></div>
              <div class="store-actions">
                <button class="btn primary" id="storeBuyBtn" type="button" disabled>購買</button>
                <button class="btn secondary" id="storeNextBtn" type="button">進入下一關 ▶</button>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="codex-overlay" id="codexOverlay" aria-hidden="true">
        <div class="backdrop" id="codexBackdrop"></div>
        <div class="codex-panel" role="dialog" aria-labelledby="codexTitle">
          <button class="codex-close" id="codexClose" type="button" aria-label="關閉圖鑑">✕</button>
          <h2 id="codexTitle">裝備圖鑑</h2>
          <p class="codex-subtitle">收藏所有裝備的資訊</p>
          <div class="codex-list" id="codexList" role="list"></div>
          <div class="codex-pagination">
            <button class="btn" id="codexPrev" type="button">前一頁</button>
            <span id="codexPageIndicator">1 / 1</span>
            <button class="btn" id="codexNext" type="button">下一頁</button>
          </div>
        </div>
      </div>
      <div class="gallery" id="gallery">
        <div class="backdrop"></div>
        <img id="galleryImg" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" alt="關卡大圖" />
        <div class="hint" id="galleryHint">點一下顯示台詞 ▶</div>
        <div class="dialog" id="galleryDialog"></div>
      </div>

      <div class="gallery-page" id="galleryPage">
        <div class="backdrop"></div>
        <div class="content">
          <div class="close" id="galleryClose">❌</div>
          <div class="thumbs" id="galleryThumbs"></div>
          <div class="nav">
            <button class="btn" id="galleryPrev">前一頁</button>
            <span id="galleryPageInfo">1 / 2</span>
            <button class="btn" id="galleryNext">下一頁</button>
          </div>
        </div>
        <div class="viewer" id="galleryViewer">
          <img id="galleryViewerImg" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" alt="畫廊大圖" />
          <div class="options" id="viewerOptions"></div>
          <div class="dialog" id="viewerDialog"></div>
        </div>
      </div>

      <div class="rank-page" id="rankPage">
        <div class="backdrop"></div>
        <div class="content">
          <div class="close" id="rankClose">❌</div>
          <h2 style="text-align:center;margin:4px 0 8px;">排行榜</h2>
          <table id="rankTable">
            <thead>
              <tr>
                <th>名次</th>
                <th>玩家</th>
                <th>分數</th>
                <th>消耗生命</th>
                <th>接球數</th>
                <th>增益次數</th>
                <th>減益次數</th>
                <th>殺敵數</th>
                <th>殺Boss數</th>
                <th>最快死亡</th>
                <th>最久存活</th>
                <th>最高Combo數</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="win" id="win">
        <div class="backdrop"></div>
        <div class="thumb-ring" id="ring"></div>
        <div class="center">
          <h2>恭喜過關！</h2>
          <div style="font-size:28px;margin:6px 0;">總分數：<span id="finalScore">0</span></div>
          <div id="statsWin" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:360px"></div>
          <div class="small">作者： GPT-5、Codex　／　指導者： Rock</div>
          <div class="again"><button class="btn" id="uploadWin">上傳排行榜</button> <button class="btn" id="againBtn">再玩一次</button></div>
        </div>
        <div class="thumb-note" id="thumbNote"></div>
      </div>

      <div class="gameover" id="gameover">
        <div class="backdrop"></div>
        <div class="center">
          <h2>遊戲結束</h2>
          <div style="font-size:28px;margin:6px 0;">最終分數：<span id="finalScore2">0</span></div>
          <div id="statsOver" style="text-align:left;font-size:13px;line-height:1.7;margin:6px auto 2px;max-width:320px"></div>
          <div class="again"><button class="btn" id="uploadOver">上傳排行榜</button> <button class="btn" id="retryBtn">再次遊戲</button></div>
        </div>
      </div>
      
      <div class="center-note" id="centerNote">
        <div class="note-box" id="noteBox"><button class="note-close" id="noteClose" aria-label="關閉">×</button>
          <h2 id="noteTitle">按 <kbd>Space</kbd> 或點畫面開始</h2>
          <p id="noteText"></p>
        </div>
      </div>
</div>
  </div>
  <div id="uploadOverlay">
    <div class="box">
      <div>上傳中...</div>
      <div class="progress"><div id="uploadBar"></div></div>
      <div class="percent" id="uploadPercent">0%</div>
    </div>
  </div>

<!-- Load skin definitions before the game script.  This file defines
     window.SKINS, window.applySkin and initializes the default skin. -->
<script src="skin.js"></script>
<script>
(() => {

  // Google Apps Script 部署後的 Web App URL，需替換為您自己的網址
  const RANK_API = 'https://script.google.com/macros/s/AKfycbwuIqqynB0ohVwnMhcA3u2Gv9GimGqUvfCJ_Nw_UnoCuEMCHG_rGhlKA_pxOO51HHU/exec';
  // 逾時毫秒數：避免網路不穩或後端未回應導致 Promise 卡住
  const FETCH_TIMEOUT = 8000;
  // Apps Script backend 必須回應 CORS 標頭，才能跨網域存取
  // === 設定 ===
  const GAME_CONFIG = {
    totalLevels: 20,
    difficulty: {
      easy:   { paddleBaseW: 220, baseSpeed: 4, rowsBase: 6, dropRate: 0.72 },
      normal: { paddleBaseW: 180, baseSpeed: 4.5, rowsBase: 7, dropRate: 0.52 },
      hard:   { paddleBaseW: 140, baseSpeed: 6, rowsBase: 8, dropRate: 0.32 },
    },
    bricks: { explosiveChance: 0.18, brickHeight: 30, padding: 9, topOffset: 60, cols: 12 },
    powers: {
      // 既有
      WIDE:{label:'平台變寬',type:'buff',durationMs:30000,paddleWidthAdd:50,badge:'↔️'},
      LONG:{label:'平台變長(可疊)',type:'buff',durationMs:30000,longPerStackAdd:40,stacksMax:2,badge:'📏'},
      STICKY:{label:'黏性平台(上彈可暫黏)',type:'buff',durationMs:5000,sticky:true,badge:'🧲'},
      MULTI:{label:'多球',type:'buff',multiDuplicate:true,maxBalls:4,badge:'✨'},
      SLOW:{label:'全局慢速',type:'buff',durationMs:15000,speedMul:0.8,badge:'🐢'},
      PIERCE:{label:'穿透球',type:'buff',durationMs:12000,piercing:true,badge:'🎯'},
      SHIELD:{label:'護盾(掉球擋一次)',type:'buff',oneShotShield:true,badge:'🛡'},
      RAMPAGE:{label:'暴走球(短暫強穿)',type:'buff',durationMs:5000,forcePiercing:true,rampageMs:5000,badge:'🔥'},
      FAST:{label:'快速球',type:'debuff',durationMs:5000,globalSpeedMul:1.5,screenShakeOnApply:6,badge:'⚡'},
      WAVY:{label:'變速球',type:'debuff',durationMs:5000,wavy:{amp:0.6,base:1.2,periodMs:200},badge:'〰️'},
      COMBO:{label:'連擊之星',desc:'連擊時間延長2倍、得分×1.5',type:'buff',durationMs:30000,combo:{timeMul:2,scoreMul:1.5},badge:'🌟'},
      // 新增
      PLASMA:{label:'電漿球(擊中放出電漿圈清列)',type:'buff',durationMs:10000,plasma:{drift:1.2,radius:38,lifeMs:3000},badge:'⚡️'},
      FREEZE:{label:'凍結球(延遲停頓一下)',type:'buff',durationMs:10000,freeze:{delayMs:300,stopMs:2000},badge:'❄️'},
      HOLY:{label:'神聖球(十字清線)',type:'buff',durationMs:5000,holy:{},badge:'✝️'},
      TRACK:{label:'追蹤球(自動修正軌跡)',type:'buff',durationMs:10000,track:{},badge:'🧭'},
      MISSILE:{label:'飛彈球(擋板反彈時發射3枚)',type:'buff',durationMs:5000,missile:{speed:7,turn:0.08,lifeMs:4000},badge:'🚀'},
      HELL:{label:'地獄球(黑洞吞鄰近格)',type:'buff',durationMs:5000,hell:{speedMul:1.2,haloMs:2000},badge:'🕳️'},
      MEGA:{label:'特大球(半徑×3, 速度×0.8, 傷害×2)',type:'buff',durationMs:5000,mega:{sizeMul:3,speedMul:0.8,damageMul:2},badge:'🟢'},
      CHAIN:{label:'鎖鏈球(命中磚鎖10秒)',type:'debuff',durationMs:5000,chain:{lockMs:10000},badge:'⛓️'},
      NARROW:{label:'平台縮小(寬度減半)',type:'debuff',durationMs:5000,narrow:true,badge:'📉'},
      HOLE:{label:'平台空洞(中間1/3無效)',type:'debuff',durationMs:5000,hole:true,badge:'🕳'},
      PADSPIN:{label:'平台翻轉',desc:'平台旋轉8秒',type:'debuff',durationMs:8000,spin:{periodMs:8000},badge:'🌀'},
      PADBOOM:{label:'平台爆炸',desc:'閃爍後消失3秒',type:'debuff',explosion:{flashMs:3000,goneMs:3000},badge:'💣'},
      FIRE:{label:'火焰球(碰撞蓄能10秒爆炸)',type:'buff',durationMs:10000,badge:'🔥'},
      POISON:{label:'劇毒球(命中磚每2秒扣血)',type:'buff',durationMs:12000,poison:{tickMs:2000},badge:'☠️'},
      BLINK:{label:'瞬移球(彈後1秒頂部落下)',type:'buff',durationMs:10000,blink:{delayMs:1000},badge:'🌀'},
      LASER:{label:'自動雷射(每2秒兩端發射)',type:'special',durationMs:10000,specialWeight:0.1,laser:{intervalMs:2000},badge:'🔫'},
      FLIP:{label:'天地翻轉(改為左側擋板)',type:'special',durationMs:15000,specialWeight:0.1,badge:'🔄'},
      NINE:{label:'9命怪貓(生命變9)',type:'special',instant:true,badge:'🐱'},
      PHOENIX:{label:'鳳凰審判(消半場/不秒殺Boss)',type:'special',instant:true,badge:'🪽'},
      GATLING:{label:'火力壓制',desc:'平台機槍掃射8秒',type:'special',durationMs:11000,specialWeight:0.1,gatling:{chargeMs:3000,fireMs:8000,intervalMs:100,bulletSpeed:10},badge:'🔫'},
      SWORD:{label:'劍芒裂空',desc:'飛劍掃場',type:'special',durationMs:20000,specialWeight:0.1,badge:'🗡️'},
      GODSPEED:{label:'神速流轉(不落地/滿速)',type:'special',durationMs:10000,specialWeight:0.1,badge:'☄️'},
      STORM:{label:'雷射風暴',desc:'全場掃射',type:'special',durationMs:5000,specialWeight:0.1,storm:{},badge:'🌩️'},
      BLACKHOLE:{label:'黑洞吞噬',desc:'黑洞吞場',type:'special',durationMs:20000,specialWeight:0.1,badge:'⚫'},
      ANNIHIL:{label:'萬物銷毀',desc:'隨機毀磚',type:'special',specialWeight:0.1,annihil:{speedMul:3},badge:'💥'}

    },
    powerCapsule:{width:24,height:16,fallVy:2.2},
    caps:{paddleMaxW:300,ballSpeedMax:19.5}
  };

  // === 影像載入（支援 .png / .jpg） ===
  const IMG_PAIRS = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.png`, cg:`images/cg${i}.png`}));
  // 準備 jpg 後備
  const IMG_PAIRS_FALLBACK = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.jpg`, cg:`images/cg${i}.jpg`}));

  const DIALOGS = {
    bg1: [
      '這麼快就破冰而來？小心，我的心比寒霜更難融化哦。',
      '嗯……你的手指一定很靈巧，才能穿過我的冰陣。',
      '別站太近，我怕不小心凍住你的心。'
    ],
    bg2: [
      '感謝你的勇氣，願月神的祝福伴你繼續前行。',
      '你的光芒……比聖堂的星光還要耀眼。',
      '或許，我該為你的心祈禱，不要被我奪走。'
    ],
    bg3: [
      '不錯，你的命暫時保住了……至少在我懷裡。',
      '你打破的不只是磚塊，還是我對你的試探。',
      '別怕鐮刀，它只收割敵人……或者偷吻盟友。'
    ],
    bg4: [
      '你讓我等太久了……這杯酒早該敬你。',
      '別問我情報的價錢，也許……用一個吻就夠。',
      '嗯，動作俐落，今晚你值得更多獎勵。'
    ],
    bg5: [
      '孩子，你的靈魂比我想像的還要純淨……或者危險。',
      '在聖光下，連你的眼神都變得無法隱藏。',
      '我可以祝福你……或者誘惑你，你選哪個？'
    ],
    bg6: [
      '好劍法……不如找時間，與我切磋更多回合。',
      '你贏得了這場戰役，也贏得了我的注意。',
      '別急著走，真正的決戰在我心裡等你。'
    ],
    bg7: [
      '真有趣……你闖進來，就是為了見我嗎？',
      '小心點，我的笑容比地獄的火焰更致命。',
      '既然你贏了，那就……讓我好好品嚐你的靈魂吧。'
    ],
    bg8: [
      '你真幸運，能活著見到我。',
      '打磚塊很厲害？下次試試打破我的心防。',
      '看來……我得重新評估你是敵人，還是我的人。'
    ],
    bg9: [
      '唉呀，被你闖進來了，火焰可不只燒磚哦。',
      '你知道嗎？我喜歡會讓我心跳加速的對手。',
      '別走太快，我還沒決定是要吻你還是燒了你。'
    ],
    bg10: [
      '我研究過萬種藥劑，唯獨你的氣息能讓我失控……要不要成為我的專屬樣本？',
      '你知道嗎？我能用藥劑讓人忘記恐懼，但對你——我只想讓你沉溺。',
      '別誤會，我不是對你有興趣……只是想看看，若吻你一次，會不會引爆魔陣。'
    ],
    cg1: [
      '你闖過來的樣子，像雪崩一樣驚心動魄。',
      '別動，我想看看你在冰霜映照下的眼神。',
      '小心，我的心情若融化……可是會淹沒你的。'
    ],
    cg2: [
      '你的步伐很輕，但足跡卻深深刻在我心上。',
      '你闖過這段路，讓我想起了失落的勇者傳說。',
      '聖堂的花為你而開……也許我也是。'
    ],
    cg3: [
      '你的膽量……足以和死神坐在同一張桌前。',
      '剛剛那一下，我幾乎想收割你的心而非靈魂。',
      '別退，我還沒決定要把你留在哪一邊。'
    ],
    cg4: [
      '你跑得快，還是我的心跳快？',
      '你贏了，獎品嘛……也許是我的陪伴一回合。',
      '下次見面前，記得多練習……我不喜歡慢吞吞的獵物。'
    ],
    cg5: [
      '你的名字，已經被我寫進禁忌的詩篇裡。',
      '在黑暗中，你的光……令人想犯罪。',
      '別以為破關了就能逃離，我的魔咒很黏人。'
    ],
    cg6: [
      '剛才那一擊……我都想跟你過招幾百次了。',
      '你的眼神告訴我，你不只是為勝利而戰。',
      '戰場上我很兇，但對贏得我心的人……很溫柔。'
    ],
    cg7: [
      '恭喜，你已經被惡魔的興趣鎖定。',
      '你的靈魂香氣……比我想像的還誘人。',
      '今晚，你最好鎖好門……或者乾脆敞開等我。'
    ],
    cg8: [
      '別回頭，我的影子已經纏上你了。',
      '動作還不錯，下次換我來試探你。',
      '你闖過的不是關卡，而是我的戒心。'
    ],
    cg9: [
      '花草會記住你的名字……就像我一樣。',
      '你的氣息，讓森林也安靜下來聆聽。',
      '小心哦，我的魔法會讓你捨不得離開。'
    ],
    cg10: [
      '你打碎的每一塊磚，都是一顆殞落的星。而如今——我願為你墜落。',
      '你的勝利讓群星為你低頭……而我，只想墜落在你懷裡。',
      '看吧，宇宙為你開出一條光的路。若你願意伸手……我會帶你飛越所有的結局。'
    ]
  };

  function makeImg(src, fallback){
    const im = new Image();
    im.decoding = 'async';
    im.loading = 'eager';
    im.src = src;
    if (fallback) {
      im.onerror = () => { if (im.src !== fallback) im.src = fallback; };
    }
    if (im.decode) { im.decode().catch(() => {}); }
    return im;
  }
  const IMG_MAP = new Array(10); // caches {bg, cg}
  function loadImagePair(i){
    if(!IMG_MAP[i]){
      IMG_MAP[i] = {
        bg: makeImg(IMG_PAIRS[i].bg, IMG_PAIRS_FALLBACK[i].bg),
        cg: makeImg(IMG_PAIRS[i].cg, IMG_PAIRS_FALLBACK[i].cg),
      };
    }
    return IMG_MAP[i];
  }

  function demonHandPosition(side='left'){
    if(!demonBoss){
      const L=layout();
      return {
        x:550 + (side==='left'?-120:120),
        y:L.top + 220
      };
    }
    const baseY = demonBoss.baseY != null ? demonBoss.baseY : demonBoss.y;
    const offsetX = (side==='left'?-1:1) * Math.max(80, (demonBoss.w||90)*1.2);
    const offsetY = Math.max(40, (demonBoss.h||90)*0.65);
    return {
      x:demonBoss.x + offsetX,
      y:baseY + offsetY
    };
  }

  function startDemonVoidVolley(now){
    if(!demonBoss || demonVoidVolleyState) return;
    const order=Math.random()>0.5?['left','right']:['right','left'];
    demonVoidVolleyState={
      start:now,
      stage:'charging',
      shots:order.map((hand, idx)=>({
        hand,
        chargeStart:now,
        chargeEnd:now+2000,
        fireAt:now+2000 + idx*2000,
        fired:false,
        firedAt:0,
        cooldownUntil:0
      }))
    };
    demonVoidNextRoll=now+5000;
  }

  function fireDemonVoidShot(shot, now){
    const handPos=demonHandPosition(shot.hand);
    const {x:targetX, y:targetY}=getPaddleTarget();
    const dx=targetX-handPos.x;
    const dy=targetY-handPos.y;
    const dist=Math.hypot(dx, dy)||1;
    const speed=520;
    demonVoidProjectiles.push({
      kind:'voidLarge',
      x:handPos.x,
      y:handPos.y,
      vx:(dx/dist)*speed,
      vy:(dy/dist)*speed,
      radius:28,
      spawnAt:now,
      splitAt:now+480,
      lastUpdate:now
    });
    spawnParticles(handPos.x, handPos.y, '#c19bff', 26, 1.6, 2.6, 2.4);
    spawnParticles(handPos.x, handPos.y, '#8c4dff', 18, 1.4, 2.2, 2.2);
    playSFX('plasma');
    shot.fired=true;
    shot.firedAt=now;
    shot.cooldownUntil=now+900;
  }

  function splitDemonVoidOrb(projectile, index, now){
    const baseAngle=Math.atan2(projectile.vy||0, projectile.vx||1);
    const offsets=[-0.36, 0, 0.36];
    const speed=620;
    for(const offset of offsets){
      demonVoidProjectiles.push({
        kind:'voidSmall',
        x:projectile.x,
        y:projectile.y,
        vx:Math.cos(baseAngle+offset)*speed,
        vy:Math.sin(baseAngle+offset)*speed,
        radius:14,
        spawnAt:now,
        lastUpdate:now,
        life:3200,
        trail:[]
      });
    }
    spawnParticles(projectile.x, projectile.y, '#d7b6ff', 34, 1.8, 2.8, 2.6);
    spawnParticles(projectile.x, projectile.y, '#9c5bff', 22, 1.6, 2.4, 2.4);
    playSFX('explosion');
    demonVoidProjectiles.splice(index,1);
  }

  function updateDemonVoidVolley(now){
    if(level!==20) return;
    const state=demonVoidVolleyState;
    if(!state) return;
    if(demonPhase!=='active' || !demonBoss){
      demonVoidVolleyState=null;
      return;
    }
    let stage='cooldown';
    let active=false;
    for(const shot of state.shots){
      if(!shot) continue;
      if(!shot.fired){
        if(now>=shot.fireAt){
          fireDemonVoidShot(shot, now);
          stage='firing';
          active=true;
        }else{
          stage='charging';
          active=true;
        }
      }else{
        const fadeEnd=shot.cooldownUntil || (shot.firedAt+900);
        shot.cooldownUntil=fadeEnd;
        if(now<fadeEnd){
          if(stage!=='charging') stage='firing';
          active=true;
        }
      }
    }
    state.stage=stage;
    if(!active && !demonVoidProjectiles.length){
      demonVoidVolleyState=null;
    }
  }

  function updateDemonVoidProjectiles(now){
    if(level!==20 || !demonVoidProjectiles.length) return;
    const L=layout();
    const stageTop=L.top;
    for(let i=demonVoidProjectiles.length-1;i>=0;i--){
      const proj=demonVoidProjectiles[i];
      if(!proj){ demonVoidProjectiles.splice(i,1); continue; }
      const dt=now-(proj.lastUpdate||now);
      proj.lastUpdate=now;
      const step=dt/1000;
      proj.x += (proj.vx||0)*step;
      proj.y += (proj.vy||0)*step;
      if(proj.trail){
        proj.trail.push({x:proj.x, y:proj.y, t:now});
        if(proj.trail.length>14) proj.trail.shift();
      }
      if(proj.kind==='voidLarge'){
        if(now>=proj.splitAt){
          splitDemonVoidOrb(proj, i, now);
          continue;
        }
      }else if(proj.kind==='voidSmall'){
        const life=proj.life||3200;
        if(now>=proj.spawnAt + life){
          demonVoidProjectiles.splice(i,1);
          continue;
        }
        const pr=paddleRect();
        if(pr.w>0 && pr.h>0 && now>=paddleGoneUntil){
          if(circleIntersectsRect(proj.x, proj.y, proj.radius||12, pr)){
            demonVoidOrbHit(now);
            spawnParticles(proj.x, proj.y, '#f0d0ff', 22, 1.6, 2.4, 2.6);
            demonVoidProjectiles.splice(i,1);
            continue;
          }
        }
      }
      if(proj.x<-160 || proj.x>1260 || proj.y<stageTop-200 || proj.y>780){
        demonVoidProjectiles.splice(i,1);
      }
    }
  }

  function demonVoidOrbHit(now){
    if(now<paddleGoneUntil) return;
    const pr=paddleRect();
    const centerX=pr.x+pr.w/2;
    const centerY=pr.y+pr.h/2;
    if(blockDamageIfShielded({x:centerX,y:centerY})){
      return;
    }
    if(stats.lifeStart){
      const dur=(now-stats.lifeStart)/1000;
      if(dur<stats.fastestDeath) stats.fastestDeath=dur;
      if(dur>stats.longestLife) stats.longestLife=dur;
    }
    stats.livesUsed++;
    if(buffs.BLACKHOLE.active){ buffs.BLACKHOLE.deaths=Math.min(8,(buffs.BLACKHOLE.deaths||0)+1); }
    if(buffs.ANNIHIL.active){ buffs.ANNIHIL.active=false; }
    spawnParticles(centerX, centerY, '#a87dff', 70, 2.8, 3.8, 3.4);
    spawnParticles(centerX, centerY, '#f2dbff', 40, 2.2, 3.2, 3.0);
    spawnParticles(centerX, centerY, '#6930c3', 28, 2.0, 3.0, 2.8);
    playSFX('explosion');
    screenShake=Math.max(screenShake,10);
    const prevLives=lives;
    const burstPos=captureHeartBurstPosition(prevLives);
    lives=Math.max(0, lives-1);
    updateHUD();
    if(burstPos){ spawnBladeHellHeartBurst(burstPos); }
    for(const ball of balls){ if(!ball) continue; ball.vy=-Math.abs(ball.vy||4); }
    if(lives<=0){ running=false; paused=true; showGameOver(); }
  }

  function drawDemonVoidVolleyEffects(now, opts={}){
    if(level!==20) return;
    const hideCharges=!!opts.hideCharges;
    const scaleAvg=(scaleX+scaleY)/2;
    if(!hideCharges && demonVoidVolleyState && demonBoss && demonPhase==='active'){
      for(const shot of demonVoidVolleyState.shots){
        if(!shot) continue;
        const pos=demonHandPosition(shot.hand);
        let intensity=0;
        if(!shot.fired){
          const dur=Math.max(1, (shot.chargeEnd||shot.fireAt) - shot.chargeStart);
          const elapsed=now-shot.chargeStart;
          intensity=Math.max(0, Math.min(1, elapsed/dur));
          if(now>= (shot.chargeEnd||shot.fireAt)) intensity=1;
        }else{
          const fadeEnd=shot.cooldownUntil || (shot.firedAt+900);
          if(now<fadeEnd){
            const remain=fadeEnd-now;
            const fadeDur=Math.max(1, fadeEnd-shot.firedAt);
            intensity=Math.max(0, Math.min(1, remain/fadeDur))*0.8;
          }
        }
        if(intensity<=0) continue;
        ctx.save();
        ctx.translate(pos.x*scaleX, pos.y*scaleY);
        ctx.globalCompositeOperation='lighter';
        const radius=36*scaleAvg*(0.7+0.6*intensity);
        const grad=ctx.createRadialGradient(0,0,radius*0.18,0,0,radius);
        grad.addColorStop(0,`rgba(240,225,255,${0.9*intensity})`);
        grad.addColorStop(0.55,`rgba(175,110,255,${0.65*intensity})`);
        grad.addColorStop(1,'rgba(70,20,130,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(0,0,radius,0,Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.translate(pos.x*scaleX, pos.y*scaleY);
        ctx.rotate(now/240 + (shot.hand==='left'?0.4:-0.4));
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle=`rgba(200,150,255,${0.4*intensity})`;
        ctx.lineWidth=4*scaleAvg*(0.6+0.4*intensity);
        ctx.beginPath();
        ctx.ellipse(0,0,radius*0.55,radius*0.28,0,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
    if(!demonVoidProjectiles.length) return;
    for(const proj of demonVoidProjectiles){
      if(!proj) continue;
      const x=proj.x*scaleX;
      const y=proj.y*scaleY;
      const radius=(proj.radius || (proj.kind==='voidLarge'?24:12))*scaleAvg;
      if(proj.trail && proj.trail.length){
        for(let t=0;t<proj.trail.length;t++){
          const tr=proj.trail[t];
          const alpha=(t+1)/proj.trail.length;
          ctx.save();
          ctx.globalCompositeOperation='lighter';
          ctx.globalAlpha=0.18*alpha;
          ctx.beginPath();
          ctx.arc(tr.x*scaleX, tr.y*scaleY, radius*0.5*alpha, 0, Math.PI*2);
          ctx.fillStyle='rgba(190,150,255,1)';
          ctx.fill();
          ctx.restore();
        }
      }
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createRadialGradient(x,y,radius*0.22,x,y,radius);
      if(proj.kind==='voidLarge'){
        grad.addColorStop(0,'rgba(245,230,255,0.95)');
        grad.addColorStop(0.55,'rgba(190,130,255,0.75)');
        grad.addColorStop(1,'rgba(80,20,150,0)');
      }else{
        grad.addColorStop(0,'rgba(245,225,255,0.9)');
        grad.addColorStop(0.6,'rgba(200,150,255,0.7)');
        grad.addColorStop(1,'rgba(90,30,160,0)');
      }
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // === 特殊增益解鎖 ===
  const SPECIAL_UNLOCK_LEVELS = {
    PHOENIX:1,
    GATLING:3,
    SWORD:5,
    GODSPEED:7,
    STORM:9,
    BLACKHOLE:10,
    ANNIHIL:15,
  };
  const defaultUnlocked=['LASER','FLIP','NINE'];
  let unlockedSpecials=new Set(defaultUnlocked);
  try{
    const stored=JSON.parse(localStorage.getItem('unlocked_specials')||'[]');
    if(Array.isArray(stored)) stored.forEach(k=>unlockedSpecials.add(k));
  }catch(e){}
  function saveUnlockedSpecials(){
    localStorage.setItem('unlocked_specials',JSON.stringify(Array.from(unlockedSpecials)));
  }
  let pendingUnlockNotice=null;
  let ALL_TYPES=[]; let NORMAL_TYPES=[];
  function recomputePowerTypes(){
    ALL_TYPES=Object.keys(GAME_CONFIG.powers).filter(k=>GAME_CONFIG.powers[k].type!=='special'||unlockedSpecials.has(k));
    NORMAL_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='special');
  }
  function unlockSpecials(clearLevel){
    for(const [key,req] of Object.entries(SPECIAL_UNLOCK_LEVELS)){
      if(clearLevel>=req && !unlockedSpecials.has(key)){
        unlockedSpecials.add(key);
        saveUnlockedSpecials();
        pendingUnlockNotice=`已解鎖特殊增益:${GAME_CONFIG.powers[key].label.split('(')[0]}`;
        recomputePowerTypes();
      }
    }
  }
  recomputePowerTypes();

  // === 參考 DOM ===
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const scoreEl=document.getElementById('score'), levelEl=document.getElementById('level'), livesEl=document.getElementById('lives');
  const silverCoinsEl=document.getElementById('silverCoins');
  const pauseBtn=document.getElementById('pauseBtn'), resetBtn=document.getElementById('resetBtn'), fsBtn=document.getElementById('fsBtn');
  const soundBtn=document.getElementById('soundBtn'), saveBtn=document.getElementById('saveBtn'), loadBtn=document.getElementById('loadBtn'), clearSaveBtn=document.getElementById('clearSaveBtn');
  const levelJumpSel=document.getElementById('levelJumpSel');
  let refreshLevelJumpVisual=null;
  let updateLevelJumpAvailability=null;
  const tutorBtn=document.getElementById('tutorBtn'), effectsBtn=document.getElementById('effectsBtn'), codexBtn=document.getElementById('codexBtn'), galleryBtn=document.getElementById('galleryBtn'), rankBtn=document.getElementById('rankBtn');
  const centerNote=document.getElementById('centerNote'), noteTitle=document.getElementById('noteTitle'), noteText=document.getElementById('noteText'), noteBox=document.getElementById('noteBox');
  const difficultySel=document.getElementById('difficulty'), activeBuffsEl=document.getElementById('buffs'), promptsDock=document.getElementById('promptsDock');
  const ledStyleSel=document.getElementById('ledStyle');

  // 新增元素參考
  const heartsEl = document.getElementById('hearts');
  const fireEnergyEl = document.getElementById('fireEnergy');
  const catsEl = document.getElementById('cats');
  const totalLevelsEl = document.getElementById('totalLevels');
  const sfxOnEl = document.getElementById('sfxOn');
  const bgmOnEl = document.getElementById('bgmOn');
  const skinSel = document.getElementById('skinSel');
  const storeOverlay=document.getElementById('storeOverlay');
  const storeGrid=document.getElementById('storeGrid');
  const storeSilverCoinsEl=document.getElementById('storeSilverCoins');
  const storeItemName=document.getElementById('storeItemName');
  const storeItemPrice=document.getElementById('storeItemPrice');
  const storeItemMeta=document.getElementById('storeItemMeta');
  const storeItemDesc=document.getElementById('storeItemDesc');
  const storeBuyBtn=document.getElementById('storeBuyBtn');
  const storeNextBtn=document.getElementById('storeNextBtn');
  const storeFeedback=document.getElementById('storeFeedback');
  const storeHeroImg=document.getElementById('storeHeroImg');
  const codexOverlay=document.getElementById('codexOverlay');
  const codexList=document.getElementById('codexList');
  const codexPrev=document.getElementById('codexPrev');
  const codexNext=document.getElementById('codexNext');
  const codexPageIndicator=document.getElementById('codexPageIndicator');
  const codexClose=document.getElementById('codexClose');
  const codexBackdrop=document.getElementById('codexBackdrop');
  const slotModal=document.getElementById('slotModal');
  const slotGrid=document.getElementById('slotGrid');
  const slotConfirm=document.getElementById('slotConfirm');
  const slotConfirmText=document.getElementById('slotConfirmText');
  const slotConfirmYes=document.getElementById('slotConfirmYes');
  const slotConfirmNo=document.getElementById('slotConfirmNo');
  const equipmentBar=document.getElementById('equipmentBar');
  const equipmentSlotsEl=document.getElementById('equipmentSlots');
  const equipmentMessageEl=document.getElementById('equipmentMessage');
  const shieldStatusEl=document.getElementById('shieldStatus');
  const shieldStatusTimeEl=document.getElementById('shieldStatusTime');

  const EQUIPMENT_TYPE_LABEL={
    passive:'被動型',
    active:'主動型',
    consumable:'消耗型'
  };
  const EQUIPMENT_LIST=[
    {id:'power1',name:'強力Ⅰ',roman:'Ⅰ',icon:'W01.jpg',grade:'C',type:'passive',price:5,description:'球對磚塊攻擊力+1（對Boss無效）',effect:{brickDamage:1}},
    {id:'power2',name:'強力Ⅱ',roman:'Ⅱ',icon:'W01.jpg',grade:'B',type:'passive',price:10,description:'球對磚塊攻擊力+2（對Boss無效）',effect:{brickDamage:2}},
    {id:'power3',name:'強力Ⅲ',roman:'Ⅲ',icon:'W01.jpg',grade:'A',type:'passive',price:30,description:'球對磚塊攻擊力+3（對Boss無效）',effect:{brickDamage:3}},
    {id:'shield1',name:'防護罩Ⅰ',roman:'Ⅰ',icon:'W02.jpg',grade:'C',type:'consumable',price:5,description:'獲得防護罩效果，5 秒內所有傷害無效，效果時間結束後裝備消失。',effect:{shieldDuration:5000}},
    {id:'shield2',name:'防護罩Ⅱ',roman:'Ⅱ',icon:'W02.jpg',grade:'B',type:'active',price:10,description:'獲得防護罩效果，5 秒內所有傷害無效，冷卻時間 60 秒。',effect:{shieldDuration:5000,cooldown:60000}},
    {id:'shield3',name:'防護罩Ⅲ',roman:'Ⅲ',icon:'W02.jpg',grade:'A',type:'active',price:30,description:'獲得防護罩效果，5 秒內所有傷害無效，冷卻時間 30 秒。',effect:{shieldDuration:5000,cooldown:30000}},
    {id:'heal1',name:'補血包Ⅰ',roman:'Ⅰ',icon:'W03.jpg',grade:'C',type:'consumable',price:10,description:'恢復 1 點 HP（最大 HP 9），使用後消失。',effect:{heal:1}},
    {id:'heal2',name:'補血包Ⅱ',roman:'Ⅱ',icon:'W03.jpg',grade:'B',type:'consumable',price:20,description:'恢復 2 點 HP（最大 HP 9），使用後消失。',effect:{heal:2}},
    {id:'heal3',name:'補血包Ⅲ',roman:'Ⅲ',icon:'W03.jpg',grade:'A',type:'consumable',price:40,description:'恢復 3 點 HP（最大 HP 9），使用後消失。',effect:{heal:3}},
    {id:'ninecat',name:'九命怪貓',icon:'W04.jpg',grade:'S',type:'consumable',price:100,description:'使用後立即獲得九命怪貓效果（上限 3 次）。',effect:{nineLives:true}},
    {id:'speedReset',name:'速度重置',icon:'W05.jpg',grade:'B',type:'consumable',price:10,description:'使用後立即將球速恢復為目前關卡的初始速度。',effect:{resetSpeed:true}},
    {id:'attractor',name:'吸引力',icon:'W06.jpg',grade:'A',type:'passive',price:30,description:'自動吸引靠近擋板的增益與特殊增益道具。',effect:{attract:true}},
    {id:'repulsor',name:'排斥力',icon:'W07.jpg',grade:'A',type:'passive',price:30,description:'自動排斥靠近擋板的減益道具。',effect:{repel:true}},
    {id:'bossSlayer',name:'王者剋星',icon:'W08.jpg',grade:'S',type:'passive',price:100,description:'對 Boss 傷害 x2，並附帶華麗金色特效。',effect:{bossDamageMultiplier:2,bossDamageFx:true}},
    {id:'bloodblade',name:'嗜血魔刃',icon:'W09.jpg',grade:'S',type:'active',price:100,description:'消耗 1 HP，10 秒內所有造成的傷害 x3，冷卻時間 60 秒。',effect:{bloodBlade:{hpCost:1,duration:10000,damageMultiplier:3,cooldown:60000}}},
    {id:'comboStar1',name:'連擊之星Ⅰ',roman:'Ⅰ',icon:'W10.jpg',grade:'C',type:'consumable',price:5,description:'啟動連擊之星效果 30 秒，效果結束後裝備消失。',effect:{comboStar:{mode:'consumable',duration:30000}}},
    {id:'comboStar2',name:'連擊之星Ⅱ',roman:'Ⅱ',icon:'W10.jpg',grade:'B',type:'active',price:10,description:'啟動連擊之星效果 30 秒，冷卻時間 60 秒。',effect:{comboStar:{mode:'active',duration:30000,cooldown:60000}}},
    {id:'comboStar3',name:'連擊之星Ⅲ',roman:'Ⅲ',icon:'W10.jpg',grade:'A',type:'passive',price:30,description:'持續擁有連擊之星的加成效果。',effect:{comboStar:{mode:'passive'}}},
    {id:'luckyStar',name:'幸運星',icon:'W11.jpg',grade:'A',type:'passive',price:30,description:'關卡期間不再掉落減益道具。',effect:{preventDebuffDrops:true}},
    {id:'grandLuckyStar',name:'大幸運星',icon:'W12.jpg',grade:'S',type:'passive',price:100,description:'不會掉落減益道具，特殊增益掉落率翻倍。',effect:{preventDebuffDrops:true,specialDropRateMultiplier:2}},
    {id:'doomSword',name:'災厄之劍',icon:'W13.jpg',grade:'A',type:'passive',price:30,description:'每持有 1 種減益效果，對敵方造成的傷害 +1。',effect:{curseSword:true}},
    {id:'splitBall1',name:'分裂球Ⅰ',roman:'Ⅰ',icon:'W14.jpg',grade:'C',type:'consumable',price:5,description:'啟動分裂球效果，立即複製球體，效果結束後裝備消失。',effect:{power:{key:'MULTI',mode:'consumable',duration:10000,message:'分裂球啟動，多球齊發！'}}},
    {id:'splitBall2',name:'分裂球Ⅱ',roman:'Ⅱ',icon:'W14.jpg',grade:'B',type:'active',price:10,description:'啟動分裂球效果，立即複製球體，冷卻時間 60 秒。',effect:{power:{key:'MULTI',mode:'active',duration:10000,cooldown:60000,message:'分裂球啟動，多球齊發！'}}},
    {id:'splitBall3',name:'分裂球Ⅲ',roman:'Ⅲ',icon:'W14.jpg',grade:'A',type:'active',price:30,description:'啟動分裂球效果，立即複製球體，冷卻時間 30 秒。',effect:{power:{key:'MULTI',mode:'active',duration:10000,cooldown:30000,message:'分裂球啟動，多球齊發！'}}},
    {id:'pierceBall1',name:'穿透球Ⅰ',roman:'Ⅰ',icon:'W15.jpg',grade:'C',type:'consumable',price:5,description:'啟動穿透球效果，球體可穿透磚塊，效果結束後裝備消失。',effect:{power:{key:'PIERCE',mode:'consumable',message:'穿透球啟動，球體可穿越磚陣！'}}},
    {id:'pierceBall2',name:'穿透球Ⅱ',roman:'Ⅱ',icon:'W15.jpg',grade:'B',type:'active',price:10,description:'啟動穿透球效果，球體可穿透磚塊，冷卻時間 60 秒。',effect:{power:{key:'PIERCE',mode:'active',cooldown:60000,message:'穿透球啟動，球體可穿越磚陣！'}}},
    {id:'pierceBall3',name:'穿透球Ⅲ',roman:'Ⅲ',icon:'W15.jpg',grade:'A',type:'active',price:30,description:'啟動穿透球效果，球體可穿透磚塊，冷卻時間 30 秒。',effect:{power:{key:'PIERCE',mode:'active',cooldown:30000,message:'穿透球啟動，球體可穿越磚陣！'}}},
    {id:'guardBall1',name:'護盾Ⅰ',roman:'Ⅰ',icon:'W16.jpg',grade:'C',type:'consumable',price:5,description:'啟動護盾效果，可阻擋下一次落球，使用後裝備消失。',effect:{power:{key:'SHIELD',mode:'consumable',message:'護盾展開，下一次失手將被保護。'}}},
    {id:'guardBall2',name:'護盾Ⅱ',roman:'Ⅱ',icon:'W16.jpg',grade:'B',type:'active',price:10,description:'啟動護盾效果，可阻擋下一次落球，冷卻時間 60 秒。',effect:{power:{key:'SHIELD',mode:'active',cooldown:60000,message:'護盾展開，下一次失手將被保護。'}}},
    {id:'guardBall3',name:'護盾Ⅲ',roman:'Ⅲ',icon:'W16.jpg',grade:'A',type:'active',price:30,description:'啟動護盾效果，可阻擋下一次落球，冷卻時間 30 秒。',effect:{power:{key:'SHIELD',mode:'active',cooldown:30000,message:'護盾展開，下一次失手將被保護。'}}},
    {id:'plasmaBall1',name:'電漿球Ⅰ',roman:'Ⅰ',icon:'W17.jpg',grade:'C',type:'consumable',price:5,description:'啟動電漿球效果，擊中會釋放電漿圈，效果結束後裝備消失。',effect:{power:{key:'PLASMA',mode:'consumable',message:'電漿球啟動，擊中會釋放電漿圈！'}}},
    {id:'plasmaBall2',name:'電漿球Ⅱ',roman:'Ⅱ',icon:'W17.jpg',grade:'B',type:'active',price:10,description:'啟動電漿球效果，擊中會釋放電漿圈，冷卻時間 60 秒。',effect:{power:{key:'PLASMA',mode:'active',cooldown:60000,message:'電漿球啟動，擊中會釋放電漿圈！'}}},
    {id:'plasmaBall3',name:'電漿球Ⅲ',roman:'Ⅲ',icon:'W17.jpg',grade:'A',type:'active',price:30,description:'啟動電漿球效果，擊中會釋放電漿圈，冷卻時間 30 秒。',effect:{power:{key:'PLASMA',mode:'active',cooldown:30000,message:'電漿球啟動，擊中會釋放電漿圈！'}}},
    {id:'freezeBall1',name:'凍結球Ⅰ',roman:'Ⅰ',icon:'W18.jpg',grade:'C',type:'consumable',price:5,description:'啟動凍結球效果，擊中後使時間短暫凝結，效果結束後裝備消失。',effect:{power:{key:'FREEZE',mode:'consumable',message:'凍結球啟動，擊中後時間將凝結！'}}},
    {id:'freezeBall2',name:'凍結球Ⅱ',roman:'Ⅱ',icon:'W18.jpg',grade:'B',type:'active',price:10,description:'啟動凍結球效果，擊中後使時間短暫凝結，冷卻時間 60 秒。',effect:{power:{key:'FREEZE',mode:'active',cooldown:60000,message:'凍結球啟動，擊中後時間將凝結！'}}},
    {id:'freezeBall3',name:'凍結球Ⅲ',roman:'Ⅲ',icon:'W18.jpg',grade:'A',type:'active',price:30,description:'啟動凍結球效果，擊中後使時間短暫凝結，冷卻時間 30 秒。',effect:{power:{key:'FREEZE',mode:'active',cooldown:30000,message:'凍結球啟動，擊中後時間將凝結！'}}},
    {id:'holyBall1',name:'神聖球Ⅰ',roman:'Ⅰ',icon:'W19.jpg',grade:'C',type:'consumable',price:5,description:'啟動神聖球效果，聖光十字掃蕩磚陣，效果結束後裝備消失。',effect:{power:{key:'HOLY',mode:'consumable',message:'神聖球啟動，聖光十字橫掃戰場！'}}},
    {id:'holyBall2',name:'神聖球Ⅱ',roman:'Ⅱ',icon:'W19.jpg',grade:'B',type:'active',price:10,description:'啟動神聖球效果，聖光十字掃蕩磚陣，冷卻時間 60 秒。',effect:{power:{key:'HOLY',mode:'active',cooldown:60000,message:'神聖球啟動，聖光十字橫掃戰場！'}}},
    {id:'holyBall3',name:'神聖球Ⅲ',roman:'Ⅲ',icon:'W19.jpg',grade:'A',type:'active',price:30,description:'啟動神聖球效果，聖光十字掃蕩磚陣，冷卻時間 30 秒。',effect:{power:{key:'HOLY',mode:'active',cooldown:30000,message:'神聖球啟動，聖光十字橫掃戰場！'}}},
    {id:'trackBall1',name:'追蹤球Ⅰ',roman:'Ⅰ',icon:'W20.jpg',grade:'C',type:'consumable',price:5,description:'啟動追蹤球效果，軌跡自動修正，效果結束後裝備消失。',effect:{power:{key:'TRACK',mode:'consumable',message:'追蹤球啟動，軌跡自動鎖定目標！'}}},
    {id:'trackBall2',name:'追蹤球Ⅱ',roman:'Ⅱ',icon:'W20.jpg',grade:'B',type:'active',price:10,description:'啟動追蹤球效果，軌跡自動修正，冷卻時間 60 秒。',effect:{power:{key:'TRACK',mode:'active',cooldown:60000,message:'追蹤球啟動，軌跡自動鎖定目標！'}}},
    {id:'trackBall3',name:'追蹤球Ⅲ',roman:'Ⅲ',icon:'W20.jpg',grade:'A',type:'active',price:30,description:'啟動追蹤球效果，軌跡自動修正，冷卻時間 30 秒。',effect:{power:{key:'TRACK',mode:'active',cooldown:30000,message:'追蹤球啟動，軌跡自動鎖定目標！'}}},
    {id:'missileBall1',name:'飛彈球Ⅰ',roman:'Ⅰ',icon:'W21.jpg',grade:'C',type:'consumable',price:5,description:'啟動飛彈球效果，擋板反彈時發射飛彈，效果結束後裝備消失。',effect:{power:{key:'MISSILE',mode:'consumable',message:'飛彈球啟動，擋板將釋放導彈！'}}},
    {id:'missileBall2',name:'飛彈球Ⅱ',roman:'Ⅱ',icon:'W21.jpg',grade:'B',type:'active',price:10,description:'啟動飛彈球效果，擋板反彈時發射飛彈，冷卻時間 60 秒。',effect:{power:{key:'MISSILE',mode:'active',cooldown:60000,message:'飛彈球啟動，擋板將釋放導彈！'}}},
    {id:'missileBall3',name:'飛彈球Ⅲ',roman:'Ⅲ',icon:'W21.jpg',grade:'A',type:'active',price:30,description:'啟動飛彈球效果，擋板反彈時發射飛彈，冷卻時間 30 秒。',effect:{power:{key:'MISSILE',mode:'active',cooldown:30000,message:'飛彈球啟動，擋板將釋放導彈！'}}},
    {id:'hellBall1',name:'地獄球Ⅰ',roman:'Ⅰ',icon:'W22.jpg',grade:'C',type:'consumable',price:5,description:'啟動地獄球效果，召喚黑洞吞噬磚塊，效果結束後裝備消失。',effect:{power:{key:'HELL',mode:'consumable',message:'地獄球啟動，黑洞能吞噬磚陣！'}}},
    {id:'hellBall2',name:'地獄球Ⅱ',roman:'Ⅱ',icon:'W22.jpg',grade:'B',type:'active',price:10,description:'啟動地獄球效果，召喚黑洞吞噬磚塊，冷卻時間 60 秒。',effect:{power:{key:'HELL',mode:'active',cooldown:60000,message:'地獄球啟動，黑洞能吞噬磚陣！'}}},
    {id:'hellBall3',name:'地獄球Ⅲ',roman:'Ⅲ',icon:'W22.jpg',grade:'A',type:'active',price:30,description:'啟動地獄球效果，召喚黑洞吞噬磚塊，冷卻時間 30 秒。',effect:{power:{key:'HELL',mode:'active',cooldown:30000,message:'地獄球啟動，黑洞能吞噬磚陣！'}}},
    {id:'megaBall1',name:'特大球Ⅰ',roman:'Ⅰ',icon:'W23.jpg',grade:'C',type:'consumable',price:5,description:'啟動特大球效果，球體巨大化並增傷，效果結束後裝備消失。',effect:{power:{key:'MEGA',mode:'consumable',message:'特大球啟動，球體瞬間巨大化！'}}},
    {id:'megaBall2',name:'特大球Ⅱ',roman:'Ⅱ',icon:'W23.jpg',grade:'B',type:'active',price:10,description:'啟動特大球效果，球體巨大化並增傷，冷卻時間 60 秒。',effect:{power:{key:'MEGA',mode:'active',cooldown:60000,message:'特大球啟動，球體瞬間巨大化！'}}},
    {id:'megaBall3',name:'特大球Ⅲ',roman:'Ⅲ',icon:'W23.jpg',grade:'A',type:'active',price:30,description:'啟動特大球效果，球體巨大化並增傷，冷卻時間 30 秒。',effect:{power:{key:'MEGA',mode:'active',cooldown:30000,message:'特大球啟動，球體瞬間巨大化！'}}},
    {id:'fireBall1',name:'火焰球Ⅰ',roman:'Ⅰ',icon:'W24.jpg',grade:'C',type:'consumable',price:5,description:'啟動火焰球效果，蓄能爆炸清場，效果結束後裝備消失。',effect:{power:{key:'FIRE',mode:'consumable',message:'火焰球啟動，蓄能引爆烈焰！'}}},
    {id:'fireBall2',name:'火焰球Ⅱ',roman:'Ⅱ',icon:'W24.jpg',grade:'B',type:'active',price:10,description:'啟動火焰球效果，蓄能爆炸清場，冷卻時間 60 秒。',effect:{power:{key:'FIRE',mode:'active',cooldown:60000,message:'火焰球啟動，蓄能引爆烈焰！'}}},
    {id:'fireBall3',name:'火焰球Ⅲ',roman:'Ⅲ',icon:'W24.jpg',grade:'A',type:'active',price:30,description:'啟動火焰球效果，蓄能爆炸清場，冷卻時間 30 秒。',effect:{power:{key:'FIRE',mode:'active',cooldown:30000,message:'火焰球啟動，蓄能引爆烈焰！'}}},
    {id:'poisonBall1',name:'劇毒球Ⅰ',roman:'Ⅰ',icon:'W25.jpg',grade:'C',type:'consumable',price:5,description:'啟動劇毒球效果，命中附帶毒素，效果結束後裝備消失。',effect:{power:{key:'POISON',mode:'consumable',message:'劇毒球啟動，命中將持續腐蝕！'}}},
    {id:'poisonBall2',name:'劇毒球Ⅱ',roman:'Ⅱ',icon:'W25.jpg',grade:'B',type:'active',price:10,description:'啟動劇毒球效果，命中附帶毒素，冷卻時間 60 秒。',effect:{power:{key:'POISON',mode:'active',cooldown:60000,message:'劇毒球啟動，命中將持續腐蝕！'}}},
    {id:'poisonBall3',name:'劇毒球Ⅲ',roman:'Ⅲ',icon:'W25.jpg',grade:'A',type:'active',price:30,description:'啟動劇毒球效果，命中附帶毒素，冷卻時間 30 秒。',effect:{power:{key:'POISON',mode:'active',cooldown:30000,message:'劇毒球啟動，命中將持續腐蝕！'}}},
    {id:'blinkBall1',name:'瞬移球Ⅰ',roman:'Ⅰ',icon:'W26.jpg',grade:'C',type:'consumable',price:5,description:'啟動瞬移球效果，反彈後瞬移至頂部，效果結束後裝備消失。',effect:{power:{key:'BLINK',mode:'consumable',message:'瞬移球啟動，球體將瞬間移位！'}}},
    {id:'blinkBall2',name:'瞬移球Ⅱ',roman:'Ⅱ',icon:'W26.jpg',grade:'B',type:'active',price:10,description:'啟動瞬移球效果，反彈後瞬移至頂部，冷卻時間 60 秒。',effect:{power:{key:'BLINK',mode:'active',cooldown:60000,message:'瞬移球啟動，球體將瞬間移位！'}}},
    {id:'blinkBall3',name:'瞬移球Ⅲ',roman:'Ⅲ',icon:'W26.jpg',grade:'A',type:'active',price:30,description:'啟動瞬移球效果，反彈後瞬移至頂部，冷卻時間 30 秒。',effect:{power:{key:'BLINK',mode:'active',cooldown:30000,message:'瞬移球啟動，球體將瞬間移位！'}}},
    {id:'triplePlasma',name:'三重雷電',icon:'W27.jpg',grade:'A',type:'passive',price:30,description:'被動：電漿生成時改為三重放電，並朝不同方向飛行。',effect:{plasmaTriple:true}},
    {id:'thunderDevour',name:'雷神噬',icon:'W28.jpg',grade:'S',type:'passive',price:100,description:'被動：電漿存在時間與飛行速度加倍，每 2 秒於鄰近電漿之間釋放閃電鏈。',effect:{plasmaLifeMultiplier:2,plasmaSpeedMultiplier:2,plasmaChain:{intervalMs:2000,range:220}}},
    {id:'plasmaBloom',name:'雷電展開',icon:'W29.jpg',grade:'A',type:'passive',price:30,description:'被動：電漿消除磚塊時，會在該處再度生成電漿。',effect:{plasmaSpawnOnKill:true}},
    {id:'pierceThunder',name:'穿雷擊',icon:'W30.jpg',grade:'A',type:'passive',price:30,description:'被動：當獲得穿透球效果時，也獲得電漿球效果。',effect:{pierceGrantPlasma:true}},
    {id:'holyJudgment',name:'輝光裁決',icon:'W31.jpg',grade:'S',type:'passive',price:100,description:'被動：神聖球的十字掃蕩升級為米字清線。',effect:{holyPattern:'miz'}},
    {id:'holyBlessing',name:'神聖加持',icon:'W32.jpg',grade:'A',type:'passive',price:30,description:'被動：獲得神聖球時的持續時間翻倍。',effect:{holyDurationMultiplier:2}},
    {id:'ultraSplit',name:'超分裂',icon:'W33.jpg',grade:'B',type:'passive',price:10,description:'被動：獲得多球效果時，球數直接提升到最大值。',effect:{multiAlwaysMax:true}},
    {id:'multiTrack',name:'多重追蹤',icon:'W34.jpg',grade:'A',type:'passive',price:30,description:'被動：獲得追蹤球時同步獲得多球效果，且每顆球鎖定不同目標。',effect:{trackAlsoMulti:true,trackUniqueTargets:true}},
    {id:'multiPierce',name:'多重穿透',icon:'W35.jpg',grade:'A',type:'passive',price:30,description:'被動：獲得穿透球效果時，也獲得多球效果。',effect:{pierceAlsoMulti:true}},
    {id:'multiHell',name:'多重地獄',icon:'W36.jpg',grade:'A',type:'passive',price:30,description:'被動：獲得地獄球效果時，也獲得多球效果。',effect:{hellAlsoMulti:true}},
    {id:'multiMega',name:'多重大球',icon:'W37.jpg',grade:'B',type:'passive',price:10,description:'被動：獲得特大球效果時，也獲得多球效果。',effect:{megaAlsoMulti:true}},
    {id:'pierceMega',name:'巨大穿透',icon:'W38.jpg',grade:'A',type:'passive',price:30,description:'被動：獲得穿透球效果時，也獲得特大球效果。',effect:{pierceAlsoMega:true}},
    {id:'multiPoison',name:'多重劇毒',icon:'W39.jpg',grade:'B',type:'passive',price:10,description:'被動：獲得劇毒球效果時，也獲得多球效果。',effect:{poisonAlsoMulti:true}},
    {id:'doubleMissile',name:'雙倍飛彈',icon:'W40.jpg',grade:'A',type:'passive',price:30,description:'被動：每次發射的飛彈數量翻倍。',effect:{missileDoubleShots:true}},
    {id:'missileVolley',name:'飛彈連射',icon:'W41.jpg',grade:'A',type:'passive',price:30,description:'被動：獲得飛彈球效果時，球擊破磚塊也會發射飛彈。',effect:{missileVolleyOnBreak:true}},
    {id:'deathBarrage',name:'死亡彈幕',icon:'W42.jpg',grade:'S',type:'active',price:100,description:'主動：發射 20 發追蹤飛彈，冷卻時間 60 秒。',effect:{missileBarrage:{count:20,cooldown:60000}}},
    {id:'powderBoost',name:'火藥提升',icon:'W43.jpg',grade:'A',type:'passive',price:30,description:'被動：飛彈擊中時引發 3×3 範圍的大爆炸。',effect:{missileExplosion:true}},
    {id:'plasmaMissile',name:'電漿飛彈',icon:'W44.jpg',grade:'A',type:'passive',price:30,description:'被動：飛彈命中時在落點生成電漿。',effect:{missilePlasma:true}},
    {id:'bombDevil',name:'炸彈惡魔',icon:'W45.jpg',grade:'S',type:'active',price:100,description:'主動：10 秒內球撞磚觸發連鎖爆破，冷卻時間 30 秒。',effect:{bombDevil:{duration:10000,cooldown:30000,intervalMs:300}}},
    {id:'divineMissile',name:'神威飛彈',icon:'W46.jpg',grade:'S',type:'passive',price:100,description:'被動：飛彈命中時追加十字清線。',effect:{missileHolyStrike:true}},
    {id:'crimsonFlame',name:'紅蓮之力',icon:'W47.jpg',grade:'B',type:'passive',price:10,description:'被動：獲得火焰球時立即滿蓄能。',effect:{fireInstantCharge:true}},
    {id:'scatterFirework',name:'散落花火',icon:'W48.jpg',grade:'A',type:'passive',price:30,description:'被動：火焰球爆炸時額外在 3 處引爆花火。',effect:{fireScatter:true}},
    {id:'instantFlare',name:'瞬爆',icon:'W49.jpg',grade:'B',type:'active',price:10,description:'主動：立刻引爆火焰球，冷卻時間 10 秒。',effect:{fireInstantDetonate:{cooldown:10000}}},
    {id:'chainDetonate',name:'連環爆炸',icon:'W50.jpg',grade:'A',type:'active',price:30,description:'主動：立刻引爆場上所有爆炸磚，冷卻時間 10 秒。',effect:{massExplode:{cooldown:10000}}},
    {id:'nuke',name:'核爆',icon:'W51.jpg',grade:'S',type:'consumable',price:100,description:'消耗：發生驚人核爆炸銷毀所有磚塊且 Boss HP-30，自身 HP-1，使用後消失。',effect:{nuke:{bossDamage:30,selfDamage:1}}},
    {id:'poisonSpread',name:'毒性擴散',icon:'W52.jpg',grade:'A',type:'passive',price:30,description:'被動：中毒的磚塊 2 秒後會感染鄰近的磚塊導致其中毒。',effect:{poisonSpread:{delay:2000}}},
    {id:'poisonBoost',name:'毒性加強',icon:'W53.jpg',grade:'B',type:'passive',price:10,description:'被動：中毒的磚塊每秒損失 1 HP。',effect:{poisonTickMs:1000}},
    {id:'poisonBurst',name:'毒性爆發',icon:'W54.jpg',grade:'A',type:'active',price:30,description:'主動：引爆所有中毒的磚塊，冷卻時間 30 秒。',effect:{poisonDetonate:{cooldown:30000}}},
    {id:'greatPlague',name:'大瘟疫',icon:'W55.jpg',grade:'S',type:'active',price:100,description:'主動：場上隨機 15 個磚塊以 0.3 秒間隔依序中毒，冷卻時間 60 秒。',effect:{greatPlague:{count:15,interval:300,cooldown:60000}}},
    {id:'superSymmetry',name:'超對稱',icon:'W56.jpg',grade:'S',type:'active',price:100,description:'主動：強制左右側磚塊對稱，較多的一側不對稱磚塊爆裂，冷卻時間 60 秒。',effect:{mirrorSymmetry:{cooldown:60000}}},
    {id:'poisonPlasma',name:'毒性電漿',icon:'W57.jpg',grade:'B',type:'passive',price:10,description:'被動：磚塊因中毒死亡時會產生電漿。',effect:{poisonPlasma:true}},
    {id:'starForce',name:'星星之力',icon:'W58.jpg',grade:'B',type:'active',price:10,description:'主動：天空隨機 3 處斜向墜落星星，命中造成 4 點傷害，冷卻時間 30 秒。',effect:{starStrike:{count:3,damage:4,cooldown:30000}}},
    {id:'sunForce',name:'太陽之力',icon:'W59.jpg',grade:'A',type:'passive',price:30,description:'被動：使用 Skin「烈陽．炙金幻焰」時，每 10 秒隨機磚塊產生 3×3 爆炸。',effect:{solarBurst:{interval:10000}}},
    {id:'moonForce',name:'月亮之力',icon:'W60.jpg',grade:'A',type:'active',price:30,description:'主動：巨大月亮隨機位置斜向墜落，命中造成 4 點傷害並最多反彈 9 次，冷卻時間 30 秒。',effect:{moonFall:{damage:4,maxBounces:9,cooldown:30000}}},
    {id:'autoLaser',name:'自動雷射',icon:'W61.jpg',grade:'A',type:'active',price:30,description:'主動：獲得自動雷射效果，冷卻時間 60 秒。',effect:{power:{key:'LASER',mode:'active',cooldown:60000,message:'自動雷射啟動！左右砲台全力掃射。'}}},
    {id:'worldFlip',name:'天地翻轉',icon:'W62.jpg',grade:'A',type:'active',price:30,description:'主動：獲得天地翻轉效果，冷卻時間 60 秒。',effect:{power:{key:'FLIP',mode:'active',cooldown:60000,message:'天地翻轉啟動！上下顛倒請小心。'}}},
    {id:'phoenixJudgment',name:'鳳凰審判',icon:'W63.jpg',grade:'S',type:'active',price:100,description:'主動：獲得鳳凰審判效果，冷卻時間 60 秒。',effect:{power:{key:'PHOENIX',mode:'active',cooldown:60000,message:'鳳凰審判啟動！聖焰橫掃全場。'}}},
    {id:'fireSuppression',name:'火力壓制',icon:'W64.jpg',grade:'S',type:'active',price:100,description:'主動：獲得火力壓制效果，冷卻時間 60 秒。',effect:{power:{key:'GATLING',mode:'active',cooldown:60000,message:'火力壓制啟動！機槍掃蕩敵陣。'}}},
    {id:'swordRift',name:'劍芒裂空',icon:'W65.jpg',grade:'A',type:'active',price:30,description:'主動：獲得劍芒裂空效果，冷卻時間 60 秒。',effect:{power:{key:'SWORD',mode:'active',cooldown:60000,message:'劍芒裂空啟動！飛劍出鞘破空。'}}},
    {id:'godspeedFlow',name:'神速流轉',icon:'W66.jpg',grade:'A',type:'active',price:30,description:'主動：獲得神速流轉效果，冷卻時間 60 秒。',effect:{power:{key:'GODSPEED',mode:'active',cooldown:60000,message:'神速流轉啟動！速度突破極限。'}}},
    {id:'laserStorm',name:'雷射風暴',icon:'W67.jpg',grade:'S',type:'active',price:100,description:'主動：獲得雷射風暴效果，冷卻時間 60 秒。',effect:{power:{key:'STORM',mode:'active',cooldown:60000,message:'雷射風暴啟動！全場掃射。'}}},
    {id:'blackholeDevour',name:'黑洞吞噬',icon:'W68.jpg',grade:'A',type:'active',price:30,description:'主動：獲得黑洞吞噬效果，冷卻時間 60 秒。',effect:{power:{key:'BLACKHOLE',mode:'active',cooldown:60000,message:'黑洞吞噬啟動！重力吞沒一切。'}}},
    {id:'annihilation',name:'萬物銷毀',icon:'W69.jpg',grade:'S',type:'active',price:100,description:'主動：獲得萬物銷毀效果，冷卻時間 60 秒。',effect:{power:{key:'ANNIHIL',mode:'active',cooldown:60000,message:'萬物銷毀啟動！毀滅能量席捲。'}}},
    {id:'timeWarp',name:'時間扭曲',icon:'W70.jpg',grade:'S',type:'passive',price:100,description:'被動：裝備冷卻時間縮短為原本的 50%。',effect:{cooldownMultiplier:0.5}},
    {id:'laserModule',name:'雷射裝置',icon:'W71.jpg',grade:'A',type:'passive',price:30,description:'被動：獲得自動雷射或雷射風暴效果時，擊球平台中心多架一個雷射槍，每次雷射時會一起發射。',effect:{laserExtraTurret:true}},
    {id:'laserPlasma',name:'雷射電漿',icon:'W72.jpg',grade:'A',type:'passive',price:30,description:'被動：所有雷射攻擊命中磚塊時產生電漿。',effect:{laserPlasma:true}},
    {id:'laserRapid',name:'連射模式',icon:'W73.jpg',grade:'A',type:'passive',price:30,description:'被動：所有雷射攻擊的間隔時間縮短 50%。',effect:{laserIntervalMultiplier:0.5}},
    {id:'phoenixHeart',name:'鳳凰之心',icon:'W74.jpg',grade:'S',type:'passive',price:100,description:'被動：鳳凰審判效果發生時，平台閃動火焰光芒且 HP +1。',effect:{phoenixHeart:true}},
    {id:'instantBlade',name:'瞬殺劍',icon:'W75.jpg',grade:'A',type:'passive',price:30,description:'被動：劍芒裂空產生的飛劍會馬上射出。',effect:{swordInstantFire:true}},
    {id:'dualBlades',name:'雙劍合璧',icon:'W76.jpg',grade:'A',type:'passive',price:30,description:'被動：劍芒裂空每次產生的飛劍數量變為 2。',effect:{swordDoubleSpawn:true}},
    {id:'endurance',name:'持久力',icon:'W77.jpg',grade:'A',type:'passive',price:30,description:'被動：劍芒裂空、自動雷射、神速流轉的效果持續時間增加 10 秒。',effect:{powerDurationBonus:{SWORD:10000,LASER:10000,GODSPEED:10000}}},
    {id:'godspeedPierce',name:'神速貫穿',icon:'W78.jpg',grade:'S',type:'passive',price:100,description:'被動：獲得神速流轉效果時，也獲得穿透球效果。',effect:{godspeedGrantsPierce:true}},
    {id:'cleanse',name:'淨化',icon:'W79.jpg',grade:'C',type:'consumable',price:5,description:'消耗：立即消除身上所有減益效果，使用後消失。',effect:{cleanse:true}},
    {id:'darkPower',name:'黑暗之力',icon:'W80.jpg',grade:'A',type:'passive',price:30,description:'被動：獲得黑洞吞噬效果時，立即產生黑洞吞噬攻擊。',effect:{blackholeInstantStrike:true}},
    {id:'darkDemon',name:'暗之惡魔',icon:'W81.jpg',grade:'S',type:'active',price:100,description:'主動：每隔 2 秒，全場畫面變黑 1 秒並使所有磚塊 HP-1，共 4 次；對 Boss 傷害為 5 倍，冷卻時間 60 秒。',effect:{darkDemon:{interval:2000,pulses:4,blackoutMs:1000,damage:1,bossMultiplier:5,cooldown:60000}}},
    {id:'infiniteBlade',name:'無限之刃',icon:'W82.jpg',grade:'S',type:'passive',price:100,description:'被動：劍芒裂空於球擊中磚塊時也會產生飛劍，且每次產生的飛劍數量額外 +1。',effect:{swordOnHit:true,swordExtraSpawn:1}},
    {id:'thunderBlade',name:'狂雷劍',icon:'W83.jpg',grade:'A',type:'passive',price:30,description:'被動：飛劍命中時會產生電漿。',effect:{swordPlasma:true}},
    {id:'silverAssault',name:'銀幣攻勢',icon:'W84.jpg',grade:'B',type:'active',price:10,description:'主動：銀幣 -10，下一次球命中的對象 HP-10，冷卻時間 60 秒。',effect:{silverAssault:{cost:10,damage:10,cooldown:60000}}},
    {id:'toxicRebirth',name:'劇毒轉生',icon:'W85.jpg',grade:'A',type:'passive',price:30,description:'被動：當場上中毒的磚塊達 20 個以上時，平台閃動綠色光芒且 HP +2，每關僅觸發 1 次。',effect:{toxicRebirth:{threshold:20,heal:2}}},
    {id:'godspeedBlade',name:'神速聖劍',icon:'W86.jpg',grade:'S',type:'passive',price:100,description:'被動：神速流轉效果期間，每 2 秒在球位置觸發一次神聖十字清線。',effect:{godspeedHolyStrike:{interval:2000}}},
    {id:'blackholePlasma',name:'黑洞電漿',icon:'W87.jpg',grade:'A',type:'passive',price:30,description:'被動：被黑洞銷毀的磚塊會產生電漿。',effect:{blackholePlasma:true}},
    {id:'deathLaser',name:'死亡雷射',icon:'W88.jpg',grade:'A',type:'active',price:30,description:'主動：10 秒內所有被擊殺的磚塊會在該位置產生 1 道雷射，冷卻時間 60 秒。',effect:{deathLaser:{duration:10000,cooldown:60000}}},
    {id:'godClock',name:'神之懷錶',icon:'W89.jpg',grade:'S',type:'active',price:100,description:'主動：立即將目前身上所有效果的剩餘時間延長為原本的 2 倍，冷卻時間 120 秒。',effect:{godClock:{cooldown:120000,multiplier:2}}},
    {id:'gunDemon',name:'槍之惡魔',icon:'W90.jpg',grade:'S',type:'active',price:100,description:'主動：4 秒內每 0.2 秒對隨機 2 個遠距離目標發射狙擊子彈，路徑上的磚塊 HP-1，冷卻時間 60 秒。',effect:{gunDevil:{duration:4000,interval:200,cooldown:60000,targets:2}}}
  ];
  const STORE_CONFIGS=[
    {min:1,max:4,hero:'S01.jpg',probabilities:{C:0.6,B:0.3,A:0.1}},
    {min:5,max:9,hero:'S02.jpg',probabilities:{B:0.7,A:0.28,S:0.02}},
    {min:10,max:14,hero:'S03.jpg',probabilities:{B:0.45,A:0.5,S:0.05}},
    {min:15,max:19,hero:'S04.jpg',probabilities:{B:0.2,A:0.65,S:0.15}}
  ];
  const STORE_GRID_SIZE=9;
  const GRADE_PRIORITY=['S','A','B','C'];
  const EQUIPMENT_BY_GRADE=EQUIPMENT_LIST.reduce((map,item)=>{
    if(!map.has(item.grade)) map.set(item.grade,[]);
    map.get(item.grade).push(item);
    return map;
  },new Map());
  const GRADE_COLOR={S:'#ffe08a',A:'#ff6a82',B:'#69adff',C:'#5fd6a0'};
  const SILVER_COIN_KEY='breakout_silver_coins';
  let silverCoins=0;
  (function(){
    try{
      const stored=localStorage.getItem(SILVER_COIN_KEY);
      if(stored!=null){
        const parsed=parseInt(stored,10);
        if(!Number.isNaN(parsed) && parsed>=0){
          silverCoins=parsed;
        }
      }
    }catch(e){}
  })();

  const equipmentSlots=[null,null,null];
  const equipmentSlotElements=[];
  let currentStoreItems=[];
  const storeItemButtons=new Map();
  const storeInventoryByKey=new Map();
  let selectedStoreItemKey=null;
  let pendingEquipItem=null;
  let pendingSlotIndex=null;
  let pendingNextLevel=null;
  let equipmentMessageUntil=0;
  function getOwnedEquipmentIds(){
    const owned=new Set();
    for(const slot of equipmentSlots){
      if(slot && slot.id){
        owned.add(slot.id);
      }
    }
    return owned;
  }
  let brickDamageBonus=0;
  let equipmentAttractBeneficial=false;
  let equipmentRepelDebuff=false;
  let equipmentBossDamageMultiplier=1;
  let equipmentBossDamageFx=false;
  let equipmentComboStarPermanent=false;
  let equipmentPreventDebuffDrops=false;
  let equipmentSpecialDropRateMultiplier=1;
  let equipmentCurseSwordActive=false;
  let equipmentPlasmaTriple=false;
  let equipmentPlasmaLifeMultiplier=1;
  let equipmentPlasmaSpeedMultiplier=1;
  let equipmentPlasmaChainActive=false;
  let equipmentPlasmaChainInterval=0;
  let equipmentPlasmaChainRange=0;
  let equipmentPlasmaSpawnOnKill=false;
  let equipmentPierceGrantPlasma=false;
  let applyingPierceLinkedPlasma=false;
  let equipmentHolyPattern='cross';
  let equipmentHolyDurationMultiplier=1;
  let equipmentMultiAlwaysMax=false;
  let equipmentTrackAlsoMulti=false;
  let equipmentTrackUniqueTargets=false;
  const trackTargetOwners=new Map();
  let trackBallTargets=new WeakMap();
  let equipmentPierceAlsoMulti=false;
  let equipmentHellAlsoMulti=false;
  let equipmentMegaAlsoMulti=false;
  let equipmentPierceAlsoMega=false;
  let equipmentPoisonAlsoMulti=false;
  let equipmentMissileDoubleShots=false;
  let equipmentMissileVolleyOnBreak=false;
  let equipmentMissileExplosion=false;
  let equipmentMissilePlasma=false;
  let equipmentMissileHolyStrike=false;
  let equipmentFireInstantCharge=false;
  let equipmentFireScatter=false;
  let equipmentLaserExtraTurret=false;
  let equipmentLaserPlasma=false;
  let equipmentLaserIntervalMultiplier=1;
  let equipmentPhoenixHeart=false;
  let equipmentSwordInstantFire=false;
  let equipmentSwordDoubleSpawn=false;
  let equipmentSwordOnHit=false;
  let equipmentSwordExtraSpawn=0;
  let equipmentSwordPlasma=false;
  let equipmentPowerDurationBonusMs={};
  let equipmentGodspeedAlsoPierce=false;
  let equipmentBlackholeInstantStrike=false;
  let equipmentPoisonSpreadDelay=0;
  let equipmentPoisonTickInterval=0;
  let equipmentPoisonPlasma=false;
  let equipmentSolarBurst=false;
  let equipmentSolarBurstInterval=0;
  let equipmentToxicRebirthConfig=null;
  let toxicRebirthTriggered=false;
  let toxicRebirthGlowUntil=0;
  let equipmentCooldownMultiplier=1;
  let equipmentGodspeedHolyStrike=false;
  let equipmentGodspeedHolyInterval=0;
  let equipmentBlackholePlasma=false;
  let silverAssaultCharge=null;
  let silverAssaultSlotIndex=null;
  let nextGodspeedHolyStrike=0;
  let darkDemonPulses=[];
  let darkDemonBlackoutUntil=0;
  let darkDemonBossMultiplier=1;
  let darkDemonDamagePerPulse=0;
  let deathLaserActiveUntil=0;
  let gunDevilActiveUntil=0;
  let gunDevilNextShot=0;
  let gunDevilIntervalMs=200;
  let gunDevilTargetsPerShot=2;
  let solarBurstNextAt=0;
  let plasmaChainNextAt=0;
  let applyingLinkedMulti=false;
  let applyingLinkedMega=false;
  let applyingGodspeedLinkedPierce=false;
  const BLOOD_BLADE_DEFAULTS={damageMultiplier:3,duration:10000,cooldown:60000,hpCost:1};
  const BOMB_DEVIL_DEFAULTS={duration:10000,cooldown:30000,intervalMs:300};
  const BOMB_DEVIL_BOSS_CHAIN_COUNT=5;
  const BOMB_DEVIL_BOSS_CHAIN_DELAY=160;
  const FIRE_SCATTER_COUNT=3;
  const FIRE_SCATTER_DELAY=500;
  const FIRE_MAX_CHARGE=16;
  let bombDevilActiveUntil=0;
  let bombDevilIntervalMs=BOMB_DEVIL_DEFAULTS.intervalMs;
  const bombDevilQueues=[];
  const bombDevilRowCooldown=new Map();
  const bombDevilBossQueues=[];
  const fireScatterQueue=[];
  let bloodBladeActive=false;
  let bloodBladeActiveUntil=0;
  let bloodBladeDamageMultiplier=BLOOD_BLADE_DEFAULTS.damageMultiplier;
  const shieldState={active:false,until:0,source:null,activatedAt:0,duration:0};
  const shieldRipples=[];
  const SHIELD_RIPPLE_DURATION=720;
  let lastShieldAbsorbAt=0;

  function getEquipmentById(id){
    if(!id) return null;
    return EQUIPMENT_LIST.find(item=>item.id===id)||null;
  }
  function getStoreConfigForLevel(level){
    const target=Math.max(1,Math.floor(level||1));
    for(const cfg of STORE_CONFIGS){
      if(target>=cfg.min && target<=cfg.max) return cfg;
    }
    return STORE_CONFIGS[STORE_CONFIGS.length-1];
  }
  function rollGrade(probabilities){
    const entries=Object.entries(probabilities||{});
    if(entries.length===0) return 'C';
    let total=0;
    for(const [,val] of entries){
      total+=Number(val)||0;
    }
    if(total<=0) return entries[entries.length-1][0];
    let r=Math.random()*total;
    for(const [grade,val] of entries){
      r-=(Number(val)||0);
      if(r<=0) return grade;
    }
    return entries[entries.length-1][0];
  }
  function pickEquipmentForGrade(desiredGrade, usedItemIds, excludeIds){
    const isExcluded=id=>{
      if(!id) return false;
      if(usedItemIds && usedItemIds.has(id)) return true;
      if(excludeIds && excludeIds.has(id)) return true;
      return false;
    };
    const order=[desiredGrade,...GRADE_PRIORITY.filter(g=>g!==desiredGrade)];
    for(const grade of order){
      const pool=EQUIPMENT_BY_GRADE.get(grade);
      if(pool && pool.length){
        const candidates=pool.filter(item=>!isExcluded(item.id));
        if(candidates.length){
          return candidates[Math.floor(Math.random()*candidates.length)];
        }
      }
    }
    const fallbackPool=EQUIPMENT_LIST.filter(item=>!isExcluded(item.id));
    if(fallbackPool.length){
      return fallbackPool[Math.floor(Math.random()*fallbackPool.length)];
    }
    return null;
  }
  function generateStoreInventoryForLevel(level){
    const cfg=getStoreConfigForLevel(level);
    if(storeHeroImg && cfg.hero){
      storeHeroImg.src=`images/${cfg.hero}`;
      const label=cfg.hero.replace(/\.[^.]+$/, '');
      storeHeroImg.alt=`商店店員 ${label}`;
    }
    currentStoreItems=[];
    const usedItemIds=new Set();
    const ownedIds=getOwnedEquipmentIds();
    for(let i=0;i<STORE_GRID_SIZE;i++){
      const desired=rollGrade(cfg.probabilities);
      const item=pickEquipmentForGrade(desired,usedItemIds,ownedIds);
      if(item){
        const key=`${item.id}#${level}-${i}-${Math.random().toString(36).slice(2,6)}`;
        currentStoreItems.push({key,item});
        usedItemIds.add(item.id);
      }else{
        break;
      }
    }
    if(!currentStoreItems.length){
      currentStoreItems=EQUIPMENT_LIST.slice(0,STORE_GRID_SIZE).map((item,idx)=>({key:`${item.id}#fallback-${idx}`,item}));
    }
  }
  function renderStoreItems(){
    if(!storeGrid) return;
    storeGrid.innerHTML='';
    storeItemButtons.clear();
    storeInventoryByKey.clear();
    for(const entry of currentStoreItems){
      const item=entry.item;
      const btn=document.createElement('button');
      btn.type='button';
      btn.className=`shop-item grade-${item.grade}`;
      btn.dataset.id=item.id;
      btn.dataset.key=entry.key;
      const thumb=document.createElement('div');
      thumb.className='shop-thumb';
      const img=document.createElement('img');
      img.src=`images/${item.icon}`;
      img.alt=item.name;
      thumb.appendChild(img);
      const badge=document.createElement('span');
      badge.className='tier-badge';
      badge.textContent=item.roman||'';
      thumb.appendChild(badge);
      btn.appendChild(thumb);
      const name=document.createElement('span');
      name.className='shop-name';
      name.textContent=item.name;
      btn.appendChild(name);
      const price=document.createElement('span');
      price.className='shop-price';
      price.textContent=`${item.price} 銀幣`;
      btn.appendChild(price);
      btn.addEventListener('click',()=>selectStoreItem(entry.key));
      storeGrid.appendChild(btn);
      storeItemButtons.set(entry.key,btn);
      storeInventoryByKey.set(entry.key,item);
    }
  }
  function selectStoreItem(key,opts={}){
    selectedStoreItemKey=key;
    for(const [itemKey,btn] of storeItemButtons.entries()){
      btn.classList.toggle('selected',itemKey===key);
    }
    const item=key?storeInventoryByKey.get(key):null;
    updateStoreDetail(item);
    if(!opts.silent){
      if(storeFeedback) storeFeedback.textContent=item?'':'請選擇一件裝備。';
    }
    refreshStoreAffordability();
  }
  function updateStoreDetail(item){
    if(!storeItemName||!storeItemMeta||!storeItemDesc||!storeItemPrice){
      return;
    }
    if(!item){
      storeItemName.textContent='選擇一件裝備';
      storeItemPrice.textContent='—';
      storeItemMeta.innerHTML='';
      storeItemDesc.textContent='完成關卡後可使用銀幣購買裝備。';
      return;
    }
    storeItemName.textContent=item.name;
    storeItemPrice.textContent=`${item.price} 銀幣`;
    const gradeColor=GRADE_COLOR[item.grade]||'#f0f6ff';
    const typeLabel=EQUIPMENT_TYPE_LABEL[item.type]||'';
    storeItemMeta.innerHTML=`<span>等級：<strong style="color:${gradeColor}">${item.grade}</strong></span><span>類型：${typeLabel}</span>`;
    storeItemDesc.textContent=item.description;
  }
  function refreshStoreAffordability(){
    if(!storeBuyBtn) return;
    if(slotModal && slotModal.classList.contains('show')){
      storeBuyBtn.disabled=true;
      return;
    }
    const item=selectedStoreItemKey?storeInventoryByKey.get(selectedStoreItemKey):null;
    const canBuy=!!item && silverCoins>=item.price;
    storeBuyBtn.disabled=!canBuy;
  }
  function handleStorePurchase(){
    if(slotModal && slotModal.classList.contains('show')) return;
    const item=selectedStoreItemKey?storeInventoryByKey.get(selectedStoreItemKey):null;
    if(!item){
      if(storeFeedback) storeFeedback.textContent='請選擇一件裝備。';
      return;
    }
    if(silverCoins<item.price){
      if(storeFeedback) storeFeedback.textContent=`銀幣不足，尚需 ${item.price-silverCoins} 枚銀幣。`;
      return;
    }
    if(!spendSilverCoins(item.price)) return;
    if(storeFeedback) storeFeedback.textContent=`已購買「${item.name}」，請選擇裝備欄位。`;
    promptEquipSlot(item);
  }
  const CODEX_PAGE_SIZE=10;
  let codexPageIndex=0;
  function getCodexTotalPages(){
    if(!EQUIPMENT_LIST.length) return 1;
    return Math.max(1,Math.ceil(EQUIPMENT_LIST.length/CODEX_PAGE_SIZE));
  }
  function renderCodexPage(){
    if(!codexList) return;
    codexList.innerHTML='';
    codexList.scrollTop=0;
    const total=getCodexTotalPages();
    const start=codexPageIndex*CODEX_PAGE_SIZE;
    const slice=EQUIPMENT_LIST.slice(start,start+CODEX_PAGE_SIZE);
    if(slice.length===0){
      const empty=document.createElement('div');
      empty.className='codex-entry codex-empty';
      empty.textContent='尚未收錄任何裝備。';
      codexList.appendChild(empty);
    }
    slice.forEach((item, idx)=>{
      const numberValue=start+idx+1;
      const numberLabel=`No. ${String(numberValue).padStart(2,'0')}`;
      const entry=document.createElement('div');
      entry.className=`codex-entry grade-${item.grade}`;
      entry.setAttribute('role','listitem');
      entry.setAttribute('data-codex-number',String(numberValue));
      const iconWrap=document.createElement('div');
      iconWrap.className='codex-icon';
      const img=document.createElement('img');
      img.src=`images/${item.icon}`;
      img.alt=item.name;
      iconWrap.appendChild(img);
      entry.appendChild(iconWrap);
      const info=document.createElement('div');
      info.className='codex-info';
      const header=document.createElement('div');
      header.className='codex-header';
      const numberSpan=document.createElement('span');
      numberSpan.className='codex-number';
      numberSpan.textContent=numberLabel;
      header.appendChild(numberSpan);
      const title=document.createElement('h3');
      title.className='codex-title';
      title.textContent=item.name;
      header.appendChild(title);
      info.appendChild(header);
      const idLine=document.createElement('div');
      idLine.className='codex-id';
      idLine.textContent=`編號：${item.id}`;
      info.appendChild(idLine);
      const meta=document.createElement('div');
      meta.className='codex-meta';
      const gradeSpan=document.createElement('span');
      gradeSpan.textContent=`等級 ${item.grade}`;
      meta.appendChild(gradeSpan);
      const typeLabel=EQUIPMENT_TYPE_LABEL[item.type]||item.type||'';
      if(typeLabel){
        const typeSpan=document.createElement('span');
        typeSpan.textContent=`類型 ${typeLabel}`;
        meta.appendChild(typeSpan);
      }
      const priceSpan=document.createElement('span');
      priceSpan.textContent=`價格 ${item.price} 銀幣`;
      meta.appendChild(priceSpan);
      info.appendChild(meta);
      const desc=document.createElement('p');
      desc.className='codex-desc';
      desc.textContent=item.description;
      info.appendChild(desc);
      entry.appendChild(info);
      codexList.appendChild(entry);
    });
    if(codexPageIndicator){
      const pageDisplay=Math.min(total, codexPageIndex+1);
      codexPageIndicator.textContent=`${pageDisplay} / ${total}`;
    }
    if(codexPrev) codexPrev.disabled=codexPageIndex<=0;
    if(codexNext) codexNext.disabled=codexPageIndex>=total-1;
  }
  function openCodex(){
    codexPageIndex=0;
    renderCodexPage();
    if(codexOverlay){
      codexOverlay.classList.add('show');
      codexOverlay.setAttribute('aria-hidden','false');
    }
    document.body.classList.add('modal-open');
    const optMenuEl=document.getElementById('optMenu');
    const optBtnEl=document.getElementById('optBtn');
    optMenuEl?.classList.remove('show');
    optBtnEl?.setAttribute('aria-expanded','false');
    window.__setMenuPause?.(true);
  }
  function closeCodex(){
    if(!codexOverlay) return;
    codexOverlay.classList.remove('show');
    codexOverlay.setAttribute('aria-hidden','true');
    if(!storeOverlay?.classList.contains('show')){
      document.body.classList.remove('modal-open');
    }
    if(!menusOpen()) window.__setMenuPause?.(false);
  }
  function promptEquipSlot(item){
    if(!slotModal) return;
    pendingEquipItem=item;
    pendingSlotIndex=null;
    renderSlotSelection();
    if(slotConfirm) slotConfirm.classList.remove('show');
    slotModal.classList.add('show');
    slotModal.setAttribute('aria-hidden','false');
    if(typeof slotModal.scrollIntoView==='function'){
      slotModal.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    equipmentBar?.classList.add('selecting');
    if(storeBuyBtn) storeBuyBtn.disabled=true;
    if(storeNextBtn) storeNextBtn.disabled=true;
  }
  function renderSlotSelection(){
    if(!slotGrid) return;
    slotGrid.innerHTML='';
    equipmentSlots.forEach((slot,idx)=>{
      const btn=document.createElement('button');
      btn.type='button';
      btn.className='slot-choice';
      if(!slot) btn.classList.add('empty');
      btn.dataset.index=String(idx);
      const name=document.createElement('div');
      name.className='slot-name';
      name.textContent=slot?`欄位 ${idx+1}：${slot.def.name}`:`欄位 ${idx+1}`;
      btn.appendChild(name);
      const note=document.createElement('div');
      note.className='slot-note';
      note.textContent=slot?`目前裝備：${slot.def.name}`:'尚未裝備';
      btn.appendChild(note);
      btn.addEventListener('click',()=>handleSlotChoice(idx));
      slotGrid.appendChild(btn);
    });
  }
  function handleSlotChoice(index){
    if(pendingEquipItem==null) return;
    pendingSlotIndex=index;
    if(slotConfirmText){
      const existing=equipmentSlots[index];
      slotConfirmText.textContent=existing
        ? `欄位 ${index+1} 目前裝備「${existing.def.name}」，是否改為「${pendingEquipItem.name}」？`
        : `要將「${pendingEquipItem.name}」裝備到欄位 ${index+1} 嗎？`;
    }
    if(slotConfirm) slotConfirm.classList.add('show');
  }
  function closeSlotModal(restoreButtons=true){
    if(!slotModal) return;
    slotModal.classList.remove('show');
    slotModal.setAttribute('aria-hidden','true');
    if(slotConfirm) slotConfirm.classList.remove('show');
    equipmentBar?.classList.remove('selecting');
    pendingEquipItem=null;
    pendingSlotIndex=null;
    if(restoreButtons){
      if(storeBuyBtn) refreshStoreAffordability();
      if(storeNextBtn) storeNextBtn.disabled=false;
    }
  }
  function createSlotState(itemDef){
    const baseCooldown=Math.max(0, Number(itemDef.effect?.cooldown)||Number(itemDef.effect?.power?.cooldown)||0);
    return {
      id:itemDef.id,
      def:itemDef,
      type:itemDef.type,
      grade:itemDef.grade,
      roman:itemDef.roman,
      cooldownUntil:0,
      cooldownDuration:baseCooldown,
      cooldownStarted:0,
      lastUsed:0,
      activeUntil:0,
      activeDuration:0,
      pendingRemoval:false,
      baseCooldownDuration:baseCooldown
    };
  }
  function exportEquipmentSlots(){
    const now=performance.now();
    return equipmentSlots.map((slot)=>{
      if(!slot) return null;
      const snapshot={id:slot.id};
      if(slot.def.type==='active' && slot.cooldownUntil && slot.cooldownUntil>now){
        snapshot.cooldownRemainingMs=Math.round(Math.max(0, slot.cooldownUntil-now));
        if(Number.isFinite(slot.cooldownDuration) && slot.cooldownDuration>0){
          snapshot.cooldownDurationMs=Math.round(slot.cooldownDuration);
        }
      }
      if(slot.activeUntil && slot.activeUntil>now){
        snapshot.activeRemainingMs=Math.round(Math.max(0, slot.activeUntil-now));
        if(Number.isFinite(slot.activeDuration) && slot.activeDuration>0){
          snapshot.activeDurationMs=Math.round(slot.activeDuration);
        }
        if(slot.pendingRemoval) snapshot.pendingRemoval=true;
      }
      if(Number.isFinite(slot.baseCooldownDuration) && slot.baseCooldownDuration>0){
        snapshot.baseCooldownDurationMs=Math.round(slot.baseCooldownDuration);
      }
      return snapshot;
    });
  }
  function importEquipmentSlots(snapshot){
    if(!Array.isArray(snapshot)){
      clearEquipmentSlots();
      return;
    }
    const now=performance.now();
    bloodBladeActive=false;
    bloodBladeActiveUntil=0;
    bloodBladeDamageMultiplier=BLOOD_BLADE_DEFAULTS.damageMultiplier;
    for(let i=0;i<equipmentSlots.length;i++){
      const entry=snapshot[i];
      if(entry&&typeof entry.id==='string'){
        const def=getEquipmentById(entry.id);
        if(def){
          const state=createSlotState(def);
          if(def.type==='active'&&typeof entry.cooldownRemainingMs==='number'&&entry.cooldownRemainingMs>0){
            const remainingMs=Math.max(0, entry.cooldownRemainingMs);
            state.cooldownUntil=now+remainingMs;
            const snapshotDuration=Number(entry.cooldownDurationMs);
            if(Number.isFinite(snapshotDuration) && snapshotDuration>0){
              state.cooldownDuration=snapshotDuration;
            }else{
              state.cooldownDuration=Math.max(state.cooldownDuration, remainingMs, Number(def.effect?.cooldown)||0);
            }
            state.cooldownStarted=Math.max(0, state.cooldownUntil-state.cooldownDuration);
          }
          if(typeof entry.activeRemainingMs==='number'&&entry.activeRemainingMs>0){
            const remaining=Math.max(0, entry.activeRemainingMs);
            const durationVal=Number(entry.activeDurationMs);
            const duration=Number.isFinite(durationVal)&&durationVal>0?durationVal:remaining;
            state.activeUntil=now+remaining;
            state.activeDuration=duration;
            state.lastUsed=Math.max(0, state.activeUntil-duration);
            state.pendingRemoval=!!entry.pendingRemoval;
            if(state.def.effect?.bloodBlade){
              bloodBladeActiveUntil=Math.max(bloodBladeActiveUntil,state.activeUntil);
              bloodBladeActive=true;
              const mul=Number(state.def.effect.bloodBlade?.damageMultiplier)||BLOOD_BLADE_DEFAULTS.damageMultiplier;
              bloodBladeDamageMultiplier=Math.max(1, mul);
            }
          }
          let baseCooldown=Math.max(0, Number(entry.baseCooldownDurationMs)||0);
          if(!(baseCooldown>0)){
            const defCooldown=Math.max(0, Number(state.def.effect?.cooldown)||Number(state.def.effect?.power?.cooldown)||0);
            if(defCooldown>0){
              baseCooldown=defCooldown;
            }else if(Number.isFinite(state.cooldownDuration) && state.cooldownDuration>0){
              baseCooldown=state.cooldownDuration;
            }else{
              baseCooldown=0;
            }
          }
          state.baseCooldownDuration=baseCooldown;
          equipmentSlots[i]=state;
          continue;
        }
      }
      equipmentSlots[i]=null;
    }
    recalcEquipmentBonuses();
    renderEquipmentSlots();
    bloodBladeActive=bloodBladeActiveUntil>now;
    refreshEquipmentRuntime(performance.now());
  }
  function clearEquipmentSlots(){
    for(let i=0;i<equipmentSlots.length;i++){
      equipmentSlots[i]=null;
    }
    recalcEquipmentBonuses();
    renderEquipmentSlots();
    equipmentMessageUntil=0;
    refreshEquipmentRuntime(performance.now());
    bloodBladeActive=false;
    bloodBladeActiveUntil=0;
    bloodBladeDamageMultiplier=BLOOD_BLADE_DEFAULTS.damageMultiplier;
    shieldState.active=false;
    shieldState.until=0;
    shieldState.source=null;
    shieldState.activatedAt=0;
    shieldState.duration=0;
    updateShieldVisual();
    updateEquipmentHint();
  }
  function equipItemToSlot(index,itemDef){
    if(index<0||index>=equipmentSlots.length) return;
    equipmentSlots[index]=createSlotState(itemDef);
    recalcEquipmentBonuses();
    renderEquipmentSlots();
    showEquipmentMessage(`「${itemDef.name}」已裝備於欄位 ${index+1}`,'success',2600);
  }
  function renderEquipmentSlots(){
    if(!equipmentSlotsEl) return;
    equipmentSlotsEl.innerHTML='';
    equipmentSlotElements.length=0;
    const svgNS='http://www.w3.org/2000/svg';
    equipmentSlots.forEach((slot,idx)=>{
      const btn=document.createElement('button');
      btn.type='button';
      btn.className='equip-slot';
      btn.dataset.index=String(idx);
      if(slot){
        btn.classList.add(`grade-${slot.def.grade}`);
      }else{
        btn.classList.add('empty');
      }
      const name=document.createElement('span');
      name.className='equip-name';
      name.textContent=slot?slot.def.name:`欄位 ${idx+1}`;
      btn.appendChild(name);
      if(slot){
        btn.title=slot.def.description||'';
        const type=document.createElement('span');
        type.className='equip-type';
        type.textContent=EQUIPMENT_TYPE_LABEL[slot.def.type]||'';
        btn.appendChild(type);
      }
      else{
        btn.title=`欄位 ${idx+1}`;
      }
      const iconWrapper=document.createElement('div');
      iconWrapper.className='equip-button';
      let activeOverlay=null;
      let activeLabel=null;
      let activeCircle=null;
      if(slot){
        const img=document.createElement('img');
        img.src=`images/${slot.def.icon}`;
        img.alt=slot.def.name;
        img.draggable=false;
        img.setAttribute('draggable','false');
        iconWrapper.appendChild(img);
        if(slot.def.roman){
          const badge=document.createElement('span');
          badge.className='tier-badge';
          badge.textContent=slot.def.roman;
          iconWrapper.appendChild(badge);
        }
        activeOverlay=document.createElement('span');
        activeOverlay.className='equip-active-overlay';
        iconWrapper.appendChild(activeOverlay);
      }
      const cooldownCover=document.createElement('span');
      cooldownCover.className='equip-cooldown-cover';
      iconWrapper.appendChild(cooldownCover);
      const cooldownLabel=document.createElement('span');
      cooldownLabel.className='equip-cooldown-label';
      iconWrapper.appendChild(cooldownLabel);
      const cooldownSvg=document.createElementNS(svgNS,'svg');
      cooldownSvg.setAttribute('viewBox','0 0 44 44');
      cooldownSvg.classList.add('equip-cooldown-ring');
      const cooldownCircle=document.createElementNS(svgNS,'circle');
      cooldownCircle.setAttribute('cx','22');
      cooldownCircle.setAttribute('cy','22');
      cooldownCircle.setAttribute('r','20');
      cooldownCircle.setAttribute('pathLength','1');
      cooldownSvg.appendChild(cooldownCircle);
      iconWrapper.appendChild(cooldownSvg);
      if(slot){
        const activeSvg=document.createElementNS(svgNS,'svg');
        activeSvg.setAttribute('viewBox','0 0 48 48');
        activeSvg.classList.add('equip-active-ring');
        activeCircle=document.createElementNS(svgNS,'circle');
        activeCircle.setAttribute('cx','24');
        activeCircle.setAttribute('cy','24');
        activeCircle.setAttribute('r','20');
        activeCircle.setAttribute('pathLength','1');
        activeSvg.appendChild(activeCircle);
        iconWrapper.appendChild(activeSvg);
        activeLabel=document.createElement('span');
        activeLabel.className='equip-active-label';
        activeLabel.textContent='啟動中';
        iconWrapper.appendChild(activeLabel);
      }
      btn.appendChild(iconWrapper);
      const status=document.createElement('span');
      status.className='equip-status';
      if(slot){
        if(slot.def.type==='active'){
          status.textContent='點擊啟動';
        }else{
          status.textContent='';
        }
      }else{
        status.textContent='未裝備';
      }
      btn.appendChild(status);
      if(slot){
        const effect=document.createElement('span');
        effect.className='equip-effect';
        effect.textContent=slot.def.description||'';
        btn.appendChild(effect);
        const showEffect=()=>{
          btn.classList.add('show-effect');
        };
        const hideEffect=()=>{
          btn.classList.remove('show-effect');
        };
        btn.addEventListener('pointerdown',(ev)=>{
          if(ev.button!=null && ev.button!==0) return;
          if(typeof ev.pointerId==='number' && btn.setPointerCapture){
            try{btn.setPointerCapture(ev.pointerId);}catch(e){}
          }
          showEffect();
        });
        btn.addEventListener('pointerup',(ev)=>{
          if(typeof ev.pointerId==='number' && btn.hasPointerCapture?.(ev.pointerId)){
            try{btn.releasePointerCapture(ev.pointerId);}catch(e){}
          }
          hideEffect();
        });
        btn.addEventListener('pointerleave',hideEffect);
        btn.addEventListener('pointercancel',hideEffect);
        btn.addEventListener('lostpointercapture',hideEffect);
        btn.addEventListener('keydown',(ev)=>{
          if(ev.code==='Space'||ev.code==='Enter'){
            showEffect();
          }
        });
        btn.addEventListener('keyup',(ev)=>{
          if(ev.code==='Space'||ev.code==='Enter'){
            hideEffect();
          }
        });
        btn.addEventListener('blur',hideEffect);
        equipmentSlotElements.push({button:btn,statusEl:status,index:idx,cooldownLabel,cooldownCircle,cooldownCover,activeCircle,activeOverlay,activeLabel});
      }else{
        equipmentSlotElements.push({button:btn,statusEl:null,index:idx,cooldownLabel:null,cooldownCircle:null,cooldownCover:null,activeCircle:null,activeOverlay:null,activeLabel:null});
      }
      equipmentSlotsEl.appendChild(btn);
    });
    updateEquipmentHint();
  }
  function updateEquipmentHint(){
    if(!equipmentMessageEl) return;
    if(equipmentMessageUntil) return;
    const hasEquip=equipmentSlots.some(Boolean);
    equipmentMessageEl.textContent=hasEquip?'':'尚未裝備任何武器。';
    equipmentMessageEl.classList.remove('tone-success','tone-warning','tone-info');
  }
  function showEquipmentMessage(text,tone='info',duration=2400){
    if(!equipmentMessageEl) return;
    equipmentMessageEl.textContent=text||'';
    equipmentMessageEl.classList.remove('tone-success','tone-warning','tone-info');
    if(tone==='success') equipmentMessageEl.classList.add('tone-success');
    else if(tone==='warning') equipmentMessageEl.classList.add('tone-warning');
    else equipmentMessageEl.classList.add('tone-info');
    equipmentMessageUntil=performance.now()+Math.max(0,duration||2000);
  }
  function refreshEquipmentRuntime(now){
    const updateActiveVisual=(entry,slot,remainMs)=>{
      if(entry.activeCircle){
        const totalMs=(Number.isFinite(slot.activeDuration)&&slot.activeDuration>0)
          ? slot.activeDuration
          : Math.max(0,(slot.activeUntil||0)-(slot.lastUsed||0));
        if(totalMs>0){
          const remainRatio=Math.min(1, Math.max(0, remainMs/totalMs));
          entry.activeCircle.style.strokeDashoffset=(1-remainRatio).toFixed(4);
          if(entry.activeOverlay){
            entry.activeOverlay.style.setProperty('--active-progress', remainRatio.toFixed(4));
          }
        }else{
          entry.activeCircle.style.strokeDashoffset='0';
          if(entry.activeOverlay){
            entry.activeOverlay.style.setProperty('--active-progress','0');
          }
        }
      }else if(entry.activeOverlay){
        entry.activeOverlay.style.setProperty('--active-progress','0');
      }
      if(entry.activeLabel){
        const remainSec=remainMs/1000;
        let labelText;
        if(remainSec>=9.5){
          labelText=`${Math.ceil(remainSec)}s`;
        }else if(remainSec>=1){
          labelText=Math.max(0,remainSec).toFixed(1).replace(/\.0$/, '')+'s';
        }else{
          labelText=Math.max(0,remainSec).toFixed(1)+'s';
        }
        entry.activeLabel.textContent=labelText;
      }
    };
    for(const entry of equipmentSlotElements){
      const slot=equipmentSlots[entry.index];
      if(!slot||!entry.statusEl) continue;
      const activeRemain=slot.activeUntil && now<slot.activeUntil;
      entry.button.classList.toggle('cooldown',false);
      let manualActive=false;
      if(slot.def.effect?.silverAssault && silverAssaultCharge && silverAssaultSlotIndex===entry.index){
        manualActive=true;
      }
      entry.button.classList.toggle('active',activeRemain||manualActive);
      if(entry.cooldownLabel) entry.cooldownLabel.textContent='';
      if(entry.cooldownCircle) entry.cooldownCircle.style.strokeDashoffset='1';
      if(entry.cooldownCover) entry.cooldownCover.style.setProperty('--cooldown-progress','0');
      if(entry.activeCircle) entry.activeCircle.style.strokeDashoffset='1';
      if(entry.activeOverlay) entry.activeOverlay.style.setProperty('--active-progress','0');
      if(entry.activeLabel) entry.activeLabel.textContent='';
      if(slot.def.type==='passive'){
        entry.statusEl.textContent='';
        entry.button.classList.remove('cooldown');
      }else if(slot.def.type==='active'){
        if(activeRemain){
          const remainMs=Math.max(0, slot.activeUntil-now);
          const remain=remainMs/1000;
          entry.statusEl.textContent=`持續中 ${remain>=9?Math.ceil(remain):Math.max(0,remain).toFixed(1)}s`;
          updateActiveVisual(entry,slot,remainMs);
        }else if(slot.cooldownUntil && now<slot.cooldownUntil){
          const remainMs=Math.max(0, slot.cooldownUntil-now);
          const remain=remainMs/1000;
          entry.statusEl.textContent=`冷卻中 ${remain>=9?Math.ceil(remain):Math.max(0,remain).toFixed(1)}s`;
          entry.button.classList.add('cooldown');
          const totalMs=slot.cooldownDuration>0?slot.cooldownDuration:Math.max(remainMs, Number(slot.def.effect?.cooldown)||0);
          if(totalMs>0){
            slot.cooldownDuration=totalMs;
            slot.cooldownStarted=Math.max(0, slot.cooldownUntil-totalMs);
            if(entry.cooldownCircle){
              const remainRatio=Math.min(1, Math.max(0, remainMs/totalMs));
              entry.cooldownCircle.style.strokeDashoffset=(1-remainRatio).toFixed(4);
            }
            if(entry.cooldownCover){
              const remainRatio=Math.min(1, Math.max(0, remainMs/totalMs));
              const areaRatio=Math.sqrt(remainRatio);
              entry.cooldownCover.style.setProperty('--cooldown-progress', areaRatio.toFixed(4));
            }
          }else if(entry.cooldownCircle){
            entry.cooldownCircle.style.strokeDashoffset='0';
          }
          if(totalMs<=0 && entry.cooldownCover){
            entry.cooldownCover.style.setProperty('--cooldown-progress','0');
          }
          if(entry.cooldownCover && !slot.cooldownUntil){
            entry.cooldownCover.style.setProperty('--cooldown-progress','0');
          }
          if(entry.cooldownLabel){
            let labelText;
            if(remain>=9.5){
              labelText=String(Math.ceil(remain));
            }else if(remain>=1){
              labelText=Math.max(0,remain).toFixed(1).replace(/\.0$/, '');
            }else{
              labelText=Math.max(0,remain).toFixed(1);
            }
            entry.cooldownLabel.textContent=labelText;
          }
        }else{
          entry.statusEl.textContent='點擊啟動';
        }
      }else if(slot.def.type==='consumable'){
        if(activeRemain){
          const remainMs=Math.max(0, slot.activeUntil-now);
          const remain=remainMs/1000;
          entry.statusEl.textContent=`持續中 ${remain>=9?Math.ceil(remain):Math.max(0,remain).toFixed(1)}s`;
          updateActiveVisual(entry,slot,remainMs);
        }else{
          entry.statusEl.textContent='';
        }
      }
      if(slot.def.effect?.silverAssault){
        if(silverAssaultCharge && silverAssaultSlotIndex===entry.index){
          const dmg=Math.max(1, silverAssaultCharge.damage||0);
          entry.statusEl.textContent=`待命：下一擊 -${dmg}HP`;
        }
      }
    }
    if(equipmentMessageUntil && now>equipmentMessageUntil){
      equipmentMessageUntil=0;
      updateEquipmentHint();
    }
  }
  function recalcEquipmentBonuses(){
    const prevCooldownMultiplier=equipmentCooldownMultiplier;
    brickDamageBonus=0;
    equipmentAttractBeneficial=false;
    equipmentRepelDebuff=false;
    equipmentBossDamageMultiplier=1;
    equipmentBossDamageFx=false;
    equipmentComboStarPermanent=false;
    equipmentPreventDebuffDrops=false;
    equipmentSpecialDropRateMultiplier=1;
    equipmentCurseSwordActive=false;
    equipmentPlasmaTriple=false;
    equipmentPlasmaLifeMultiplier=1;
    equipmentPlasmaSpeedMultiplier=1;
    equipmentPlasmaChainActive=false;
    equipmentPlasmaChainInterval=0;
    equipmentPlasmaChainRange=0;
    equipmentPlasmaSpawnOnKill=false;
    equipmentPierceGrantPlasma=false;
    applyingPierceLinkedPlasma=false;
    equipmentHolyPattern='cross';
    equipmentHolyDurationMultiplier=1;
    equipmentMultiAlwaysMax=false;
    equipmentTrackAlsoMulti=false;
    equipmentTrackUniqueTargets=false;
    equipmentPierceAlsoMulti=false;
    equipmentHellAlsoMulti=false;
    equipmentMegaAlsoMulti=false;
    equipmentPierceAlsoMega=false;
    equipmentPoisonAlsoMulti=false;
    equipmentMissileDoubleShots=false;
    equipmentMissileVolleyOnBreak=false;
    equipmentMissileExplosion=false;
    equipmentMissilePlasma=false;
    equipmentMissileHolyStrike=false;
    equipmentFireInstantCharge=false;
    equipmentFireScatter=false;
    equipmentLaserExtraTurret=false;
    equipmentLaserPlasma=false;
    equipmentLaserIntervalMultiplier=1;
    equipmentPhoenixHeart=false;
    equipmentSwordInstantFire=false;
    equipmentSwordDoubleSpawn=false;
    equipmentSwordOnHit=false;
    equipmentSwordExtraSpawn=0;
    equipmentSwordPlasma=false;
    equipmentPowerDurationBonusMs={};
    equipmentGodspeedAlsoPierce=false;
    equipmentBlackholeInstantStrike=false;
    equipmentPoisonSpreadDelay=0;
    equipmentPoisonTickInterval=0;
    equipmentPoisonPlasma=false;
    equipmentSolarBurst=false;
    equipmentSolarBurstInterval=0;
    equipmentToxicRebirthConfig=null;
    equipmentCooldownMultiplier=1;
    solarBurstNextAt=0;
    plasmaChainNextAt=0;
    equipmentGodspeedHolyStrike=false;
    equipmentGodspeedHolyInterval=0;
    equipmentBlackholePlasma=false;
    for(const slot of equipmentSlots){
      if(!slot) continue;
      const effect=slot.def.effect||{};
      if(effect.brickDamage){
        brickDamageBonus+=effect.brickDamage;
      }
      if(effect.attract) equipmentAttractBeneficial=true;
      if(effect.repel) equipmentRepelDebuff=true;
      if(effect.bossDamageMultiplier){
        const mul=Math.max(1, Number(effect.bossDamageMultiplier)||1);
        equipmentBossDamageMultiplier*=mul;
      }
      if(effect.bossDamageFx) equipmentBossDamageFx=true;
      if(effect.comboStar?.mode==='passive') equipmentComboStarPermanent=true;
      if(effect.preventDebuffDrops) equipmentPreventDebuffDrops=true;
      if(effect.specialDropRateMultiplier){
        const mul=Math.max(1, Number(effect.specialDropRateMultiplier)||1);
        equipmentSpecialDropRateMultiplier*=mul;
      }
      if(effect.curseSword) equipmentCurseSwordActive=true;
      if(effect.plasmaTriple) equipmentPlasmaTriple=true;
      if(effect.plasmaLifeMultiplier){
        const mul=Math.max(0, Number(effect.plasmaLifeMultiplier)||0);
        if(mul>0) equipmentPlasmaLifeMultiplier*=mul;
      }
      if(effect.plasmaSpeedMultiplier){
        const mul=Math.max(0, Number(effect.plasmaSpeedMultiplier)||0);
        if(mul>0) equipmentPlasmaSpeedMultiplier*=mul;
      }
      if(effect.plasmaChain){
        equipmentPlasmaChainActive=true;
        const interval=Math.max(200, Number(effect.plasmaChain.intervalMs)||0);
        const range=Math.max(10, Number(effect.plasmaChain.range)||0);
        if(interval>0) equipmentPlasmaChainInterval=interval;
        if(range>0) equipmentPlasmaChainRange=Math.max(equipmentPlasmaChainRange, range);
      }
      if(effect.plasmaSpawnOnKill) equipmentPlasmaSpawnOnKill=true;
      if(effect.pierceGrantPlasma) equipmentPierceGrantPlasma=true;
      if(effect.holyPattern){
        equipmentHolyPattern=String(effect.holyPattern);
      }
      if(effect.holyDurationMultiplier){
        const mul=Math.max(0, Number(effect.holyDurationMultiplier)||0);
        if(mul>0) equipmentHolyDurationMultiplier*=mul;
      }
      if(effect.multiAlwaysMax) equipmentMultiAlwaysMax=true;
      if(effect.trackAlsoMulti) equipmentTrackAlsoMulti=true;
      if(effect.trackUniqueTargets) equipmentTrackUniqueTargets=true;
      if(effect.pierceAlsoMulti) equipmentPierceAlsoMulti=true;
      if(effect.hellAlsoMulti) equipmentHellAlsoMulti=true;
      if(effect.megaAlsoMulti) equipmentMegaAlsoMulti=true;
      if(effect.pierceAlsoMega) equipmentPierceAlsoMega=true;
      if(effect.poisonAlsoMulti) equipmentPoisonAlsoMulti=true;
      if(effect.missileDoubleShots) equipmentMissileDoubleShots=true;
      if(effect.missileVolleyOnBreak) equipmentMissileVolleyOnBreak=true;
      if(effect.missileExplosion) equipmentMissileExplosion=true;
      if(effect.missilePlasma) equipmentMissilePlasma=true;
      if(effect.missileHolyStrike) equipmentMissileHolyStrike=true;
      if(effect.fireInstantCharge) equipmentFireInstantCharge=true;
      if(effect.fireScatter) equipmentFireScatter=true;
      if(effect.laserExtraTurret) equipmentLaserExtraTurret=true;
      if(effect.laserPlasma) equipmentLaserPlasma=true;
      if(effect.laserIntervalMultiplier){
        const mul=Math.max(0.05, Number(effect.laserIntervalMultiplier)||0);
        if(mul>0) equipmentLaserIntervalMultiplier*=mul;
      }
      if(effect.phoenixHeart) equipmentPhoenixHeart=true;
      if(effect.swordInstantFire) equipmentSwordInstantFire=true;
      if(effect.swordDoubleSpawn) equipmentSwordDoubleSpawn=true;
      if(effect.swordOnHit) equipmentSwordOnHit=true;
      if(effect.swordExtraSpawn){
        const extra=Math.max(0, Math.floor(effect.swordExtraSpawn)||0);
        equipmentSwordExtraSpawn+=extra;
      }
      if(effect.swordPlasma) equipmentSwordPlasma=true;
      if(effect.powerDurationBonus){
        for(const [key,val] of Object.entries(effect.powerDurationBonus)){
          const extra=Math.max(0, Number(val)||0);
          if(extra>0){
            equipmentPowerDurationBonusMs[key]=(equipmentPowerDurationBonusMs[key]||0)+extra;
          }
        }
      }
      if(effect.godspeedGrantsPierce) equipmentGodspeedAlsoPierce=true;
      if(effect.blackholeInstantStrike) equipmentBlackholeInstantStrike=true;
      if(effect.blackholePlasma) equipmentBlackholePlasma=true;
      if(effect.poisonSpread){
        const delay=Math.max(0, Number(effect.poisonSpread.delay)||0);
        if(delay>0){
          equipmentPoisonSpreadDelay = equipmentPoisonSpreadDelay>0 ? Math.min(equipmentPoisonSpreadDelay, delay) : delay;
        }
      }
      if(effect.poisonTickMs){
        const interval=Math.max(50, Number(effect.poisonTickMs)||0);
        if(interval>0){
          equipmentPoisonTickInterval = equipmentPoisonTickInterval>0 ? Math.min(equipmentPoisonTickInterval, interval) : interval;
        }
      }
      if(effect.poisonPlasma) equipmentPoisonPlasma=true;
      if(effect.solarBurst){
        const interval=Math.max(1000, Number(effect.solarBurst.interval)||0);
        equipmentSolarBurst=true;
        if(interval>0){
          equipmentSolarBurstInterval = equipmentSolarBurstInterval>0 ? Math.min(equipmentSolarBurstInterval, interval) : interval;
        }
      }
      if(effect.toxicRebirth){
        const threshold=Math.max(1, Math.floor(effect.toxicRebirth.threshold)||0);
        const heal=Math.max(0, Math.floor(effect.toxicRebirth.heal)||0);
        equipmentToxicRebirthConfig={threshold,heal};
      }
      if(effect.godspeedHolyStrike){
        equipmentGodspeedHolyStrike=true;
        const interval=Math.max(200, Number(effect.godspeedHolyStrike.interval)||0);
        if(interval>0){
          equipmentGodspeedHolyInterval = equipmentGodspeedHolyInterval>0 ? Math.min(equipmentGodspeedHolyInterval, interval) : interval;
        }
      }
      if(effect.cooldownMultiplier){
        const mul=Math.max(0, Number(effect.cooldownMultiplier)||0);
        if(mul>0){
          equipmentCooldownMultiplier*=mul;
        }
      }
    }
    if(equipmentGodspeedHolyStrike && equipmentGodspeedHolyInterval<=0){
      equipmentGodspeedHolyInterval=2000;
    }
      if(silverAssaultSlotIndex!=null){
        const slot=equipmentSlots[silverAssaultSlotIndex];
        if(!slot || !slot.def?.effect?.silverAssault){
          silverAssaultSlotIndex=null;
          silverAssaultCharge=null;
        }
      }
      if(!equipmentToxicRebirthConfig){
        toxicRebirthTriggered=false;
        toxicRebirthGlowUntil=0;
      }
      adjustSlotCooldownsForMultiplierChange(prevCooldownMultiplier);
    if(equipmentPlasmaChainActive && equipmentPlasmaChainInterval>0){
      const now=typeof performance!=='undefined'?performance.now():0;
      plasmaChainNextAt=now+equipmentPlasmaChainInterval;
    }
    if(!equipmentTrackUniqueTargets){
      resetTrackAssignments();
    }
  }
  function adjustSlotCooldownsForMultiplierChange(prevMultiplier){
    const newMultiplier=equipmentCooldownMultiplier>0?equipmentCooldownMultiplier:1;
    const prevMul=prevMultiplier>0?prevMultiplier:1;
    const now=typeof performance!=='undefined'?performance.now():0;
    for(const slot of equipmentSlots){
      if(!slot) continue;
      let base=Number(slot.baseCooldownDuration);
      if(!Number.isFinite(base) || base<0){
        const defCooldown=Number(slot.def?.effect?.cooldown)||Number(slot.def?.effect?.power?.cooldown)||0;
        if(Number.isFinite(defCooldown) && defCooldown>0){
          base=defCooldown;
        }else if(Number.isFinite(slot.cooldownDuration) && slot.cooldownDuration>0){
          base=prevMul>0?slot.cooldownDuration/prevMul:slot.cooldownDuration;
        }else{
          base=0;
        }
      }
      base=Math.max(0, base);
      slot.baseCooldownDuration=base;
      const targetDuration=Math.round(base*newMultiplier);
      slot.cooldownDuration=targetDuration;
      if(targetDuration<=0){
        slot.cooldownStarted=0;
        slot.cooldownUntil=0;
        continue;
      }
      if(slot.cooldownUntil && slot.cooldownUntil>now){
        const elapsedActual=Math.max(0, now-(slot.cooldownStarted||0));
        const newElapsed=Math.min(elapsedActual, targetDuration);
        const newStart=now-newElapsed;
        slot.cooldownStarted=Math.max(0,newStart);
        slot.cooldownUntil=slot.cooldownStarted+targetDuration;
      }else if(slot.cooldownUntil && slot.cooldownUntil<=now){
        slot.cooldownStarted=0;
        slot.cooldownUntil=0;
      }else{
        slot.cooldownStarted=0;
        slot.cooldownUntil=0;
      }
    }
  }
  function applySlotCooldown(slot,cooldownMs,now){
    if(!slot) return 0;
    const base=Math.max(0, Number(cooldownMs)||0);
    slot.baseCooldownDuration=base;
    const multiplier=equipmentCooldownMultiplier>0?equipmentCooldownMultiplier:1;
    const adjusted=Math.round(base*multiplier);
    const currentNow=Number.isFinite(now)?now:(typeof performance!=='undefined'?performance.now():0);
    if(adjusted>0){
      slot.cooldownDuration=adjusted;
      slot.cooldownStarted=currentNow;
      slot.cooldownUntil=currentNow+adjusted;
    }else{
      slot.cooldownDuration=0;
      slot.cooldownStarted=0;
      slot.cooldownUntil=0;
    }
    return adjusted;
  }

  function extendFutureTime(value, now, multiplier){
    if(!Number.isFinite(value) || value<=now) return value;
    const remain=value-now;
    return now + remain*multiplier;
  }

  function applyGodClockMultiplier(multiplier){
    const now=performance.now();
    const mul=Math.max(1, Number(multiplier)||1);
    let extended=0;
    for(const [key,buff] of Object.entries(buffs)){
      if(!buff) continue;
      if(buff.until && buff.until>now){
        buff.until=extendFutureTime(buff.until, now, mul);
        extended++;
      }
      if(key==='FLIP'){
        if(buff.startAt && buff.startAt>now) buff.startAt=extendFutureTime(buff.startAt, now, mul);
        if(buff.endAt && buff.endAt>now){
          buff.endAt=extendFutureTime(buff.endAt, now, mul);
          buff.until=buff.endAt;
        }
      }
      if(key==='PADBOOM'){
        if(buff.explodeAt && buff.explodeAt>now) buff.explodeAt=extendFutureTime(buff.explodeAt, now, mul);
        if(buff.returnAt && buff.returnAt>now){
          buff.returnAt=extendFutureTime(buff.returnAt, now, mul);
          buff.until=buff.returnAt;
        }
      }
      if(key==='GATLING' && gatling){
        if(gatling.chargeUntil && gatling.chargeUntil>now) gatling.chargeUntil=extendFutureTime(gatling.chargeUntil, now, mul);
        if(gatling.fireStart && gatling.fireStart>now) gatling.fireStart=extendFutureTime(gatling.fireStart, now, mul);
        if(gatling.fireUntil && gatling.fireUntil>now) gatling.fireUntil=extendFutureTime(gatling.fireUntil, now, mul);
        if(gatling.lastShot && gatling.lastShot>now) gatling.lastShot=extendFutureTime(gatling.lastShot, now, mul);
      }
      if(key==='STORM' && stormTurret){
        if(stormTurret.fireAt && stormTurret.fireAt>now) stormTurret.fireAt=extendFutureTime(stormTurret.fireAt, now, mul);
      }
      if(key==='ANNIHIL'){
        if(buff.next && buff.next>now) buff.next=extendFutureTime(buff.next, now, mul);
      }
      if(key==='LONG' && Array.isArray(buff.stacks)){
        buff.stacks=buff.stacks.map(t=>t>now?extendFutureTime(t, now, mul):t);
      }
    }
    if(shieldState.active && shieldState.until>now){
      shieldState.until=extendFutureTime(shieldState.until, now, mul);
      extended++;
    }
    if(bloodBladeActiveUntil>now){
      bloodBladeActiveUntil=extendFutureTime(bloodBladeActiveUntil, now, mul);
      extended++;
    }
    if(bombDevilActiveUntil>now){
      bombDevilActiveUntil=extendFutureTime(bombDevilActiveUntil, now, mul);
      extended++;
    }
    if(darkDemonBlackoutUntil>now){
      darkDemonBlackoutUntil=extendFutureTime(darkDemonBlackoutUntil, now, mul);
    }
    if(darkDemonPulses && darkDemonPulses.length){
      for(const pulse of darkDemonPulses){
        if(pulse && !pulse.executed && pulse.fireAt>now){
          pulse.fireAt=extendFutureTime(pulse.fireAt, now, mul);
        }
      }
    }
    if(deathLaserActiveUntil>now){
      deathLaserActiveUntil=extendFutureTime(deathLaserActiveUntil, now, mul);
      extended++;
    }
    if(gunDevilActiveUntil>now){
      gunDevilActiveUntil=extendFutureTime(gunDevilActiveUntil, now, mul);
      if(gunDevilNextShot>now) gunDevilNextShot=extendFutureTime(gunDevilNextShot, now, mul);
      extended++;
    }
    if(phoenixHeartGlowUntil>now){
      phoenixHeartGlowUntil=extendFutureTime(phoenixHeartGlowUntil, now, mul);
    }
    if(solarBurstNextAt>now) solarBurstNextAt=extendFutureTime(solarBurstNextAt, now, mul);
    if(plasmaChainNextAt>now) plasmaChainNextAt=extendFutureTime(plasmaChainNextAt, now, mul);
    if(toxicRebirthGlowUntil>now){
      toxicRebirthGlowUntil=extendFutureTime(toxicRebirthGlowUntil, now, mul);
    }
    for(const slot of equipmentSlots){
      if(!slot) continue;
      if(slot.activeUntil && slot.activeUntil>now){
        const prevUntil=slot.activeUntil;
        const startTime=Number.isFinite(slot.lastUsed)?slot.lastUsed:(prevUntil - (slot.activeDuration||0));
        slot.activeUntil=extendFutureTime(prevUntil, now, mul);
        if(Number.isFinite(startTime)){
          const newDuration=Math.max(0, slot.activeUntil-startTime);
          slot.activeDuration=newDuration;
        }
        extended++;
      }
    }
    return extended;
  }

  function triggerDarkDemonPulse(now,pulse){
    if(!pulse) return;
    if(pulse.blackout){
      darkDemonBlackoutUntil=Math.max(darkDemonBlackoutUntil, now+Math.max(0, pulse.blackout));
    }
    const damage=Math.max(0, Number(pulse.damage)||0);
    const bossMultiplier=Math.max(1, Number(pulse.bossMul ?? darkDemonBossMultiplier)||1);
    if(damage>0){
      for(let i=bricks.length-1;i>=0;i--){
        const brick=bricks[i];
        if(!brick) continue;
        if(!canDestroyBrick(brick) && !brick.boss) continue;
        const cx=brick.x+brick.w/2;
        const cy=brick.y+brick.h/2;
        if(brick.boss){
          const bossHits=Math.max(1, Math.floor(bossMultiplier));
          for(let n=0;n<bossHits;n++){
            if(i>=bricks.length || bricks[i]!==brick) break;
            damageBrick(i,1,'none');
          }
        }else{
          damageBrick(i,damage,'none');
        }
        strikeDemonAbyssBricksAtPoint(cx, cy, Math.max(brick.w, brick.h)*0.75, 'darkDemon');
      }
    }
    if(damage>0 && bossMultiplier>0 && isSpecialBossActive()){
      const center=activeBossCenter();
      if(center){
        damageActiveBoss(Math.max(0,damage)*Math.max(1,bossMultiplier),'darkDemon',{x:center.x,y:center.y});
      }
    }
    screenShake=Math.max(screenShake,6);
    playSFX('blackhole');
  }

  function triggerDeathLaserAt(x,y){
    if(deathLaserActiveUntil<=performance.now()) return;
    const target=pickLaserTarget(x,y);
    if(!target) return;
    fireLaserFromSource(x,y,target,performance.now());
  }

  function computeSwordSpawnCount(){
    const base=equipmentSwordDoubleSpawn?2:1;
    return Math.max(0, base + (equipmentSwordExtraSpawn||0));
  }

  function spawnSwordBatch(count){
    const total=Math.max(0, count);
    for(let n=0;n<total;n++){
      const sword={x:Math.random()*1100,y:650,vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*0.5,state:'wander'};
      if(equipmentSwordInstantFire){
        sword.state='ready';
        sword.vx=0;
        sword.vy=0;
        assignSwordTarget(sword);
      }
      swords.push(sword);
    }
  }

  function pickGunDevilTargets(source,count){
    const targets=[];
    const candidates=[];
    for(let i=0;i<bricks.length;i++){
      const bk=bricks[i];
      if(!bk || !canDestroyBrick(bk)) continue;
      const cx=bk.x+bk.w/2;
      const cy=bk.y+bk.h/2;
      const dx=cx-source.x;
      const dy=cy-source.y;
      const dist=dx*dx+dy*dy;
      candidates.push({type:'brick',idx:i,x:cx,y:cy,dist});
    }
    candidates.sort((a,b)=>b.dist-a.dist);
    let poolSize=candidates.length;
    if(poolSize>0){
      const selectPool=Math.max(count, Math.ceil(poolSize*0.5));
      poolSize=Math.min(poolSize, selectPool);
      for(let n=0;n<count && candidates.length;n++){
        const pickIndex=Math.min(candidates.length-1, Math.floor(Math.random()*poolSize));
        targets.push(candidates.splice(pickIndex,1)[0]);
      }
    }
    if(isSpecialBossActive()){
      const center=activeBossCenter();
      if(center){
        targets.push({type:'boss',x:center.x,y:center.y});
        if(targets.length>count){
          targets.length=count;
        }
      }
    }
    return targets;
  }

  function fireGunDevilShot(source,target,now){
    if(!target) return;
    const x1=source.x;
    const y1=source.y;
    const x2=target.x;
    const y2=target.y;
    strikeDemonSpearsAlongLine(x1,y1,x2,y2,'gunDevil');
    strikeDemonAbyssBricksAlongLine(x1,y1,x2,y2,'gunDevil');
    for(let i=bricks.length-1;i>=0;i--){
      const bk=bricks[i];
      if(!bk) continue;
      const rect={x:bk.x,y:bk.y,w:bk.w,h:bk.h};
      if(lineIntersectsRect(x1,y1,x2,y2,rect)){
        damageBrick(i,1,'none');
      }
    }
    if(isSpecialBossActive()){
      const bounds=getActiveBossBounds();
      if(bounds && lineIntersectsRect(x1,y1,x2,y2,bounds)){
        const impact=activeBossImpactPoint(x1,y1);
        damageActiveBoss(1,'gunDevil',impact);
      }
    }
    laserBeams.push({x1,y1,x2,y2,until:now+160});
    laserImpacts.push({x:x2,y:y2,t0:now,tEnd:now+260});
    playSFX('laser');
  }

  function fireGunDevilVolley(now){
    const pr=paddleRect();
    const origin=pr?{x:pr.x+pr.w/2,y:pr.y}:{x:550,y:650};
    const targets=pickGunDevilTargets(origin,gunDevilTargetsPerShot);
    if(!targets.length){
      return;
    }
    for(const target of targets){
      fireGunDevilShot(origin,target,now);
    }
  }
  function activateEquipmentPower(index,slot,powerCfg={}){
    if(!slot||!powerCfg||typeof powerCfg!=='object') return false;
    const powerKey=powerCfg.key;
    if(!powerKey){
      return false;
    }
    const powerDef=GAME_CONFIG.powers?.[powerKey]||null;
    applyPower(powerKey);
    const now=performance.now();
    const mode=powerCfg.mode|| (slot.def?.type==='active'?'active':'consumable');
    const durationSource=powerCfg.duration;
    const duration=Number.isFinite(durationSource)?Math.max(0,durationSource):Math.max(0,(powerDef?.durationMs)||0);
    const cooldownSource=powerCfg.cooldown;
    const cooldown=Number.isFinite(cooldownSource)?Math.max(0,cooldownSource): (mode==='active'?Math.max(0,slot.def?.effect?.cooldown||0):0);
    const label=powerDef?.label||powerKey;
    const message=powerCfg.message||`${label.replace(/（.*?）|\(.*?\)/g,'')}效果啟動！`;
    const tone=powerCfg.tone||'success';
    const messageDuration=Number.isFinite(powerCfg.messageDuration)?powerCfg.messageDuration:2400;
    slot.lastUsed=now;
    slot.pendingRemoval=false;
    if(duration>0){
      slot.activeUntil=now+duration;
      slot.activeDuration=duration;
    }else{
      slot.activeUntil=0;
      slot.activeDuration=0;
    }
    const buffState=buffs[powerKey];
    if(buffState && buffState.until){
      slot.activeUntil=buffState.until;
      slot.activeDuration=Math.max(0, buffState.until-now);
    }
    let removed=false;
    if(mode==='consumable'){
      applySlotCooldown(slot,0,now);
      if(duration>0){
        slot.pendingRemoval=true;
      }else{
        equipmentSlots[index]=null;
        recalcEquipmentBonuses();
        renderEquipmentSlots();
        removed=true;
      }
    }else if(mode==='active'){
      applySlotCooldown(slot,cooldown,now);
    }
    showEquipmentMessage(message,tone,messageDuration);
    if(!removed){
      refreshEquipmentRuntime(performance.now());
    }
    return true;
  }
  function useEquipmentFromSlot(index){
    const slot=equipmentSlots[index];
    if(!slot) return;
    const def=slot.def;
    if(def.type==='passive'){
      showEquipmentMessage(`「${def.name}」為被動型裝備，效果已自動生效。`,'info',2000);
      return;
    }
    const now=performance.now();
    if(def.type==='active' && slot.cooldownUntil && now<slot.cooldownUntil){
      const remain=Math.ceil((slot.cooldownUntil-now)/1000);
      showEquipmentMessage(`冷卻中，還需 ${remain} 秒。`,'warning',1800);
      return;
    }
    if(def.effect?.shieldDuration){
      const activated=activateShield(def.effect.shieldDuration,def);
      if(!activated){
        showEquipmentMessage('防護罩仍在作用中。','warning',1800);
        return;
      }
      if(def.type==='consumable'){
        equipmentSlots[index]=null;
        recalcEquipmentBonuses();
        renderEquipmentSlots();
      }else{
        const cd=def.effect.cooldown||0;
        applySlotCooldown(slot,cd,now);
        slot.lastUsed=now;
      }
      return;
    }
    if(def.effect?.heal){
      if(healPlayer(def.effect.heal)){
        equipmentSlots[index]=null;
        recalcEquipmentBonuses();
        renderEquipmentSlots();
      }else{
        showEquipmentMessage('HP 已達上限。','warning',2000);
      }
      return;
    }
    const effect=def.effect||{};
    if(effect.nineLives){
      if(nineCatEaten>=3){
        showEquipmentMessage('已達九命怪貓效果上限。','warning',2000);
        return;
      }
      lives=9;
      nineCatEaten++;
      updateHUD();
      spawnParticles(550,350,'#ffd',40,2.2,3.5,4);
      beep(880,0.1,0.06);
      showEquipmentMessage('九命怪貓守護著你，HP 已回滿！','success',2400);
      if(def.type==='consumable'){
        equipmentSlots[index]=null;
        recalcEquipmentBonuses();
        renderEquipmentSlots();
      }
      return;
    }
    if(effect.resetSpeed){
      const restored=resetBallSpeeds();
      if(restored){
        showEquipmentMessage('球速已重置為初始值。','success',2000);
        beep(700,0.07,0.05);
        if(def.type==='consumable'){
          equipmentSlots[index]=null;
          recalcEquipmentBonuses();
          renderEquipmentSlots();
        }
      }else{
        showEquipmentMessage('目前沒有可重置的球。','warning',2000);
      }
      return;
    }
    if(effect.cleanse){
      const cleared=cleanseActiveDebuffs();
      if(cleared>0){
        showEquipmentMessage(`已淨化 ${cleared} 種減益效果。`,'success',2200);
      }else{
        showEquipmentMessage('目前沒有減益效果。','info',2000);
      }
      equipmentSlots[index]=null;
      recalcEquipmentBonuses();
      renderEquipmentSlots();
      return;
    }
    if(effect.comboStar){
      const mode=effect.comboStar.mode||'consumable';
      const duration=Math.max(0, effect.comboStar.duration??(GAME_CONFIG.powers.COMBO?.durationMs||30000));
      if(mode==='passive'){
        showEquipmentMessage('連擊之星效果持續生效中。','info',2000);
        return;
      }
      applyPower('COMBO');
      slot.activeUntil=now+duration;
      slot.lastUsed=now;
      slot.activeDuration=duration;
      if(mode==='consumable'){
        slot.pendingRemoval=true;
      }else{
        const cd=Math.max(0, effect.comboStar.cooldown??60000);
        applySlotCooldown(slot,cd,now);
      }
      showEquipmentMessage('連擊之星啟動！ 連擊效果提升。','success',2200);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.bloodBlade){
      const cfg={...BLOOD_BLADE_DEFAULTS,...effect.bloodBlade};
      const hpCost=Math.max(1, Math.floor(cfg.hpCost||1));
      if(lives<=hpCost){
        showEquipmentMessage('HP 不足，無法啟動嗜血魔刃。','warning',2200);
        return;
      }
      lives=Math.max(0,lives-hpCost);
      stats.livesUsed+=hpCost;
      updateHUD();
      const duration=Math.max(0, cfg.duration||BLOOD_BLADE_DEFAULTS.duration);
      const cooldown=Math.max(0, cfg.cooldown||BLOOD_BLADE_DEFAULTS.cooldown);
      const dmgMul=Math.max(1, Number(cfg.damageMultiplier)||BLOOD_BLADE_DEFAULTS.damageMultiplier);
      bloodBladeDamageMultiplier=dmgMul;
      bloodBladeActiveUntil=Math.max(bloodBladeActiveUntil, now+duration);
      bloodBladeActive=true;
      slot.activeUntil=now+duration;
      slot.activeDuration=duration;
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage(`嗜血魔刃啟動！ 接下來 ${(duration/1000).toFixed(0)} 秒傷害 x${dmgMul}。`,'success',2600);
      const pr=paddleRect();
      if(pr){
        spawnParticles(pr.x+pr.w/2,pr.y,'#ff4d6a',24,1.8,3.2,2.6);
      }
      beep(520,0.12,0.05);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.missileBarrage){
      const cfg=effect.missileBarrage||{};
      const count=Math.max(1, Math.floor(cfg.count||20));
      const pr=paddleRect();
      const origin=pr?{x:pr.x+pr.w/2, y:pr.y}:{x:1100/2, y:700-50};
      emitMissilesFromSource(origin,{shots:count});
      const cooldown=Math.max(0, cfg.cooldown||0);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('死亡彈幕啟動！ 飛彈全方位出擊。','success',2600);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.bombDevil){
      const cfg={...BOMB_DEVIL_DEFAULTS,...effect.bombDevil};
      const duration=Math.max(0, Number(cfg.duration)||BOMB_DEVIL_DEFAULTS.duration);
      if(duration<=0){
        showEquipmentMessage('炸彈惡魔目前無法啟動。','warning',2200);
        return;
      }
      const cooldown=Math.max(0, Number(cfg.cooldown)||BOMB_DEVIL_DEFAULTS.cooldown);
      bombDevilActiveUntil=Math.max(bombDevilActiveUntil, now+duration);
      bombDevilIntervalMs=Math.max(50, Number(cfg.intervalMs)||BOMB_DEVIL_DEFAULTS.intervalMs);
      bombDevilRowCooldown.clear();
      bombDevilBossQueues.length=0;
      slot.activeUntil=now+duration;
      slot.activeDuration=duration;
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('炸彈惡魔啟動！球擊中磚塊會引爆整列。','success',2600);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.fireInstantDetonate){
      const detonated=detonateFireballNow();
      if(!detonated){
        showEquipmentMessage('目前沒有火焰球可引爆。','warning',2000);
        return;
      }
      const cooldown=Math.max(0, Number(effect.fireInstantDetonate.cooldown)||10000);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('火焰球提前引爆！','success',2200);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.massExplode){
      const triggered=triggerMassExplosiveDetonation();
      if(!triggered){
        showEquipmentMessage('目前沒有爆炸磚可引爆。','warning',2000);
        return;
      }
      const cooldown=Math.max(0, Number(effect.massExplode.cooldown)||10000);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('爆炸磚引爆完成！','success',2400);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.nuke){
      const detonated=triggerNuke(effect.nuke||{});
      if(!detonated){
        showEquipmentMessage('核爆目前無法啟動。','warning',2200);
        return;
      }
      showEquipmentMessage('核爆啟動！戰場被徹底清空。','success',2600);
      equipmentSlots[index]=null;
      recalcEquipmentBonuses();
      renderEquipmentSlots();
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.darkDemon){
      const cfg={interval:2000,pulses:4,blackoutMs:1000,damage:1,bossMultiplier:5,cooldown:60000,...(effect.darkDemon||{})};
      const interval=Math.max(200, Number(cfg.interval)||2000);
      const pulses=Math.max(1, Math.floor(cfg.pulses)||1);
      const blackoutMs=Math.max(0, Number(cfg.blackoutMs)||0);
      const damage=Math.max(0, Number(cfg.damage)||0);
      const bossMul=Math.max(1, Number(cfg.bossMultiplier)||1);
      const cooldown=Math.max(0, Number(cfg.cooldown)||0);
      darkDemonPulses=[];
      for(let n=0;n<pulses;n++){
        darkDemonPulses.push({fireAt:now + n*interval, blackout:blackoutMs, damage, bossMul, executed:false});
      }
      darkDemonDamagePerPulse=damage;
      darkDemonBossMultiplier=bossMul;
      if(pulses>0){
        const totalDuration=(pulses-1)*interval + blackoutMs;
        slot.activeUntil=now+totalDuration;
        slot.activeDuration=totalDuration;
      }else{
        slot.activeUntil=0;
        slot.activeDuration=0;
      }
      darkDemonBlackoutUntil=0;
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('暗之惡魔啟動！ 黑暗侵蝕磚陣。','success',2600);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.silverAssault){
      const cfg={cost:10,damage:10,cooldown:60000,...(effect.silverAssault||{})};
      const cost=Math.max(0, Number(cfg.cost)||0);
      if(cost>0){
        if(!spendSilverCoins(cost)){
          showEquipmentMessage('銀幣不足，無法啟動銀幣攻勢。','warning',2200);
          return;
        }
      }
      const damage=Math.max(1, Math.floor(cfg.damage)||1);
      silverAssaultCharge={damage, createdAt:now};
      silverAssaultSlotIndex=index;
      const cooldown=Math.max(0, Number(cfg.cooldown)||0);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage(`銀幣攻勢啟動！ 下一擊造成額外 ${damage} 點傷害。`,'success',2600);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.deathLaser){
      const cfg={duration:10000,cooldown:60000,...(effect.deathLaser||{})};
      const duration=Math.max(0, Number(cfg.duration)||0);
      if(duration<=0){
        showEquipmentMessage('死亡雷射目前無法啟動。','warning',2200);
        return;
      }
      const cooldown=Math.max(0, Number(cfg.cooldown)||0);
      deathLaserActiveUntil=Math.max(deathLaserActiveUntil, now+duration);
      slot.activeUntil=now+duration;
      slot.activeDuration=duration;
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('死亡雷射啟動！ 擊殺即刻引發雷射追擊。','success',2600);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.godClock){
      const cfg={multiplier:2,cooldown:120000,...(effect.godClock||{})};
      const cooldown=Math.max(0, Number(cfg.cooldown)||0);
      const multiplier=Math.max(1, Number(cfg.multiplier)||1);
      const extended=applyGodClockMultiplier(multiplier);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      updateShieldVisual();
      refreshEquipmentRuntime(performance.now());
      if(extended>0){
        showEquipmentMessage(`神之懷錶啟動！ ${extended} 項效果時間延長。`,'success',2600);
      }else{
        showEquipmentMessage('神之懷錶啟動，但目前沒有可延長的效果。','info',2400);
      }
      return;
    }
    if(effect.gunDevil){
      const cfg={duration:4000,interval:200,cooldown:60000,targets:2,...(effect.gunDevil||{})};
      const duration=Math.max(0, Number(cfg.duration)||0);
      if(duration<=0){
        showEquipmentMessage('槍之惡魔目前無法啟動。','warning',2200);
        return;
      }
      const interval=Math.max(50, Number(cfg.interval)||0);
      const targets=Math.max(1, Math.floor(cfg.targets)||1);
      const cooldown=Math.max(0, Number(cfg.cooldown)||0);
      gunDevilActiveUntil=Math.max(gunDevilActiveUntil, now+duration);
      gunDevilNextShot=now;
      gunDevilIntervalMs=interval;
      gunDevilTargetsPerShot=targets;
      slot.activeUntil=now+duration;
      slot.activeDuration=duration;
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('槍之惡魔啟動！ 狙擊火力即將掃蕩戰場。','success',2600);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.poisonDetonate){
      const triggered=triggerPoisonDetonation();
      if(!triggered){
        showEquipmentMessage('目前沒有中毒的磚塊可引爆。','warning',2200);
        return;
      }
      const cooldown=Math.max(0, Number(effect.poisonDetonate.cooldown)||30000);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('毒性爆發！中毒磚塊全面引爆。','success',2400);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.greatPlague){
      const triggered=triggerGreatPlague(effect.greatPlague||{});
      if(!triggered){
        showEquipmentMessage('場上沒有適合感染的磚塊。','warning',2200);
        return;
      }
      const cooldown=Math.max(0, Number(effect.greatPlague.cooldown)||60000);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('大瘟疫擴散！劇毒蔓延全場。','success',2600);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.mirrorSymmetry){
      const triggered=triggerMirrorSymmetry();
      if(!triggered){
        showEquipmentMessage('目前磚陣已近乎對稱。','warning',2000);
        return;
      }
      const cooldown=Math.max(0, Number(effect.mirrorSymmetry.cooldown)||60000);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('超對稱啟動，左右鏡像完成！','success',2400);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.starStrike){
      const cfg=effect.starStrike||{};
      const count=Math.max(1, Math.floor(cfg.count||3));
      const dmg=Math.max(1, Number(cfg.damage)||4);
      spawnStarProjectiles(count, dmg);
      const cooldown=Math.max(0, Number(cfg.cooldown)||30000);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('星星之力降臨，群星墜落！','success',2200);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.moonFall){
      const cfg=effect.moonFall||{};
      spawnMoonProjectile(cfg);
      const cooldown=Math.max(0, Number(cfg.cooldown)||30000);
      applySlotCooldown(slot,cooldown,now);
      slot.lastUsed=now;
      showEquipmentMessage('月亮之力啟動，巨月橫掃戰場！','success',2200);
      refreshEquipmentRuntime(performance.now());
      return;
    }
    if(effect.power){
      const used=activateEquipmentPower(index,slot,effect.power);
      if(used) return;
    }
  }
  function activateShield(durationMs,source){
    if(!Number.isFinite(durationMs)||durationMs<=0) return false;
    const now=performance.now();
    if(shieldState.active && now<shieldState.until){
      return false;
    }
    shieldState.active=true;
    shieldState.until=now+durationMs;
    shieldState.source=source?.id||null;
    shieldState.activatedAt=now;
    shieldState.duration=durationMs;
    shieldRipples.length=0;
    if(buffs?.SHIELD) buffs.SHIELD.active=true;
    updateShieldVisual();
    showEquipmentMessage(`防護罩啟動，${(durationMs/1000).toFixed(0)} 秒內所有傷害無效！`,'success',2600);
    beep(860,0.09,0.05);
    return true;
  }
  function updateShieldVisual(){
    if(!shieldStatusEl||!equipmentBar) return;
    const now=performance.now();
    const active=shieldState.active && now<shieldState.until;
    shieldStatusEl.hidden=!active;
    equipmentBar.classList.toggle('shielding',active);
    if(!active && shieldStatusTimeEl){
      shieldStatusTimeEl.textContent='0.0';
    }
  }
  function updateShieldRuntime(now){
    if(shieldState.active && now>=shieldState.until){
      shieldState.active=false;
      shieldState.activatedAt=0;
      shieldState.duration=0;
      shieldRipples.length=0;
      updateShieldVisual();
    }
    if(shieldState.active){
      const remain=Math.max(0,(shieldState.until-now)/1000);
      if(shieldStatusTimeEl){
        shieldStatusTimeEl.textContent=remain>=10?Math.ceil(remain).toString():remain.toFixed(1);
      }
      if(buffs?.SHIELD) buffs.SHIELD.active=true;
    }else if(buffs?.SHIELD){
      buffs.SHIELD.active=false;
    }
  }
  function blockDamageIfShielded(opts={}){
    if(!shieldState.active) return false;
    const now=performance.now();
    if(now>=shieldState.until){
      shieldState.active=false;
      shieldState.activatedAt=0;
      shieldState.duration=0;
      updateShieldVisual();
      return false;
    }
    showShieldAbsorbEffect(opts);
    return true;
  }
  function resetBallSpeeds(){
    if(!Array.isArray(balls)||balls.length===0) return false;
    const targetSpeed=speedForLevel(level);
    let changed=false;
    for(const ball of balls){
      if(!ball) continue;
      if(ball.stuck||ball.capturedByBladeHell) continue;
      if(ball.freeze && ball.freeze.state==='stopped') continue;
      const currentSpeed=Math.hypot(ball.vx||0,ball.vy||0);
      let ang;
      if(currentSpeed<=0.0001){
        ang=-Math.PI/3;
      }else{
        ang=Math.atan2(ball.vy,ball.vx);
      }
      if(!Number.isFinite(ang)) ang=-Math.PI/3;
      ball.vx=Math.cos(ang)*targetSpeed;
      ball.vy=Math.sin(ang)*targetSpeed;
      if(Math.abs(currentSpeed-targetSpeed)>0.01) changed=true;
    }
    return changed;
  }
  function checkEquipmentExpirations(now){
    let changed=false;
    const expiredNames=[];
    for(let i=0;i<equipmentSlots.length;i++){
      const slot=equipmentSlots[i];
      if(!slot) continue;
      if(slot.pendingRemoval && slot.activeUntil && now>=slot.activeUntil){
        expiredNames.push(slot.def.name);
        equipmentSlots[i]=null;
        changed=true;
        continue;
      }
      if(slot.def.effect?.bloodBlade && slot.activeUntil && now>=slot.activeUntil){
        slot.activeUntil=0;
        slot.activeDuration=0;
      }
    }
    if(changed){
      recalcEquipmentBonuses();
      renderEquipmentSlots();
      if(expiredNames.length){
        showEquipmentMessage(`${expiredNames.join('、')} 的效果已結束。`,'info',2000);
      }
    }
  }
  function updateBloodBladeState(now){
    const wasActive=bloodBladeActive;
    const active=bloodBladeActiveUntil>now;
    if(wasActive && !active){
      bloodBladeActiveUntil=0;
      for(const slot of equipmentSlots){
        if(slot?.def.effect?.bloodBlade){
          slot.activeUntil=0;
          slot.activeDuration=0;
        }
      }
      showEquipmentMessage('嗜血魔刃的暴走已平息。','info',2000);
      bloodBladeDamageMultiplier=BLOOD_BLADE_DEFAULTS.damageMultiplier;
    }
    bloodBladeActive=active;
  }
  function showShieldAbsorbEffect(opts={}){
    const now=performance.now();
    const px=opts.x;
    const py=opts.y;
    const pr=typeof paddleRect==='function'?paddleRect():null;
    if(Number.isFinite(px)&&Number.isFinite(py)){
      spawnParticles(px,py,'#86d6ff',24,1.8,2.8,2.6);
    }else if(pr){
      spawnParticles(pr.x+pr.w/2,pr.y+pr.h/2,'#86d6ff',20,1.8,2.6,2.4);
    }
    if(pr && pr.w>0 && pr.h>0){
      const centerX=pr.x+pr.w/2;
      const centerY=pr.y+pr.h/2;
      const impactX=Number.isFinite(px)?px:centerX;
      const impactY=Number.isFinite(py)?py:centerY;
      const padLen=orientLeft?pr.h:pr.w;
      const denom=Math.max(1,padLen/2);
      const rawOffset=orientLeft?((impactY-centerY)/denom):((impactX-centerX)/denom);
      const offset=Math.max(-1,Math.min(1,rawOffset));
      shieldRipples.push({createdAt:now,offset});
      while(shieldRipples.length>6){
        shieldRipples.shift();
      }
    }
    if(now-lastShieldAbsorbAt>400){
      showEquipmentMessage('防護罩吸收了傷害！','info',1600);
      lastShieldAbsorbAt=now;
    }
  }
  function healPlayer(amount){
    if(!Number.isFinite(amount)||amount<=0) return false;
    const prev=lives;
    const maxHP=9;
    const next=Math.min(maxHP,prev+Math.floor(amount));
    const gained=next-prev;
    if(gained<=0){
      return false;
    }
    lives=next;
    updateHUD();
    showEquipmentMessage(`HP +${gained}`,'success',2200);
    beep(720,0.08,0.05);
    return true;
  }

  function cleanseActiveDebuffs(){
    let cleared=0;
    const now=performance.now();
    for(const [key,def] of Object.entries(GAME_CONFIG.powers||{})){
      if(!def || def.type!=='debuff') continue;
      const buff=buffs[key];
      if(!buff) continue;
      const wasActive=!!buff.active && (!buff.until || buff.until>now);
      const hasDuration=buff.until && buff.until>now;
      if(wasActive || hasDuration){
        cleared++;
      }
      buff.active=false;
      buff.until=0;
      if('start' in buff) buff.start=0;
      if('stacks' in buff && Array.isArray(buff.stacks)) buff.stacks.length=0;
      if('explodeAt' in buff) buff.explodeAt=0;
      if('returnAt' in buff) buff.returnAt=0;
      if('exploded' in buff) buff.exploded=false;
    }
    if(cleared>0){
      paddleGoneUntil=0;
      updateBuffBadges();
      updateHUD();
    }
    return cleared;
  }
  function openStore(nextLevel){
    if(!storeOverlay) return;
    pendingNextLevel=nextLevel;
    const prevItemId=selectedStoreItemKey?storeInventoryByKey.get(selectedStoreItemKey)?.id:null;
    const targetLevel=Math.max(1,typeof nextLevel==='number'?nextLevel:1);
    generateStoreInventoryForLevel(targetLevel);
    renderStoreItems();
    storeOverlay.classList.add('show');
    storeOverlay.setAttribute('aria-hidden','false');
    document.body.classList.add('modal-open');
    if(storeFeedback) storeFeedback.textContent='';
    let defaultKey=null;
    if(prevItemId){
      const match=currentStoreItems.find(entry=>entry.item.id===prevItemId);
      if(match) defaultKey=match.key;
    }
    if(!defaultKey && currentStoreItems.length){
      defaultKey=currentStoreItems[0].key;
    }
    selectStoreItem(defaultKey,{silent:true});
    if(storeNextBtn){
      const labelLevel=Math.max(1,Math.floor(targetLevel));
      storeNextBtn.textContent=nextLevel?`進入下一關（Lv.${labelLevel}）`:'進入下一關 ▶';
      storeNextBtn.disabled=false;
    }
    refreshStoreAffordability();
  }
  function closeStore(){
    if(!storeOverlay) return;
    closeSlotModal(false);
    storeOverlay.classList.remove('show');
    storeOverlay.setAttribute('aria-hidden','true');
    document.body.classList.remove('modal-open');
  }
  function prepareNextLevel(nextLevel){
    const target=Math.max(1,Math.min(GAME_CONFIG.totalLevels,nextLevel));
    level=target;
    updateHUD();
    initBricks();
    resetBalls();
    paused=true;
    running=false;
    applyBGMThemeForLevel();
    showCenter(`進入關卡 ${level}`,'按 Space 或點畫面開始');
  }
  function enterNextLevelFromStore(){
    const target=pendingNextLevel||level+1;
    closeStore();
    prepareNextLevel(target);
    pendingNextLevel=null;
  }

  storeBuyBtn?.addEventListener('click',handleStorePurchase);
  storeNextBtn?.addEventListener('click',enterNextLevelFromStore);
  slotConfirmYes?.addEventListener('click',()=>{
    if(pendingEquipItem==null||pendingSlotIndex==null) return;
    const item=pendingEquipItem;
    const index=pendingSlotIndex;
    equipItemToSlot(index,item);
    pendingEquipItem=null;
    pendingSlotIndex=null;
    closeSlotModal();
    if(storeFeedback) storeFeedback.textContent='';
    refreshStoreAffordability();
    if(storeNextBtn) storeNextBtn.disabled=false;
  });
  slotConfirmNo?.addEventListener('click',()=>{
    pendingSlotIndex=null;
    if(slotConfirm) slotConfirm.classList.remove('show');
  });
  equipmentSlotsEl?.addEventListener('click',(e)=>{
    const btn=e.target.closest('.equip-slot');
    if(!btn) return;
    const index=parseInt(btn.dataset.index,10);
    if(Number.isNaN(index)) return;
    if(slotModal && slotModal.classList.contains('show') && pendingEquipItem){
      handleSlotChoice(index);
      return;
    }
    useEquipmentFromSlot(index);
  });
  codexBtn?.addEventListener('click',()=>{
    openCodex();
  },{passive:true});
  codexPrev?.addEventListener('click',()=>{
    if(codexPageIndex>0){
      codexPageIndex--;
      renderCodexPage();
    }
  },{passive:true});
  codexNext?.addEventListener('click',()=>{
    const total=getCodexTotalPages();
    if(codexPageIndex<total-1){
      codexPageIndex++;
      renderCodexPage();
    }
  },{passive:true});
  codexClose?.addEventListener('click',closeCodex,{passive:true});
  codexBackdrop?.addEventListener('click',closeCodex,{passive:true});

  generateStoreInventoryForLevel(1);
  renderStoreItems();
  renderEquipmentSlots();
  recalcEquipmentBonuses();
  updateShieldVisual();
  if(currentStoreItems.length){
    selectStoreItem(currentStoreItems[0].key,{silent:true});
  }else{
    selectStoreItem(null,{silent:true});
  }
  refreshStoreAffordability();
  const gallery=document.getElementById('gallery'), galleryImg=document.getElementById('galleryImg'), galleryHint=document.getElementById('galleryHint'), galleryDialog=document.getElementById('galleryDialog');
  const win=document.getElementById('win'), ring=document.getElementById('ring'), finalScore=document.getElementById('finalScore'), againBtn=document.getElementById('againBtn');
  let finalVictorySequence=null;
  document.getElementById('retryBtn')?.addEventListener('click', ()=>{ gameover.classList.remove('show'); gameOver=false; resetGame(); startGameWithCountdown(); });

  const bgmBtn=document.getElementById('bgmBtn'), bgmVol=document.getElementById('bgmVol');

  function saveSilverCoins(){
    try{ localStorage.setItem(SILVER_COIN_KEY, String(Math.max(0, Math.floor(silverCoins)))); }catch(e){}
  }


  let maxLevelReached=1;
  try{
    const storedMax=parseInt(localStorage.getItem('breakout_max_level')||'1',10);
    if(!Number.isNaN(storedMax)){
      maxLevelReached=Math.max(1, Math.min(GAME_CONFIG.totalLevels, storedMax));
    }
  }catch(e){}

  function unlockLevel(targetLevel){
    const numeric=parseInt(targetLevel,10);
    if(Number.isNaN(numeric)) return;
    const sanitized=Math.max(1, Math.min(GAME_CONFIG.totalLevels, numeric));
    if(sanitized>maxLevelReached){
      maxLevelReached=sanitized;
      try{ localStorage.setItem('breakout_max_level', String(maxLevelReached)); }catch(e){}
      if(typeof updateLevelJumpAvailability==='function') updateLevelJumpAvailability();
    }
  }
  const gameover=document.getElementById('gameover'), finalScore2=document.getElementById('finalScore2');
  const retryBtn=document.getElementById('retryBtn');

  // Gallery page elements
  const galleryPage=document.getElementById('galleryPage'), galleryThumbs=document.getElementById('galleryThumbs'), galleryClose=document.getElementById('galleryClose'), galleryPrev=document.getElementById('galleryPrev'), galleryNext=document.getElementById('galleryNext'), galleryPageInfo=document.getElementById('galleryPageInfo'), galleryViewer=document.getElementById('galleryViewer'), galleryViewerImg=document.getElementById('galleryViewerImg'), viewerOptions=document.getElementById('viewerOptions'), viewerDialog=document.getElementById('viewerDialog');

  // Rank page elements
  const rankPage=document.getElementById('rankPage'), rankClose=document.getElementById('rankClose'), rankTableBody=document.querySelector('#rankTable tbody');
  const uploadWin=document.getElementById('uploadWin'), uploadOver=document.getElementById('uploadOver'),
        uploadOverlay=document.getElementById('uploadOverlay'), uploadBar=document.getElementById('uploadBar'),
        uploadPercent=document.getElementById('uploadPercent');

  // === Gallery page logic ===
  let galleryPageIdx = 0;
  function renderGalleryPage(){
    const type = galleryPageIdx===0?'bg':'cg';
    galleryThumbs.innerHTML='';
    for(let i=1;i<=10;i++){
      const key = `${type}${i}`;
      const div=document.createElement('div');
      div.className='thumb';
      const im=document.createElement('img');
      im.src=`images/${key}.png`;
      div.appendChild(im);
      if(!galleryUnlocks[key]){
        div.classList.add('locked');
      }else{
        div.addEventListener('click',()=>{
          openGalleryViewer(key);
        },{passive:true});
      }
      galleryThumbs.appendChild(div);
    }
    galleryPageInfo.textContent=`${galleryPageIdx+1} / 2`;
    galleryPrev.disabled = galleryPageIdx===0;
    galleryNext.disabled = galleryPageIdx===1;
  }

  function openGalleryViewer(key){
    galleryViewerImg.src=`images/${key}.png`;
    galleryViewer.style.display='flex';
    if(viewerDialog) viewerDialog.style.display='none';
    if(viewerOptions){
      viewerOptions.innerHTML='';
      const mask = dialogUnlocks[key] || 0;
      const lines = DIALOGS[key] || [];
      for(let i=0;i<3;i++){
        const btn=document.createElement('button');
        btn.className='btn';
        if(mask & (1<<i)){
          btn.textContent=`台詞${i+1}`;
          btn.addEventListener('click',e=>{ e.stopPropagation(); if(viewerDialog){ viewerDialog.textContent=lines[i]; viewerDialog.style.display='block'; } },{passive:true});
        }else{
          btn.textContent='🔒';
          btn.disabled=true;
          btn.classList.add('locked');
        }
        viewerOptions.appendChild(btn);
      }
    }
  }
  function openGalleryPage(){
    galleryPageIdx=0;
    renderGalleryPage();
    galleryPage.style.display='flex';
    window.__setMenuPause?.(true);
  }
  function closeGalleryPage(){
    galleryPage.style.display='none';
    galleryViewer.style.display='none';
    if(viewerDialog) viewerDialog.style.display='none';
    if(!menusOpen()) window.__setMenuPause?.(false);
  }
  galleryClose?.addEventListener('click', closeGalleryPage, {passive:true});
  galleryPrev?.addEventListener('click', ()=>{ if(galleryPageIdx>0){galleryPageIdx--; renderGalleryPage();}}, {passive:true});
  galleryNext?.addEventListener('click', ()=>{ if(galleryPageIdx<1){galleryPageIdx++; renderGalleryPage();}}, {passive:true});
  galleryViewer?.addEventListener('click', ()=>{ if(viewerDialog && viewerDialog.style.display==='block'){ viewerDialog.style.display='none'; } else { galleryViewer.style.display='none'; } }, {passive:true});
  viewerOptions?.addEventListener('click', e=>{ e.stopPropagation(); }, {passive:true});
  galleryBtn?.addEventListener('click', ()=>{
    openGalleryPage();
  }, {passive:true});

  function showFinalWinOverlay(){
    finalScore.textContent=String(score);
    const statsEl=document.getElementById('statsWin');
    if(statsEl) statsEl.innerHTML = renderStatsHtml();
    ring.innerHTML='';
    for(let i=1;i<=GAME_CONFIG.totalLevels;i++){
      const im=getLevelImage(i);
      if(!im) continue;
      const th=document.createElement('img');
      th.src=im.src;
      th.loading='lazy';
      ring.appendChild(th);
    }
    const thumbNote=document.getElementById('thumbNote');
    if(thumbNote){
      const totalThumbs=ring.childElementCount;
      thumbNote.textContent = totalThumbs
        ? `${totalThumbs} 張角色收藏已亮相，改以 5×4 滿版網格一次排開。`
        : '尚未解鎖角色收藏，請再接再厲！';
    }
    win.classList.add('show');
    playSFX('win');
    resetCombo();
  }

  function startFinalVictorySequence(){
    if(finalVictorySequence) return;
    const key=getLevelImageKey(level);
    const img=getLevelImage(level);
    if(img) galleryImg.src=img.src;
    galleryDialog.style.display='none';
    if(galleryHint) galleryHint.textContent='點一下顯示台詞 ▶';
    gallery.style.display='flex';
    requestAnimationFrame(()=>gallery.classList.add('show'));
    const proceed=()=>{
      finalVictorySequence={stage:'completed'};
      gallery.classList.remove('show');
      setTimeout(()=>{
        gallery.style.display='none';
        galleryDialog.style.display='none';
        if(galleryHint) galleryHint.textContent='點一下顯示台詞 ▶';
      },220);
      showFinalWinOverlay();
    };
    const showLine=()=>{
      finalVictorySequence={stage:'dialog'};
      const dlg=getRandomDialog(key);
      unlockDialog(key, dlg.idx);
      galleryDialog.textContent=dlg.text;
      galleryDialog.style.display='block';
      if(galleryHint) galleryHint.textContent='點一下進入最終結算 ▶';
      gallery.addEventListener('click', proceed, {once:true, passive:true});
    };
    finalVictorySequence={stage:'gallery'};
    gallery.addEventListener('click', showLine, {once:true, passive:true});
  }

  // === Rank page logic ===
  async function fetchLeaderboard(){
    const controller = new AbortController();
    const to = setTimeout(()=>controller.abort(), FETCH_TIMEOUT);
    // GET leaderboard as JSON (supports both array-of-arrays and array-of-objects)
    const res = await fetch(RANK_API + '?t=' + Date.now(), { cache: 'no-store', signal: controller.signal });
    clearTimeout(to);
    if (!res.ok) throw new Error('fetch failed: ' + res.status);
    const text = await res.text();
    let data;
    try { data = JSON.parse(text); }
    catch { throw new Error('invalid json'); }
    // Normalize to array-of-arrays: [timestamp,name,score,lives,catches,powerUps,powerDowns,enemiesKilled,bossKilled,fastestDeath,longestSurvival,maxCombo]
    if (Array.isArray(data) && data.length && !Array.isArray(data[0]) && typeof data[0] === 'object') {
      // array of objects
      data = data.map(o => [
        o.timestamp ?? '',
        o.name ?? '',
        Number(o.score ?? 0),
        Number(o.lives ?? 0),
        Number(o.catches ?? 0),
        Number(o.powerUps ?? 0),
        Number(o.powerDowns ?? 0),
        Number(o.enemiesKilled ?? 0),
        Number(o.bossKilled ?? 0),
        Number(o.fastestDeath ?? 0),
        Number(o.longestSurvival ?? 0),
        Number(o.maxCombo ?? o.comboMax ?? 0),
      ]);
    }
    if (!Array.isArray(data)) throw new Error('unexpected data');
  return data;
  }
  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
  }
  function renderLeaderboard(data){
    rankTableBody.innerHTML='';
    try{
      data.sort((a,b)=>Number(b[2]||0)-Number(a[2]||0));
    }catch{}
    (data||[]).slice(0,20).forEach((row,i)=>{
      const tr=document.createElement('tr');
      const fd = Number(row[9]||0).toFixed(1);
      const ld = Number(row[10]||0).toFixed(1);
      const mc = Number(row[11]||0);
      tr.innerHTML = `<td>${i+1}</td>
        <td>${escapeHtml(row[1]??'')}</td>
        <td>${Number(row[2]||0)}</td>
        <td>${Number(row[3]||0)}</td>
        <td>${Number(row[4]||0)}</td>
        <td>${Number(row[5]||0)}</td>
        <td>${Number(row[6]||0)}</td>
        <td>${Number(row[7]||0)}</td>
        <td>${Number(row[8]||0)}</td>
        <td>${fd}</td>
        <td>${ld}</td>
        <td>${mc}</td>`;
      rankTableBody.appendChild(tr);
    });
    if(!rankTableBody.children.length){
      rankTableBody.innerHTML='<tr><td colspan="12">暫無資料</td></tr>';
    }
  }
  async function openRankPage(){
    document.getElementById('optMenu')?.classList.remove('show');
    rankPage.style.display='flex';
    rankTableBody.innerHTML='<tr><td colspan="12">載入中...</td></tr>';
    window.__setMenuPause?.(true);
    try{
      const data = await fetchLeaderboard();
      renderLeaderboard(data);
    }catch(e){
      console.error(e);
      rankTableBody.innerHTML='<tr><td colspan="12">載入失敗</td></tr>';
    }
  }
  function closeRankPage(){
    rankPage.style.display='none';
    if(!menusOpen()) window.__setMenuPause?.(false);
  }
  rankClose?.addEventListener('click', closeRankPage, {passive:true});
  rankBtn?.addEventListener('click', openRankPage, {passive:true});

    async function uploadScore(){
      if(scoreUploaded){
        alert('已上傳過，請勿再次上傳');
        return;
      }
      if(uploading){
        alert('上傳中，請勿再次點擊!');
        return;
      }
      const rawName = prompt('請輸入玩家名稱：\n注意: 姓名最多輸入8個字');
    if(rawName==null) return;
    const name = (rawName||'').trim();
    if(!name) return;
    if([...(name||'')].length>8){
      alert('名字這麼長是想怎樣啦? 請重新輸入!');
      return uploadScore();
    }
      const payload = {
        name,
        score,
        lives: stats.livesUsed,
        catches: stats.catches,
        powerUps: stats.buffs,
        powerDowns: stats.debuffs,
        enemiesKilled: stats.eliteKills,
        bossKilled: stats.bossKills,
        fastestDeath: stats.fastestDeath===Infinity?0:stats.fastestDeath,
        longestSurvival: stats.longestLife,
        maxCombo: stats.maxCombo
      };
      uploading = true;
      uploadOverlay.style.display='flex';
      let prog=0;
      const setProg=p=>{ uploadBar.style.width=p+'%'; uploadPercent.textContent=p+'%'; };
      setProg(0);
      const progTimer=setInterval(()=>{ if(prog<90){ prog+=5; setProg(prog); } },200);
      const controller = new AbortController();
      const to = setTimeout(()=>controller.abort(), FETCH_TIMEOUT);
      try{
        const res = await fetch(RANK_API, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain; charset=UTF-8' }, // simple request to avoid preflight
          body: JSON.stringify(payload),
          signal: controller.signal
        });
        const text = await res.text().catch(()=> '');
        clearTimeout(to);
        clearInterval(progTimer);
        setProg(100);
        uploadOverlay.style.display='none';
        if (res.ok && /ok/i.test(text.trim())) {
          alert('上傳完成');
          scoreUploaded = true;
        } else {
          alert('上傳失敗');
        }
      }catch(e){
        clearTimeout(to);
        clearInterval(progTimer);
        uploadOverlay.style.display='none';
        console.error(e);
        alert('上傳失敗');
      }finally{
        uploading = false;
      }
    }
  uploadWin?.addEventListener('click', uploadScore, {passive:true});
  uploadOver?.addEventListener('click', uploadScore, {passive:true});

  // === Skin initialization ===
  // Populate the skin dropdown and set up the current skin.  Skins are
  // defined in skin.js and exposed via the global SKINS object.  Each
  // option uses its key as the value; the displayed text comes from
  // selectLabel or falls back to the label.
  if (window.SKINS && skinSel) {
    // Remove any existing options before populating.
    skinSel.innerHTML = '';
    Object.keys(window.SKINS).forEach((key) => {
      const opt = document.createElement('option');
      opt.value = key;
      const s = window.SKINS[key];
      opt.textContent = (s.selectLabel || s.label || key);
      skinSel.appendChild(opt);
    });
    // Provide a UI update callback on window so skin.js can call it.
    window.updateSkinUI = function (skin) {
      const titleEl = document.getElementById('skinTitle');
      if (titleEl) titleEl.textContent = skin.label || '';
    };
    // Determine the initial skin from localStorage, with fallback.
    let initKey;
    try {
      initKey = localStorage.getItem('selected_skin') || 'classic';
    } catch (e) {
      initKey = 'classic';
    }
    if (!window.SKINS[initKey]) initKey = 'classic';
    skinSel.value = initKey;
    // Apply the initial skin using the helper from skin.js.  This also
    // stores the selection for later and updates the UI via updateSkinUI.
    if (typeof window.applySkin === 'function') {
      window.applySkin(initKey);
    }
    // Listen for changes and re-apply skins accordingly.
    skinSel.addEventListener('change', function () {
      if (typeof window.applySkin === 'function') {
        window.applySkin(this.value);
      }
    }, { passive: true });
  }

  /*
   * 新 UI 音效與 BGM 控制
   *
   * 為了沿用既有的聲音邏輯，我們用複選框控制隱藏的舊按鈕 soundBtn / bgmBtn。
   * 由於 soundsOn 與 bgmOn 在稍後才宣告（使用 let），這段初始化邏輯會在
   * 狀態宣告之後重新插入。這裡僅預留說明文字，實際邏輯見後方的插入區塊。
  */


  function menusOpen(){
    return !!(
      document.querySelector('#soundMenu.show, #optMenu.show') ||
      (galleryPage && galleryPage.style.display && galleryPage.style.display !== 'none') ||
      (rankPage && rankPage.style.display && rankPage.style.display !== 'none') ||
      (codexOverlay && codexOverlay.classList.contains('show'))
    );
  }

  // 關閉視窗按鈕（關閉後立即倒數、繼續遊戲）
  const noteClose = document.getElementById('noteClose');
  function closeNoteAndResume(){
    hideCenter();
    helpMode = null;
    // 在關閉說明視窗後恢復遊戲：先調整所有計時，再透過倒數繼續
    if(menusOpen()) return;
    if(running){ onResumeFromPause(); startCountdown(); } else { startGameWithCountdown(); }
  }
  noteClose.addEventListener('click', (e)=>{ e.stopPropagation(); closeNoteAndResume(); });

  // === 暫停與恢復計時 ===
  // 在暫停開始時呼叫，記錄當前時間以便恢復時修正各種定時器。
  function onPauseStart(){
    // 只在第一次暫停時記錄時間，避免重覆覆寫
    if(pauseStartedAt === null){
      pauseStartedAt = performance.now();
    }
  }

  // 在恢復遊戲時呼叫，將暫停期間的經過時間加回所有依賴絕對時間的定時器。
  function onResumeFromPause(){
    if(pauseStartedAt !== null){
      const delta = performance.now() - pauseStartedAt;
      pauseStartedAt = null;
      // 調整各增益 buff 的有效期
      for(const key of Object.keys(GAME_CONFIG.powers)){
        const b = buffs[key];
        if(!b) continue;
        // 通用 until 屬性
        if(b.active && b.until){ b.until += delta; }
        // LONG buff 的 stacks 為多個 until 時間
        if(key === 'LONG' && Array.isArray(b.stacks)){
          for(let i=0;i<b.stacks.length;i++){ b.stacks[i] += delta; }
        }
        // 萬物銷毀：調整起始與下次計時
        if(key === 'ANNIHIL'){
          if(b.start){ b.start += delta; }
          if(b.next){ b.next += delta; }
        }
      }
      // 調整天地翻轉特效的起止時間
      if(buffs.FLIP){
        const bf = buffs.FLIP;
        if(bf.startAt) bf.startAt += delta;
        if(bf.endAt) bf.endAt += delta;
      }
      // 調整下一次天空掉落與自動增益掉落時間
      if(nextSkyDropAt){ nextSkyDropAt += delta; }
      if(nextAutoBeneficialDropAt){ nextAutoBeneficialDropAt += delta; }
      // 調整 Boss 能力排程
      if(typeof nextBossAtkA !== 'undefined' && nextBossAtkA){ nextBossAtkA += delta; }
      if(typeof nextBossAtkB !== 'undefined' && nextBossAtkB){ nextBossAtkB += delta; }
      if(typeof bossChargeUntil !== 'undefined' && bossChargeUntil){ bossChargeUntil += delta; }
      if(typeof cyclopsShakeUntil !== 'undefined' && cyclopsShakeUntil){ cyclopsShakeUntil += delta; }
      if(typeof cyclopsForcedPetrifyAt !== 'undefined' && cyclopsForcedPetrifyAt){ cyclopsForcedPetrifyAt += delta; }
      if(gatling){ gatling.chargeUntil+=delta; gatling.fireStart+=delta; gatling.fireUntil+=delta; if(gatling.lastShot) gatling.lastShot+=delta; }
      if(spaceBossRevealScheduled) spaceBossRevealScheduled += delta;
      if(spaceBossNextAttackAt) spaceBossNextAttackAt += delta;
      if(spaceBossAttack){
        if(spaceBossAttack.start) spaceBossAttack.start += delta;
        if(spaceBossAttack.countdownEnd) spaceBossAttack.countdownEnd += delta;
        if(spaceBossAttack.fireStart) spaceBossAttack.fireStart += delta;
        if(spaceBossAttack.fireEnd) spaceBossAttack.fireEnd += delta;
        if(spaceBossAttack.sweepStart) spaceBossAttack.sweepStart += delta;
        if(spaceBossAttack.sweepEnd) spaceBossAttack.sweepEnd += delta;
      }
      if(spaceBossMarquee){ spaceBossMarquee.start+=delta; if(spaceBossMarquee.fadeStart) spaceBossMarquee.fadeStart+=delta; if(spaceBossMarquee.end) spaceBossMarquee.end+=delta; }
      for(const fx of spaceBossBursts){ if(fx.t0) fx.t0 += delta; }
      if(spaceBossPaddleRespawnAt) spaceBossPaddleRespawnAt += delta;
      if(spaceBossDeathAnim){ spaceBossDeathAnim.start+=delta; spaceBossDeathAnim.explosionAt+=delta; spaceBossDeathAnim.end+=delta; spaceBossDeathAnim.lastBurst+=delta; }
      if(spaceBossSuppressLifeLossUntil) spaceBossSuppressLifeLossUntil += delta;
      // 調整各種特效物件（粒子、雷射、黑洞等）的 till/until 終止時間
      const lists = [plasmas, plasmaChains, holyFlashes, blackHoles, laserBeams, laserImpacts, missiles, hostileBeams, hostileArcs, hostileColumns, hazardClouds];
      for(const arr of lists){
        if(!arr) continue;
        for(const item of arr){
          if(item.until){ item.until += delta; }
          if(item.tEnd){ item.tEnd += delta; }
          if(item.t0){ item.t0 += delta; }
          if(item.lifeUntil){ item.lifeUntil += delta; }
          if(item.tStart){ item.tStart += delta; }
        }
      }
      // 調整球的凍結狀態
      for(const ball of balls){
        const fr = ball.freeze;
        if(fr && fr.t0){ fr.t0 += delta; }
        if(fr && fr.until){ fr.until += delta; }
      }
      if(combo>0 && comboLastTime){ comboLastTime += delta; }
    }
  }


  // === DPR 縮放 ===
  function resizeCanvasDPR(){ const dpr=Math.min(window.devicePixelRatio||1,2); const cssW=canvas.clientWidth; const cssH=Math.round(cssW*(700/1100)); canvas.style.height=cssH+'px'; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); scaleX=canvas.width/1100; scaleY=canvas.height/700; }
  let scaleX=1, scaleY=1; window.addEventListener('resize', resizeCanvasDPR, {passive:true}); resizeCanvasDPR();

  // === 狀態 ===
  let running=false, paused=true, level=1, score=0, lives=9, soundsOn=false;
  let nineCatEaten=0;
  const bossNineCatDrops=new Set();
  let fireEnergy=0;
  let gameOver=false;
  let combo=0;
  let comboLastTime=0;
  const comboEl=document.getElementById('combo');
  let comboNoticeTriggered={50:false,100:false,200:false,300:false,400:false,500:false,800:false,1000:false};
  function comboStarConfig(){
    return GAME_CONFIG.powers?.COMBO?.combo||{timeMul:1,scoreMul:1};
  }
  function isComboStarActive(now=performance.now()){
    if(equipmentComboStarPermanent) return true;
    const buff=buffs.COMBO;
    if(!buff||!buff.active) return false;
    if(buff.until && now>buff.until) return false;
    return true;
  }
  function getComboStarTimeMultiplier(now=performance.now()){
    return isComboStarActive(now)?(comboStarConfig().timeMul||1):1;
  }
  function getComboStarScoreMultiplier(now=performance.now()){
    return isComboStarActive(now)?(comboStarConfig().scoreMul||1):1;
  }
  function countActiveDebuffEffects(now=performance.now()){
    let count=0;
    for(const key of Object.keys(GAME_CONFIG.powers||{})){
      const def=GAME_CONFIG.powers[key];
      if(!def || def.type!=='debuff') continue;
      const state=buffs[key];
      if(!state) continue;
      if(Array.isArray(state.stacks)){
        if(state.stacks.some(t=>t>now)) count++;
      }else if(state.active && (!state.until || state.until>now)){
        count++;
      }
    }
    return count;
  }
  function getCurseSwordBonus(now=performance.now()){
    if(!equipmentCurseSwordActive) return 0;
    return countActiveDebuffEffects(now);
  }
  function getBloodBladeMultiplier(now=performance.now()){
    return (bloodBladeActiveUntil && now<bloodBladeActiveUntil)?bloodBladeDamageMultiplier:1;
  }
  let stats={catches:0,buffs:0,debuffs:0,eliteKills:0,bossKills:0,lifeStart:0,fastestDeath:Infinity,longestLife:0,livesUsed:0,maxCombo:0};
  unlockLevel(level);
  const SPACE_BOSS_MAX_HP = 30;
  const SPACE_BOSS_ATTACK_INTERVAL = 15000;
  const SPACE_BOSS_FIRST_ATTACK_DELAY = 5000;
  const SPACE_BOSS_PADDLE_MIN_WIDTH = 60;
  const SPACE_BOSS_GUN_FIRE_RATE = 100; // ms between each burst per gun
  const SPACE_BOSS_GUN_FIRE_DURATION = 3000;
  const SPACE_BOSS_LASER_SWEEP_DURATION = 2000;
  const DRAGON_MAX_HP = 80;
  const DRAGON_BASE_MODEL_WIDTH = 260;
  const DRAGON_ATTACK_INTERVAL = 10000;
  let spaceBossPhase='inactive';
  let spaceBoss=null;
  let spaceBossPlaceholder=null;
  let spaceBossAnchor=null;
  let spaceBossRevealScheduled=0;
  let spaceBossBursts=[];
  let spaceBossMarquee=null;
  let spaceBossDefeatedAt=0;
  let spaceBossAttack=null;
  let spaceBossNextAttackAt=0;
  const spaceBossBullets=[];
  let spaceBossPaddlePenalty=0;
  let spaceBossPaddleRespawnAt=0;
  let spaceBossDeathAnim=null;
  let spaceBossLastPaddleCenter=0;
  let spaceBossPrevPaddleCenter=0;
  let spaceBossSuppressLifeLossUntil=0;

  let reaperPhase='inactive';
  let reaperBoss=null;
  let reaperPlaceholder=null;
  let reaperAnchor=null;
  let reaperRevealScheduled=0;
  let reaperBursts=[];
  let cyclopsFirstAttackAt=0;
  let cyclopsEventStarted=false;
  let cyclopsMarqueeShown=false;
  let cyclopsRowBlastIndex=-1;
  let cyclopsNextRowBlast=0;
  let cyclopsShellBurst=false;
  let cyclopsEventComplete=false;
  let cyclopsForcedPetrifyAt=0;
  let cyclopsForcedPetrifyFired=false;
  let reaperAfterimages=[];
  let reaperMarquee=null;
  let reaperDefeatedAt=0;
  let reaperDeathAnim=null;
  let reaperTeleportSchedule=null;
  let reaperTargetHighlightUntil=0;
  let reaperAttackState=null;
  let reaperSlashZone=null;
  let reaperSlashEffects=[];
  let reaperBlackHoleAttack=null;
  let reaperLifeLossCooldownUntil=0;
  let reaperPaddlePenalty=0;
  let reaperPenaltyLastUpdate=0;
  const REAPER_PADDLE_MIN_WIDTH=80;
  const REAPER_FIRST_ATTACK_DELAY = 5000;
  const REAPER_ATTACK_INTERVAL = 15000;
  let dragonPhase='inactive';
  let dragonBoss=null;
  let dragonPlaceholder=null;
  let dragonAnchor=null;
  let dragonRevealScheduled=0;
  let dragonBursts=[];
  let dragonMarquee=null;
  let dragonDefeatedAt=0;
  let dragonDeathAnim=null;
  let dragonAttackState=null;
  let dragonNextAttackAt=0;
  const dragonDeathRayOrbs=[];
  const dragonDeathRayBeams=[];
  let demonShellBrick=null;
  let demonEventPhase='inactive';
  let demonEventTimerStart=0;
  let demonEventTriggeredAt=0;
  let demonEventMarquee=null;
  let demonEventWave=null;
  let demonDeathShockwaves=[];
  let demonDeathFlares=[];
  let demonEventRows=[];
  let demonEventNextRowAt=0;
  let demonFallingDebris=[];
  let demonEventShakeUntil=0;
  let demonCore=null;
  let demonEventTargets=0;
  let demonEventCleared=0;
  let demonPhase='inactive';
  let demonBoss=null;
  let demonRevealScheduled=0;
  let demonAfterimages=[];
  let demonTeleportTrails=[];
  const DEMON_TELEPORT_HIT_WINDOW = 1000;
  const DEMON_TELEPORT_HIT_THRESHOLD = 5;
  const DEMON_TELEPORT_BUFF_SOURCES = new Set(['holy','fire','phoenix','plasma','laser','gatling','blackhole','annihil','sword','missile','bladeHellReflect']);
  let demonDeathAnim=null;
  let demonDefeatedAt=0;
  let demonAttackActive=null;
  let demonAttackNextAt=0;
  const DEMON_ATTACK_INTERVAL = 15000;
  const DEMON_FIRST_ATTACK_DELAY = 5000;
  let demonVoidVolleyState=null;
  const demonVoidProjectiles=[];
  let demonVoidNextRoll=0;
  let demonBlackSpears=[];
  let demonBlackSpearId=0;
  const demonBloodEffects=[]; // 華麗噴血爆炸特效 {x,y,t0,life,ringStart,ringEnd}
  const demonBladeHellTelegraphs=[];
  const demonBladeHellSlashes=[];
  const demonBladeHellCounterSlashes=[];
  let demonBladeHellCounterstrike=null;
  let demonBladeHellLastPaddleCenter={x:550, y:640};
  let demonBladeHellBallCapture=null;
  let demonBladeHellPlatformGlow=0;
  const demonAbyssBricks=[];
  let demonAbyssBrickId=0;
  const demonAbyssExplosions=[];
  let currentPaddleTint='#9aaeff';
  const lastPaddleDrawState={ axis:null, time:0, vertical:false };
  const DEMON_DESCENT_DURATION=20000;
  const DEMON_ASCENT_DURATION=2600;
  const DEMON_RECOVERY_DURATION=4000;
  const DEMON_LOW_KNOCKBACK_WINDOW=5000;

  function isSpaceBossActive(){
    return level===5 && spaceBossPhase==='active' && !!spaceBoss;
  }

  function isReaperActive(){
    return level===10 && reaperPhase==='active' && !!reaperBoss;
  }

  function isDragonActive(){
    return level===15 && dragonPhase==='active' && !!dragonBoss;
  }

  function isDemonActive(){
    if(!(level===20 && demonPhase==='active' && !!demonBoss)) return false;
    if(demonAttackActive && demonAttackActive.type==='bladeHell' && demonAttackActive.stage==='hell') return false;
    return true;
  }

  function getSpaceBossBounds(){
    if(!spaceBoss) return null;
    return {
      x: spaceBoss.x - spaceBoss.w/2,
      y: spaceBoss.y - spaceBoss.h/2,
      w: spaceBoss.w,
      h: spaceBoss.h
    };
  }

  function computeDragonHitZones(bossOverride=null){
    const boss = bossOverride || dragonBoss;
    if(!boss) return [];
    const scale = (boss.w||DRAGON_BASE_MODEL_WIDTH)/DRAGON_BASE_MODEL_WIDTH;
    const cx = boss.x;
    const cy = boss.y;
    const wingPhase = boss.wingPhase||0;
    const sine=Math.sin(wingPhase);
    const downstroke=Math.pow(Math.max(0, sine), 1.6);
    const upstroke=Math.pow(Math.max(0, -sine), 1.2);
    const flap=(downstroke*0.65 - upstroke*0.42);
    let wingLift = 26*flap;
    let wingSpread = 1.38 + flap*0.42;
    if(boss.pose==='deathRay'){
      wingLift += 18;
      wingSpread += 0.6;
    }
    const zones=[];
    const addZone=(ox, oy, radius)=>{
      zones.push({
        cx: cx + ox*scale,
        cy: cy + oy*scale,
        r: Math.max(6, radius*scale)
      });
    };

    addZone(0,-48,62);
    addZone(0,24,70);
    addZone(0,110,58);
    addZone(0,190,48);
    addZone(0,268,42);
    addZone(0,-132,28);

    addZone(96,-12,42);
    addZone(-96,-12,42);
    addZone(102,108,38);
    addZone(-102,108,38);

    const tailSegments=[
      {y:146,r:44},
      {y:214,r:38},
      {y:286,r:32},
      {y:344,r:28}
    ];
    for(const seg of tailSegments){ addZone(0,seg.y,seg.r); }

    const wingClusters=[
      {x:-150, y:-72-wingLift*0.15, r:76},
      {x:-212, y:18-wingLift*0.05, r:70},
      {x:-252, y:126+wingLift*0.18, r:64},
      {x:-220, y:202+wingLift*0.32, r:58}
    ];
    for(const cluster of wingClusters){
      addZone(cluster.x*wingSpread, cluster.y, cluster.r);
      addZone(-cluster.x*wingSpread, cluster.y, cluster.r);
    }

    return zones;
  }

  function getDragonBounds(){
    if(!dragonBoss) return null;
    const zones=computeDragonHitZones();
    if(!zones.length){
      return {
        x: dragonBoss.x - dragonBoss.w/2,
        y: dragonBoss.y - dragonBoss.h/2,
        w: dragonBoss.w,
        h: dragonBoss.h
      };
    }
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const zone of zones){
      minX=Math.min(minX, zone.cx - zone.r);
      minY=Math.min(minY, zone.cy - zone.r);
      maxX=Math.max(maxX, zone.cx + zone.r);
      maxY=Math.max(maxY, zone.cy + zone.r);
    }
    return {x:minX, y:minY, w:maxX-minX, h:maxY-minY};
  }

  function circleIntersectsSpaceBoss(cx, cy, radius){
    const bounds=getSpaceBossBounds();
    if(!bounds) return false;
    const nearestX = Math.max(bounds.x, Math.min(cx, bounds.x + bounds.w));
    const nearestY = Math.max(bounds.y, Math.min(cy, bounds.y + bounds.h));
    const dx = cx - nearestX;
    const dy = cy - nearestY;
    return dx*dx + dy*dy <= radius*radius;
  }

  function circleIntersectsDragon(cx, cy, radius){
    const zones=computeDragonHitZones();
    if(!zones.length) return false;
    for(const zone of zones){
      const dx=cx-zone.cx;
      const dy=cy-zone.cy;
      const rr=radius + zone.r;
      if(dx*dx + dy*dy <= rr*rr) return true;
    }
    return false;
  }

  function resolveDragonBallCollision(ball, radius, inRampage){
    const zones=computeDragonHitZones();
    if(!zones.length) return null;
    let best=null;
    for(const zone of zones){
      const dx=ball.x - zone.cx;
      const dy=ball.y - zone.cy;
      const dist=Math.hypot(dx,dy);
      const overlap=(zone.r + radius) - dist;
      if(overlap>0 && (!best || overlap>best.overlap)){
        best={zone, dx, dy, dist:dist||0.0001, overlap};
      }
    }
    if(!best) return null;
    const nx=best.dx/(best.dist||0.0001);
    const ny=best.dy/(best.dist||0.0001);
    const impactX=best.zone.cx + nx*best.zone.r;
    const impactY=best.zone.cy + ny*best.zone.r;
    ball.x = impactX + nx*(radius+0.5);
    ball.y = impactY + ny*(radius+0.5);
    const dot = ball.vx*nx + ball.vy*ny;
    ball.vx -= 2*dot*nx;
    ball.vy -= 2*dot*ny;
    if(inRampage || ball.piercing){
      ball.piercing=true;
    }
    if(Math.abs(ball.vx)<0.2){ ball.vx += nx*4; }
    if(Math.abs(ball.vy)<0.2){ ball.vy += ny*4; }
    const bounceAxis = Math.abs(nx) > Math.abs(ny) ? 'x' : 'y';
    return {impactX, impactY, bounceAxis};
  }

  function spawnPlasmaBurst(x,y,opts={}){
    const cfg=GAME_CONFIG.powers?.PLASMA?.plasma;
    if(!cfg) return;
    const now=performance.now();
    const baseCount=Math.max(1, Math.floor(opts.count||1));
    const count=equipmentPlasmaTriple?Math.max(3, baseCount):baseCount;
    const lifeMultiplier=(opts.lifeMultiplier||1)*equipmentPlasmaLifeMultiplier;
    const speedMultiplier=(opts.speedMultiplier||1)*equipmentPlasmaSpeedMultiplier;
    const radius=cfg.radius||0;
    const drift=(cfg.drift||0)*speedMultiplier;
    const baseLife=Math.max(0, cfg.lifeMs||0);
    const lifeMs=Math.max(0, baseLife*lifeMultiplier);
    if(lifeMs<=0) return;
    const baseAngle=opts.baseAngle ?? Math.random()*Math.PI*2;
    for(let i=0;i<count;i++){
      const angle = count===1 ? (opts.angle ?? baseAngle) : baseAngle + i*(Math.PI*2/count);
      const vx=Math.cos(angle)*drift;
      const vy=Math.sin(angle)*drift;
      plasmas.push({
        x,
        y,
        vx,
        vy,
        until:now+lifeMs,
        radius,
        phase:Math.random()*Math.PI*2,
        spawnAt:now
      });
    }
    if(opts.sound!==false){
      playSFX('plasma');
    }
  }

  function pickLaserTarget(sx, sy){
    let bestScore=-Infinity;
    let bestTarget=null;
    for(let i=0;i<bricks.length;i++){
      const bk=bricks[i];
      if(!canDestroyBrick(bk)) continue;
      const cx=bk.x+bk.w/2;
      const cy=bk.y+bk.h/2;
      const dx=cx-sx;
      const dy=cy-sy;
      const dist=dx*dx+dy*dy;
      if(dist>bestScore){
        bestScore=dist;
        bestTarget={type:'brick', idx:i, x:cx, y:cy};
      }
    }
    if(isSpecialBossActive()){
      const center=activeBossCenter();
      if(center){
        const dx=center.x-sx;
        const dy=center.y-sy;
        const dist=dx*dx+dy*dy;
        if(dist>bestScore){
          bestTarget={type:'boss', x:center.x, y:center.y};
        }
      }
    }
    return bestTarget;
  }

  function fireLaserFromSource(sx, sy, target, now){
    if(!target) return false;
    const impact = target.type==='boss' ? activeBossImpactPoint(sx, sy) : {x:target.x, y:target.y};
    strikeDemonSpearsAlongLine(sx, sy, impact.x, impact.y, 'laser');
    strikeDemonAbyssBricksAlongLine(sx, sy, impact.x, impact.y, 'laser');
    laserBeams.push({x1:sx,y1:sy,x2:impact.x,y2:impact.y,until:now+200});
    laserImpacts.push({x:impact.x, y:impact.y, t0:now, tEnd:now+320});
    spawnParticles(impact.x,impact.y,'rgba(160,255,200,0.9)',10,1.8,2.2,2.6);
    if(target.type==='boss'){
      highlightSpaceBossTarget();
      damageActiveBoss(1,'laser',impact);
    }else if(target.type==='brick'){
      destroyBrick(target.idx,'laser');
      if(equipmentLaserPlasma){
        spawnPlasmaBurst(impact.x, impact.y, {sound:false});
      }
    }
    return true;
  }

  function triggerBlackholeStrike(now,{deactivate=true}={}){
    const pr=paddleRect();
    if(!pr) return false;
    const d=Math.min(8,buffs.BLACKHOLE.deaths||0);
    const dmg=1+(d/8)*(40-1);
    const rad=200+(d/8)*(800-200);
    const cx=pr.x+pr.w/2;
    const cy=pr.y-rad;
    const spinDir=(Math.random()>0.5?1:-1);
    blackHoles.push({x:cx,y:cy,r:rad,until:now+3000,start:now,spinDir});
    for(let i=bricks.length-1;i>=0;i--){
      const bk=bricks[i];
      if(!bk) continue;
      const bx=bk.x+bk.w/2, by=bk.y+bk.h/2;
      if(Math.hypot(bx-cx,by-cy)<=rad){
        const ref=bk;
        damageBrick(i,dmg,'none');
        if(equipmentBlackholePlasma && !bricks.includes(ref)){
          spawnPlasmaBurst(bx,by,{sound:false});
        }
      }
    }
    strikeDemonAbyssBricksAtPoint(cx, cy, rad, 'blackhole');
    if(circleIntersectsActiveBoss(cx,cy,rad)){
      const impact=activeBossCenter();
      damageActiveBoss(1,'blackhole',impact?{x:impact.x,y:impact.y}:{x:cx,y:cy});
    }
    playSFX('blackhole');
    if(deactivate){
      buffs.BLACKHOLE.active=false;
    }
    return true;
  }

  function applyHolyStrike(cx, cy){
    const now=performance.now();
    const pattern=(equipmentHolyPattern==='miz')?'miz':'cross';
    playSFX('holy');
    holyFlashes.push({x:cx, y:cy, until:now+350, pattern});
    const L=layout();
    const rowIdx=Math.round((cy - L.top)/(brickH + L.pad));
    const colIdx=Math.round((cx - L.pad)/(brickW + L.pad));
    const diagMode=pattern==='miz';
    for(let i=bricks.length-1;i>=0;i--){
      const t=bricks[i];
      if(!t) continue;
      const row=Math.round((t.y - L.top)/(brickH + L.pad));
      const col=Math.round((t.x - L.pad)/(brickW + L.pad));
      const sameRow=row===rowIdx;
      const sameCol=col===colIdx;
      const onDiag=diagMode && Math.abs(row-rowIdx)===Math.abs(col-colIdx);
      if(sameRow || sameCol || onDiag){
        destroyBrick(i,'none');
      }
    }
    strikeDemonAbyssBricksInCross(cx, cy, {includeDiagonals:diagMode, source:'holyStrike'});
    if(isSpecialBossActive()){
      const bounds=getActiveBossBounds();
      if(bounds){
        const hits=[];
        const rowY=L.top + rowIdx*(brickH + L.pad) + brickH/2;
        if(rowIdx>=0 && rowY>=bounds.y && rowY<=bounds.y+bounds.h){
          hits.push({impact:{x:bounds.x+bounds.w/2,y:rowY},key:'row'});
        }
        const colX=L.pad + colIdx*(brickW + L.pad) + brickW/2;
        if(colIdx>=0 && colX>=bounds.x && colX<=bounds.x+bounds.w){
          hits.push({impact:{x:colX,y:bounds.y+bounds.h/2},key:'col'});
        }
        if(diagMode){
          const diag1Const=cy-cx;
          const diag2Const=cy+cx;
          const corners=[
            {x:bounds.x,y:bounds.y},
            {x:bounds.x+bounds.w,y:bounds.y},
            {x:bounds.x,y:bounds.y+bounds.h},
            {x:bounds.x+bounds.w,y:bounds.y+bounds.h}
          ];
          const minusVals=corners.map(p=>p.y-p.x);
          const plusVals=corners.map(p=>p.y+p.x);
          const minMinus=Math.min(...minusVals);
          const maxMinus=Math.max(...minusVals);
          const minPlus=Math.min(...plusVals);
          const maxPlus=Math.max(...plusVals);
          if(diag1Const>=minMinus && diag1Const<=maxMinus){
            hits.push({impact:{x:bounds.x+bounds.w/2,y:bounds.y+bounds.h/2},key:'diag1'});
          }
          if(diag2Const>=minPlus && diag2Const<=maxPlus){
            hits.push({impact:{x:bounds.x+bounds.w/2,y:bounds.y+bounds.h/2},key:'diag2'});
          }
        }
        const seen=new Set();
        for(const hit of hits){
          if(!hit||!hit.impact) continue;
          const key=hit.key||`${hit.impact.x.toFixed(1)}:${hit.impact.y.toFixed(1)}`;
          if(seen.has(key)) continue;
          seen.add(key);
          damageActiveBoss(1,'holy',hit.impact);
        }
      }
    }
    screenShake=Math.max(screenShake,4);
  }

  function triggerBallBuffEffectsOnBossHit(ball, impactX, impactY, now, opts={}){
    if(buffs.PLASMA.active){
      spawnPlasmaBurst(impactX, impactY);
    }

    if(buffs.FREEZE.active && (ball.freeze.state==='idle' || !ball.freeze.state)){
      const f=GAME_CONFIG.powers.FREEZE.freeze;
      ball.freeze.state='delay';
      ball.freeze.t0=now;
      ball.freeze.delay=f.delayMs;
      ball.freeze.stop=f.stopMs;
      ball.freeze.oldVX=ball.vx;
      ball.freeze.oldVY=ball.vy;
    }

    if(buffs.HOLY.active){
      applyHolyStrike(impactX, impactY);
    }

    if(buffs.HELL.active){
      const holeSpin=(Math.random()>0.5?1:-1);
      blackHoles.push({
        x:impactX,
        y:impactY,
        r:40,
        until:now+GAME_CONFIG.powers.HELL.hell.haloMs,
        start:performance.now(),
        spinDir:holeSpin
      });
      playSFX('blackhole');
    }

    if(opts.bossHit!==false && now<bombDevilActiveUntil){
      queueBombDevilBossExplosions(impactX, impactY, now);
    }
  }

  function getReaperBounds(){
    if(!reaperBoss) return null;
    return {
      x: reaperBoss.x - reaperBoss.w/2,
      y: reaperBoss.y - reaperBoss.h/2,
      w: reaperBoss.w,
      h: reaperBoss.h
    };
  }

  function circleIntersectsReaper(cx, cy, radius){
    const bounds=getReaperBounds();
    if(!bounds) return false;
    const nearestX = Math.max(bounds.x, Math.min(cx, bounds.x + bounds.w));
    const nearestY = Math.max(bounds.y, Math.min(cy, bounds.y + bounds.h));
    const dx = cx - nearestX;
    const dy = cy - nearestY;
    return dx*dx + dy*dy <= radius*radius;
  }

  function getDemonBounds(){
    if(!demonBoss) return null;
    if(demonAttackActive && demonAttackActive.type==='bladeHell' && demonAttackActive.stage==='hell') return null;
    const hitW=demonBoss.hitW||demonBoss.w;
    const hitH=demonBoss.hitH||demonBoss.h;
    const offsetX=demonBoss.hitOffsetX||0;
    const offsetY=demonBoss.hitOffsetY||0;
    return {
      x: demonBoss.x + offsetX - hitW/2,
      y: demonBoss.y + offsetY - hitH/2,
      w: hitW,
      h: hitH
    };
  }

  function computeDemonHitZones(){
    if(!demonBoss) return [];
    const bounds=getDemonBounds();
    if(!bounds) return [];
    const cx=bounds.x + bounds.w/2;
    const hitW=bounds.w;
    const hitH=bounds.h;
    const top=bounds.y;
    const zones=[];

    const headH=hitH*0.22;
    const headW=hitW*0.56;
    zones.push({x:cx-headW/2, y:top, w:headW, h:headH});

    const torsoH=hitH*0.38;
    const torsoW=hitW*0.74;
    zones.push({x:cx-torsoW/2, y:top+headH*0.7, w:torsoW, h:torsoH});

    const waistH=hitH*0.26;
    const waistW=hitW*0.7;
    zones.push({x:cx-waistW/2, y:top+headH*0.7+torsoH*0.85, w:waistW, h:waistH});

    const legH=hitH*0.34;
    const legW=hitW*0.32;
    const legY=top+hitH*0.6;
    const legOffset=hitW*0.18;
    zones.push({x:cx-legOffset-legW/2, y:legY, w:legW, h:legH});
    zones.push({x:cx+legOffset-legW/2, y:legY, w:legW, h:legH});

    const armH=hitH*0.34;
    const armW=hitW*0.34;
    const armY=top+hitH*0.28;
    const armOffset=torsoW/2 + armW*0.3;
    zones.push({x:cx-armOffset-armW/2, y:armY, w:armW, h:armH});
    zones.push({x:cx+armOffset-armW/2, y:armY, w:armW, h:armH});

    return zones;
  }

  function demonPointInHitArea(px, py){
    const zones=computeDemonHitZones();
    for(const zone of zones){
      if(px>=zone.x && px<=zone.x+zone.w && py>=zone.y && py<=zone.y+zone.h){
        return true;
      }
    }
    return false;
  }

  function circleIntersectsRect(cx, cy, radius, rect){
    const nearestX=Math.max(rect.x, Math.min(cx, rect.x+rect.w));
    const nearestY=Math.max(rect.y, Math.min(cy, rect.y+rect.h));
    const dx=cx-nearestX;
    const dy=cy-nearestY;
    return dx*dx + dy*dy <= radius*radius;
  }

  function circleIntersectsDemon(cx, cy, radius){
    const zones=computeDemonHitZones();
    if(!zones.length) return false;
    for(const zone of zones){
      if(circleIntersectsRect(cx, cy, radius, zone)) return true;
    }
    return false;
  }

  function getDemonCloakBounds(){
    if(!demonBoss) return null;
    const cloakW=demonBoss.cloakW || ((demonBoss.hitW||demonBoss.w)*1.8);
    const cloakH=demonBoss.cloakH || ((demonBoss.hitH||demonBoss.h)*1.2);
    const offsetX=(demonBoss.cloakOffsetX!=null?demonBoss.cloakOffsetX:(demonBoss.hitOffsetX||0));
    const offsetY=(demonBoss.cloakOffsetY!=null?demonBoss.cloakOffsetY:(demonBoss.hitOffsetY||0));
    const cx=demonBoss.x + offsetX;
    const cy=demonBoss.y + offsetY + cloakH*0.1;
    return {
      x: cx - cloakW/2,
      y: cy - cloakH/2,
      w: cloakW,
      h: cloakH
    };
  }

  function demonCloakCenter(){
    const bounds=getDemonCloakBounds();
    if(!bounds) return null;
    return {x:bounds.x + bounds.w/2, y:bounds.y + bounds.h/2};
  }

  function resolveDemonBallCollision(ball, radius){
    const zones=computeDemonHitZones();
    if(!zones.length) return null;
    let best=null;
    for(const zone of zones){
      if(ball.x+radius<=zone.x || ball.x-radius>=zone.x+zone.w || ball.y+radius<=zone.y || ball.y-radius>=zone.y+zone.h) continue;
      const oL=(ball.x+radius)-zone.x;
      const oR=(zone.x+zone.w)-(ball.x-radius);
      const oT=(ball.y+radius)-zone.y;
      const oB=(zone.y+zone.h)-(ball.y-radius);
      const minOverlap=Math.min(oL,oR,oT,oB);
      if(minOverlap<=0) continue;
      if(!best || minOverlap<best.penetration){
        best={zone, penetration:minOverlap, oL, oR, oT, oB};
      }
    }
    return best;
  }

  function startDemonAscent(now){
    if(!demonBoss || demonPhase!=='active') return;
    if(demonBoss.mode==='bloodDrain') return;
    if(demonBoss.mode==='ascending') return;
    demonBoss.mode='ascending';
    demonBoss.ascentStart=now;
    demonBoss.ascentDuration=DEMON_ASCENT_DURATION;
    demonBoss.moveTarget=null;
    demonBoss.knockbackVX=0;
    demonBoss.knockbackVY=0;
  }

  function applyDemonKnockback(dirX, dirY){
    if(!demonBoss || demonPhase!=='active') return;
    if(demonBoss.mode==='bloodDrain') return;
    const now=performance.now();
    if(dirX){
      demonBoss.knockbackVX = (demonBoss.knockbackVX||0) + dirX*16.8;
    }
    if(dirY){
      demonBoss.knockbackVY = (demonBoss.knockbackVY||0) + dirY*20.4;
    }
    if(demonBoss.mode==='low'){
      if(demonBoss.lastKnockbackAt && now - demonBoss.lastKnockbackAt <= DEMON_LOW_KNOCKBACK_WINDOW){
        demonBoss.lowKnockbacks = (demonBoss.lowKnockbacks||0) + 1;
      }else{
        demonBoss.lowKnockbacks = 1;
      }
      demonBoss.lastKnockbackAt=now;
      if(demonBoss.lowKnockbacks>=3){
        startDemonAscent(now);
      }
    }else{
      demonBoss.lowKnockbacks=0;
      demonBoss.lastKnockbackAt=now;
    }
  }

  function demonBlackSpearRect(spear){
    const width = spear.width||60;
    return {
      x: spear.x - width/2,
      y: spear.y,
      w: width,
      h: spear.length
    };
  }

  function spawnDemonBlackSpear(lane, now, overrides={}){
    const L=layout();
    const startY = overrides.startY ?? Math.max(0, L.top - 260);
    const baseWidth = lane.width || 60;
    const intendedWidth = overrides.width ?? Math.max(24, baseWidth * 0.34);
    const width = Math.max(12, intendedWidth * 0.5);
    const intendedLength = overrides.length ?? Math.max(110, (brickH||40)*1.9);
    const length = Math.max(60, intendedLength * 0.5);
    const tipScale = Math.max(0.12, Math.min(0.45, overrides.tipScale ?? 0.22));
    const spear={
      id: ++demonBlackSpearId,
      lane,
      x: overrides.x ?? lane.x,
      width,
      tipScale,
      y: startY,
      length,
      state:'charging',
      spawnAt: now,
      chargeProgress: 0,
      lastUpdate: now,
      alpha:0,
      paddleHit:false
    };
    demonBlackSpears.push(spear);
    if(lane.queue){ lane.queue.push(spear); }
    return spear;
  }

  function circleIntersectsRect(cx, cy, r, rect){
    const nearestX = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
    const nearestY = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
    const dx = cx - nearestX;
    const dy = cy - nearestY;
    return (dx*dx + dy*dy) <= r*r;
  }

  function circleIntersectsSegment(cx, cy, r, x1, y1, x2, y2){
    const dx=x2-x1;
    const dy=y2-y1;
    const lenSq=dx*dx+dy*dy;
    let t=0;
    if(lenSq>0){
      t=((cx-x1)*dx + (cy-y1)*dy)/lenSq;
      if(t<0) t=0;
      else if(t>1) t=1;
    }
    const px=x1 + dx*t;
    const py=y1 + dy*t;
    const distX=cx-px;
    const distY=cy-py;
    return (distX*distX + distY*distY) <= r*r;
  }

  function lineIntersectsRect(x1,y1,x2,y2,rect){
    const xMin=rect.x, xMax=rect.x+rect.w;
    const yMin=rect.y, yMax=rect.y+rect.h;
    if((x1>=xMin&&x1<=xMax&&y1>=yMin&&y1<=yMax)||(x2>=xMin&&x2<=xMax&&y2>=yMin&&y2<=yMax)) return true;
    let t0=0, t1=1;
    const dx=x2-x1, dy=y2-y1;
    const p=[-dx, dx, -dy, dy];
    const q=[x1-xMin, xMax-x1, y1-yMin, yMax-y1];
    for(let i=0;i<4;i++){
      const pi=p[i], qi=q[i];
      if(pi===0){ if(qi<0) return false; }
      else{
        const r=qi/pi;
        if(pi<0){ if(r>t1) return false; if(r>t0) t0=r; }
        else{ if(r<t0) return false; if(r<t1) t1=r; }
      }
    }
    return true;
  }

  function destroyDemonSpear(spear, cause='generic', now=performance.now()){
    if(!spear || spear.state==='broken'){ return false; }
    spear.state='broken';
    spear.breakAt=now;
    spear.removeAt=now+400;
    spear.blockRect=null;
    const attack=demonAttackActive;
    if(attack && attack.queue){
      const idx=attack.queue.indexOf(spear);
      if(idx>=0) attack.queue.splice(idx,1);
    }
    spawnParticles(spear.x, spear.y + spear.length*0.45, '#140916', 26, 2.6, 3.6, 3.6);
    spawnParticles(spear.x, spear.y + spear.length*0.6, '#3a1020', 32, 2.8, 3.4, 3.6);
    spawnParticles(spear.x, spear.y + spear.length*0.72, '#8a1b2f', 20, 2.2, 2.8, 3.0);
    spawnParticles(spear.x, spear.y + spear.length*0.82, '#d03040', 14, 1.6, 2.4, 2.6);
    playSFX('fireExplosion');
    return true;
  }

  function strikeDemonSpearsAtPoint(x, y, radius=6, source='generic'){
    if(!demonBlackSpears.length) return false;
    const now=performance.now();
    let hit=false;
    for(const spear of demonBlackSpears){
      if(!spear || (spear.state!=='charging' && spear.state!=='falling' && spear.state!=='stuck')) continue;
      const rect=demonBlackSpearRect(spear);
      if(circleIntersectsRect(x, y, radius, rect)){
        destroyDemonSpear(spear, source, now);
        hit=true;
      }
    }
    return hit;
  }

  function strikeDemonSpearsAlongLine(x1,y1,x2,y2,source='generic'){
    if(!demonBlackSpears.length) return false;
    const now=performance.now();
    let hit=false;
    for(const spear of demonBlackSpears){
      if(!spear || (spear.state!=='charging' && spear.state!=='falling' && spear.state!=='stuck')) continue;
      const rect=demonBlackSpearRect(spear);
      if(lineIntersectsRect(x1,y1,x2,y2,rect)){
        destroyDemonSpear(spear, source, now);
        hit=true;
      }
    }
    return hit;
  }

  function spawnDemonSpearBlood(x, y){
    const now=performance.now();
    spawnParticles(x, y, '#36040d', 42, 3.6, 4.8, 4.8);
    spawnParticles(x, y, '#720c24', 48, 3.2, 4.0, 4.4);
    spawnParticles(x, y, '#a11232', 32, 2.6, 3.6, 3.8);
    spawnParticles(x, y, '#ff375b', 22, 2.2, 3.0, 3.4);
    spawnParticles(x, y, '#ffd1dc', 14, 2.4, 3.4, 3.6);
    demonBloodEffects.push({
      x,
      y,
      t0: now,
      life: 900,
      ringStart: 36 + Math.random()*12,
      ringEnd: 220 + Math.random()*60
    });
  }

  function spawnBladeHellBlood(x, y){
    const now=performance.now();
    spawnParticles(x, y, '#220006', 54, 4.0, 5.4, 5.0);
    spawnParticles(x, y, '#4e0014', 64, 3.6, 4.8, 4.6);
    spawnParticles(x, y, '#8c0624', 48, 3.2, 4.0, 4.2);
    spawnParticles(x, y, '#ff1f3f', 32, 2.8, 3.6, 3.6);
    spawnParticles(x, y, '#ffd6e4', 18, 2.4, 3.2, 3.2);
    demonBloodEffects.push({
      x,
      y,
      t0: now,
      life: 1100,
      ringStart: 42 + Math.random()*18,
      ringEnd: 280 + Math.random()*90
    });
  }

  function spawnAbyssPlatformShatter(x, y){
    const now=performance.now();
    playSFX('abyssPlatformBreak');
    spawnParticles(x, y, '#fff3ff', 56, 2.8, 4.4, 4.8);
    spawnParticles(x, y, '#c089ff', 46, 2.6, 4.0, 4.4);
    spawnParticles(x, y, '#61e8ff', 34, 2.4, 3.8, 4.0);
    spawnParticles(x, y, '#ffbc73', 32, 2.2, 3.6, 3.8);
    spawnParticles(x, y, '#341442', 28, 2.8, 3.6, 4.2);
    const seed=Math.random()*TAU;
    const cracks=Array.from({length:10},()=>({
      angle:Math.random()*TAU,
      length:160+Math.random()*160,
      sway:0.2+Math.random()*0.45,
      branch:Math.random()<0.55
    }));
    const shards=Array.from({length:26},()=>({
      angle:Math.random()*TAU,
      speed:180+Math.random()*220,
      size:10+Math.random()*6,
      tint:0.55+Math.random()*0.35
    }));
    demonAbyssExplosions.push({
      x,
      y,
      start:now,
      end:now+900,
      style:'abyssPlatformShock',
      radius:240,
      seed
    });
    demonAbyssExplosions.push({
      x,
      y,
      start:now,
      end:now+1200,
      style:'abyssPlatformCracks',
      radius:260,
      seed,
      cracks
    });
    demonAbyssExplosions.push({
      x,
      y,
      start:now,
      end:now+1000,
      style:'abyssPlatformSparks',
      radius:300,
      seed,
      shards
    });
  }

  function getStandardBrickDimensions(){
    const L=layout();
    const pad=L.pad ?? GAME_CONFIG.bricks.padding;
    const cols=L.cols ?? GAME_CONFIG.bricks.cols;
    const available=Math.max(1, cols);
    const width = brickW>0 ? brickW : Math.floor((1100 - (available+1)*pad)/available);
    const height = brickH>0 ? brickH : (L.h ?? GAME_CONFIG.bricks.brickHeight);
    return {width, height};
  }

  const TAU=Math.PI*2;

  function normalizeAngle(angle){
    if(!Number.isFinite(angle)) return 0;
    let a=angle % TAU;
    if(a<0) a+=TAU;
    return a;
  }

  function shortestAngleDiff(target, from){
    let diff=(target-from)%TAU;
    if(diff>Math.PI) diff-=TAU;
    if(diff<-Math.PI) diff+=TAU;
    return diff;
  }

  function easeOutCubic(t){
    const clamped=Math.max(0, Math.min(1, t));
    const inv=1-clamped;
    return 1 - inv*inv*inv;
  }

  function realignDemonAbyssOrbit(attack, now){
    if(!attack) return;
    const living=demonAbyssBricks.filter(b=>b && !b.destroyed && (b.state==='orbit' || b.state==='beam'));
    if(!living.length) return;
    const rotation=attack.orbitRotation=normalizeAngle(attack.orbitRotation||0);
    const baseAngle=attack.orbitAngleSeed!=null ? attack.orbitAngleSeed : (attack.orbitAngleSeed=Math.random()*TAU);
    const radius=(attack.orbitRadius ?? attack.orbitRadiusBase ?? 140);
    attack.orbitRadius=radius;
    living.sort((a,b)=> (a.orbitOrder||a.id) - (b.orbitOrder||b.id));
    const step=TAU/living.length;
    for(let i=0;i<living.length;i++){
      const brick=living[i];
      const targetActual=normalizeAngle(baseAngle + i*step);
      const targetBase=normalizeAngle(targetActual - rotation);
      const currentBase=normalizeAngle((brick.baseAngle!=null?brick.baseAngle:((brick.angle||0)-rotation)));
      brick.baseAngle=currentBase;
      brick.baseAngleStart=currentBase;
      brick.baseAngleTarget=targetBase;
      brick.baseAngleAdjustStart=now;
      brick.baseAngleAdjustDuration=500;
      const fromRadius=brick.orbitRadius ?? radius;
      brick.orbitRadius = brick.orbitRadius ?? radius;
      brick.radiusAdjustFrom=fromRadius;
      brick.radiusAdjustTo=radius;
      brick.radiusAdjustStart=now;
      brick.radiusAdjustDuration=500;
    }
  }

  function spawnDemonAbyssBrick(attack, now){
    if(!attack) return null;
    const L=layout();
    const stageTop=L.top;
    const stageBottom=700;
    const stageHeight=stageBottom-stageTop;
    const center=attack.orbitCenter || {x:550, y:stageTop + stageHeight*0.38};
    const sides=['top','left','right'];
    const side=sides[Math.floor(Math.random()*sides.length)];
    let startX=center.x, startY=stageTop-60;
    if(side==='top'){
      const minX=L.pad + 40;
      const maxX=1100 - L.pad - 40;
      startX = minX + Math.random()*(Math.max(minX, maxX)-minX);
      startY = stageTop - 70;
    }else if(side==='left'){
      startX = L.pad - 70;
      startY = stageTop + Math.random()*stageHeight*0.82;
    }else{
      startX = 1100 - L.pad + 70;
      startY = stageTop + Math.random()*stageHeight*0.82;
    }
    const {width:stdWidth, height:stdHeight}=getStandardBrickDimensions();
    const baseRadius=attack.orbitRadius ?? attack.orbitRadiusBase ?? Math.max(100, stageHeight*0.2);
    const orbiters=demonAbyssBricks.filter(b=>b && !b.destroyed && (b.state==='orbit' || b.state==='beam')).length;
    const totalSlots=orbiters+1;
    const baseAngle = attack.orbitAngleSeed!=null?attack.orbitAngleSeed:(attack.orbitAngleSeed=Math.random()*TAU);
    const targetAngle = normalizeAngle(baseAngle + (totalSlots-1)*(TAU/Math.max(1,totalSlots)));
    const rotation=attack.orbitRotation||0;
    const baseAngleForBrick=normalizeAngle(targetAngle - rotation);
    const orbitRadius = baseRadius;
    const targetX = center.x + Math.cos(targetAngle)*orbitRadius;
    const targetY = center.y + Math.sin(targetAngle)*orbitRadius;
    const brick={
      id: ++demonAbyssBrickId,
      x:startX,
      y:startY,
      startX,
      startY,
      targetX,
      targetY,
      orbitCenter:{x:center.x, y:center.y},
      orbitRadius,
      baseAngle:baseAngleForBrick,
      orbitOrder:(attack.nextOrbitOrder||0),
      orbitSpeed:(Math.PI*2)/2000,
      state:'flying',
      spawnAt:now,
      arrivalDuration:1000,
      hitRadius:Math.hypot(stdWidth*0.45, stdHeight*0.45),
      renderWidth:stdWidth,
      renderHeight:stdHeight,
      renderPulse:Math.random()*Math.PI*2,
      crackleSeed:Math.random()*Math.PI*2,
      lastUpdate:now,
      hp:1
    };
    attack.nextOrbitOrder=(attack.nextOrbitOrder||0)+1;
    demonAbyssBricks.push(brick);
    attack.spawnCount = (attack.spawnCount||0) + 1;
    spawnParticles(startX, startY, '#401355', 24, 2.6, 3.4, 3.6);
    spawnParticles(startX, startY, '#b38aff', 18, 2.0, 3.0, 3.2);
    playSFX('abyssBrickLaunch');
    return brick;
  }

  function destroyDemonAbyssBrick(brick, cause='generic', now=performance.now()){
    if(!brick || brick.destroyed) return false;
    brick.destroyed=true;
    brick.state='destroyed';
    brick.destroyedAt=now;
    brick.removeAt=now+700;
    brick.baseAngleTarget=null;
    brick.baseAngleStart=null;
    brick.baseAngleAdjustStart=null;
    brick.baseAngleAdjustDuration=null;
    brick.radiusAdjustTo=null;
    brick.radiusAdjustFrom=null;
    brick.radiusAdjustStart=null;
    brick.radiusAdjustDuration=null;
    spawnParticles(brick.x, brick.y, '#ffe9ff', 64, 3.4, 4.8, 5.0);
    spawnParticles(brick.x, brick.y, '#9f6dff', 52, 3.0, 4.2, 4.4);
    spawnParticles(brick.x, brick.y, '#4a1b7a', 36, 2.6, 3.4, 3.6);
    spawnParticles(brick.x, brick.y, '#6effff', 42, 3.2, 4.6, 4.2);
    spawnParticles(brick.x, brick.y, '#ffd684', 26, 2.8, 4.0, 4.6);
    spawnDemonAbyssNovaFx(brick.x, brick.y, brick.hitRadius*2.2, now);
    playSFX('abyssBrickShatter');
    if(demonAttackActive && demonAttackActive.type==='abyssShatter'){
      realignDemonAbyssOrbit(demonAttackActive, now);
    }
    return true;
  }

  function spawnDemonAbyssNovaFx(x, y, radius, now){
    const baseRadius=Math.max(80, radius);
    const seed=Math.random()*TAU;
    demonAbyssExplosions.push({
      x,
      y,
      start:now,
      end:now+1200,
      radius:baseRadius,
      style:'abyssNova',
      seed,
      rings:3
    });
    demonAbyssExplosions.push({
      x,
      y,
      start:now+90,
      end:now+2200,
      radius:baseRadius*1.35,
      style:'abyssNovaAura',
      seed:seed+Math.PI/3
    });
    demonAbyssExplosions.push({
      x,
      y,
      start:now+180,
      end:now+1600,
      radius:baseRadius*0.9,
      style:'abyssNovaCore',
      seed:seed+Math.PI*0.75
    });
  }

  function strikeDemonAbyssBricksAtPoint(x, y, radius=6, source='generic'){
    if(!demonAbyssBricks.length) return false;
    const now=performance.now();
    let hit=false;
    for(const brick of demonAbyssBricks){
      if(!brick || brick.destroyed) continue;
      const dx=brick.x - x;
      const dy=brick.y - y;
      const range=brick.hitRadius + radius;
      if(dx*dx + dy*dy <= range*range){
        destroyDemonAbyssBrick(brick, source, now);
        hit=true;
      }
    }
    return hit;
  }

  function strikeDemonAbyssBricksAlongLine(x1,y1,x2,y2,source='generic'){
    if(!demonAbyssBricks.length) return false;
    const now=performance.now();
    let hit=false;
    for(const brick of demonAbyssBricks){
      if(!brick || brick.destroyed) continue;
      if(circleIntersectsSegment(brick.x, brick.y, brick.hitRadius, x1,y1,x2,y2)){
        destroyDemonAbyssBrick(brick, source, now);
        hit=true;
      }
    }
    return hit;
  }

  function strikeDemonAbyssBricksInCross(x, y, opts={}){
    if(!demonAbyssBricks.length) return false;
    const tolerance=Math.max(10, opts.tolerance||40);
    const diagTolerance=Math.max(10, opts.diagTolerance||50);
    const includeDiagonals=!!opts.includeDiagonals;
    const source=opts.source||'cross';
    let hit=false;
    for(const brick of demonAbyssBricks){
      if(!brick || brick.destroyed) continue;
      const dx=brick.x - x;
      const dy=brick.y - y;
      const hitsRow=Math.abs(dx)<=tolerance;
      const hitsCol=Math.abs(dy)<=tolerance;
      let hitsDiag=false;
      if(includeDiagonals){
        const sum=Math.abs(dx+dy);
        const diff=Math.abs(dx-dy);
        hitsDiag = diff<=diagTolerance || sum<=diagTolerance;
      }
      if(hitsRow || hitsCol || hitsDiag){
        destroyDemonAbyssBrick(brick, source);
        hit=true;
      }
    }
    return hit;
  }

  function triggerDemonAbyssFinale(now){
    for(const brick of demonAbyssBricks){
      if(!brick || brick.destroyed) continue;
      destroyDemonAbyssBrick(brick, 'finale', now);
    }
  }

  function bladeHellSlashWouldHitRect(angle, cx, cy, rect){
    if(!rect) return false;
    const len=Math.hypot(1100,700);
    const dx=Math.cos(angle);
    const dy=Math.sin(angle);
    const x1=cx - dx*len;
    const y1=cy - dy*len;
    const x2=cx + dx*len;
    const y2=cy + dy*len;
    return segmentIntersectsRect(x1,y1,x2,y2,rect);
  }

  function bladeHellComputeSafeRects(cx, cy, baseRect){
    if(!baseRect) return [];
    const margin=Math.max(24, (brickW||80)*0.5);
    const rects=[];
    if(!orientLeft){
      const w=Math.max(40, baseRect.w||desiredPaddleWidth());
      const h=Math.max(12, baseRect.h||paddle.h||18);
      const y=baseRect.y|| (700-h-10);
      const leftRect={x:cx - margin - w, y, w, h};
      const rightRect={x:cx + margin, y, w, h};
      leftRect.x=Math.max(0, Math.min(1100-w, leftRect.x));
      rightRect.x=Math.max(0, Math.min(1100-w, rightRect.x));
      rects.push(leftRect, rightRect);
    }else{
      const w=Math.max(12, baseRect.w||paddle.h||18);
      const h=Math.max(60, baseRect.h||desiredPaddleWidth());
      const L=layout();
      const topRect={x:baseRect.x||40, y:cy - margin - h, w, h};
      const bottomRect={x:baseRect.x||40, y:cy + margin, w, h};
      const minY=L.top;
      const maxY=700-h;
      topRect.y=Math.max(minY, Math.min(maxY, topRect.y));
      bottomRect.y=Math.max(minY, Math.min(maxY, bottomRect.y));
      rects.push(topRect, bottomRect);
    }
    return rects;
  }

  function bladeHellRandomAngle(context=null){
    const min=-Math.PI*0.6;
    const max=Math.PI*0.6;
    const rects=context?.safeRects||null;
    for(let attempt=0;attempt<60;attempt++){
      const angle=min + Math.random()*(max-min);
      if(Math.abs(Math.sin(angle))<0.12) continue;
      if(!rects || !rects.length){
        return angle;
      }
      let hit=false;
      for(const rect of rects){
        if(bladeHellSlashWouldHitRect(angle, context.x, context.y, rect)){
          hit=true; break;
        }
      }
      if(!hit) return angle;
    }
    return min + Math.random()*(max-min);
  }

  function captureHeartBurstPosition(prevLives){
    if(!heartsEl || !prevLives || prevLives<=0) return null;
    const icons = heartsEl.querySelectorAll('.life-icon');
    if(!icons.length) return null;
    const idx = Math.min(prevLives-1, icons.length-1);
    const target = icons[idx];
    if(!target) return null;
    const containerRect = heartsEl.getBoundingClientRect();
    const rect = target.getBoundingClientRect();
    return {
      x: rect.left - containerRect.left + rect.width/2,
      y: rect.top - containerRect.top + rect.height/2
    };
  }

  function spawnBladeHellHeartBurst(pos){
    if(!heartsEl || !pos) return;
    const burst=document.createElement('span');
    burst.className='life-blood-burst';
    burst.style.left=`${pos.x}px`;
    burst.style.top=`${pos.y}px`;
    burst.style.setProperty('--burst-rot', `${(Math.random()*40-20).toFixed(1)}deg`);
    heartsEl.appendChild(burst);
    setTimeout(()=>{ burst.remove(); }, 720);
  }

  function bladeHellPaddleHit(now, cause='slash'){
    if(now<paddleGoneUntil) return;
    if(demonAttackActive?.type==='bladeHell'){
      demonAttackActive.hitsTaken=(demonAttackActive.hitsTaken||0)+1;
    }
    const pr=paddleRect();
    const centerX=(pr.w>0 && pr.h>0)?(pr.x+pr.w/2):(demonBladeHellLastPaddleCenter?.x||550);
    const centerY=(pr.w>0 && pr.h>0)?(pr.y+pr.h/2):(demonBladeHellLastPaddleCenter?.y||640);
    demonBladeHellLastPaddleCenter={x:centerX,y:centerY};
    if(blockDamageIfShielded({x:centerX,y:centerY})){
      return;
    }
    if(stats.lifeStart){
      const dur=(now-stats.lifeStart)/1000;
      if(dur<stats.fastestDeath) stats.fastestDeath=dur;
      if(dur>stats.longestLife) stats.longestLife=dur;
    }
    stats.livesUsed++;
    if(buffs.BLACKHOLE.active){ buffs.BLACKHOLE.deaths=Math.min(8,(buffs.BLACKHOLE.deaths||0)+1); }
    if(buffs.ANNIHIL.active){ buffs.ANNIHIL.active=false; }
    if(cause==='beam'){
      spawnDemonSpearBlood(centerX, centerY);
      spawnParticles(centerX, centerY, '#3a0a18', 40, 3.4, 4.6, 4.0);
      spawnParticles(centerX, centerY, '#8a1340', 36, 2.8, 3.8, 3.4);
      paddleGoneUntil=now+3000;
    }else{
      spawnBladeHellBlood(centerX, centerY);
      spawnParticles(centerX, centerY, '#ff2952', 110, 3.2, 4.6, 3.8);
      spawnParticles(centerX, centerY, '#ffc7d9', 60, 2.6, 3.6, 3.2);
    }
    playSFX('explosion');
    screenShake=Math.max(screenShake, cause==='beam'?12:9);
    const prevLives=lives;
    const burstPos = (cause==='slash') ? captureHeartBurstPosition(prevLives) : null;
    lives=Math.max(0, lives-1);
    updateHUD();
    if(burstPos){ spawnBladeHellHeartBurst(burstPos); }
    for(const ball of balls){ if(ball.capturedByBladeHell) continue; ball.vy=-Math.abs(ball.vy||4); }
    if(lives<=0){ running=false; paused=true; showGameOver(); }
  }

  function spawnBladeHellTelegraph(def, attack, now){
    const prActual=paddleRect();
    const ghost=flipDecoy?.active
      ? {x:flipDecoy.x, y:flipDecoy.y, w:flipDecoy.w ?? desiredPaddleWidth(), h:flipDecoy.h ?? paddle.h}
      : null;
    const pr=ghost || prActual;
    const L=layout();
    let x, y;
    let baseRect=null;
    if(pr.w>0 && pr.h>0){
      x=pr.x+pr.w/2;
      y=pr.y+pr.h-8;
      baseRect={x:pr.x, y:pr.y, w:pr.w, h:pr.h};
      attack.lastPaddleRect={...baseRect};
      attack.lastPaddleX=x;
      attack.lastPaddleY=pr.y+pr.h/2;
      demonBladeHellLastPaddleCenter={x, y:pr.y+pr.h/2};
    }else{
      const fallbackRect=attack.lastPaddleRect?{...attack.lastPaddleRect}:null;
      if(fallbackRect){ baseRect={...fallbackRect}; }
      x=attack.lastPaddleX ?? demonBladeHellLastPaddleCenter.x ?? 550;
      y=(attack.lastPaddleY ?? demonBladeHellLastPaddleCenter.y ?? (L.top+480));
    }
    if(!baseRect){
      const width=desiredPaddleWidth();
      const height=Math.max(12, paddle.h||18);
      const centerY=(attack.lastPaddleY ?? demonBladeHellLastPaddleCenter.y ?? (L.top+520));
      baseRect={x:x-width/2, y:centerY-height/2, w:width, h:height};
    }
    baseRect.x=Math.max(0, Math.min(1100-(baseRect.w||0), baseRect.x));
    const minBaseY=L.top;
    const maxBaseY=700-(baseRect.h||0);
    baseRect.y=Math.max(minBaseY, Math.min(maxBaseY, baseRect.y));
    x=Math.max(60, Math.min(1100-60, x));
    y=Math.max(L.top+40, Math.min(700-24, y));
    const delay=def.slashDelay||500;
    const safeRects=bladeHellComputeSafeRects(x, y, baseRect);
    const tele={x,y,start:now,slashAt:now+delay,delay,angle:bladeHellRandomAngle({x,y,safeRects}),waveIndex:attack.waveIndex};
    demonBladeHellTelegraphs.push(tele);
    spawnParticles(x, y, '#ff4f4f', 18, 1.6, 2.6, 2.6);
    spawnParticles(x, y, '#ffd0c0', 10, 1.2, 2.0, 2.0);
  }

  function spawnBladeHellSlash(tele, now){
    const len=Math.hypot(1100,700);
    const dx=Math.cos(tele.angle);
    const dy=Math.sin(tele.angle);
    const x1=tele.x - dx*len;
    const y1=tele.y - dy*len;
    const x2=tele.x + dx*len;
    const y2=tele.y + dy*len;
    const slash={x1,y1,x2,y2,start:now,life:260,hitPaddle:false,waveIndex:tele.waveIndex};
    demonBladeHellSlashes.push(slash);
    spawnParticles(tele.x, tele.y, '#d8a6ff', 20, 1.6, 2.6, 2.6);
    playSFX('sword');
    screenShake=Math.max(screenShake,7);
    const pr=paddleRect();
    if(pr.w>0 && pr.h>0 && now>=paddleGoneUntil && segmentIntersectsRect(x1,y1,x2,y2, pr)){
      slash.hitPaddle=true;
      bladeHellPaddleHit(now,'slash');
    }
  }

  function updateBladeHellEffects(attack, now){
    for(let i=demonBladeHellTelegraphs.length-1;i>=0;i--){
      const tele=demonBladeHellTelegraphs[i];
      if(now>=tele.slashAt){
        spawnBladeHellSlash(tele, now);
        demonBladeHellTelegraphs.splice(i,1);
      }
    }
    for(let i=demonBladeHellSlashes.length-1;i>=0;i--){
      const slash=demonBladeHellSlashes[i];
      const life=slash.life||260;
      if(now>=slash.start+life){
        if(!slash.hitPaddle && now>=paddleGoneUntil){
          incrementCombo();
          addScore(30);
          updateHUD();
        }
        demonBladeHellSlashes.splice(i,1);
      }
    }
  }

  function scheduleBladeHellCounterstrike(now){
    demonBladeHellCounterSlashes.length=0;
    demonBladeHellCounterstrike={
      start:now+3000,
      activated:false,
      total:10,
      slashesDone:0,
      nextSlash:0,
      endAt:0,
      shakeUntil:0,
      shakeMagnitude:0,
      marqueeShown:false
    };
  }

  function spawnBladeHellCounterSlash(now){
    if(!demonBoss) return;
    const bounds=getDemonBounds();
    if(!bounds) return;
    const cx=bounds.x + Math.random()*bounds.w;
    const cy=bounds.y + Math.random()*bounds.h;
    const angle=bladeHellRandomAngle();
    const len=Math.hypot(bounds.w, bounds.h)+220;
    const dx=Math.cos(angle);
    const dy=Math.sin(angle);
    const x1=cx - dx*len;
    const y1=cy - dy*len;
    const x2=cx + dx*len;
    const y2=cy + dy*len;
    demonBladeHellCounterSlashes.push({x1,y1,x2,y2,start:now,life:260});
    spawnParticles(cx, cy, '#b05cff', 40, 2.6, 3.8, 3.2);
    spawnParticles(cx, cy, '#f0c2ff', 18, 2.2, 3.2, 2.8);
    spawnBladeHellBlood(cx, cy);
    screenShake=Math.max(screenShake,11);
    playSFX('sword');
        damageActiveBoss(3,'bladeHellReflect',{x:cx,y:cy},{ignoreCooldown:true,cooldown:60,screenShake:11});
  }

  function updateDemonBladeHellCounterstrike(now){
    const state=demonBladeHellCounterstrike;
    if(!state) return;
    if(!state.activated){
      if(now>=state.start){
        state.activated=true;
        state.nextSlash=now;
        state.shakeUntil=now+1600;
        state.shakeMagnitude=10;
        if(!state.marqueeShown){
          state.marqueeShown=true;
          demonEventMarquee={text:'魔王埃里赫曼被斬擊地獄反噬!', start:now, fadeStart:now+3000, end:now+3000, style:'elegant'};
        }
      }
      return;
    }
    if(state.slashesDone<state.total && now>=state.nextSlash){
      spawnBladeHellCounterSlash(now);
      state.slashesDone++;
      state.nextSlash=now+100;
      if(state.slashesDone>=state.total){
        state.endAt=now+900;
      }
    }
    if(state.endAt && now>=state.endAt){
      demonBladeHellCounterstrike=null;
    }
  }

  function startBladeHellBallCapture(now){
    if(demonBladeHellBallCapture){ forceReleaseBladeHellBall(); }
    if(!Array.isArray(balls) || !balls.length) return;
    const targetBall = balls[0];
    demonBladeHellBallCapture={
      ball:targetBall,
      start:now,
      state:'emerging',
      holdX:targetBall.x,
      holdY:targetBall.y,
      originalVX:targetBall.vx,
      originalVY:targetBall.vy,
      emergeDuration:600,
      releaseDuration:520,
      pulseOffset:Math.random()*Math.PI*2,
      handAngle:(orientLeft?Math.PI/2:-Math.PI/2)+(Math.random()*0.35-0.18),
      visible:0
    };
    targetBall.capturedByBladeHell=true;
    targetBall.vx=0;
    targetBall.vy=0;
  }

  function beginBladeHellBallRelease(now){
    const cap=demonBladeHellBallCapture;
    if(!cap) return;
    if(cap.state==='releasing') return;
    cap.state='releasing';
    cap.releaseStart=now;
  }

  function forceReleaseBladeHellBall(){
    const cap=demonBladeHellBallCapture;
    if(!cap) { demonBladeHellPlatformGlow=0; return; }
    const ball=cap.ball;
    if(ball && balls.includes(ball)){
      ball.capturedByBladeHell=false;
      let vx=cap.originalVX;
      let vy=cap.originalVY;
      if(!vx && !vy){
        vx=0; vy=0;
      }
      if(Math.abs(vx)+Math.abs(vy)<0.2){
        const sp=Math.max(6, speedForLevel(level));
        const ang=-Math.PI/2 + (Math.random()*0.3-0.15);
        vx=Math.cos(ang)*sp*0.75;
        vy=Math.sin(ang)*sp;
      }
      ball.vx=vx;
      ball.vy=vy;
    }
    demonBladeHellBallCapture=null;
  }

  function updateBladeHellBallCapture(now){
    const cap=demonBladeHellBallCapture;
    if(!cap) return;
    const ball=cap.ball;
    if(!ball || !balls.includes(ball)){
      demonBladeHellBallCapture=null;
      return;
    }
    if(cap.state!=='releasing'){
      if(!demonAttackActive || demonAttackActive.type!=='bladeHell' || demonAttackActive.stage!=='hell'){
        beginBladeHellBallRelease(now);
      }
    }
    if(cap.state==='releasing'){
      const dur=cap.releaseDuration||500;
      const start=cap.releaseStart||now;
      const prog=Math.min(1, Math.max(0, (now-start)/dur));
      cap.visible = 1 - prog;
      cap.holdX = cap.holdX ?? ball.x;
      cap.holdY = cap.holdY ?? ball.y;
      ball.x = cap.holdX;
      ball.y = cap.holdY;
      ball.vx = 0;
      ball.vy = 0;
      if(prog>=1){
        forceReleaseBladeHellBall();
      }
      return;
    }
    const dur=cap.emergeDuration||600;
    const prog=Math.min(1, Math.max(0,(now-cap.start)/dur));
    cap.visible = prog;
    if(prog>=1){ cap.state='holding'; }
    cap.holdX = cap.holdX ?? ball.x;
    cap.holdY = cap.holdY ?? ball.y;
    ball.x = cap.holdX;
    ball.y = cap.holdY;
    ball.vx = 0;
    ball.vy = 0;
  }

  function startDemonBladeHell(now){
    if(!demonBoss) return;
    const prActual=paddleRect();
    const ghost=flipDecoy?.active
      ? {x:flipDecoy.x, y:flipDecoy.y, w:flipDecoy.w ?? desiredPaddleWidth(), h:flipDecoy.h ?? paddle.h}
      : null;
    const pr=ghost || prActual;
    const L=layout();
    const targetX=(pr.w>0 && pr.h>0)?(pr.x+pr.w/2):(demonBoss.x||550);
    const normalBase=demonBoss.normalBaseY ?? demonBoss.baseY;
    demonBladeHellTelegraphs.length=0;
    demonBladeHellSlashes.length=0;
    demonAbyssBricks.length=0;
    demonAbyssExplosions.length=0;
    const bodyHalfWidth=Math.max(6, (demonBoss?.w||90)/2);
    demonAttackActive={
      type:'bladeHell',
      start:now,
      stage:'windup',
      overrideMovement:true,
      targetX,
      targetBase:normalBase,
      lockedTargetX:targetX,
      lockedBaseY:demonBoss.baseY,
      beam:{
        start:now,
        damageAt:now+500,
        expandUntil:now+2500,
        vanishAt:now+3000,
        radius:4,
        initialRadius:4,
        maxRadius:bodyHalfWidth,
        x:targetX,
        damaging:false,
        damageStartedAt:0,
        contactStart:null
      },
      currentDarkness:0,
      targetDarkness:0.68,
      currentPlatformGlow:0,
      currentBallGlow:0,
      countdownDuration:30000,
      countdownStart:0,
      countdownEnd:0,
      waveDefs:[
        {rounds:3, points:3, pointInterval:500, roundInterval:1000, slashDelay:300},
        {rounds:3, points:2, pointInterval:200, roundInterval:1000, slashDelay:300},
        {rounds:3, points:3, pointInterval:200, roundInterval:1000, slashDelay:300},
        {rounds:3, points:4, pointInterval:200, roundInterval:1000, slashDelay:300},
        {rounds:1, points:30, pointInterval:100, roundInterval:0, slashDelay:300}
      ],
      waveIndex:-1,
      waveState:null,
      nextWaveAt:0,
      hitsTaken:0,
      lastPaddleX:(pr.w>0 && pr.h>0)?(pr.x+pr.w/2):(demonBladeHellLastPaddleCenter.x||targetX),
      lastPaddleY:(pr.w>0 && pr.h>0)?(pr.y+pr.h/2):(demonBladeHellLastPaddleCenter.y|| (L.top+480)),
      lastPaddleRect:(pr.w>0 && pr.h>0)?{x:pr.x,y:pr.y,w:pr.w,h:pr.h}:null
    };
    demonEventMarquee={text:'危險！ 魔王埃里赫曼即將召喚斬擊地獄!', start:now, fadeStart:now+3000, end:now+3000, style:'elegant', countdown:{start:now, end:now+3000}};
    demonEventShakeUntil=now+3200;
    demonBoss.mode='attack';
    demonBoss.knockbackVX=0;
    demonBoss.knockbackVY=0;
    demonBoss.moveTarget=null;
    demonBoss.lowKnockbacks=0;
    demonBoss.lastKnockbackAt=now;
    demonBoss.attackAura='bladeHell';
  }

  function updateDemonBladeHell(now, dt){
    if(!demonAttackActive || demonAttackActive.type!=='bladeHell' || !demonBoss) return;
    const attack=demonAttackActive;
    const lerp=1-Math.pow(0.001, dt/16);
    const prActual=paddleRect();
    const ghost=flipDecoy?.active
      ? {x:flipDecoy.x, y:flipDecoy.y, w:flipDecoy.w ?? desiredPaddleWidth(), h:flipDecoy.h ?? paddle.h}
      : null;
    const pr=ghost || prActual;
    const normalBase=demonBoss.normalBaseY ?? demonBoss.baseY;
    const desiredX=(pr.w>0 && pr.h>0)?(pr.x+pr.w/2):attack.targetX;
    if(attack.stage==='windup'){
      if(attack.lockedTargetX==null){ attack.lockedTargetX = attack.targetX ?? demonBoss.x; }
      if(attack.lockedBaseY==null){ attack.lockedBaseY = demonBoss.baseY; }
      attack.targetX=attack.lockedTargetX;
      attack.targetBase=attack.lockedBaseY;
    }else if(attack.stage==='ending'){
      const lockX = (attack.endingLockX!=null) ? attack.endingLockX : (attack.endBeam?.x ?? demonBoss.x);
      const lockBase = (attack.endingLockBase!=null) ? attack.endingLockBase : (attack.lockedBaseY ?? demonBoss.baseY);
      attack.targetX = lockX;
      attack.targetBase = lockBase;
      attack.endingLockX = lockX;
      attack.endingLockBase = lockBase;
    }else{
      attack.targetX=desiredX;
      attack.targetBase=normalBase;
    }
    demonBoss.x += (attack.targetX - demonBoss.x)*lerp;
    demonBoss.baseY += (attack.targetBase - demonBoss.baseY)*lerp*0.35;
    demonBoss.knockbackVX*=Math.pow(0.6, dt/16);
    demonBoss.knockbackVY*=Math.pow(0.6, dt/16);
    if(pr.w>0 && pr.h>0){
      attack.lastPaddleX=pr.x+pr.w/2;
      attack.lastPaddleY=pr.y+pr.h/2;
      attack.lastPaddleRect={x:pr.x,y:pr.y,w:pr.w,h:pr.h};
      demonBladeHellLastPaddleCenter={x:attack.lastPaddleX, y:attack.lastPaddleY};
    }
    let beam=null;
    if(attack.stage==='windup'){ beam=attack.beam; }
    else if(attack.stage==='ending'){ beam=attack.endBeam; }
    if(beam){
      const bodyHalfWidth=Math.max(6, (demonBoss?.w||90)/2);
      beam.maxRadius=bodyHalfWidth;
      if(attack.stage==='windup'){ beam.x=demonBoss.x; }
      if(now>=beam.damageAt){
        if(!beam.damaging){
          beam.damaging=true;
          beam.damageStartedAt=beam.damageStartedAt||now;
          beam.contactStart=null;
          playSFX('bladeHellBeamExpand');
        }
      }
      const initialRadius=beam.initialRadius ?? 4;
      if(now<beam.damageAt){ beam.radius=initialRadius; }
      else if(now<beam.expandUntil){
        const prog=Math.max(0, Math.min(1, (now-beam.damageAt)/Math.max(1, beam.expandUntil-beam.damageAt)));
        beam.radius=initialRadius + (beam.maxRadius-initialRadius)*prog;
      }else{
        beam.radius=beam.maxRadius;
      }
      if(beam.damaging){
        const prNow=paddleRect();
        if(prNow.w>0 && prNow.h>0 && now>=paddleGoneUntil){
          const L=layout();
          const radius=Math.max(4, beam.radius||0);
          const rect={x:(beam.x||demonBoss.x)-radius, y:L.top, w:radius*2, h:700-L.top};
          if(rectsOverlap(rect, prNow)){
            if(!beam.contactStart){
              beam.contactStart=now;
            }
            if(now - beam.contactStart >= 1000){
              bladeHellPaddleHit(now,'beam');
              beam.contactStart=now;
            }
          }else{
            beam.contactStart=null;
          }
        }else{
          beam.contactStart=null;
        }
      }
    }
    if(attack.stage==='windup'){
      attack.currentDarkness=Math.min(attack.targetDarkness, attack.currentDarkness + dt/2400);
      attack.currentPlatformGlow=Math.min(1, (attack.currentPlatformGlow||0) + dt/1800);
      attack.currentBallGlow=Math.min(1, attack.currentBallGlow + dt/1500);
      if(now>=attack.beam.vanishAt){
        attack.stage='hell';
        attack.countdownStart=now;
        attack.countdownEnd=now+attack.countdownDuration;
        attack.nextWaveAt=now+2000;
        attack.waveIndex=-1;
        attack.waveState=null;
        demonBoss.hiddenUntil = Math.max(demonBoss.hiddenUntil||0, attack.countdownEnd+800);
        startBladeHellBallCapture(now);
      }
    }else if(attack.stage==='hell'){
      attack.currentDarkness=Math.min(attack.targetDarkness, attack.currentDarkness + dt/3200);
      attack.currentPlatformGlow=Math.min(1, (attack.currentPlatformGlow||0) + dt/2200);
      attack.currentBallGlow=Math.min(1, attack.currentBallGlow + dt/2000);
      if(attack.waveState){
        const ws=attack.waveState;
        if(!ws.roundState && now>=ws.nextRoundAt){
          ws.roundState={pointIndex:0,nextPointAt:now};
        }
        if(ws.roundState){
          const rs=ws.roundState;
          while(rs.pointIndex<ws.def.points && now>=rs.nextPointAt){
            spawnBladeHellTelegraph(ws.def, attack, now);
            rs.pointIndex++;
            rs.nextPointAt += ws.def.pointInterval;
          }
          if(rs.pointIndex>=ws.def.points){
            ws.roundState=null;
            ws.roundIndex=(ws.roundIndex||0)+1;
            ws.nextRoundAt = now + ws.def.roundInterval;
            if(ws.roundIndex>=ws.def.rounds){
              attack.waveState=null;
              attack.nextWaveAt = now + 2000;
            }
          }
        }
      }else if(attack.waveIndex+1 < attack.waveDefs.length && now>=attack.nextWaveAt){
        attack.waveIndex++;
        const def=attack.waveDefs[attack.waveIndex];
        attack.waveState={def, roundIndex:0, nextRoundAt:now, roundState:null};
      }
      updateBladeHellEffects(attack, now);
      for(const ball of balls){ suppressSpeedBoost(ball, now, 200); }
      if(attack.countdownEnd && now>=attack.countdownEnd){
        attack.stage='ending';
        demonBladeHellTelegraphs.length=0;
        const prNow=paddleRect();
        const fallbackBeamX = attack.lastPaddleX ?? demonBladeHellLastPaddleCenter?.x ?? 550;
        const beamX=(prNow.w>0 && prNow.h>0)?(prNow.x+prNow.w/2):fallbackBeamX;
        const bodyHalfWidth=Math.max(6, (demonBoss?.w||90)/2);
        attack.endBeam={
          start:now,
          damageAt:now+500,
          expandUntil:now+2500,
          vanishAt:now+3000,
          radius:4,
          initialRadius:4,
          maxRadius:bodyHalfWidth,
          x:beamX,
          damaging:false,
          damageStartedAt:0,
          contactStart:null
        };
        attack.endingLockX = beamX;
        attack.endingLockBase = demonBoss.baseY;
        demonBoss.x = beamX;
        demonBoss.baseY = attack.endingLockBase;
        const reappearLead=300;
        const endBeamVanish=attack.endBeam.vanishAt||0;
        if(endBeamVanish>0){
          const desiredReturn=endBeamVanish - reappearLead;
          demonBoss.hiddenUntil = Math.max(demonBoss.hiddenUntil||0, desiredReturn);
        }
        demonEventShakeUntil=now+3200;
        beginBladeHellBallRelease(now);
      }
    }else if(attack.stage==='ending'){
      attack.currentDarkness=Math.max(0, attack.currentDarkness - dt/2200);
      attack.currentPlatformGlow=Math.max(0, (attack.currentPlatformGlow||0) - dt/2000);
      attack.currentBallGlow=Math.max(0, attack.currentBallGlow - dt/1800);
      updateBladeHellEffects(attack, now);
      demonBoss.knockbackVX=0;
      demonBoss.knockbackVY=0;
      if(attack.endBeam && now>=attack.endBeam.vanishAt){
        const flawless=(attack.hitsTaken||0)===0;
        demonBladeHellTelegraphs.length=0;
        demonBladeHellSlashes.length=0;
        finishDemonAttack(now);
        if(flawless){ scheduleBladeHellCounterstrike(now); }
      }
    }
  }

  function updateDemonAbyssBricks(now, attack, dt){
    if(attack){
      const orbitDt=Math.max(0, now - (attack.lastOrbitUpdate||now));
      const omega=attack.orbitAngularSpeed || ((Math.PI*2)/2200);
      attack.orbitAngularSpeed=omega;
      attack.orbitRotation=normalizeAngle((attack.orbitRotation||0) + omega*orbitDt);
      attack.lastOrbitUpdate=now;
      if(attack.orbitRadius==null){ attack.orbitRadius=attack.orbitRadiusBase ?? 140; }
    }
    for(let i=demonAbyssBricks.length-1;i>=0;i--){
      const brick=demonAbyssBricks[i];
      if(!brick){ demonAbyssBricks.splice(i,1); continue; }
      const prevX=brick.x;
      const prevY=brick.y;
      const delta=now-(brick.lastUpdate||now);
      brick.lastUpdate=now;
      if(brick.destroyed){
        if(now>=brick.removeAt){ demonAbyssBricks.splice(i,1); }
        continue;
      }
      const center=(attack && attack.orbitCenter) ? attack.orbitCenter : (brick.orbitCenter||{x:550,y:350});
      brick.orbitCenter=center;
      if(brick.state==='flying'){
        const dur=Math.max(1, brick.arrivalDuration||1000);
        const prog=Math.max(0, Math.min(1, (now-brick.spawnAt)/dur));
        brick.x = brick.startX + (brick.targetX-brick.startX)*prog;
        brick.y = brick.startY + (brick.targetY-brick.startY)*prog;
        if(prog>=1){
          brick.state='orbit';
          brick.phaseOffset = Math.random()*Math.PI*2;
          if(attack){
            const rotation=attack.orbitRotation||0;
            const actual=Math.atan2(brick.y-center.y, brick.x-center.x);
            brick.baseAngle=normalizeAngle(actual - rotation);
            brick.baseAngleStart=null;
            brick.baseAngleTarget=null;
            brick.orbitRadius=attack.orbitRadius ?? attack.orbitRadiusBase ?? brick.orbitRadius;
            brick.radiusAdjustTo=null;
            realignDemonAbyssOrbit(attack, now);
          }else{
            brick.angle=Math.atan2(brick.y-center.y, brick.x-center.x);
          }
        }
      }else if(brick.state==='orbit' || brick.state==='beam'){
        if(attack){
          let orbitRadius=brick.orbitRadius ?? attack.orbitRadius ?? attack.orbitRadiusBase ?? 140;
          if(brick.radiusAdjustTo!=null){
            const start=brick.radiusAdjustStart||now;
            const dur=Math.max(1, brick.radiusAdjustDuration||500);
            const t=Math.max(0, Math.min(1, (now-start)/dur));
            const eased=easeOutCubic(t);
            const from=brick.radiusAdjustFrom ?? orbitRadius;
            const to=brick.radiusAdjustTo;
            orbitRadius = from + (to-from)*eased;
            brick.orbitRadius=orbitRadius;
            if(t>=1){
              brick.radiusAdjustTo=null;
              brick.radiusAdjustFrom=null;
              brick.radiusAdjustStart=null;
              brick.radiusAdjustDuration=null;
            }
          }else{
            brick.orbitRadius=orbitRadius;
          }
          let baseAngle=brick.baseAngle ?? 0;
          if(brick.baseAngleTarget!=null){
            const start=brick.baseAngleAdjustStart||now;
            const dur=Math.max(1, brick.baseAngleAdjustDuration||500);
            const t=Math.max(0, Math.min(1, (now-start)/dur));
            const eased=easeOutCubic(t);
            const from=(brick.baseAngleStart!=null)?brick.baseAngleStart:baseAngle;
            const diff=shortestAngleDiff(brick.baseAngleTarget, from);
            baseAngle=normalizeAngle(from + diff*eased);
            brick.baseAngle=baseAngle;
            if(t>=1){
              brick.baseAngle=normalizeAngle(brick.baseAngleTarget);
              brick.baseAngleTarget=null;
              brick.baseAngleStart=null;
              brick.baseAngleAdjustStart=null;
              brick.baseAngleAdjustDuration=null;
            }
          }
          const rotation=attack.orbitRotation||0;
          const jitter = 6*Math.sin((now/240)+(brick.phaseOffset||0));
          const radius=Math.max(60, (brick.orbitRadius ?? orbitRadius) + jitter);
          const angle=normalizeAngle(rotation + (brick.baseAngle ?? baseAngle));
          brick.angle=angle;
          brick.x = center.x + Math.cos(angle)*radius;
          brick.y = center.y + Math.sin(angle)*radius;
        }else{
          const omega=brick.orbitSpeed || ((Math.PI*2)/2000);
          brick.angle = (brick.angle||0) + omega*delta;
          const jitter = 6*Math.sin((now/240)+(brick.phaseOffset||0));
          const radius=Math.max(60, (brick.orbitRadius||140) + jitter);
          brick.x = center.x + Math.cos(brick.angle)*radius;
          brick.y = center.y + Math.sin(brick.angle)*radius;
        }
      }else if(brick.state==='projectile'){
        const dur=Math.max(1, brick.travelDuration||1000);
        const elapsed=now - (brick.launchAt||now);
        const t=Math.max(0, Math.min(1, elapsed/dur));
        const nx=brick.targetX - brick.startX;
        const ny=brick.targetY - brick.startY;
        const newX=brick.startX + nx*t;
        const newY=brick.startY + ny*t;
        const pr=paddleRect();
        if(!brick.projectileResolved && pr.w>0 && pr.h>0 && now>=paddleGoneUntil){
          if(lineIntersectsRect(prevX, prevY, newX, newY, pr)){
            const hitX=pr.x+pr.w/2;
            const hitY=pr.y+pr.h/2;
            if(blockDamageIfShielded({x:hitX,y:hitY})){
              destroyDemonAbyssBrick(brick,'paddle', now);
            }else{
              spawnAbyssPlatformShatter(hitX, hitY);
              paddleGoneUntil=now+3000;
              destroyDemonAbyssBrick(brick,'paddle', now);
            }
            brick.projectileResolved=true;
            continue;
          }
        }
        brick.x=newX;
        brick.y=newY;
        if(t>=1 && !brick.projectileResolved){
          destroyDemonAbyssBrick(brick,'impact', now);
          brick.projectileResolved=true;
        }
      }
      brick.prevX=prevX;
      brick.prevY=prevY;
    }
  }

  function updateDemonAbyssResiduals(now){
    for(let i=demonAbyssExplosions.length-1;i>=0;i--){
      const fx=demonAbyssExplosions[i];
      if(!fx){ demonAbyssExplosions.splice(i,1); continue; }
      if(now>=fx.end){ demonAbyssExplosions.splice(i,1); }
    }
  }

  function startDemonAbyssShatter(now){
    if(!demonBoss) return;
    const L=layout();
    const stageTop=L.top;
    const stageHeight=700-stageTop;
    const center={x:550, y:stageTop + stageHeight*0.38};
    demonAbyssBricks.length=0;
    demonAbyssExplosions.length=0;
    const attack={
      type:'abyssShatter',
      start:now,
      stage:'countdown',
      overrideMovement:true,
      countdownEnd:now+10000,
      spawnStart:now+1000,
      spawnEnd:now+9000,
      nextSpawn:now+1000,
      spawnInterval:500,
      orbitCenter:center,
      orbitRadiusBase:Math.min(200, Math.max(110, stageHeight*0.20)),
      orbitRadius:Math.min(200, Math.max(110, stageHeight*0.20)),
      orbitRotation:0,
      spawnCount:0,
      orbitAngleSeed:null,
      nextOrbitOrder:0,
      lastOrbitUpdate:now,
      bossDepartStart:now,
      bossDepartEnd:now+1000,
      bossDepartFrom:demonBoss.baseY,
      bossDepartTo:stageTop-220,
      bossVanishY:stageTop-260,
      bossOffscreenY:stageTop-340,
      bossAscendSpeed:420,
      bossDepartureComplete:false,
      bossAnchorX:demonBoss.x,
      bossAnchorY:demonBoss.baseY,
      hideBoss:false,
      minBaseClamp:stageTop-360,
      evaluated:false,
      resolveAt:0,
      result:null,
      beamEnd:0,
      cleanupAt:0,
      returnTarget:demonBoss.normalBaseY ?? demonBoss.baseY,
      returnStart:0,
      returnDuration:1200
    };
    demonAttackActive=attack;
    demonAttackNextAt=0;
    demonBoss.mode='attack';
    demonBoss.knockbackVX=0;
    demonBoss.knockbackVY=0;
    demonBoss.moveTarget=null;
    demonBoss.lowKnockbacks=0;
    demonBoss.lastKnockbackAt=now;
    demonBoss.attackAura='abyssShatter';
    demonEventMarquee={text:'危險！ 魔王埃里赫曼即將施展深淵破碎!', start:now, fadeStart:now+10000, end:now+10000, style:'elegant', countdown:{start:now, end:now+10000}};
  }

  function updateDemonAbyssShatter(now, dt){
    if(!demonAttackActive || demonAttackActive.type!=='abyssShatter' || !demonBoss) return;
    const attack=demonAttackActive;
    const lerp=Math.min(1, dt/260);
    const anchorX=attack.bossAnchorX ?? demonBoss.x;
    demonBoss.x += (anchorX - demonBoss.x)*lerp;
    const stage=attack.stage;
    const vanishY=(attack.bossVanishY!=null)?attack.bossVanishY:(attack.bossDepartTo-80);
    const offscreenY=(attack.bossOffscreenY!=null)?attack.bossOffscreenY:(vanishY-120);
    const ascendSpeed=Math.max(180, attack.bossAscendSpeed||420);
    if(stage!=='return'){
      if(!attack.hideBoss){
        if(!attack.bossDepartureComplete){
          if(now<attack.bossDepartEnd){
            const prog=Math.max(0, Math.min(1, (now-attack.bossDepartStart)/Math.max(1, attack.bossDepartEnd-attack.bossDepartStart)));
            const base=attack.bossDepartFrom + (attack.bossDepartTo-attack.bossDepartFrom)*prog;
            demonBoss.baseY=base;
            demonBoss.y=base;
            if(prog>=1){
              attack.bossDepartureComplete=true;
              demonBoss.baseY=attack.bossDepartTo;
              demonBoss.y=attack.bossDepartTo;
            }
          }else{
            attack.bossDepartureComplete=true;
            demonBoss.baseY=attack.bossDepartTo;
            demonBoss.y=attack.bossDepartTo;
          }
        }else{
          const dtSec=Math.max(0.001, dt/1000);
          demonBoss.baseY=Math.min(demonBoss.baseY, attack.bossDepartTo);
          demonBoss.baseY -= ascendSpeed*dtSec;
          if(demonBoss.baseY<=vanishY){
            if(demonBoss.baseY<=offscreenY){
              demonBoss.baseY=offscreenY;
              attack.hideBoss=true;
              attack.bossGoneAt=now;
            }
          }
          demonBoss.y=demonBoss.baseY;
        }
      }else{
        demonBoss.baseY=offscreenY;
        demonBoss.y=offscreenY;
      }
    }
    if(now>=attack.spawnStart && now<attack.spawnEnd && now>=attack.nextSpawn){
      spawnDemonAbyssBrick(attack, now);
      attack.nextSpawn += attack.spawnInterval;
    }
    updateDemonAbyssBricks(now, attack, dt);
    updateDemonAbyssResiduals(now);
    if(!attack.evaluated && now>=attack.countdownEnd){
      const remaining=demonAbyssBricks.filter(b=>b && !b.destroyed).length;
      attack.remaining=remaining;
      attack.result=remaining>=9?'beam':'barrage';
      attack.evaluated=true;
      attack.stage='resolve';
      attack.resolveAt=now+2000;
    }
    if(attack.stage==='resolve'){
      if(now>=attack.resolveAt){
        if(attack.result==='beam' && demonAbyssBricks.some(b=>b && !b.destroyed)){
          attack.stage='beam';
          attack.beamEnd=now+4000;
          for(const brick of demonAbyssBricks){ if(!brick || brick.destroyed) continue; brick.state='beam'; }
          realignDemonAbyssOrbit(attack, now);
        }else if(attack.result==='barrage' && demonAbyssBricks.some(b=>b && !b.destroyed)){
          attack.stage='launch';
          attack.nextLaunch=now;
        }else{
          attack.stage='cleanup';
          attack.cleanupAt=now+2000;
        }
      }
      return;
    }
    if(attack.stage==='beam'){
      updateDemonAbyssBricks(now, attack, dt);
      const pr=paddleRect();
      if(pr.w>0 && pr.h>0 && now>=paddleGoneUntil){
        for(const brick of demonAbyssBricks){
          if(!brick || brick.destroyed) continue;
          const center=attack.orbitCenter || {x:brick.x,y:brick.y};
          const dir=Math.atan2(brick.y-center.y, brick.x-center.x);
          const reach=1400;
          const endX=brick.x + Math.cos(dir)*reach;
          const endY=brick.y + Math.sin(dir)*reach;
          if(lineIntersectsRect(brick.x, brick.y, endX, endY, pr)){
            const hitX=pr.x+pr.w/2;
            const hitY=pr.y+pr.h/2;
            if(!blockDamageIfShielded({x:hitX,y:hitY})){
              spawnAbyssPlatformShatter(hitX, hitY);
              paddleGoneUntil=now+3000;
            }
          }
        }
      }
      if(now>=attack.beamEnd){
        triggerDemonAbyssFinale(now);
        attack.stage='cleanup';
        attack.cleanupAt=now+2000;
      }
      return;
    }
    if(attack.stage==='launch'){
      if(now>=attack.nextLaunch){
        const candidate=demonAbyssBricks.find(b=>b && !b.destroyed && (b.state==='orbit' || b.state==='beam'));
        if(candidate){
          candidate.state='projectile';
          candidate.baseAngleTarget=null;
          candidate.baseAngleStart=null;
          candidate.radiusAdjustTo=null;
          candidate.startX=candidate.x;
          candidate.startY=candidate.y;
          const prNow=paddleRect();
          const targetX=(prNow.w>0 && prNow.h>0)?(prNow.x+prNow.w/2):(attack.orbitCenter?.x??550);
          const targetY=(prNow.w>0 && prNow.h>0)?(prNow.y+prNow.h/2):(700-60);
          candidate.targetX=targetX;
          candidate.targetY=targetY;
          candidate.launchAt=now;
          candidate.travelDuration=1000;
          candidate.projectileResolved=false;
          attack.nextLaunch=now+1000;
          realignDemonAbyssOrbit(attack, now);
        }else if(!demonAbyssBricks.some(b=>b && !b.destroyed)){
          attack.stage='cleanup';
          attack.cleanupAt=now+2000;
        }
      }
      updateDemonAbyssBricks(now, attack, dt);
      if(!demonAbyssBricks.some(b=>b && !b.destroyed)){
        attack.stage='cleanup';
        attack.cleanupAt=now+2000;
      }
      return;
    }
    if(attack.stage==='cleanup'){
      updateDemonAbyssBricks(now, attack, dt);
      if(!demonAbyssBricks.some(b=>b && !b.destroyed) && now>=attack.cleanupAt){
        attack.stage='return';
        attack.hideBoss=false;
        attack.returnStart=now;
        attack.returnFrom=demonBoss.baseY;
        attack.returnDuration=Math.max(800, attack.returnDuration||1200);
      }
      return;
    }
    if(attack.stage==='return'){
      const dur=Math.max(1, attack.returnDuration||1200);
      const prog=Math.max(0, Math.min(1, (now-attack.returnStart)/dur));
      const base=attack.returnFrom + (attack.returnTarget-attack.returnFrom)*prog;
      demonBoss.baseY=base;
      demonBoss.y=base;
      demonBoss.x += (anchorX - demonBoss.x)*lerp;
      if(prog>=1){
        attack.hideBoss=false;
        demonAbyssBricks.length=0;
        finishDemonAttack(now);
      }
    }
  }

  function startDemonBlackRitual(now){
    if(!demonBoss) return;
    const L=layout();
    const laneWidth=Math.max((brickW||80)*2, 140);
    const margin=120;
    const minX=margin + laneWidth/2;
    const maxX=1100 - margin - laneWidth/2;
    const lanes=[];
    for(let attempts=0;lanes.length<3 && attempts<40;attempts++){
      const x=minX + Math.random()*(Math.max(minX, maxX)-minX);
      if(lanes.every(l=>Math.abs(l.x-x)>laneWidth*0.9)){
        lanes.push({x, width:laneWidth, queue:[]});
      }
    }
    if(lanes.length<3){
      const step=(maxX-minX)/2;
      lanes.length=0;
      for(let i=0;i<3;i++) lanes.push({x:minX+step*i, width:laneWidth, queue:[]});
    }
    demonBlackSpears=[];
    demonAbyssBricks.length=0;
    demonAbyssExplosions.length=0;
    demonBloodEffects.length=0;
    demonAttackActive={
      type:'blackRitual',
      start:now,
      stage:'windup',
      countdownUntil:now+3000,
      spawnInterval:80,
      launchInterval:100,
      launchSpeed:2200,
      launchEnd:0,
      lanes,
      queue:[],
      spearsPerLane:20,
      overrideMovement:true,
      targetX:1100/2,
      targetBase:Math.max(L.top+110, (demonBoss.normalBaseY??demonBoss.baseY)-40)
    };
    for(const lane of lanes){
      lane.queue=[];
      lane.spawnedCount=0;
      lane.maxSpears=demonAttackActive.spearsPerLane;
      lane.spawnNextAt=now;
      lane.launchIndex=0;
      lane.nextLaunchAt=0;
    }
    demonBoss.mode='attack';
    demonBoss.knockbackVX=0;
    demonBoss.knockbackVY=0;
    demonBoss.moveTarget=null;
    demonBoss.lowKnockbacks=0;
    demonBoss.lastKnockbackAt=now;
    demonBoss.attackAura='blackRitual';
    demonEventMarquee={text:'危險！ 魔王埃里赫曼即將施展黑之陣!', start:now, fadeStart:now+3000, end:now+3000, style:'elegant', countdown:{start:now, end:now+3000}};
  }

  function finishDemonAttack(now){
    if(!demonAttackActive || !demonBoss) { demonAttackActive=null; return; }
    demonBoss.attackAura=null;
    demonBoss.mode='descending';
    demonBoss.descentStart=now;
    demonBoss.moveTarget=null;
    if(demonAttackActive.type==='bladeHell'){
      demonBladeHellTelegraphs.length=0;
      demonBladeHellSlashes.length=0;
      beginBladeHellBallRelease(now);
      forceReleaseBladeHellBall();
    }else if(demonAttackActive.type==='abyssShatter'){
      demonAbyssBricks.length=0;
      demonAbyssExplosions.length=0;
    }
    demonAttackActive=null;
    demonAttackNextAt = now + DEMON_ATTACK_INTERVAL;
  }

  function updateDemonBlackRitual(now, dt){
    if(!demonAttackActive || demonAttackActive.type!=='blackRitual' || !demonBoss) return;
    const attack=demonAttackActive;
    const lerp=1-Math.pow(0.001, dt/16);
    demonBoss.x += (attack.targetX - demonBoss.x)*lerp;
    demonBoss.baseY += (attack.targetBase - demonBoss.baseY)*lerp;
    demonBoss.knockbackVX*=Math.pow(0.7, dt/16);
    demonBoss.knockbackVY*=Math.pow(0.7, dt/16);
    if(attack.stage==='windup'){
      const spawnInterval=Math.max(30, attack.spawnInterval||80);
      for(const lane of attack.lanes){
        if(!lane.spawnNextAt){ lane.spawnNextAt=now; }
        while(lane.spawnedCount<lane.maxSpears && now>=lane.spawnNextAt){
          const laneSpan = lane.width || Math.max((brickW||80)*2, 140);
          const spread=laneSpan*0.45;
          const offset=(Math.random()*2-1)*spread;
          const spearWidth=Math.max(24, laneSpan*(0.24 + Math.random()*0.08));
          const spearLength=Math.max(260, (brickH||40)*(3.6 + Math.random()*0.8));
          const spear=spawnDemonBlackSpear(lane, now, {
            x: lane.x + offset,
            width: spearWidth,
            length: spearLength,
            tipScale: 0.16 + Math.random()*0.1
          });
          lane.spawnedCount++;
          lane.spawnNextAt += spawnInterval;
          attack.queue.push(spear);
        }
      }
      if(now>=attack.countdownUntil){
        attack.stage='barrage';
        attack.launchStart=now;
        attack.launchEnd=now+2000;
        for(const lane of attack.lanes){
          lane.launchIndex=0;
          lane.nextLaunchAt=now;
        }
      }
    }else if(attack.stage==='barrage'){
      const launchInterval=Math.max(60, attack.launchInterval||100);
      let allLaunched=true;
      for(const lane of attack.lanes){
        if(!lane.queue || !lane.queue.length) continue;
        if(lane.launchIndex===undefined){ lane.launchIndex=0; }
        if(!lane.nextLaunchAt){ lane.nextLaunchAt=now; }
        while(lane.launchIndex<lane.queue.length && now>=lane.nextLaunchAt){
          const spear=lane.queue[lane.launchIndex++];
          lane.nextLaunchAt += launchInterval;
          if(spear && spear.state==='charging'){
            spear.state='falling';
            spear.launchAt=now;
            spear.vy=attack.launchSpeed||2200;
          }
        }
        if(lane.launchIndex<lane.queue.length){
          allLaunched=false;
        }
      }
      if(allLaunched && now>=attack.launchEnd && !attack.queue.some(s=>s && s.state==='charging')){
        attack.stage='linger';
      }
    }
    if(attack.stage==='linger'){
      const active=demonBlackSpears.some(s=>s && (s.state==='charging'||s.state==='falling'||s.state==='stuck'));
      if(!active){
        finishDemonAttack(now);
      }
    }
  }

  function updateDemonBlackSpears(now){
    for(let i=demonBlackSpears.length-1;i>=0;i--){
      const spear=demonBlackSpears[i];
      if(!spear){ demonBlackSpears.splice(i,1); continue; }
      const dt=now-(spear.lastUpdate||now);
      spear.lastUpdate=now;
      if(spear.state==='charging'){
        const dur=1000;
        spear.chargeProgress=Math.max(0, Math.min(1, (now - spear.spawnAt)/dur));
        spear.alpha=0.25+0.6*spear.chargeProgress;
      }else if(spear.state==='falling'){
        const vy=spear.vy||1800;
        const move=vy*(dt/1000);
        const prevTip=spear.y+spear.length;
        spear.y+=move;
        const tip=spear.y+spear.length;
        const pr=paddleRect();
        if(!orientLeft && !spear.paddleHit && pr.w>0 && pr.h>0){
          const rect={x:pr.x, y:pr.y, w:pr.w, h:pr.h};
          const spearRect=demonBlackSpearRect(spear);
          spearRect.y= Math.min(prevTip, tip)-spear.length*0.3;
          spearRect.h=spear.length*0.3;
          if(lineIntersectsRect(spear.x, prevTip, spear.x, tip, rect)){
            spear.paddleHit=true;
            spawnDemonSpearBlood(pr.x+pr.w/2, pr.y+pr.h/2);
            spawnParticles(spear.x, pr.y+pr.h/2, '#ff8fa3', 20, 2.2, 3.2, 3.4);
            playSFX('explosion');
            paddleStunUntil=Math.max(paddleStunUntil, now+1200);
            screenShake=Math.max(screenShake,18);
          }
        }
        if(tip>=700){
          spear.y=700-spear.length;
          spear.state='stuck';
          spear.stuckAt=now;
          const blockWidth=Math.max(18, (spear.width||60)*0.75);
          const blockHeight=Math.min(80, Math.max(40, spear.length*0.25));
          spear.blockRect={x:spear.x-blockWidth/2, y:700-blockHeight, w:blockWidth, h:blockHeight};
        }
      }else if(spear.state==='stuck'){
        if(now - spear.stuckAt >= 1000){
          destroyDemonSpear(spear, 'expire', now);
        }
      }else if(spear.state==='broken'){
        if(now>=spear.removeAt){
          demonBlackSpears.splice(i,1);
          continue;
        }
      }
    }
  }

  function drawDemonBlackSpears(now){
    if(!demonBlackSpears.length) return;
    const scaleAvg=(scaleX+scaleY)/2;
    for(const spear of demonBlackSpears){
      if(!spear || spear.state==='broken') continue;
      const rect=demonBlackSpearRect(spear);
      const alpha=spear.state==='charging'?spear.alpha:(spear.state==='falling'?0.95:1);
      const tip=rect.y+rect.h;
      ctx.save();
      ctx.globalAlpha=Math.max(0, Math.min(1, alpha));
      const grad=ctx.createLinearGradient(spear.x*scaleX, rect.y*scaleY, spear.x*scaleX, tip*scaleY);
      grad.addColorStop(0,'rgba(18,18,26,0.08)');
      grad.addColorStop(0.25,'rgba(42,24,60,0.55)');
      grad.addColorStop(0.7,'rgba(16,8,24,0.96)');
      grad.addColorStop(1,'rgba(8,4,16,1)');
      ctx.fillStyle=grad;
      const halfW=(spear.width||60)/2;
      const tipScale=spear.tipScale ?? 0.22;
      ctx.beginPath();
      ctx.moveTo((spear.x-halfW)*scaleX, rect.y*scaleY);
      ctx.lineTo((spear.x+halfW)*scaleX, rect.y*scaleY);
      ctx.lineTo((spear.x+halfW*tipScale)*scaleX, tip*scaleY);
      ctx.lineTo((spear.x-halfW*tipScale)*scaleX, tip*scaleY);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle='rgba(255,80,160,0.25)';
      ctx.lineWidth=2*scaleAvg;
      ctx.stroke();
      ctx.beginPath();
      ctx.strokeStyle='rgba(255,200,240,0.3)';
      ctx.lineWidth=1.4*scaleAvg;
      ctx.moveTo(spear.x*scaleX, rect.y*scaleY);
      ctx.lineTo(spear.x*scaleX, tip*scaleY);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawDemonBloodEffects(now){
    if(!demonBloodEffects.length) return;
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    const scaleAvg=(scaleX+scaleY)/2;
    for(let i=demonBloodEffects.length-1;i>=0;i--){
      const fx=demonBloodEffects[i];
      const life=fx.life||900;
      const age=now-(fx.t0||0);
      const prog=life>0?age/life:1;
      if(prog>=1){ demonBloodEffects.splice(i,1); continue; }
      const x=fx.x*scaleX;
      const y=fx.y*scaleY;
      const ringStart=fx.ringStart||40;
      const ringEnd=fx.ringEnd||240;
      const ringRadius=(ringStart + (ringEnd-ringStart)*easeOut(prog))*scaleAvg;
      const glowRadius=ringEnd*0.72*scaleAvg;
      const coreRadius=(ringStart*0.45 + ringEnd*0.22*prog)*scaleAvg;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createRadialGradient(x,y,0,x,y,glowRadius);
      grad.addColorStop(0,`rgba(255,100,160,${0.55*(1-prog*0.4)})`);
      grad.addColorStop(0.45,`rgba(170,0,50,${0.32*(1-prog)})`);
      grad.addColorStop(1,'rgba(40,0,16,0)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(x,y,glowRadius,0,Math.PI*2);
      ctx.fill();

      ctx.globalAlpha=1;
      ctx.fillStyle=`rgba(255,140,200,${0.28*(1-prog)})`;
      ctx.beginPath();
      ctx.arc(x,y,coreRadius,0,Math.PI*2);
      ctx.fill();

      ctx.strokeStyle=`rgba(255,220,230,${0.52*(1-prog)})`;
      const ringWidth=Math.max(3.2*scaleAvg, (6 + 6*(1-prog))*scaleAvg);
      ctx.lineWidth=ringWidth;
      ctx.beginPath();
      ctx.arc(x,y,ringRadius,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawDemonAbyssShatterLayer(now){
    if(level!==20) return;
    const attack=(demonAttackActive && demonAttackActive.type==='abyssShatter')?demonAttackActive:null;
    if(!attack && !demonAbyssBricks.length && !demonAbyssExplosions.length) return;
    const L=layout();
    const stageTop=L.top;
    const scaleAvg=(scaleX+scaleY)/2;
    const dims=getStandardBrickDimensions();
    const baseBrickW=dims.width;
    const baseBrickH=dims.height;
    if(attack && attack.orbitCenter){
      const cx=attack.orbitCenter.x*scaleX;
      const cy=attack.orbitCenter.y*scaleY;
      const auraRadius=(attack.orbitRadius||160)*scaleAvg*1.4;
      const pulse=0.8 + 0.2*Math.sin(now/240);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const aura=ctx.createRadialGradient(cx, cy, 0, cx, cy, auraRadius);
      aura.addColorStop(0,`rgba(150,90,220,${0.28*pulse})`);
      aura.addColorStop(0.55,`rgba(80,30,140,${0.32*pulse})`);
      aura.addColorStop(1,'rgba(30,0,60,0)');
      ctx.fillStyle=aura;
      ctx.beginPath();
      ctx.arc(cx, cy, auraRadius, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    if(attack && attack.stage==='beam'){
      for(const brick of demonAbyssBricks){
        if(!brick || brick.destroyed) continue;
        const center=attack.orbitCenter || {x:brick.x,y:brick.y};
        const dir=Math.atan2(brick.y-center.y, brick.x-center.x);
        const reach=1500;
        const x1=brick.x*scaleX;
        const y1=brick.y*scaleY;
        const x2=(brick.x + Math.cos(dir)*reach)*scaleX;
        const y2=(brick.y + Math.sin(dir)*reach)*scaleY;
        const pulseSeed=brick.renderPulse||0;
        const surge=0.78 + 0.28*Math.sin((now/120)+pulseSeed*2.3);
        const beamWidthBase=Math.max(6, (brick.hitRadius||24)*1.05*scaleAvg);
        const coreWidth=beamWidthBase*(0.45 + 0.18*Math.sin((now/90)+pulseSeed));
        const auraWidth=beamWidthBase*(1.8 + 0.32*Math.sin((now/160)+pulseSeed*1.7));

        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.lineCap='round';

        // Outer nebula aura
        const auraGrad=ctx.createLinearGradient(x1,y1,x2,y2);
        auraGrad.addColorStop(0,`rgba(120,40,180,${0.0})`);
        auraGrad.addColorStop(0.08,`rgba(120,50,200,${0.35*surge})`);
        auraGrad.addColorStop(0.35,`rgba(70,20,140,${0.32*surge})`);
        auraGrad.addColorStop(1,'rgba(20,4,50,0)');
        ctx.strokeStyle=auraGrad;
        ctx.lineWidth=auraWidth;
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();

        // Main beam body with intense magenta core
        const bodyGrad=ctx.createLinearGradient(x1,y1,x2,y2);
        bodyGrad.addColorStop(0,'rgba(255,255,255,0.0)');
        bodyGrad.addColorStop(0.05,`rgba(255,220,255,${0.75*surge})`);
        bodyGrad.addColorStop(0.32,`rgba(195,120,255,${0.9*surge})`);
        bodyGrad.addColorStop(0.6,`rgba(120,50,220,${0.65*surge})`);
        bodyGrad.addColorStop(1,'rgba(70,10,160,0)');
        ctx.strokeStyle=bodyGrad;
        ctx.lineWidth=beamWidthBase*(1.05 + 0.25*Math.sin((now/140)+pulseSeed));
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();

        // Brilliant inner core
        const coreGrad=ctx.createLinearGradient(x1,y1,x2,y2);
        coreGrad.addColorStop(0,'rgba(255,255,255,0.0)');
        coreGrad.addColorStop(0.12,`rgba(255,250,255,${0.95*surge})`);
        coreGrad.addColorStop(0.28,'rgba(240,190,255,0.95)');
        coreGrad.addColorStop(0.52,'rgba(180,100,255,0.85)');
        coreGrad.addColorStop(1,'rgba(90,20,210,0)');
        ctx.strokeStyle=coreGrad;
        ctx.lineWidth=coreWidth;
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();

        // Pulsing energy rings racing along the beam
        const dash = Math.max(40, beamWidthBase*3.2);
        ctx.setLineDash([dash*0.55, dash*0.9]);
        ctx.lineDashOffset = -((now/16) + pulseSeed*360);
        ctx.strokeStyle=`rgba(255,200,255,${0.22*surge})`;
        ctx.lineWidth=beamWidthBase*0.9;
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();
        ctx.setLineDash([]);

        // Radiant lens flare at the origin
        const originRadius=beamWidthBase*2.6;
        ctx.save();
        ctx.translate(x1,y1);
        ctx.rotate(dir);
        const flareGrad=ctx.createRadialGradient(0,0,0,0,0,originRadius);
        flareGrad.addColorStop(0,'rgba(255,255,255,0.95)');
        flareGrad.addColorStop(0.35,'rgba(220,160,255,0.65)');
        flareGrad.addColorStop(0.9,'rgba(110,40,200,0.0)');
        ctx.fillStyle=flareGrad;
        ctx.beginPath();
        ctx.arc(0,0,originRadius,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle=`rgba(255,220,255,${0.4*surge})`;
        ctx.lineWidth=beamWidthBase*0.6;
        ctx.beginPath();
        ctx.ellipse(0,0,originRadius*0.35,originRadius*1.15,0,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();

        // Enveloping final spark at far end
        const tipRadius=beamWidthBase*1.4;
        ctx.save();
        ctx.translate(x2,y2);
        const tipGrad=ctx.createRadialGradient(0,0,0,0,0,tipRadius);
        tipGrad.addColorStop(0,'rgba(255,255,255,0.7)');
        tipGrad.addColorStop(0.45,'rgba(190,120,255,0.5)');
        tipGrad.addColorStop(1,'rgba(70,20,160,0)');
        ctx.fillStyle=tipGrad;
        ctx.beginPath();
        ctx.arc(0,0,tipRadius,0,Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.restore();
      }
    }
    for(const brick of demonAbyssBricks){
      if(!brick) continue;
      const lifeSpan=Math.max(1, (brick.removeAt||now) - (brick.destroyedAt||now));
      const fade=brick.destroyed?Math.max(0, 1 - (now-(brick.destroyedAt||now))/lifeSpan):1;
      if(fade<=0) continue;
      const pulseBase = (brick.renderPulse||0);
      const widthBase=(brick.renderWidth||baseBrickW);
      const heightBase=(brick.renderHeight||baseBrickH);
      const width=widthBase*(0.97 + 0.03*Math.sin((now/240)+pulseBase));
      const height=heightBase*(0.96 + 0.03*Math.cos((now/260)+pulseBase));
      const x=brick.x - width/2;
      const y=brick.y - height/2;
      const right=x+width;
      const bottom=y+height;
      const radius=Math.max(4, Math.min(width,height)*0.22);
      const innerX=x + width*0.08;
      const innerY=y + height*0.14;
      const innerW=width*0.84;
      const innerH=height*0.72;
      const innerR=Math.max(3, radius*0.55);
      const glowPulse=0.65 + 0.35*Math.sin((now/180)+pulseBase);
      const veinAlpha=0.14 + 0.10*Math.sin((now/140)+pulseBase*1.7);
      ctx.save();
      ctx.globalAlpha=fade;
      const baseGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, right*scaleX, bottom*scaleY);
      baseGrad.addColorStop(0,'rgba(18,0,36,0.95)');
      baseGrad.addColorStop(0.45,'rgba(76,0,96,0.98)');
      baseGrad.addColorStop(0.72,'rgba(26,0,44,0.92)');
      baseGrad.addColorStop(1,'rgba(8,0,18,0.9)');
      ctx.fillStyle=baseGrad;
      drawRoundedRect(x, y, width, height, radius);
      ctx.fill();

      const cavityGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
      cavityGrad.addColorStop(0,'rgba(10,0,24,0.85)');
      cavityGrad.addColorStop(0.55,'rgba(68,18,100,0.38)');
      cavityGrad.addColorStop(1,'rgba(140,90,190,0.28)');
      ctx.fillStyle=cavityGrad;
      drawRoundedRect(innerX, innerY, innerW, innerH, innerR);
      ctx.fill();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const glow=ctx.createRadialGradient(brick.x*scaleX, brick.y*scaleY, 0, brick.x*scaleX, brick.y*scaleY, Math.max(width*scaleX,height*scaleY)*0.65);
      glow.addColorStop(0,`rgba(180,130,255,${0.34*glowPulse})`);
      glow.addColorStop(0.6,`rgba(110,50,170,${0.20*glowPulse})`);
      glow.addColorStop(1,'rgba(40,0,80,0)');
      ctx.fillStyle=glow;
      drawRoundedRect(innerX, innerY, innerW, innerH, innerR);
      ctx.fill();
      ctx.restore();

      const sheen=ctx.createLinearGradient(innerX*scaleX, innerY*scaleY, innerX*scaleX, (innerY+innerH*0.45)*scaleY);
      sheen.addColorStop(0,`rgba(240,220,255,${0.24*glowPulse})`);
      sheen.addColorStop(1,'rgba(130,70,210,0)');
      ctx.fillStyle=sheen;
      drawRoundedRect(innerX, innerY, innerW, innerH*0.45, Math.max(3, innerR*0.85));
      ctx.fill();

      const abyssGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH*0.35)*scaleY, innerX*scaleX, (innerY+innerH)*scaleY);
      abyssGrad.addColorStop(0,'rgba(30,0,55,0)');
      abyssGrad.addColorStop(1,'rgba(0,0,0,0.55)');
      ctx.fillStyle=abyssGrad;
      drawRoundedRect(innerX, innerY+innerH*0.35, innerW, innerH*0.65, Math.max(2.5, innerR*0.65));
      ctx.fill();

      ctx.strokeStyle=`rgba(200,160,255,${veinAlpha})`;
      ctx.lineWidth=Math.max(1, Math.min(width,height)*0.03*scaleAvg);
      ctx.beginPath();
      ctx.moveTo((x+width*0.22)*scaleX, (y+height*0.18)*scaleY);
      ctx.quadraticCurveTo((brick.x + Math.cos(brick.crackleSeed||0)*width*0.08)*scaleX, (brick.y - height*0.06)*scaleY, (x+width*0.78)*scaleX, (y+height*0.28)*scaleY);
      ctx.moveTo((x+width*0.3)*scaleX, (y+height*0.72)*scaleY);
      ctx.quadraticCurveTo((brick.x - Math.sin(brick.crackleSeed||0)*width*0.12)*scaleX, (brick.y + height*0.04)*scaleY, (x+width*0.8)*scaleX, (y+height*0.84)*scaleY);
      ctx.stroke();

      const borderAlpha=0.5 + 0.25*Math.sin((now/200)+pulseBase);
      ctx.strokeStyle=`rgba(215,185,255,${borderAlpha})`;
      ctx.lineWidth=Math.max(2, Math.min(width,height)*0.06*scaleAvg);
      drawRoundedRect(x, y, width, height, radius);
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.shadowColor=`rgba(110,50,200,${0.35*fade})`;
      ctx.shadowBlur=20*scaleAvg;
      ctx.strokeStyle='rgba(110,40,200,0.22)';
      ctx.lineWidth=Math.max(1.2, Math.min(width,height)*0.025*scaleAvg);
      drawRoundedRect(x, y, width, height, radius);
      ctx.stroke();
      ctx.restore();

      ctx.restore();
    }
    for(const fx of demonAbyssExplosions){
      if(!fx) continue;
      const start=fx.start||now;
      const end=fx.end||start+600;
      const life=Math.max(1, end-start);
      const prog=Math.max(0, Math.min(1, (now-start)/life));
      if(prog>=1) continue;
      const style=fx.style||'pulse';
      const cx=(fx.x||0)*scaleX;
      const cy=(fx.y||0)*scaleY;
      const scaleAvg=(scaleX+scaleY)/2;
      if(style==='abyssPlatformShock'){
        const fade=Math.max(0, 1-Math.pow(prog,0.9));
        const baseRadius=Math.max(120, (fx.radius||220))*scaleAvg;
        const inner=baseRadius*(0.35 + 0.18*Math.sin((now-start)/150 + (fx.seed||0)));
        const outer=baseRadius*(0.65 + prog*0.85);
        ctx.save();
        ctx.globalCompositeOperation='screen';
        const shock=ctx.createRadialGradient(cx, cy, inner, cx, cy, outer);
        shock.addColorStop(0,`rgba(255,255,255,${0.35*fade})`);
        shock.addColorStop(0.45,`rgba(220,190,255,${0.45*fade})`);
        shock.addColorStop(0.75,`rgba(120,70,210,${0.38*fade})`);
        shock.addColorStop(1,'rgba(20,0,40,0)');
        ctx.fillStyle=shock;
        ctx.beginPath();
        ctx.arc(cx, cy, outer, 0, Math.PI*2);
        ctx.fill();
        ctx.lineWidth=Math.max(2.5, outer*0.032);
        ctx.strokeStyle=`rgba(255,240,255,${0.55*fade})`;
        ctx.setLineDash([outer*0.18, outer*0.22]);
        ctx.lineDashOffset = -((now-start)/9 + (fx.seed||0)*180);
        ctx.beginPath();
        ctx.arc(cx, cy, outer*0.86, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
        continue;
      }
      if(style==='abyssPlatformCracks'){
        const fade=Math.max(0, 1-Math.pow(prog,0.6));
        const cracks=fx.cracks || [];
        const grow=0.3 + prog*1.1;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.globalCompositeOperation='lighter';
        ctx.lineCap='round';
        const baseWidth=Math.max(1.6, (fx.radius||220)*0.012*scaleAvg*(1-prog*0.4));
        for(const crack of cracks){
          const ang=crack.angle||0;
          const innerOffset=(fx.radius||220)*(0.05 + prog*0.06);
          const totalLen=(crack.length||200)*grow;
          const sway=crack.sway||0;
          const ctrlLen=totalLen*(0.32 + sway*0.5);
          const ctrlAngle=ang + (sway*0.6-0.3);
          ctx.lineWidth=baseWidth;
          ctx.strokeStyle=`rgba(190,150,255,${0.55*fade})`;
          ctx.beginPath();
          ctx.moveTo(Math.cos(ang)*innerOffset*scaleAvg, Math.sin(ang)*innerOffset*scaleAvg);
          ctx.quadraticCurveTo(
            Math.cos(ctrlAngle)*ctrlLen*scaleAvg,
            Math.sin(ctrlAngle)*ctrlLen*scaleAvg,
            Math.cos(ang)*totalLen*scaleAvg,
            Math.sin(ang)*totalLen*scaleAvg
          );
          ctx.stroke();
          if(crack.branch){
            const branchLen=totalLen*0.45;
            const branchAng=ang + (Math.sin((now-start)/180 + ang)*0.35);
            ctx.lineWidth=baseWidth*0.72;
            ctx.strokeStyle=`rgba(130,210,255,${0.45*fade})`;
            ctx.beginPath();
            ctx.moveTo(Math.cos(ang)*totalLen*scaleAvg*0.65, Math.sin(ang)*totalLen*scaleAvg*0.65);
            ctx.lineTo(
              Math.cos(branchAng)*branchLen*scaleAvg,
              Math.sin(branchAng)*branchLen*scaleAvg
            );
            ctx.stroke();
          }
        }
        ctx.restore();
        continue;
      }
      if(style==='abyssPlatformSparks'){
        const fade=Math.max(0, 1-prog);
        const shards=fx.shards || [];
        const travelBase=(fx.radius||280);
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        for(const shard of shards){
          const ease=Math.pow(prog,0.7);
          const dist=(travelBase*ease + (shard.speed||200)*prog*0.45)*scaleAvg;
          const px=cx + Math.cos(shard.angle||0)*dist;
          const py=cy + Math.sin(shard.angle||0)*dist;
          const size=(shard.size||12)*(0.55 + (1-prog)*0.5)*scaleAvg;
          const tint=shard.tint||0.7;
          ctx.save();
          ctx.translate(px, py);
          ctx.rotate((shard.angle||0) + (now-start)/300);
          ctx.shadowColor=`rgba(150,220,255,${0.45*fade*tint})`;
          ctx.shadowBlur=24*fade;
          const grad=ctx.createLinearGradient(-size,0,size,0);
          grad.addColorStop(0,'rgba(40,10,90,0)');
          grad.addColorStop(0.35,`rgba(255,255,255,${0.45*fade*tint})`);
          grad.addColorStop(0.7,`rgba(160,210,255,${0.35*fade*tint})`);
          grad.addColorStop(1,'rgba(30,0,60,0)');
          ctx.fillStyle=grad;
          ctx.beginPath();
          ctx.ellipse(0,0,size*0.35,size,0,0,Math.PI*2);
          ctx.fill();
          ctx.strokeStyle=`rgba(255,230,255,${0.4*fade*tint})`;
          ctx.lineWidth=Math.max(1.2, size*0.14);
          ctx.beginPath();
          ctx.moveTo(-size*0.55,0);
          ctx.lineTo(size*0.55,0);
          ctx.stroke();
          ctx.restore();
        }
        ctx.restore();
        continue;
      }
      if(style==='abyssNova'){
        const fade=Math.max(0, 1-prog);
        const baseRadius=(fx.radius||80)*scaleAvg;
        const outer=baseRadius*(0.85 + prog*0.6);
        const seed=fx.seed||0;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.globalCompositeOperation='lighter';
        const glow=ctx.createRadialGradient(0,0,0,0,0,outer);
        glow.addColorStop(0,`rgba(255,255,255,${0.45*fade})`);
        glow.addColorStop(0.35,`rgba(240,215,255,${0.55*fade})`);
        glow.addColorStop(0.78,`rgba(160,100,255,${0.45*fade})`);
        glow.addColorStop(1,'rgba(40,0,90,0)');
        ctx.fillStyle=glow;
        ctx.beginPath();
        ctx.arc(0,0,outer,0,Math.PI*2);
        ctx.fill();
        const rings=Math.max(2, fx.rings||3);
        const spin=seed + (now-start)/160;
        const rayCount=10;
        ctx.lineCap='round';
        ctx.lineJoin='round';
        ctx.strokeStyle=`rgba(255,235,255,${0.55*fade})`;
        ctx.lineWidth=Math.max(1.8, outer*0.018);
        for(let i=0;i<rayCount;i++){
          const ang=spin + i*(TAU/rayCount);
          const rayLen=outer*(0.55 + 0.28*Math.sin((now/120)+i));
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.lineTo(Math.cos(ang)*rayLen, Math.sin(ang)*rayLen);
          ctx.stroke();
        }
        for(let i=0;i<rings;i++){
          const ringPhase=Math.max(0, Math.min(1, prog*1.05 + i*0.12));
          const ringRadius=outer*(0.35 + i*0.24 + ringPhase*0.3);
          const ringAlpha=Math.max(0, 0.65 - ringPhase*0.45)*fade;
          if(ringAlpha<=0) continue;
          ctx.strokeStyle=`rgba(255,240,255,${ringAlpha})`;
          ctx.lineWidth=Math.max(1.6, outer*0.02*(1-ringPhase*0.5));
          ctx.beginPath();
          ctx.arc(0,0,ringRadius,0,Math.PI*2);
          ctx.stroke();
        }
        const petals=6;
        ctx.strokeStyle=`rgba(150,220,255,${0.28*fade})`;
        ctx.lineWidth=Math.max(1.2, outer*0.015);
        for(let i=0;i<petals;i++){
          const ang=spin*0.8 + i*(TAU/petals);
          const stretch=outer*(0.58 + 0.24*(1-prog));
          ctx.save();
          ctx.rotate(ang);
          ctx.beginPath();
          ctx.ellipse(0,0,stretch*0.18,stretch*0.62,0,0,Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }
        ctx.restore();
        continue;
      }
      if(style==='abyssNovaAura'){
        const fade=Math.max(0, 1-prog);
        const baseRadius=(fx.radius||100)*scaleAvg;
        const pulse=0.9 + 0.2*Math.sin((now-start)/220 + (fx.seed||0));
        const auraOuter=baseRadius*(0.85 + prog*0.65)*pulse;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(1.1 + 0.18*Math.sin((now/260)+(fx.seed||0)*0.6), 0.92 + 0.16*Math.cos((now/210)+(fx.seed||0)));
        ctx.globalCompositeOperation='screen';
        ctx.globalAlpha=fade*0.8;
        const aura=ctx.createRadialGradient(0,0,auraOuter*0.24,0,0,auraOuter);
        aura.addColorStop(0,`rgba(255,255,255,${0.18*fade})`);
        aura.addColorStop(0.4,`rgba(180,130,255,${0.32*fade})`);
        aura.addColorStop(0.78,`rgba(80,20,160,${0.32*fade})`);
        aura.addColorStop(1,'rgba(20,0,45,0)');
        ctx.fillStyle=aura;
        ctx.beginPath();
        ctx.arc(0,0,auraOuter,0,Math.PI*2);
        ctx.fill();
        const loops=5;
        const spin=(fx.seed||0) + (now-start)/180;
        ctx.lineWidth=Math.max(1.2, auraOuter*0.014);
        for(let i=0;i<loops;i++){
          const ang=spin + i*(TAU/loops);
          const len=auraOuter*(0.7 + 0.2*Math.sin((now/140)+i));
          ctx.strokeStyle=`rgba(150,230,255,${0.2*fade})`;
          ctx.beginPath();
          ctx.arc(0,0,len,ang-0.42, ang+0.42);
          ctx.stroke();
        }
        ctx.restore();
        continue;
      }
      if(style==='abyssNovaCore'){
        const fade=Math.max(0, 1-prog);
        const baseRadius=(fx.radius||60)*scaleAvg;
        const flicker=0.75 + 0.25*Math.sin((now-start)/90 + (fx.seed||0));
        const coreRadius=baseRadius*(0.38 + (1-prog)*0.42)*flicker;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.globalCompositeOperation='lighter';
        const core=ctx.createRadialGradient(0,0,0,0,0,coreRadius);
        core.addColorStop(0,`rgba(255,255,255,${0.9*fade})`);
        core.addColorStop(0.55,`rgba(255,210,255,${0.65*fade})`);
        core.addColorStop(1,'rgba(150,70,220,0)');
        ctx.fillStyle=core;
        ctx.beginPath();
        ctx.arc(0,0,coreRadius,0,Math.PI*2);
        ctx.fill();
        const crossRadius=coreRadius*1.65;
        const spin=(fx.seed||0)/2 + (now-start)/140;
        ctx.strokeStyle=`rgba(255,245,240,${0.35*fade})`;
        ctx.lineWidth=Math.max(1.4, baseRadius*0.018);
        for(let i=0;i<4;i++){
          const ang=spin + i*(Math.PI/2);
          ctx.beginPath();
          ctx.moveTo(Math.cos(ang)*coreRadius*0.25, Math.sin(ang)*coreRadius*0.25);
          ctx.lineTo(Math.cos(ang)*crossRadius, Math.sin(ang)*crossRadius);
          ctx.stroke();
        }
        ctx.restore();
        continue;
      }
      const alpha=Math.max(0, 1-prog);
      const radius=(fx.radius||80)*(0.6+prog*0.7)*scaleAvg;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha=alpha*0.85;
      const glow=ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
      glow.addColorStop(0,`rgba(255,240,255,${0.65*alpha})`);
      glow.addColorStop(0.45,`rgba(190,120,255,${0.45*alpha})`);
      glow.addColorStop(1,'rgba(50,10,90,0)');
      ctx.fillStyle=glow;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    if(attack && attack.stage==='countdown' && attack.countdownEnd){
      const remain=Math.max(0, attack.countdownEnd-now);
      if(remain>0){
        const seconds=Math.max(1, Math.ceil(remain/1000));
        ctx.save();
        ctx.fillStyle='rgba(210,40,80,0.92)';
        const font=Math.max(42, Math.round(56*scaleAvg));
        ctx.font=`${font}px 'Playfair Display','Noto Sans TC',serif`;
        ctx.textAlign='center';
        ctx.textBaseline='top';
        ctx.shadowColor='rgba(255,80,120,0.55)';
        ctx.shadowBlur=24*scaleAvg;
        ctx.fillText(String(seconds), (1100/2)*scaleX, Math.max(8, stageTop-48)*scaleY);
        ctx.restore();
      }
    }
  }

  function drawBladeHellBallCaptureOverlay(now){
    const cap=demonBladeHellBallCapture;
    if(!cap || !cap.ball || !balls.includes(cap.ball)) return;
    const ball=cap.ball;
    const strength=Math.max(0, Math.min(1, cap.visible ?? 1));
    if(strength<=0) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const bx=(cap.holdX ?? ball.x)*scaleX;
    const by=(cap.holdY ?? ball.y)*scaleY;
    const ballRadius=(ball.r||10)*scaleAvg;
    ctx.save();
    ctx.translate(bx, by);
    ctx.rotate(cap.handAngle || (orientLeft?Math.PI/2:-Math.PI/2));
    const shimmer=Math.sin((now+(cap.pulseOffset||0))/180);
    const portalRadius=ballRadius*(2.4 + 0.6*shimmer)*Math.max(0.6,strength);
    ctx.save();
    ctx.scale(1.2,0.7);
    const portal=ctx.createRadialGradient(0,0,portalRadius*0.22,0,0,portalRadius);
    portal.addColorStop(0,`rgba(255,210,230,${0.22*strength})`);
    portal.addColorStop(0.55,`rgba(190,60,130,${0.55*strength})`);
    portal.addColorStop(1,'rgba(20,0,30,0)');
    ctx.globalCompositeOperation='screen';
    ctx.fillStyle=portal;
    ctx.beginPath();
    ctx.arc(0,0,portalRadius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=`rgba(255,150,190,${0.3*strength})`;
    ctx.lineWidth=Math.max(1.2, ballRadius*0.35);
    for(let i=0;i<5;i++){
      const ang=i*(Math.PI*2/5)+(now/280);
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*ballRadius*0.4, Math.sin(ang)*ballRadius*0.4);
      ctx.lineTo(Math.cos(ang)*ballRadius*1.25, Math.sin(ang)*ballRadius*1.25);
      ctx.stroke();
    }
    ctx.restore();

    const baseScale=ballRadius*2.3;
    ctx.save();
    ctx.scale(baseScale/160, baseScale/160);
    ctx.translate(-14,-22);
    ctx.lineCap='round';
    ctx.lineJoin='round';
    const boneColor=`rgba(250,245,235,${0.92*strength})`;
    const outlineColor=`rgba(200,160,200,${0.45*strength})`;
    ctx.fillStyle=boneColor;
    ctx.strokeStyle=outlineColor;
    ctx.shadowColor=`rgba(255,160,220,${0.35*strength})`;
    ctx.shadowBlur=24*strength;

    const drawFinger=(ox,oy,len,angle)=>{
      ctx.save();
      ctx.translate(ox,oy);
      ctx.rotate(angle);
      let radius=18;
      const segments=3;
      const segLen=len/segments;
      for(let i=0;i<segments;i++){
        const nextRadius = (i===segments-1)?10:14-(i*3);
        ctx.beginPath();
        ctx.lineWidth=Math.max(8,nextRadius*0.9);
        ctx.moveTo(0,0);
        ctx.lineTo(segLen,0);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0,0,radius,0,Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(segLen,0,nextRadius,0,Math.PI*2);
        ctx.fill();
        ctx.translate(segLen,0);
        radius=nextRadius;
      }
      ctx.restore();
    };

    const drawPalm=()=>{
      ctx.save();
      ctx.translate(18,32);
      ctx.beginPath();
      ctx.moveTo(-42,-6);
      ctx.bezierCurveTo(-52,18,-18,60,26,54);
      ctx.bezierCurveTo(48,50,60,20,38,-12);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    };

    drawPalm();
    drawFinger(-32,10,78,-1.7);
    drawFinger(-4,-2,88,-1.25);
    drawFinger(18,-6,86,-0.95);
    drawFinger(40,-4,82,-0.55);
    drawFinger(-18,36,58,-2.05);

    ctx.shadowBlur=0;
    ctx.restore();
    ctx.restore();
  }

  function drawDemonBladeHellLayer(now){
    if(level!==20) return;
    const attack=(demonAttackActive && demonAttackActive.type==='bladeHell')?demonAttackActive:null;
    const hasCounter=demonBladeHellCounterSlashes.length>0;
    if(!attack && !hasCounter) return;
    const L=layout();
    const stageTop=L.top;
    const stageHeight=700-stageTop;
    const scaleAvg=(scaleX+scaleY)/2;

    demonBladeHellPlatformGlow=0;
    if(attack){
      const dark=attack.currentDarkness||0;
      if(dark>0){
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, stageTop*scaleY, canvas.width, stageHeight*scaleY);
        ctx.clip();
        ctx.globalAlpha=Math.max(0, Math.min(1,dark));
        ctx.fillStyle='#000';
        ctx.fillRect(0, stageTop*scaleY, canvas.width, stageHeight*scaleY);
        ctx.restore();
      }
      const platformGlow=Math.max(0, Math.min(1, attack.currentPlatformGlow||0));
      demonBladeHellPlatformGlow=platformGlow;
      let beam=null;
      if(attack.stage==='windup'){ beam=attack.beam; }
      else if(attack.stage==='ending'){ beam=attack.endBeam; }
      if(beam){
        const x=(beam.x??demonBoss?.x??550);
        const radius=Math.max(1.5, beam.radius||0);
        const initialRadius=beam.initialRadius ?? 4;
        const maxRadius=Math.max(initialRadius, beam.maxRadius||radius);
        const expandProg=Math.max(0, Math.min(1, (radius-initialRadius)/Math.max(1, maxRadius-initialRadius)));
        const damageProg=beam.damaging ? Math.max(0, Math.min(1, (now-(beam.damageStartedAt||beam.damageAt))/800)) : 0;
        const impact=Math.max(expandProg, damageProg);
        const pulse=beam.damaging ? (0.2+0.2*Math.sin((now-(beam.damageStartedAt||now))/140)) : 0;
        const auraStrength=Math.max(0, 0.18 + 0.32*impact + pulse*0.15);
        const midAlpha=0.35 + 0.4*impact;
        const coreAlpha=0.45 + 0.35*impact;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const y1=stageTop;
        const y2=700;
        const auraWidth=radius*(1.35 + 0.45*impact);
        const auraGrad=ctx.createLinearGradient(x*scaleX, y1*scaleY, x*scaleX, y2*scaleY);
        auraGrad.addColorStop(0,'rgba(80,30,160,0)');
        auraGrad.addColorStop(0.42,`rgba(150,70,220,${auraStrength})`);
        auraGrad.addColorStop(0.58,`rgba(150,70,220,${auraStrength})`);
        auraGrad.addColorStop(1,'rgba(80,30,160,0)');
        ctx.fillStyle=auraGrad;
        ctx.fillRect((x-auraWidth)*scaleX, y1*scaleY, auraWidth*2*scaleX, (y2-y1)*scaleY);

        const coreGrad=ctx.createLinearGradient(x*scaleX, y1*scaleY, x*scaleX, y2*scaleY);
        coreGrad.addColorStop(0,'rgba(120,70,210,0)');
        coreGrad.addColorStop(0.38,`rgba(180,120,255,${midAlpha})`);
        coreGrad.addColorStop(0.5,`rgba(230,190,255,${coreAlpha})`);
        coreGrad.addColorStop(0.62,`rgba(180,120,255,${midAlpha})`);
        coreGrad.addColorStop(1,'rgba(120,70,210,0)');
        ctx.shadowColor=`rgba(210,160,255,${0.35 + 0.45*impact})`;
        ctx.shadowBlur=(beam.damaging?60:36)*scaleAvg;
        ctx.fillStyle=coreGrad;
        ctx.fillRect((x-radius)*scaleX, y1*scaleY, radius*2*scaleX, (y2-y1)*scaleY);
        ctx.restore();
      }
      }

    if(demonBladeHellTelegraphs.length){
      for(const tele of demonBladeHellTelegraphs){
        const delay=Math.max(1, tele.delay||1);
        const remain=Math.max(0, tele.slashAt-now);
        const prog=1-Math.max(0, Math.min(1, remain/delay));
        ctx.save();
        ctx.translate(tele.x*scaleX, tele.y*scaleY);
        const sampleBallRadius=(balls && balls.length)?(balls[0].r||10):10;
        const easeOutCubic=(t)=>1-Math.pow(1-t,3);
        const eased=easeOutCubic(prog);
        const baseRadius=sampleBallRadius*(orientLeft?0.55:1.0);
        const outerRadius=baseRadius*(1.9 + 1.2*eased);
        const innerRadius=baseRadius*(0.28 + 0.22*eased);
        const haloRadius=baseRadius*(1.1 + 0.8*eased);
        const flatten=orientLeft?1:0.46;
        const shimmer=0.6 + 0.4*Math.sin((now/220)+(tele.waveIndex||0));
        ctx.scale(1, flatten);
        ctx.globalCompositeOperation='lighter';
        const grad=ctx.createRadialGradient(0,0,innerRadius*scaleAvg*0.6,0,0,outerRadius*scaleAvg);
        grad.addColorStop(0,`rgba(255,240,226,${0.32+0.28*eased})`);
        grad.addColorStop(0.36,`rgba(255,138,168,${0.58+0.28*eased})`);
        grad.addColorStop(0.72,`rgba(170,24,58,${0.42+0.22*eased})`);
        grad.addColorStop(1,'rgba(70,0,30,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(0,0,outerRadius*scaleAvg,0,Math.PI*2);
        ctx.fill();
        ctx.lineWidth=Math.max(2*scaleAvg,3.8*scaleAvg*eased);
        ctx.strokeStyle=`rgba(255,210,220,${0.35+0.4*eased})`;
        ctx.beginPath();
        ctx.arc(0,0,haloRadius*scaleAvg,0,Math.PI*2);
        ctx.stroke();
        ctx.globalCompositeOperation='screen';
        ctx.strokeStyle=`rgba(255,120,160,${0.25+0.25*eased})`;
        ctx.lineWidth=Math.max(1.3*scaleAvg,2.6*scaleAvg*eased);
        const petals=6;
        for(let p=0;p<petals;p++){
          const ang=p*(Math.PI*2/petals)+shimmer*0.45;
          ctx.beginPath();
          ctx.arc(Math.cos(ang)*innerRadius*scaleAvg*0.6, Math.sin(ang)*innerRadius*scaleAvg*0.6, innerRadius*scaleAvg*0.55, 0, Math.PI*2);
          ctx.stroke();
        }
        ctx.globalCompositeOperation='source-over';
        ctx.save();
        ctx.rotate((tele.waveIndex||0)*0.4);
        ctx.strokeStyle=`rgba(255,220,230,${0.18+0.32*eased})`;
        ctx.lineWidth=Math.max(1.2*scaleAvg,2.2*scaleAvg*eased);
        ctx.beginPath();
        ctx.moveTo(-haloRadius*scaleAvg*0.7,0);
        ctx.lineTo(haloRadius*scaleAvg*0.7,0);
        ctx.moveTo(0,-haloRadius*scaleAvg*0.38);
        ctx.lineTo(0,haloRadius*scaleAvg*0.38);
        ctx.stroke();
        ctx.restore();
        ctx.restore();
      }
    }

    if(demonBladeHellSlashes.length){
      for(const slash of demonBladeHellSlashes){
        const life=slash.life||260;
        const prog=Math.max(0, Math.min(1, (now-slash.start)/life));
        if(prog>=1) continue;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const alpha=1-prog;
        const width=(6 + 6*(1-prog))*scaleAvg;
        const grad=ctx.createLinearGradient(slash.x1*scaleX, slash.y1*scaleY, slash.x2*scaleX, slash.y2*scaleY);
        grad.addColorStop(0,'rgba(180,90,255,0)');
        grad.addColorStop(0.5,`rgba(220,150,255,${0.85*alpha})`);
        grad.addColorStop(1,'rgba(180,90,255,0)');
        ctx.strokeStyle=grad;
        ctx.lineWidth=width;
        ctx.shadowColor=`rgba(210,160,255,${0.45*alpha})`;
        ctx.shadowBlur=28*scaleAvg;
        ctx.beginPath();
        ctx.moveTo(slash.x1*scaleX, slash.y1*scaleY);
        ctx.lineTo(slash.x2*scaleX, slash.y2*scaleY);
        ctx.stroke();
        ctx.restore();
      }
    }

    if(demonBladeHellCounterSlashes.length){
      for(let i=demonBladeHellCounterSlashes.length-1;i>=0;i--){
        const slash=demonBladeHellCounterSlashes[i];
        const life=slash.life||260;
        const prog=Math.max(0, Math.min(1, (now-slash.start)/life));
        if(prog>=1){ demonBladeHellCounterSlashes.splice(i,1); continue; }
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const alpha=1-prog;
        const width=(5 + 5*(1-prog))*scaleAvg;
        const grad=ctx.createLinearGradient(slash.x1*scaleX, slash.y1*scaleY, slash.x2*scaleX, slash.y2*scaleY);
        grad.addColorStop(0,'rgba(150,90,255,0)');
        grad.addColorStop(0.5,`rgba(200,150,255,${0.9*alpha})`);
        grad.addColorStop(1,'rgba(150,90,255,0)');
        ctx.strokeStyle=grad;
        ctx.lineWidth=width;
        ctx.shadowColor=`rgba(170,110,255,${0.6*alpha})`;
        ctx.shadowBlur=24*scaleAvg;
        ctx.beginPath();
        ctx.moveTo(slash.x1*scaleX, slash.y1*scaleY);
        ctx.lineTo(slash.x2*scaleX, slash.y2*scaleY);
        ctx.stroke();
        ctx.restore();
      }
    }

    if(attack){
      if(attack.countdownEnd){
        const remain=Math.max(0, attack.stage==='ending'?0:attack.countdownEnd-now);
        const seconds=Math.max(0, Math.ceil(remain/1000));
        ctx.save();
        ctx.fillStyle='rgba(210,40,80,0.92)';
        const font=Math.max(42, Math.round(56*scaleAvg));
        ctx.font=`${font}px 'Playfair Display','Noto Sans TC',serif`;
        ctx.textAlign='center';
        ctx.textBaseline='top';
        ctx.shadowColor='rgba(255,80,120,0.55)';
        ctx.shadowBlur=24*scaleAvg;
        ctx.fillText(String(seconds), (1100/2)*scaleX, Math.max(8, stageTop-48)*scaleY);
        ctx.restore();
      }
      if(attack.stage==='hell'){
        const total=attack.waveDefs.length;
        let waveNumber;
        if(attack.waveState){ waveNumber = attack.waveIndex+1; }
        else if(attack.waveIndex<0){ waveNumber = 1; }
        else { waveNumber = Math.min(total, attack.waveIndex+2); }
        waveNumber=Math.max(1, Math.min(total, waveNumber));
        ctx.save();
        ctx.fillStyle='rgba(255,220,200,0.9)';
        const font=Math.max(18, Math.round(22*scaleAvg));
        ctx.font=`${font}px 'Noto Sans TC',sans-serif`;
        ctx.textAlign='left';
        ctx.textBaseline='top';
        ctx.fillText(`第${waveNumber}波`, 24*scaleX, Math.max(8, stageTop-44)*scaleY);
        ctx.restore();
      }
    }
  }

  function handleBallVsDemonSpears(ball, now){
    if(!demonBlackSpears.length) return;
    const r=ball.r;
    const prevVX=ball.vx;
    const prevVY=ball.vy;
    let collided=false;
    for(const spear of demonBlackSpears){
      if(!spear) continue;
      if(spear.state!=='falling' && spear.state!=='stuck' && spear.state!=='charging') continue;
      const rect=demonBlackSpearRect(spear);
      if(circleIntersectsRect(ball.x, ball.y, r, rect)){
        if(destroyDemonSpear(spear, 'ball', now)){
          collided=true;
          fireCollide();
          triggerBallBuffEffectsOnBossHit(ball, ball.x, ball.y, now, {bossHit:false});
        }
      }
    }
    if(collided){
      ball.vx=prevVX;
      ball.vy=prevVY;
    }
  }

  function applyDemonSpearPaddleBlock(prevX){
    if(orientLeft || !demonBlackSpears.length) return;
    const pr=paddleRect();
    for(const spear of demonBlackSpears){
      if(!spear || spear.state!=='stuck' || !spear.blockRect) continue;
      const block=spear.blockRect;
      if(pr.x+pr.w<=block.x || pr.x>=block.x+block.w) continue;
      if(prevX+pr.w<=block.x){
        paddle.x=block.x-pr.w;
      }else if(prevX>=block.x+block.w){
        paddle.x=block.x+block.w;
      }else{
        const leftDist=Math.abs((block.x-pr.w)-prevX);
        const rightDist=Math.abs((block.x+block.w)-prevX);
        if(leftDist<rightDist){ paddle.x=block.x-pr.w; }
        else{ paddle.x=block.x+block.w; }
      }
    }
    paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x));
  }

  function triggerDemonBloodDrain(now, pr){
    if(!demonBoss || demonPhase!=='active') return;
    if(demonBoss.mode==='bloodDrain') return;
    const centerX = pr.x + pr.w/2;
    const centerY = pr.y + pr.h/2;
    const L=layout();
    const normalBase = demonBoss.normalBaseY ?? demonBoss.baseY;
    const targetY = Math.max(L.top+90, normalBase-90);
    demonBoss.mode='bloodDrain';
    demonBoss.bloodDrain={
      start:now,
      grabX:centerX,
      grabY:centerY,
      ascendDuration:900,
      burstAt:now+900,
      end:now+2300,
      burstDone:false,
      targetY
    };
    demonBoss.moveTarget=null;
    demonBoss.knockbackVX=0;
    demonBoss.knockbackVY=0;
    demonBoss.lowKnockbacks=0;
    demonBoss.lastKnockbackAt=0;
    demonEventMarquee={text:'魔王埃里赫曼施展鮮血吸取!', start:now, fadeStart:now+3000, end:now+3000, style:'elegant'};
    spawnParticles(centerX, centerY, '#7a0820', 60, 2.4, 3.6, 3.4);
    demonBoss.hp=Math.min(demonBoss.maxHp, demonBoss.hp+20);
    updateHUD();
    paddleGoneUntil=Math.max(paddleGoneUntil, now+3200);
    screenShake=Math.max(screenShake,12);
  }

  function captureBallInCloak(ball, now){
    const center=demonCloakCenter();
    if(!center) return false;
    const anchor={dx:ball.x-center.x, dy:ball.y-center.y};
    ball.demonCloakState='captured';
    ball.demonCloakCapturedAt=now;
    ball.demonCloakReleaseAt=now+2000;
    ball.demonCloakAnchor=anchor;
    ball.demonCloakStoredSpeed=Math.max(Math.hypot(ball.vx, ball.vy), 4);
    ball.demonCloakStayStart=0;
    ball.demonCloakInside=true;
    const wrapRadius=Math.max(36, Math.min(120, Math.hypot(anchor.dx, anchor.dy)));
    ball.demonCloakWrapRadius=wrapRadius;
    ball.demonCloakWrapPhase=Math.atan2(anchor.dy, anchor.dx);
    ball.demonCloakWrapProgress=0;
    ball.demonCloakWrapDuration=900+Math.random()*400;
    ball.demonCloakLastUpdate=now;
    ball.vx=0;
    ball.vy=0;
    const baseCenterX = demonBoss ? (demonBoss.x + (demonBoss.cloakOffsetX!=null?demonBoss.cloakOffsetX:(demonBoss.hitOffsetX||0))) : center.x;
    const gripSide = (ball.x||center.x) < baseCenterX ? -1 : 1;
    ball.demonCloakGripSide=gripSide;
    if(demonBoss){
      demonBoss.cloakGripSide=gripSide;
      demonBoss.cloakGripTarget=1;
      demonBoss.cloakGripLastActive=now;
    }
    return true;
  }

  function releaseBallFromCloak(ball){
    const center=demonCloakCenter();
    const anchor=ball.demonCloakAnchor||{dx:0,dy:0};
    if(center){
      ball.x=center.x + anchor.dx;
      ball.y=center.y + anchor.dy;
    }
    const speedCap=ball.speedCap||GAME_CONFIG.caps.ballSpeedMax;
    const stored=Math.max(ball.demonCloakStoredSpeed||speedCap, 4);
    const speed=Math.min(speedCap, stored*1.2);
    const phase=ball.demonCloakWrapPhase||Math.atan2(anchor.dy, anchor.dx||1);
    const tangent={
      x:-Math.sin(phase),
      y:Math.abs(Math.cos(phase))*0.75 + 0.35
    };
    const dirX=tangent.x>=0?1:-1;
    const len=Math.hypot(tangent.x, tangent.y)||1;
    ball.vx=(tangent.x/len)*speed;
    ball.vy=(tangent.y/len)*speed;
    ball.demonCloakState='launched';
    ball.demonCloakReleaseAt=0;
    ball.demonCloakCapturedAt=0;
    ball.demonCloakWrapProgress=0;
    ball.demonCloakWrapRadius=0;
    ball.demonCloakLastUpdate=0;
    if(demonBoss){
      const now=performance.now();
      demonBoss.cloakWhipStart=now;
      demonBoss.cloakWhipDuration=420;
      demonBoss.cloakWhipUntil=now+420;
      demonBoss.cloakWhipStrength=Math.min(1.4, 0.7+(ball.demonCloakStoredSpeed?Math.min(ball.demonCloakStoredSpeed/10,0.8):0));
      demonBoss.cloakWhipDir=dirX||1;
      demonBoss.cloakGripTarget=0;
      demonBoss.cloakGripLastActive=now;
      if(!demonBoss.cloakGripSide){
        demonBoss.cloakGripSide=dirX<0?-1:1;
      }
    }
    ball.demonCloakGripSide=null;
  }

  function handleDemonCloakState(ball, now){
    if(!demonBoss || demonPhase!=='active'){
      if(ball.demonCloakState==='captured'){
        const restore=Math.max(ball.demonCloakStoredSpeed||4,4);
        if(Math.abs(ball.vx)+Math.abs(ball.vy)<0.2){
          ball.vx=0;
          ball.vy=-restore;
        }
        ball.demonCloakState=null;
      }
      ball.demonCloakGripSide=null;
      ball.demonCloakStoredSpeed=0;
      ball.demonCloakAnchor=null;
      ball.demonCloakStayStart=0;
      ball.demonCloakInside=false;
      ball.demonCloakWrapProgress=0;
      ball.demonCloakWrapRadius=0;
      ball.demonCloakLastUpdate=0;
      return false;
    }

    if(ball.demonCloakState==='captured'){
      const center=demonCloakCenter();
      if(center){
        const anchor=ball.demonCloakAnchor||{dx:0,dy:0};
        const dt=now-(ball.demonCloakLastUpdate||now);
        const wrapDuration=ball.demonCloakWrapDuration||1000;
        const progress=Math.max(0, Math.min(1, (ball.demonCloakWrapProgress||0) + (wrapDuration>0?dt/wrapDuration:0)));
        ball.demonCloakWrapProgress=progress;
        const baseRadius=ball.demonCloakWrapRadius||Math.max(36, Math.hypot(anchor.dx, anchor.dy));
        const eased=Math.pow(progress,0.85);
        const radius=Math.max(18, baseRadius*(1-eased) + 18*eased);
        const swirlSpeed=0.006 + 0.006*progress;
        ball.demonCloakWrapPhase=(ball.demonCloakWrapPhase||Math.atan2(anchor.dy, anchor.dx||1)) + dt*swirlSpeed;
        const phase=ball.demonCloakWrapPhase;
        const lift=Math.sin(progress*Math.PI*1.2)*10;
        const dx=Math.cos(phase)*radius;
        const dy=Math.sin(phase)*radius*0.65 + lift;
        const sway=Math.sin((now-(ball.demonCloakCapturedAt||now))/260)*3;
        ball.demonCloakAnchor={dx, dy:dy+sway};
        ball.x=center.x + dx;
        ball.y=center.y + dy + sway;
        ball.demonCloakLastUpdate=now;
        if(demonBoss){
          const baseCenterX=demonBoss.x + (demonBoss.cloakOffsetX!=null?demonBoss.cloakOffsetX:(demonBoss.hitOffsetX||0));
          const gripSide = (ball.demonCloakGripSide!=null)?ball.demonCloakGripSide:((ball.x||center.x)<baseCenterX?-1:1);
          ball.demonCloakGripSide=gripSide;
          demonBoss.cloakGripSide=gripSide;
          demonBoss.cloakGripTarget=1;
          demonBoss.cloakGripLastActive=now;
        }
      }
      ball.vx=0;
      ball.vy=0;
      if(ball.demonCloakReleaseAt && now>=ball.demonCloakReleaseAt){
        releaseBallFromCloak(ball);
      }
      return ball.demonCloakState==='captured';
    }

    const cloakBounds=getDemonCloakBounds();
    if(!cloakBounds) return false;
    const inCloak=(ball.x>=cloakBounds.x && ball.x<=cloakBounds.x+cloakBounds.w && ball.y>=cloakBounds.y && ball.y<=cloakBounds.y+cloakBounds.h);
    const wasInside=!!ball.demonCloakInside;
    ball.demonCloakInside=inCloak;
    if(inCloak && ball.demonCloakState!=='launched' && !demonPointInHitArea(ball.x, ball.y)){
      if(!wasInside){
        ball.demonCloakStayStart=now;
        if(Math.random()<0.05){
          if(captureBallInCloak(ball, now)){
            return true;
          }
        }
      }
    }else if(!inCloak){
      if(wasInside){ ball.demonCloakStayStart=0; }
      if(ball.demonCloakState!=='launched'){ ball.demonCloakState=null; }
      ball.demonCloakGripSide=null;
    }
    return false;
  }

  function spaceBossImpactPoint(fromX, fromY){
    const bounds=getSpaceBossBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const targetX = spaceBoss.x;
    const targetY = spaceBoss.y;
    const dx = targetX - fromX;
    const dy = targetY - fromY;
    let bestT = Infinity;
    function test(t){
      if(t<=0 || t>=1e6) return;
      const ix = fromX + dx*t;
      const iy = fromY + dy*t;
      if(ix>=bounds.x-1e-6 && ix<=bounds.x+bounds.w+1e-6 && iy>=bounds.y-1e-6 && iy<=bounds.y+bounds.h+1e-6){
        if(t<bestT) bestT=t;
      }
    }
    if(Math.abs(dx)>1e-6){
      test((bounds.x - fromX)/dx);
      test((bounds.x + bounds.w - fromX)/dx);
    }
    if(Math.abs(dy)>1e-6){
      test((bounds.y - fromY)/dy);
      test((bounds.y + bounds.h - fromY)/dy);
    }
    if(bestT!==Infinity){
      return {x: fromX + dx*bestT, y: fromY + dy*bestT};
    }
    return {x: targetX, y: targetY};
  }

  function reaperImpactPoint(fromX, fromY){
    const bounds=getReaperBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const targetX = reaperBoss.x;
    const targetY = reaperBoss.y;
    const dx = targetX - fromX;
    const dy = targetY - fromY;
    let bestT = Infinity;
    function test(t){
      if(t<=0 || t>=1e6) return;
      const ix = fromX + dx*t;
      const iy = fromY + dy*t;
      if(ix>=bounds.x-1e-6 && ix<=bounds.x+bounds.w+1e-6 && iy>=bounds.y-1e-6 && iy<=bounds.y+bounds.h+1e-6){
        if(t<bestT) bestT=t;
      }
    }
    if(Math.abs(dx)>1e-6){
      test((bounds.x - fromX)/dx);
      test((bounds.x + bounds.w - fromX)/dx);
    }
    if(Math.abs(dy)>1e-6){
      test((bounds.y - fromY)/dy);
      test((bounds.y + bounds.h - fromY)/dy);
    }
    if(bestT!==Infinity){
      return {x: fromX + dx*bestT, y: fromY + dy*bestT};
    }
    return {x: targetX, y: targetY};
  }

  function demonImpactPoint(fromX, fromY){
    const bounds=getDemonBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const targetX = demonBoss.x;
    const targetY = demonBoss.y;
    const dx = targetX - fromX;
    const dy = targetY - fromY;
    let bestT = Infinity;
    function test(t){
      if(t<=0 || t>=1e6) return;
      const ix = fromX + dx*t;
      const iy = fromY + dy*t;
      if(ix>=bounds.x-1e-6 && ix<=bounds.x+bounds.w+1e-6 && iy>=bounds.y-1e-6 && iy<=bounds.y+bounds.h+1e-6){
        if(t<bestT) bestT=t;
      }
    }
    if(Math.abs(dx)>1e-6){
      test((bounds.x - fromX)/dx);
      test((bounds.x + bounds.w - fromX)/dx);
    }
    if(Math.abs(dy)>1e-6){
      test((bounds.y - fromY)/dy);
      test((bounds.y + bounds.h - fromY)/dy);
    }
    if(bestT!==Infinity){
      return {x: fromX + dx*bestT, y: fromY + dy*bestT};
    }
    return {x: targetX, y: targetY};
  }

  function highlightSpaceBossTarget(){
    if(isReaperActive()){
      const bounds=getReaperBounds();
      if(bounds){
        reaperTargetHighlightUntil = Math.max(reaperTargetHighlightUntil, performance.now()+600);
        pushLockBox(bounds.x, bounds.y, bounds.w, bounds.h, 'target');
      }
      return;
    }
    const bounds=getSpaceBossBounds();
    if(bounds){
      pushLockBox(bounds.x, bounds.y, bounds.w, bounds.h, 'target');
      return;
    }
    if(isDragonActive()){
      const dragonBounds=getDragonBounds();
      if(dragonBounds){
        pushLockBox(dragonBounds.x, dragonBounds.y, dragonBounds.w, dragonBounds.h, 'target');
      }
    }
  }
    let scoreUploaded=false;
    let uploading=false;
  let ledStyle = (localStorage.getItem('led_style')||'classic');
  function resetCombo(){
    combo=0; comboLastTime=0;
    comboNoticeTriggered={50:false,100:false,200:false,300:false,400:false,500:false,800:false,1000:false};
    if(comboEl){ comboEl.textContent=''; comboEl.className='combo'; comboEl.style.opacity=0; }
  }
  function showComboNotice(text,showMs=5000,fadeMs=3000){
    let notice=document.getElementById('comboNotice');
    if(!notice){
      notice=document.createElement('div');
      notice.id='comboNotice';
      document.getElementById('playArea').appendChild(notice);
    }
    notice.className='';
    notice.innerHTML='';
    const span=document.createElement('span');
    span.className='marqueeText';
    span.textContent=text;
    span.style.animation=`comboMarquee ${showMs}ms linear`;
    notice.appendChild(span);
    notice.style.transition=`opacity ${fadeMs/1000}s`;
    void notice.offsetWidth;
    notice.className='show';
    setTimeout(()=>notice.classList.add('fade'),showMs);
    setTimeout(()=>{notice.className=''; notice.innerHTML=''; notice.style.transition='';},showMs+fadeMs);
  }
  function incrementCombo(){
    combo++; comboLastTime=performance.now();
    if(combo>stats.maxCombo) stats.maxCombo=combo;
    if(!comboEl) return;
    comboEl.textContent='Combo '+combo;
    comboEl.className='combo show';
    if(combo>=200){ comboEl.classList.add('tier6','glow'); }
    else if(combo>=100){ comboEl.classList.add('tier5'); }
    else if(combo>=50){ comboEl.classList.add('tier4'); }
    else if(combo>=30){ comboEl.classList.add('tier3'); }
    else if(combo>=10){ comboEl.classList.add('tier2'); }
    else { comboEl.classList.add('tier1'); }
    if(isComboStarActive()){ comboEl.classList.add('star'); }
    comboEl.classList.add('pop'); setTimeout(()=>comboEl.classList.remove('pop'),500);
    comboEl.style.opacity=1;
    if(combo===50 && !comboNoticeTriggered[50]){ comboNoticeTriggered[50]=true; showComboNotice('看來是個高手呢！'); }
    else if(combo===100 && !comboNoticeTriggered[100]){ comboNoticeTriggered[100]=true; showComboNotice('真是驚人！ 你……是怪物嗎？'); }
    else if(combo===200 && !comboNoticeTriggered[200]){ comboNoticeTriggered[200]=true; showComboNotice('難以置信！ 你……是神嗎？'); }
    else if(combo===300 && !comboNoticeTriggered[300]){ comboNoticeTriggered[300]=true; showComboNotice('你是還想突破天際到哪裡去呀？異次元嗎？'); }
    else if(combo===400 && !comboNoticeTriggered[400]){ comboNoticeTriggered[400]=true; showComboNotice('你這已經破碎虛空了吧？'); }
    else if(combo===500 && !comboNoticeTriggered[500]){ comboNoticeTriggered[500]=true; showComboNotice('算你狠！有種Combo 1000看看呀！'); }
    else if(combo===800 && !comboNoticeTriggered[800]){ comboNoticeTriggered[800]=true; showComboNotice('我看你是到不了Combo 1000的啦！是不是開始感覺手滑啦？'); }
    else if(combo===1000 && !comboNoticeTriggered[1000]){ comboNoticeTriggered[1000]=true; showComboNotice('快截圖給同事看吧！你是真正的連擊之神！',10000,5000); }
  }
  function getComboMultiplier(){
    if(combo>=1000) return 10;
    if(combo>=800) return 8;
    if(combo>=500) return 7;
    if(combo>=400) return 6;
    if(combo>=300) return 5;
    if(combo>=200) return 4;
    if(combo>=100) return 3;
    if(combo>=50) return 2;
    if(combo>=30) return 1.5;
    if(combo>=10) return 1.2;
    return 1;
  }
  function addScore(base){
    let mul=getComboMultiplier();
    mul*=getComboStarScoreMultiplier();
    const d=difficultySel?.value;
    if(d==='easy') mul*=0.5;
    else if(d==='hard') mul*=1.2;
    score += Math.round(base * mul);
  }
  function scoreForBrick(b){ return b.boss ? 3000 : (b.elite ? 100 : 10); }
  const BOSS_DEFEAT_SCORE = {
    space: 5000,
    reaper: 10000,
    dragon: 20000,
    demon: 50000
  };
  const BOSS_HIT_SCORE = 30;
  function renderStatsHtml(){
    const fd = (stats.fastestDeath===Infinity)? '-' : stats.fastestDeath.toFixed(1);
    const ld = (stats.longestLife===0)? '-' : stats.longestLife.toFixed(1);
    return `<div class="grid">
      <div>消耗生命：<strong>${stats.livesUsed}</strong></div>
      <div>接球次數：<strong>${stats.catches}</strong></div>
      <div>增益次數：<strong>${stats.buffs}</strong></div>
      <div>減益次數：<strong>${stats.debuffs}</strong></div>
      <div>殺菁英數：<strong>${stats.eliteKills}</strong></div>
      <div>殺Boss數：<strong>${stats.bossKills}</strong></div>
      <div>最高Combo數：<strong>${stats.maxCombo}</strong></div>
      <div>最快死亡：<strong>${fd}</strong> s</div>
      <div>最久存活：<strong>${ld}</strong> s</div>
    </div>`;
  }

  let bgTime=0; let screenShake=0;
  let countdownTimer=null, countdownShow=0, resumePending=false;
  // === 新增暫停時間追蹤與自動增益掉落計時 ===
  // pauseStartedAt: 記錄暫停開始時的時間戳。當非 null 時表遊戲處於暫停狀態（包括開啟音效/選項菜單、教學說明等）。
  // lastBeneficialPickupAt: 上一次取得增益或特殊增益的時間戳，用於觸發十秒未拾取增益時自動掉落。
  // nextAutoBeneficialDropAt: 下一次自動掉落增益的預定時間，將在 update 中檢查並觸發。
  let pauseStartedAt = null;
  let lastBeneficialPickupAt = 0;
  let nextAutoBeneficialDropAt = 0;
  // 影像選擇：1~10 隨機 bg/cg，11~20 用對應未用者
  let imageChoice = new Array(10).fill(-1); // 0=bg,1=cg; -1: 未決
  let galleryUnlocks = {};
  try{ galleryUnlocks = JSON.parse(localStorage.getItem('gallery_unlocks')||'{}'); }catch(e){ galleryUnlocks={}; }
  function markImageUnlocked(type, idx){
    const key = `${type}${idx+1}`;
    if(!galleryUnlocks[key]){
      galleryUnlocks[key]=true;
      try{ localStorage.setItem('gallery_unlocks', JSON.stringify(galleryUnlocks)); }catch(e){}
    }
  }

  let dialogUnlocks = {};
  try{ dialogUnlocks = JSON.parse(localStorage.getItem('dialog_unlocks')||'{}'); }catch(e){ dialogUnlocks={}; }
  function unlockDialog(key, idx){
    const mask = dialogUnlocks[key] || 0;
    dialogUnlocks[key] = mask | (1<<idx);
    try{ localStorage.setItem('dialog_unlocks', JSON.stringify(dialogUnlocks)); }catch(e){}
  }
  function getRandomDialog(key){
    const lines = DIALOGS[key] || [];
    const mask = dialogUnlocks[key] || 0;
    const lockedIdx = [];
    for(let i=0;i<lines.length;i++){
      if(!(mask & (1<<i))) lockedIdx.push(i);
    }
    let idx;
    if(lockedIdx.length>0){
      idx = lockedIdx[Math.floor(Math.random()*lockedIdx.length)];
    }else{
      idx = Math.floor(Math.random()*lines.length);
    }
    return {idx, text: lines[idx]||''};
  }
  // BGM
  let audioCtx=null, bgmGain=null, bgmOn=false, bgmStarted=false;
  // 追蹤目前作用中的 BGM node，便於停止與清除
  let bgmNodes=new Set();

  // === 初始化新 UI 的聲音/BGM 控制 ===
  // 連結複選框至原有的 soundBtn/bgmBtn 按鈕，並同步本地儲存值
  if (sfxOnEl) {
    const stored = localStorage.getItem('sfx_on');
    // 若本地有設定則使用，否則沿用預設的 soundsOn
    soundsOn = (stored ?? (soundsOn ? '1' : '0')) === '1';
    sfxOnEl.checked = soundsOn;
    // 切換複選框即呼叫舊邏輯的按鈕 click，並依據更新後的變數同步複選框狀態
    sfxOnEl.addEventListener('change', () => {
      soundBtn.click();
      sfxOnEl.checked = soundsOn;
    });
  }
  if (bgmOnEl) {
    const stored = localStorage.getItem('bgm_on');
    bgmOn = (stored ?? (bgmOn ? '1' : '0')) === '1';
    bgmOnEl.checked = bgmOn;
    bgmOnEl.addEventListener('change', () => {
      bgmBtn.click();
      bgmOnEl.checked = bgmOn;
    });
  }
  // 初始化 BGM 音量滑桿
  if (localStorage.getItem('bgm_vol')) {
    const vol = parseFloat(localStorage.getItem('bgm_vol'));
    if (!isNaN(vol)) {
      bgmVol.value = String(vol);
      if (bgmGain) bgmGain.gain.value = vol;
    }
  }

  // 粒子 / 特效容器
  const particles=[]; // {x,y,vx,vy,life,size,color}
  const plasmas=[];   // {x,y,vx,vy,until,radius}
  const plasmaChains=[]; // {x1,y1,x2,y2,until}
  const holyFlashes=[]; // {x,y,until,pattern}
  let phoenixAnim=null; // {x, tEnd}
  let phoenixHeartGlowUntil=0;
  const fireBursts=[];  // 火焰片段 {x,y,life}
  const fireExplosions=[]; // 火焰球爆炸效果 {x,y,r,t0,life}
  const starProjectiles=[]; // 隕落星星 {x,y,vx,vy,damage,radius}
  const moonProjectiles=[]; // 反彈月亮 {x,y,vx,vy,damage,radius,bounces,maxBounces,alive}
  const activePlagueTimers=[];

  // 新增容器：飛彈、黑洞特效、雷射光束
  const missiles=[]; // {x,y,vx,vy,targetId,targetType,lifeUntil,trail:[]}
  function gatherMissileCandidates(src){
    const origin=src||{x:1100/2,y:layout().top};
    const candidates=[];
    for(let i=0;i<bricks.length;i++){
      const brick=bricks[i];
      if(!brick || !canDestroyBrick(brick)) continue;
      const cx=brick.x+brick.w/2;
      const cy=brick.y+brick.h/2;
      const dx=cx-origin.x;
      const dy=cy-origin.y;
      const dist=dx*dx+dy*dy;
      candidates.push({type:'brick',targetId:i,x:cx,y:cy,brick,dist});
    }
    const bossCenter=isSpecialBossActive()?activeBossCenter():null;
    if(bossCenter){
      const dx=bossCenter.x-origin.x;
      const dy=bossCenter.y-origin.y;
      const dist=dx*dx+dy*dy;
      candidates.push({type:'boss',targetId:'boss',x:bossCenter.x,y:bossCenter.y,dist});
    }
    candidates.sort((a,b)=>a.dist-b.dist);
    return candidates;
  }
  function pickMissileTargets(candidates,count){
    if(!candidates.length) return [];
    const targetCount=Math.max(1, Math.min(count, candidates.length));
    const picks=[];
    const base=[0, Math.floor((candidates.length-1)/2), candidates.length-1];
    for(const idx of base){
      if(idx>=0 && idx<candidates.length){
        const candidate=candidates[idx];
        if(!picks.includes(candidate)) picks.push(candidate);
        if(picks.length>=targetCount) return picks.slice(0,targetCount);
      }
    }
    for(const candidate of candidates){
      if(!picks.includes(candidate)) picks.push(candidate);
      if(picks.length>=targetCount) break;
    }
    return picks.slice(0,targetCount);
  }
  function spawnMissileForTarget(src,target,now){
    if(!target) return;
    const ang=Math.random()*Math.PI*2;
    missiles.push({
      x:src.x,
      y:src.y,
      vx:Math.cos(ang)*2,
      vy:Math.sin(ang)*2,
      targetId:target.targetId,
      targetType:target.type||'brick',
      lifeUntil:now+GAME_CONFIG.powers.MISSILE.missile.lifeMs,
      trail:[]
    });
    if(target.type==='boss'){
      highlightSpaceBossTarget();
    }else if(target.brick){
      pushLockBox(target.brick.x, target.brick.y, target.brick.w, target.brick.h, 'target');
    }
  }
  function emitMissilesFromSource(src,options={}){
    if(!src) return;
    const candidates=gatherMissileCandidates(src);
    if(!candidates.length) return;
    const now=performance.now();
    if(options.shots!=null){
      const baseShots=Math.max(1, Math.floor(options.shots));
      const totalShots=baseShots * (equipmentMissileDoubleShots?2:1);
      const targetCount=Math.max(1, Math.min(candidates.length, totalShots));
      const picks=pickMissileTargets(candidates,targetCount);
      if(!picks.length) return;
      for(let i=0;i<totalShots;i++){
        const target=picks[i % picks.length];
        spawnMissileForTarget(src,target,now);
      }
      return;
    }
    const baseCount=options.baseCount || 3;
    const picks=pickMissileTargets(candidates,baseCount);
    const repeats=equipmentMissileDoubleShots?2:1;
    for(const target of picks){
      for(let i=0;i<repeats;i++){
        spawnMissileForTarget(src,target,now);
      }
    }
  }
  function handleMissileImpact(x,y){
    if(!Number.isFinite(x) || !Number.isFinite(y)) return;
    if(equipmentMissilePlasma){
      spawnPlasmaBurst(x,y);
    }
    if(equipmentMissileHolyStrike){
      applyHolyStrike(x,y);
    }
  }
  const blackHoles=[]; // {x,y,until}
  const laserBeams=[]; // {x1,y1,x2,y2,until}
  const laserImpacts=[]; // {x,y,t0,tEnd}
  const gatlingBullets=[]; // 火力壓制子彈 {x,y,vx,vy}
  const lockBoxes=[]; // {x,y,w,h,until,kind}
  let nextTreasureBrickAt=0;

  function scheduleNextTreasureBrick(now=performance.now()){
    nextTreasureBrickAt = now + 5000 + Math.random()*3000;
  }

  function isTrueBossFightActive(){
    return (spaceBossPhase==='active' && spaceBoss) || (reaperPhase==='active' && reaperBoss) || (dragonPhase==='active' && dragonBoss) || (demonPhase==='active' && demonBoss);
  }

  function spawnBossTreasureBrick(){
    if(!isTrueBossFightActive()) return;
    const L=layout();
    const width=Math.max(48, brickW||80);
    const height=Math.max(20, brickH||24);
    const pad=40;
    const minX=pad;
    const maxX=Math.max(minX, 1100 - pad - width);
    const spawnX=minX + Math.random()*(maxX - minX);
    const top=L?L.top:0;
    const spawnY=(top||0) - height - 12;
    const fallVy=GAME_CONFIG.powerCapsule.fallVy||2.2;
    addBrick(bricks, spawnX, spawnY, width, height, {
      hp:1,
      treasure:true,
      fallingTreasure:true,
      vy:fallVy,
      colorIdx:0
    });
    spawnParticles(spawnX + width/2, Math.max(spawnY + height/2, 0), '#a8e3ff', 14, 1.6, 2.6, 2.4);
    spawnParticles(spawnX + width/2, Math.max(spawnY + height/2, 0), '#ff9bf1', 10, 1.2, 2.0, 2.0);
    updateHUD();
  }

  // 特殊增益相關容器
  const swords=[]; // 劍芒裂空：{x,y,vx,vy,state,tx,ty}
  let swordFireStart=0, nextSwordFire=0;

  let stormTurret=null; // 雷射風暴：{x,y,chargeUntil,fireAt,shots,lastShot}
  let gatling=null; // 火力壓制：{x,y,chargeUntil,fireStart,fireUntil,lastShot,angle}

  const annihilSparks=[]; // 萬物銷毀：天空灑落的金色光點 {x,y,v}

  // === Boss 投射物 ===
  const hostileBeams=[]; // 線性光束彈 {x,y,vx,vy,color,hit,onHit}
  const hostileArcs=[];  // 弧形劍氣 {x,y,vx,vy,phase,amp,color,onHit}
  const hostileColumns=[]; // 直下石化光束 {x,w,tStart,tEnd,color,applied}
  const hazardClouds=[]; // 烏雲 {x,y,tEnd,spawned}

  function bossCenter(){
    if(isDragonActive() && dragonBoss) return {b:null, x:dragonBoss.x, y:dragonBoss.y, type:'dragon'};
    for(const b of bricks){ if(b.boss) return {b, x:b.x+b.w/2, y:b.y+b.h/2}; }
    return null;
  }

  function spawnLionBeamFrom(x,y){
    const {x:tx, y:ty}=getPaddleTarget();
    const ang=Math.atan2(ty-y, tx-x); const speed=6.0;
    hostileBeams.push({x:x, y:y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); screenShake=Math.max(screenShake,6); }});
    beep(1100,0.12,0.08);
  }
  function spawnLionBeam(){
    const bc=bossCenter(); if(!bc) return;
    bossChargeColor='255,215,90'; bossChargeUntil=performance.now()+2000;
    setTimeout(()=>{
      const {x:tx, y:ty}=getPaddleTarget();
      const ang=Math.atan2(ty-bc.y, tx-bc.x); const speed=6.0;
      hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'gold', hit:false, onHit:(pr)=>{ paddle.w = Math.max(60, paddle.w - 20); screenShake=Math.max(screenShake,6); }});
      beep(1100,0.12,0.08);
    },2000);
  }
  function spawnKnightArc(){
    const bc=bossCenter(); if(!bc) return;
    bossChargeColor='210,210,255'; bossChargeUntil=performance.now()+2000;
    setTimeout(()=>{
      const {x:tx, y:ty}=getPaddleTarget();
      const ang=Math.atan2(ty-bc.y, tx-bc.x);
      const speed=4.5;
    hostileArcs.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, phase:0, amp:32, color:'silver', onHit:()=>{
      const pr=paddleRect();
      const cx=pr.x+pr.w/2;
      const cy=pr.y+pr.h/2;
      if(blockDamageIfShielded({x:cx,y:cy})) return;
      lives=Math.max(0, lives-1);
      updateHUD();
      screenShake=Math.max(screenShake,10);
    }});
      beep(900,0.12,0.07);
    },2000);
  }
  function spawnCyclopsColumn(opts={}){
    const bc=bossCenter(); if(!bc) return;
    const now=performance.now();
    bossChargeColor='255,235,150';
    bossChargeUntil=now+3000;
    if(isDragonActive() && dragonBoss){
      dragonBoss.petrifyCharge={start:now,end:now+3000};
      dragonMarquee={text:'危險！ 毀滅之龍即將使出石化光束!', start:now, fadeStart:now+2600, end:now+3000, style:'elegant'};
    }
    setTimeout(()=>{
      const center=bossCenter();
      if(!center){
        if(dragonBoss) dragonBoss.petrifyCharge=null;
        return;
      }
      const releaseAt=performance.now();
      hostileColumns.push({x:center.x, w:150, tStart:releaseAt, tEnd:releaseAt+1000, color:'#eedc9a', applied:false});
      cyclopsShakeUntil=releaseAt+2000;
      if(isDragonActive() && dragonBoss){
        dragonBoss.petrifyCharge=null;
      }
      noteCyclopsFirstAttack(releaseAt);
      beep(500,0.12,0.08);
      if(opts.onComplete){ setTimeout(()=>{ opts.onComplete(); },1000); }
    },3000);
  }
  function finishDragonAttack(expectType=null){
    const now=performance.now();
    if(expectType && dragonAttackState && dragonAttackState.type!==expectType){ return; }
    dragonAttackState=null;
    dragonDeathRayOrbs.length=0;
    dragonDeathRayBeams.length=0;
    if(dragonBoss){
      dragonBoss.pose=null;
      dragonBoss.moveTarget=null;
      dragonBoss.nextMove=now+1400;
    }
    dragonNextAttackAt=now+DRAGON_ATTACK_INTERVAL;
  }

  function maybeStartDragonAttack(now){
    if(!isDragonActive() || !dragonBoss) return;
    if(dragonAttackState) return;
    if(!dragonNextAttackAt){ dragonNextAttackAt=now+3000; }
    if(now<dragonNextAttackAt) return;
    const options=['petrify','deathRay','annihilation'];
    const pick=options[Math.floor(Math.random()*options.length)];
    startDragonAttack(pick);
  }

  function startDragonAttack(type){
    if(!dragonBoss) return;
    const now=performance.now();
    if(type==='petrify'){
      dragonAttackState={type:'petrify', startedAt:now, phase:'charge'};
      spawnCyclopsColumn({onComplete:()=>finishDragonAttack('petrify')});
    }else if(type==='deathRay'){
      const L=layout();
      const targetY=L.top+120;
      dragonBoss.moveTarget=null;
      dragonAttackState={
        type:'deathRay',
        startedAt:now,
        phase:'countdown',
        overrideMovement:true,
        targetX:550,
        targetY,
        countdownEnd:now+3000,
        nextOrb:now,
        countdownValue:3,
        nextCountdownTick:now+1000,
        fireIndex:0,
        fireNext:0,
        lockedTarget:null,
        beamTravel:900,
        beamFade:320
      };
      dragonDeathRayOrbs.length=0;
      dragonBoss.pose='deathRay';
      dragonMarquee={text:'危險！ 毀滅之龍即將使出破壞死光! 3', start:now, fadeStart:now+2600, end:now+3000, style:'elegant'};
    }else if(type==='annihilation'){
      const L=layout();
      const tag=`annihilation_${now}`;
      const rowY=L.top + brickH + L.pad*0.5;
      const challengeBricks=[];
      for(let c=0;c<L.cols;c++){
        const x=L.pad + c*(brickW+L.pad);
        addBrick(bricks, x, rowY, brickW, brickH, {hp:1, colorIdx:c%4, annihilationTag:tag});
        challengeBricks.push(brickIdCounter-1);
      }
      updateHUD();
      dragonBoss.moveTarget=null;
      dragonAttackState={
        type:'annihilation',
        startedAt:now,
        phase:'challenge',
        overrideMovement:true,
        countdownEnd:now+10000,
        bricksTag:tag,
        challengeBricks,
        targetY:Math.max(L.top-240, dragonBoss.baseY-220),
        returnY:dragonBoss.baseY,
        explosionEnd:0,
        hideDragon:false
      };
      dragonBoss.pose=null;
      dragonMarquee={text:'危險！ 毀滅之龍即將使出萬物銷毀!', start:now, fadeStart:now+9000, end:now+10000, style:'elegant'};
      showPrompt('請於10sec內擊毀所有磚塊阻止萬物銷毀');
    }
    dragonNextAttackAt=0;
  }

  function updateDragonAttackState(now, dt){
    if(!dragonAttackState){
      maybeStartDragonAttack(now);
      return false;
    }
    const state=dragonAttackState;
    if(state.type==='petrify'){
      return false;
    }
    if(state.type==='deathRay'){
      const travelDuration = state.beamTravel || 900;
      const fadeDuration = state.beamFade || 320;
      const speed=Math.min(0.28, (dt/1000)*0.9);
      const tx=state.targetX||dragonBoss.x;
      const ty=state.targetY||dragonBoss.baseY;
      dragonBoss.x += (tx - dragonBoss.x)*speed;
      dragonBoss.baseY += (ty - dragonBoss.baseY)*speed;

      for(const orb of dragonDeathRayOrbs){
        if(!orb.angle){ orb.angle=Math.random()*Math.PI*2; }
        const rot=0.0024*dt;
        orb.angle += rot;
        const radius=orb.radius||(110+Math.random()*40);
        orb.radius=radius;
        const verticalScale=orb.vertScale||0.55+Math.random()*0.25;
        orb.vertScale=verticalScale;
        orb.x = dragonBoss.x + Math.cos(orb.angle)*radius;
        orb.y = dragonBoss.y - 40 + Math.sin(orb.angle)*radius*verticalScale;
      }

      if(state.phase==='countdown'){
        if(now>=state.nextOrb){
          state.nextOrb=now+500;
          dragonDeathRayOrbs.push({createdAt:now});
        }
        if(state.countdownValue>1 && now>=state.nextCountdownTick){
          state.countdownValue--;
          state.nextCountdownTick+=1000;
          if(dragonMarquee){ dragonMarquee.text=`危險！ 毀滅之龍即將使出破壞死光! ${state.countdownValue}`; }
          beep(720+(3-state.countdownValue)*40,0.08,0.05);
        }
        if(now>=state.countdownEnd){
          state.phase='firing';
          state.fireNext=now;
          if(dragonMarquee){
            dragonMarquee.text='破壞死光啟動！';
            dragonMarquee.start=now;
            dragonMarquee.fadeStart=now+800;
            dragonMarquee.end=now+1400;
          }
        }
      }
      if(state.phase==='firing' && now>=state.fireNext){
        const orb=dragonDeathRayOrbs.shift();
        if(orb){
          const targetInfo=getPaddleTarget();
          const aimX=targetInfo.x;
          const aimY=targetInfo.y;
          let target=state.lockedTarget;
          if(!target || now>=paddleGoneUntil){
            target={x:aimX, y:aimY};
            state.lockedTarget={...target};
          }
          dragonDeathRayBeams.push({
            x1:orb.x||dragonBoss.x,
            y1:orb.y||dragonBoss.y,
            x2:target.x,
            y2:target.y,
            start:now,
            impactAt:now+travelDuration,
            end:now+travelDuration+fadeDuration,
            hit:false
          });
          state.fireNext=now+500;
        }else{
          state.phase='cooldown';
          state.cooldownUntil=now+800;
        }
      }
      for(const beam of dragonDeathRayBeams){
        if(beam.hit) continue;
        const impactAt=beam.impactAt || beam.end;
        if(now>=impactAt){
          beam.hit=true;
          const targetX=beam.x2;
          const targetY=beam.y2;
          const pr=paddleRect();
          const intersects = pr.w>0 && pr.h>0 && segmentIntersectsRect(beam.x1, beam.y1, targetX, targetY, pr);
          if(intersects){
            const hitX=pr.x+pr.w/2;
            const hitY=pr.y+pr.h/2;
            if(blockDamageIfShielded({x:hitX,y:hitY})){
              continue;
            }
            spawnParticles(targetX, targetY, '#ffec8a', 36, 2.4, 4.0, 4.0);
            dragonBursts.push({type:'flare',x:targetX,y:targetY,r0:0,r1:280,t0:now,life:900,color:'255,225,150'});
            screenShake=Math.max(screenShake,14);
            playSFX('fireExplosion');
            if(now>=paddleGoneUntil){
              paddleGoneUntil=now+3000;
            }
          }
        }
      }
      if(state.phase==='cooldown' && now>=state.cooldownUntil && !dragonDeathRayBeams.length){
        finishDragonAttack('deathRay');
      }
      return true;
    }
    if(state.type==='annihilation'){
      if(state.phase==='challenge'){
        const speed=Math.min(0.32, (dt/1000)*1.1);
        dragonBoss.x += (550 - dragonBoss.x)*speed;
        dragonBoss.baseY += (state.targetY - dragonBoss.baseY)*speed;
        if(dragonBoss.baseY<=state.targetY+2){ state.hideDragon=true; }
        const remain = bricks.some(b=>b.annihilationTag===state.bricksTag);
        if(!remain){
          state.phase='returning';
          state.hideDragon=false;
          state.returnStart=now;
          if(dragonMarquee){
            dragonMarquee.text='成功阻止萬物銷毀!';
            dragonMarquee.start=now;
            dragonMarquee.fadeStart=now+1600;
            dragonMarquee.end=now+2000;
          }
        }else if(now>=state.countdownEnd){
          state.phase='detonate';
          state.detonated=false;
          state.detonateStart=now;
          state.explosionEnd=now+5000;
          state.hideDragon=true;
          dragonMarquee={text:'萬物銷毀啟動!', start:now, fadeStart:now+4200, end:now+5000, style:'alert'};
        }
        return true;
      }
      if(state.phase==='detonate'){
        if(!state.detonated){
          state.detonated=true;
          screenShake=Math.max(screenShake,36);
          playSFX('dragonAnnihilation');
          const nowDet=now;
          for(let i=bricks.length-1;i>=0;i--){
            const b=bricks[i];
            const cx=b.x+b.w/2, cy=b.y+b.h/2;
            spawnParticles(cx, cy, '#ffe7a6', 30, 2.8, 4.0, 4.2);
            dragonBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:280,t0:nowDet,life:1200,color:'255,220,150'});
            bricks.splice(i,1);
          }
          const L=layout();
          const stageHeight=L.rows*(brickH+L.pad) - L.pad;
          const centerX=550;
          const centerY=L.top + stageHeight/2;
          dragonBursts.push({type:'apocalypse',x:centerX,y:centerY,r0:140,r1:960,t0:nowDet,life:2600,color:'255,236,190'});
          dragonBursts.push({type:'shockwave',x:centerX,y:centerY,r0:0,r1:1100,width:46,t0:nowDet,life:2200,color:'255,230,180'});
          const emberParticles=Array.from({length:90},()=>({
            angle:Math.random()*Math.PI*2,
            radius:40+Math.random()*220,
            speed:260+Math.random()*360,
            size:10+Math.random()*18,
            drift:(Math.random()*0.6-0.3)
          }));
          dragonBursts.push({type:'emberRain',x:centerX,y:centerY,t0:nowDet,life:2400,count:emberParticles.length,particles:emberParticles});
          const aftershockDelays=[0,200,420,660,900];
          aftershockDelays.forEach((delay, idx)=>{
            setTimeout(()=>{
              screenShake=Math.max(screenShake, Math.max(18, 30 - idx*4));
              if(idx>0){ playSFX('fireExplosion'); }
            }, delay);
          });
          updateHUD();
          const pr=paddleRect();
          if(!(pr.w>0 && pr.h>0 && blockDamageIfShielded({x:pr.x+pr.w/2,y:pr.y+pr.h/2}))){
            paddleGoneUntil=Math.max(paddleGoneUntil, now+5500);
          }
        }
        if(now>=state.explosionEnd){
          state.phase='returning';
          state.hideDragon=false;
          dragonBoss.baseY=state.targetY;
          dragonBoss.y=state.targetY;
          dragonBoss.x=550;
        }
        return true;
      }
      if(state.phase==='returning'){
        const speed=Math.min(0.26, (dt/1000)*0.9);
        dragonBoss.x += (550 - dragonBoss.x)*speed;
        dragonBoss.baseY += (state.returnY - dragonBoss.baseY)*speed;
        if(Math.abs(dragonBoss.baseY-state.returnY)<2 && Math.abs(dragonBoss.x-550)<3){
          finishDragonAttack('annihilation');
        }
        return true;
      }
      return true;
    }
    return false;
  }

  function spawnDemonBeam(){
    const bc=bossCenter(); if(!bc) return;
    bossChargeColor='255,60,80'; bossChargeUntil=performance.now()+2000;
    setTimeout(()=>{
      const {x:tx, y:ty}=getPaddleTarget();
      const ang=Math.atan2(ty-bc.y, tx-bc.x); const speed=7.2;
    hostileBeams.push({x:bc.x, y:bc.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, color:'red', hit:false, onHit:()=>{
      const pr=paddleRect();
      const cx=pr.x+pr.w/2;
      const cy=pr.y+pr.h/2;
      if(blockDamageIfShielded({x:cx,y:cy})) return;
      lives=Math.max(0, lives-1);
      updateHUD();
      screenShake=Math.max(screenShake,12);
    }});
      beep(600,0.14,0.09);
    },2000);
  }
  function spawnDemonClouds(){
    showPrompt('哈哈哈! 接受惡魔的詛咒吧!');
    const picks = Array.from({length:5}, ()=> 40 + Math.random()*(1100-80));
    const y = layout().top - 10;
    const tEnd = performance.now() + 1000;
    for(const x of picks){ hazardClouds.push({x,y,tEnd,spawned:false}); }
  }
  function noteCyclopsFirstAttack(at){
    if(level!==15 || cyclopsFirstAttackAt) return;
    cyclopsFirstAttackAt = at;
    cyclopsMarqueeShown=false;
    cyclopsEventStarted=false;
    cyclopsEventComplete=false;
    cyclopsForcedPetrifyAt=0;
    cyclopsForcedPetrifyFired=false;
    cyclopsRowBlastIndex=-1;
    cyclopsNextRowBlast=0;
    cyclopsShellBurst=false;
  }
  function updateCyclopsEvent(){
    if(level!==15 || !cyclopsFirstAttackAt || cyclopsEventComplete) return;
    const now=performance.now();
    const triggerAt = cyclopsFirstAttackAt + 5000;
    if(now>=triggerAt){
      if(!cyclopsMarqueeShown){
        showComboNotice('竟然妄想踏入神之領域嗎? 真是愚蠢的人類!',5000,3000);
        cyclopsMarqueeShown=true;
      }
      if(!cyclopsEventStarted){
        cyclopsEventStarted=true;
        const L=layout();
        cyclopsRowBlastIndex=L.rows-1;
        cyclopsNextRowBlast=now;
      }
    }
    if(cyclopsEventStarted){
      screenShake=Math.max(screenShake,20);
      if(cyclopsRowBlastIndex>=0 && now>=cyclopsNextRowBlast){
        cyclopsBlastRow(cyclopsRowBlastIndex);
        cyclopsRowBlastIndex--;
        cyclopsNextRowBlast=now+500;
      }
      if(cyclopsRowBlastIndex<0){
        cyclopsEventStarted=false;
        cyclopsEventComplete=true;
      }
    }
  }

  function prepareDemonRows(){
    const L=layout();
    const spacing = brickH + L.pad;
    const rowsMap=new Map();
    for(const b of bricks){
      if(b.demonShell) continue;
      if(b.fallingTreasure) continue;
      const row=Math.round((b.y - L.top)/spacing);
      if(!rowsMap.has(row)) rowsMap.set(row, []);
      rowsMap.get(row).push(b);
    }
    demonEventRows = Array.from(rowsMap.entries())
      .sort((a,b)=>b[0]-a[0])
      .map(([,arr])=>{
        const copy=arr.slice();
        for(let i=copy.length-1;i>0;i--){
          const j=Math.floor(Math.random()*(i+1));
          [copy[i], copy[j]]=[copy[j], copy[i]];
        }
        return copy;
      });
    demonEventTargets = demonEventRows.reduce((sum,row)=>sum+row.length,0);
    demonEventCleared=0;
  }

  function dropDemonRow(row, now){
    if(!Array.isArray(row)) return;
    const debris=[];
    for(const brick of row){
      const idx=bricks.indexOf(brick);
      if(idx>=0){
        revealBrickArea(brick);
        bricks.splice(idx,1);
      }
      demonEventCleared++;
      const baseColor = brick.treasure ? '#ffd166' : brick.boss ? '#ff4d6d' : brick.unbreakable ? '#888888' : brick.strong ? '#bb7aff' : brick.moving ? '#6ec6ff' : brick.explosive ? getVar('--expl') : brickColor(brick.colorIdx||0);
      debris.push({
        x:brick.x,
        y:brick.y,
        w:brick.w,
        h:brick.h,
        color:baseColor,
        treasure:!!brick.treasure,
        vx:(Math.random()-0.5)*1.4,
        vy:2.1 + Math.random()*2.0,
        gravity:0.16 + Math.random()*0.07,
        angle:(Math.random()-0.5)*0.25,
        spin:(Math.random()-0.5)*0.06
      });
    }
    if(debris.length){
      demonFallingDebris.push(...debris);
      screenShake=Math.max(screenShake,16);
    }
    if(row){ row.length=0; }
  }

  function startDemonEvent(now){
    if(demonEventPhase!=='awaiting') return;
    demonEventPhase='collapse';
    demonPhase='event';
    demonEventTriggeredAt=now;
    const shell=demonShellBrick;
    const cx=shell? shell.x + shell.w/2 : 1100/2;
    const cy=shell? shell.y + shell.h/2 : layout().top;
    demonEventMarquee={
      text:'跪伏於我的力量之下吧!',
      start:now,
      fadeStart:now+5000,
      end:now+8000,
      style:'elegant'
    };
    demonEventWave={x:cx, y:cy, start:now, duration:2000, maxRadius:Math.hypot(1100,700)};
    demonEventShakeUntil = now + 7000;
    prepareDemonRows();
    demonEventNextRowAt=now;
    if(demonEventTargets===0){
      explodeDemonShell(now);
      return;
    }
    screenShake=Math.max(screenShake,26);
  }

  function explodeDemonShell(now){
    if(!demonShellBrick) return;
    const shell=demonShellBrick;
    const idx=bricks.indexOf(shell);
    if(idx>=0) bricks.splice(idx,1);
    const cx=shell.x + shell.w/2;
    const cy=shell.y + shell.h/2;
    spawnParticles(cx,cy,'#fff5d6',120,3.2,5.0,5.5);
    spawnParticles(cx,cy,'#8a6bff',90,2.6,4.2,4.6);
    spawnParticles(cx,cy,'#d476ff',70,2.3,3.8,4.2);
    demonEventWave={x:cx,y:cy,start:now,duration:2600,maxRadius:Math.hypot(1100,700)};
    demonCore={x:cx,y:cy,start:now,visibleUntil:now+4000};
    screenShake=Math.max(screenShake,22);
    demonShellBrick=null;
    demonEventPhase='revealed';
    demonPhase='intro';
    demonRevealScheduled=now+1400;
    demonAfterimages=[];
    demonTeleportTrails=[];
  }

  function updateDemonEvent(now){
    if(level!==20){
      return;
    }
    if(demonEventPhase==='awaiting'){
      if(running && !paused && !resumePending){
        if(!demonEventTimerStart){
          demonEventTimerStart=now;
        }else if(now - demonEventTimerStart >= 10000){
          startDemonEvent(now);
        }
      }
    }else if(demonEventPhase==='collapse'){
      if(demonEventRows.length && now>=demonEventNextRowAt){
        const row=demonEventRows.shift();
        dropDemonRow(row, now);
        demonEventNextRowAt = now + 1000;
      }
      if(demonEventTargets>0 && demonEventCleared>=demonEventTargets){
        explodeDemonShell(now);
      }
    }else if(demonEventPhase==='revealed'){
      if(demonCore && now>=demonCore.visibleUntil){
        demonCore=null;
        demonEventPhase='complete';
      }
    }

    if(demonEventMarquee && now>=demonEventMarquee.end){
      demonEventMarquee=null;
    }
    if(demonEventWave && now>=demonEventWave.start + demonEventWave.duration){
      demonEventWave=null;
    }
    if(demonEventShakeUntil && now<demonEventShakeUntil){
      screenShake=Math.max(screenShake,18);
    }
  }

  function drawDemonMarquee(now){
    if(level!==20 || !demonEventMarquee) return;
    const evt=demonEventMarquee;
    if(now<evt.start) return;
    if(now>=evt.end){
      demonEventMarquee=null;
      return;
    }
    let alpha=1;
    if(evt.fadeStart && now>evt.fadeStart){
      const span=Math.max(1, evt.end - evt.fadeStart);
      alpha=Math.max(0, 1 - (now - evt.fadeStart)/span);
    }
    if(alpha<=0) return;
    const L=layout();
    const areaHeight=60;
    const top=Math.max(16, L.top - areaHeight - 14);
    const width=Math.min(560, 1100-120);
    const x=(1100-width)/2;
    const radius=20;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, top, width, areaHeight, radius);
    const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
    grad.addColorStop(0,'rgba(48,22,10,0.9)');
    grad.addColorStop(1,'rgba(28,12,6,0.88)');
    ctx.fillStyle=grad;
    ctx.fill();
    ctx.strokeStyle='rgba(255,210,150,0.85)';
    ctx.lineWidth=2.4;
    drawRoundedRect(x, top, width, areaHeight, radius);
    ctx.stroke();
    const innerX=x+10;
    const innerY=top+6;
    const innerW=width-20;
    const innerH=areaHeight-12;
    ctx.save();
    drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
    const innerGrad=ctx.createLinearGradient(innerX*scaleX, innerY*scaleY, innerX*scaleX, (innerY+innerH)*scaleY);
    innerGrad.addColorStop(0,'rgba(140,70,30,0.45)');
    innerGrad.addColorStop(1,'rgba(80,34,14,0.35)');
    ctx.fillStyle=innerGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(255,220,180,0.45)';
    ctx.lineWidth=1.4;
    ctx.stroke();
    ctx.restore();
    ctx.save();
    drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
    ctx.clip();
    ctx.fillStyle='#ffeedd';
    const fontSize=Math.max(20, Math.round(26*((scaleX+scaleY)/2)));
    ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.shadowColor='rgba(255,150,110,0.55)';
    ctx.shadowBlur=14*((scaleX+scaleY)/2);
    ctx.fillText(evt.text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
    if(evt.countdown){
      const remain=Math.max(0, evt.countdown.end - now);
      if(remain>0 && !evt.countdown.inline){
        const value=Math.max(1, Math.ceil(remain/1000));
        const cdFont=Math.max(26, Math.round(32*((scaleX+scaleY)/2)));
        ctx.font=`${cdFont}px 'Playfair Display','Noto Sans TC',serif`;
        ctx.textAlign='right';
        ctx.fillText(String(value), (innerX+innerW-18)*scaleX, (innerY+innerH/2)*scaleY);
      }
    }
    ctx.restore();
  }

  function drawDemonInlineCountdown(now){
    if(level!==20) return;
    const evt=demonEventMarquee;
    if(!evt || !evt.countdown || !evt.countdown.inline) return;
    if(now<evt.start) return;
    if(now>=evt.countdown.end) return;
    const remain=Math.max(0, evt.countdown.end-now);
    if(remain<=0) return;
    const value=Math.max(1, Math.ceil(remain/1000));
    const L=layout();
    const scaleAvg=(scaleX+scaleY)/2;
    const fontSize=Math.max(68, Math.round(88*scaleAvg));
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.shadowColor='rgba(150,0,20,0.45)';
    ctx.shadowBlur=30*scaleAvg;
    ctx.fillStyle='rgba(255,60,60,0.92)';
    const x=550*scaleX;
    const y=(L.top+40)*scaleY;
    ctx.fillText(String(value), x, y);
    ctx.strokeStyle='rgba(255,200,200,0.35)';
    ctx.lineWidth=4*scaleAvg;
    ctx.strokeText(String(value), x, y);
    ctx.restore();
  }


  function renderDemonFigure(entity, now, opts={}){
    if(!entity) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const baseSize=entity.h||entity.w||150;
    const size=baseSize/150;
    let alpha = opts.alpha!=null ? opts.alpha : 1;
    if(entity.deathFade!=null) alpha*=entity.deathFade;
    if(alpha<=0) return;
    ctx.save();
    ctx.translate(entity.x*scaleX, entity.y*scaleY);
    if(opts.shake){
      ctx.translate((Math.random()-0.5)*opts.shake*scaleX*0.6, (Math.random()-0.5)*opts.shake*scaleY*0.6);
    }
    ctx.scale(scaleAvg*size, scaleAvg*size);
    const ghostMul = opts.ghost ? 0.65 : 1;
    ctx.globalAlpha *= Math.max(0, Math.min(1, alpha*ghostMul));

    if(entity.attackAura==='blackRitual'){
      const phase=(now/220);
      for(let i=0;i<3;i++){
        const radius=1.6 + i*0.35 + Math.sin(phase+i*0.9)*0.08;
        ctx.save();
        ctx.rotate((i*0.8) + phase*0.5);
        ctx.scale(radius, radius*0.8);
        ctx.strokeStyle=`rgba(40,10,60,${0.35+0.15*i})`;
        ctx.lineWidth=0.08;
        ctx.beginPath();
        ctx.ellipse(0,-1.4,1,1.25,0,0,Math.PI*2);
        ctx.stroke();
        ctx.strokeStyle=`rgba(120,40,120,${0.2+0.15*i})`;
        ctx.lineWidth=0.04;
        ctx.beginPath();
        ctx.ellipse(0,-1.4,1.02,1.27,0,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }else if(entity.attackAura==='bladeHell'){
      const phase=now/280;
      for(let i=0;i<3;i++){
        const radius=1.2 + i*0.22 + Math.sin(phase+i*1.3)*0.08;
        ctx.save();
        ctx.rotate(phase + i*2.1);
        ctx.scale(radius, radius*0.6);
        ctx.strokeStyle=`rgba(200,120,255,${0.18+0.12*i})`;
        ctx.lineWidth=0.06;
        ctx.beginPath();
        ctx.ellipse(0,-1.2,1,1.08,0,0,Math.PI*2);
        ctx.stroke();
        ctx.strokeStyle=`rgba(120,40,200,${0.12+0.1*i})`;
        ctx.lineWidth=0.04;
        ctx.beginPath();
        ctx.ellipse(0,-1.2,1.12,1.2,0,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }

    const hitFlash = entity.hitFlashUntil && now<entity.hitFlashUntil;
    const teleportFlash = entity.teleportFlashUntil && now<entity.teleportFlashUntil;
    const flash = !!(hitFlash || teleportFlash);
    const hoverPhase = entity.hoverPhase||0;
    const whipActive = entity.cloakWhipUntil && now<entity.cloakWhipUntil;
    let whipStrength=0;
    let whipDir=entity.cloakWhipDir||1;
    if(whipActive){
      const duration=Math.max(1, (entity.cloakWhipDuration||360));
      const start=entity.cloakWhipStart|| (entity.cloakWhipUntil-duration);
      const total=Math.max(1, entity.cloakWhipUntil-start);
      const phase=Math.max(0, Math.min(1, 1-((entity.cloakWhipUntil-now)/total)));
      whipStrength=(entity.cloakWhipStrength||1)*Math.sin(phase*Math.PI);
    }

    const gripStrengthRaw = entity.cloakGripStrength!=null ? entity.cloakGripStrength : 0;
    const gripStrength = Math.max(0, Math.min(1, gripStrengthRaw));
    const gripSide = entity.cloakGripSide||0;
    const leftGrip = gripSide<0 ? gripStrength : 0;
    const rightGrip = gripSide>0 ? gripStrength : 0;

    const palette={
      metalDark: flash ? 'rgba(238,234,242,0.96)' : 'rgba(24,26,34,0.96)',
      metalMid: flash ? 'rgba(255,250,252,0.92)' : 'rgba(46,48,62,0.92)',
      metalEdge: flash ? 'rgba(255,255,255,0.86)' : 'rgba(134,138,166,0.75)',
      accent: flash ? 'rgba(255,200,160,0.95)' : 'rgba(210,70,40,0.92)',
      glowCore: flash ? 'rgba(255,220,210,0.85)' : 'rgba(255,90,50,0.8)',
      glowOuter: flash ? 'rgba(255,220,220,0.45)' : 'rgba(160,20,30,0.38)',
      horn: flash ? 'rgba(220,210,240,0.92)' : 'rgba(44,42,62,0.92)',
      visor: flash ? 'rgba(255,248,246,0.9)' : 'rgba(18,18,24,0.88)',
      eye: flash ? 'rgba(255,150,110,0.95)' : 'rgba(255,50,40,0.95)'
    };
    const bodyStretch=1.3;

    // ground shadow
    ctx.save();
    ctx.globalAlpha*=0.32;
    ctx.fillStyle='rgba(0,0,0,0.6)';
    ctx.scale(1,0.34);
    ctx.beginPath();
    ctx.ellipse(0,240,72,30,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // aura glow
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const auraPulse = 0.55 + 0.25*Math.sin(now/240 + hoverPhase*0.7);
    ctx.globalAlpha*=0.55 + auraPulse*0.25;
    const aura=ctx.createRadialGradient(0,20,18,0,20,190);
    aura.addColorStop(0,palette.glowCore);
    aura.addColorStop(0.45,palette.glowOuter);
    aura.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=aura;
    ctx.beginPath();
    ctx.ellipse(0,30,120,140,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // tattered cloak with long flowing hem (only below the pauldrons)
    ctx.save();
    ctx.translate(0,-12);
    const cloakPhase=entity.cloakPhase||0;
    const baseCloakSway = entity.cloakSway!=null ? entity.cloakSway : 0.18;
    const cloakSwayStrength = baseCloakSway + (whipStrength?0.35*whipStrength:0);
    const hoverLift = Math.sin(hoverPhase*0.7)*4;
    const whipSwing=whipStrength?whipDir*(32+60*cloakSwayStrength)*whipStrength:0;
    const anchorLift = Math.sin(cloakPhase*0.5 + hoverPhase*0.45)*6*cloakSwayStrength + whipStrength*10;
    const swayLeft = Math.sin(cloakPhase - whipStrength*0.4)* (16 + 34*cloakSwayStrength) - whipSwing;
    const swayRight = Math.sin(cloakPhase + Math.PI*0.65 + whipStrength*0.4)* (18 + 36*cloakSwayStrength) + whipSwing;
    const foldBlend = leftGrip + rightGrip;
    const ragAmplitudeBase = 26 + 48*cloakSwayStrength + (whipStrength?38*whipStrength:0);
    const ragAmplitude = Math.max(12, ragAmplitudeBase - foldBlend*18);
    const hemBase = 288 + hoverLift*0.25 - foldBlend*6;
    const hemDrift = (t)=>Math.sin(cloakPhase + t*Math.PI*1.9 + hoverPhase*0.5)*ragAmplitude;
    const ragJut = (i)=> (i%2===0 ? -ragAmplitude*0.85 : ragAmplitude*0.3);
    const leftFoldIn = leftGrip*74;
    const rightFoldIn = rightGrip*74;
    const leftFoldLift = leftGrip*64;
    const rightFoldLift = rightGrip*64;
    const leftHemLift = leftGrip*110;
    const rightHemLift = rightGrip*110;
    const cloak=ctx.createLinearGradient(0,-40,0,320);
    cloak.addColorStop(0, flash ? 'rgba(255,220,220,0.5)' : 'rgba(96,8,18,0.96)');
    cloak.addColorStop(0.38, flash ? 'rgba(255,200,200,0.42)' : 'rgba(140,0,18,0.94)');
    cloak.addColorStop(1, flash ? 'rgba(255,188,188,0.34)' : 'rgba(56,0,8,0.88)');
    ctx.beginPath();
    const leftTopX = -118 + leftFoldIn*0.45;
    const rightTopX = 118 - rightFoldIn*0.45;
    const leftTopY = 36 + anchorLift + hoverLift*0.3 - leftFoldLift*0.35;
    const rightTopY = 36 + anchorLift + hoverLift*0.3 - rightFoldLift*0.35;
    ctx.moveTo(leftTopX, leftTopY);
    ctx.bezierCurveTo(-198 + leftFoldIn*0.9, 96 - swayLeft*0.4 - leftFoldLift*0.5, -218 + leftFoldIn*1.25, 212 + hoverLift*0.25 - leftHemLift*0.4, -202 + leftFoldIn*1.18, hemBase - ragAmplitude*0.45 - leftHemLift*0.55);
    const segments=12;
    const leftEdge = -202 + leftFoldIn*0.9;
    const rightEdge = 202 - rightFoldIn*0.9;
    const span = rightEdge - leftEdge;
    for(let i=0;i<=segments;i++){
      const t=i/segments;
      const baseX=leftEdge + span*t;
      const x=baseX + Math.sin(cloakPhase*0.8 + t*Math.PI*2.1)*18*cloakSwayStrength;
      const wave=hemDrift(t);
      const jag = (i===0||i===segments) ? -ragAmplitude*0.4 : ragJut(i);
      const liftBias = -leftHemLift*(1-t) - rightHemLift*t;
      ctx.lineTo(x, hemBase + wave + jag + liftBias);
    }
    ctx.bezierCurveTo(218 - rightFoldIn*1.25, 212 + hoverLift*0.25 - rightHemLift*0.4, 198 - rightFoldIn*0.9, 96 - swayRight*0.4 - rightFoldLift*0.5, rightTopX, rightTopY);
    ctx.quadraticCurveTo(56 - rightFoldIn*0.22, 18 + swayRight*0.12 - rightFoldLift*0.3, 42 - rightFoldIn*0.18, 74 + anchorLift*0.15 - rightFoldLift*0.22);
    const centerOffset = (rightFoldIn - leftFoldIn)*0.08;
    ctx.quadraticCurveTo(centerOffset, 24 - (leftFoldLift-rightFoldLift)*0.22, -42 + leftFoldIn*0.18, 74 + anchorLift*0.15 - leftFoldLift*0.22);
    ctx.quadraticCurveTo(-56 + leftFoldIn*0.22, 18 + swayLeft*0.12 - leftFoldLift*0.3, leftTopX, leftTopY);
    ctx.closePath();
    ctx.fillStyle=cloak;
    ctx.fill();
    ctx.strokeStyle=flash ? 'rgba(255,226,220,0.56)' : 'rgba(54,0,8,0.7)';
    ctx.lineWidth=3.6;
    ctx.stroke();

    if(leftGrip>0){
      ctx.save();
      ctx.globalAlpha=0.32*leftGrip;
      const foldShade=ctx.createLinearGradient(-140 + leftFoldIn*0.4, 40, -20 + leftFoldIn*0.2, 260);
      foldShade.addColorStop(0,'rgba(40,0,8,0.85)');
      foldShade.addColorStop(1,'rgba(150,40,70,0.6)');
      ctx.fillStyle=foldShade;
      ctx.beginPath();
      ctx.moveTo(-90 + leftFoldIn*0.35, 54 + anchorLift*0.15 - leftFoldLift*0.4);
      ctx.quadraticCurveTo(-160 + leftFoldIn*0.9, 142 - leftHemLift*0.45, -78 + leftFoldIn*0.5, 226 - leftHemLift*0.9);
      ctx.quadraticCurveTo(-40 + leftFoldIn*0.3, 164 - leftHemLift*0.6, -52 + leftFoldIn*0.22, 98 - leftFoldLift*0.4);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    if(rightGrip>0){
      ctx.save();
      ctx.globalAlpha=0.32*rightGrip;
      const foldShade=ctx.createLinearGradient(140 - rightFoldIn*0.4, 40, 20 - rightFoldIn*0.2, 260);
      foldShade.addColorStop(0,'rgba(40,0,8,0.85)');
      foldShade.addColorStop(1,'rgba(150,40,70,0.6)');
      ctx.fillStyle=foldShade;
      ctx.beginPath();
      ctx.moveTo(90 - rightFoldIn*0.35, 54 + anchorLift*0.15 - rightFoldLift*0.4);
      ctx.quadraticCurveTo(160 - rightFoldIn*0.9, 142 - rightHemLift*0.45, 78 - rightFoldIn*0.5, 226 - rightHemLift*0.9);
      ctx.quadraticCurveTo(40 - rightFoldIn*0.3, 164 - rightHemLift*0.6, 52 - rightFoldIn*0.22, 98 - rightFoldLift*0.4);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    const leftDetailTop = 18 + anchorLift*0.3 + hoverLift*0.2 - leftFoldLift*0.35;
    const rightDetailTop = 18 + anchorLift*0.3 + hoverLift*0.2 - rightFoldLift*0.35;
    const leftDetailBottom = hemBase-18 + swayLeft*0.05 - leftHemLift*0.65;
    const rightDetailBottom = hemBase-18 + swayRight*0.05 - rightHemLift*0.65;
    const centerTop = 12 + anchorLift*0.2 + hoverLift*0.2 - (leftFoldLift-rightFoldLift)*0.25;
    const centerBottom = hemBase-12 + (swayLeft+swayRight)*0.04 - (leftHemLift+rightHemLift)*0.45;

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=flash ? 'rgba(255,230,224,0.62)' : 'rgba(200,40,40,0.44)';
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(-56 + leftFoldIn*0.35, leftDetailTop);
    ctx.quadraticCurveTo(-42 + leftFoldIn*0.18, 138 + swayLeft*0.08 - leftHemLift*0.5,-32 + leftFoldIn*0.22,leftDetailBottom);
    ctx.moveTo(56 - rightFoldIn*0.35, rightDetailTop);
    ctx.quadraticCurveTo(42 - rightFoldIn*0.18, 138 + swayRight*0.08 - rightHemLift*0.5,32 - rightFoldIn*0.22,rightDetailBottom);
    ctx.stroke();
    ctx.beginPath();
    const centerLineOffset = (rightFoldIn - leftFoldIn)*0.12;
    ctx.moveTo(centerLineOffset, centerTop);
    ctx.quadraticCurveTo(centerLineOffset-4, 144 + (swayLeft+swayRight)*0.04 - (leftHemLift-rightHemLift)*0.4, centerLineOffset, centerBottom);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // lower tabard, battle skirt and waist armour
    ctx.save();
    ctx.translate(0,62);
    ctx.scale(1, bodyStretch);
    const tabard=ctx.createLinearGradient(0,-44,0,156);
    tabard.addColorStop(0, flash ? 'rgba(255,232,232,0.84)' : 'rgba(80,20,32,0.9)');
    tabard.addColorStop(0.5, flash ? 'rgba(255,214,214,0.76)' : 'rgba(46,12,20,0.82)');
    tabard.addColorStop(1, flash ? 'rgba(255,206,206,0.68)' : 'rgba(26,6,12,0.7)');
    ctx.fillStyle=tabard;
    ctx.beginPath();
    ctx.moveTo(-36,-10);
    ctx.quadraticCurveTo(-10,-92,0,-98);
    ctx.quadraticCurveTo(10,-92,36,-10);
    ctx.quadraticCurveTo(22,188,0,208);
    ctx.quadraticCurveTo(-22,188,-36,-10);
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth=2.4;
    ctx.strokeStyle=palette.metalEdge;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(0,-44);
    ctx.lineTo(0,182);
    ctx.stroke();
    ctx.restore();

    const innerPlates=ctx.createLinearGradient(0,-20,0,146);
    innerPlates.addColorStop(0, flash ? 'rgba(255,226,226,0.72)' : 'rgba(96,30,44,0.86)');
    innerPlates.addColorStop(1, flash ? 'rgba(255,210,210,0.62)' : 'rgba(52,14,24,0.78)');
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(12,-24);
      ctx.quadraticCurveTo(54,-80,62,-14);
      ctx.quadraticCurveTo(48,122,16,188);
      ctx.lineTo(-4,122);
      ctx.closePath();
      ctx.fillStyle=innerPlates;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2;
      ctx.stroke();
      ctx.restore();
    }

    const skirtPanel=ctx.createLinearGradient(-110,-20,-10,160);
    skirtPanel.addColorStop(0, flash ? 'rgba(255,224,224,0.82)' : 'rgba(66,16,24,0.86)');
    skirtPanel.addColorStop(1, flash ? 'rgba(255,204,204,0.62)' : 'rgba(28,8,14,0.72)');
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(30,-6);
      ctx.quadraticCurveTo(102,-84,118,12);
      ctx.quadraticCurveTo(110,188,38,214);
      ctx.quadraticCurveTo(22,112,30,-6);
      ctx.closePath();
      ctx.fillStyle=skirtPanel;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.2;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=1.8;
      ctx.beginPath();
      ctx.moveTo(52,18);
      ctx.quadraticCurveTo(84,112,46,198);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    const waist=ctx.createLinearGradient(-70,-48,70,66);
    waist.addColorStop(0,palette.metalMid);
    waist.addColorStop(1,palette.metalDark);
    ctx.fillStyle=waist;
    ctx.beginPath();
    ctx.moveTo(-88,-22);
    ctx.quadraticCurveTo(0,-86,88,-22);
    ctx.lineTo(68,68);
    ctx.quadraticCurveTo(0,98,-68,68);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(-52,-8);
    ctx.quadraticCurveTo(0,-44,52,-8);
    ctx.moveTo(-48,38);
    ctx.quadraticCurveTo(0,70,48,38);
    ctx.stroke();
    ctx.restore();

    const waistPlates=ctx.createLinearGradient(-50,-18,50,80);
    waistPlates.addColorStop(0,palette.metalDark);
    waistPlates.addColorStop(1,palette.metalMid);
    ctx.fillStyle=waistPlates;
    ctx.beginPath();
    ctx.moveTo(-58,-10);
    ctx.quadraticCurveTo(-18,-58,-6,-32);
    ctx.lineTo(-10,62);
    ctx.quadraticCurveTo(-36,70,-52,36);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=1.8;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(58,-10);
    ctx.quadraticCurveTo(18,-58,6,-32);
    ctx.lineTo(10,62);
    ctx.quadraticCurveTo(36,70,52,36);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    const layeredSkirt=ctx.createLinearGradient(-20,-12,-20,200);
    layeredSkirt.addColorStop(0, flash ? 'rgba(255,230,220,0.82)' : 'rgba(70,18,26,0.92)');
    layeredSkirt.addColorStop(1, flash ? 'rgba(255,206,198,0.7)' : 'rgba(32,8,12,0.78)');
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(34,0);
      ctx.quadraticCurveTo(92,-48,122,30);
      ctx.quadraticCurveTo(112,196,40,216);
      ctx.quadraticCurveTo(24,128,34,0);
      ctx.closePath();
      ctx.fillStyle=layeredSkirt;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=1.6;
      ctx.beginPath();
      ctx.moveTo(52,28);
      ctx.quadraticCurveTo(86,132,44,204);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    const frontSkirt=ctx.createLinearGradient(0,-18,0,210);
    frontSkirt.addColorStop(0, flash ? 'rgba(255,224,214,0.84)' : 'rgba(78,18,26,0.92)');
    frontSkirt.addColorStop(1, flash ? 'rgba(255,200,188,0.68)' : 'rgba(34,10,14,0.78)');
    ctx.beginPath();
    ctx.moveTo(-42,12);
    ctx.quadraticCurveTo(-12,-68,0,-82);
    ctx.quadraticCurveTo(12,-68,42,12);
    ctx.quadraticCurveTo(26,188,0,214);
    ctx.quadraticCurveTo(-26,188,-42,12);
    ctx.closePath();
    ctx.fillStyle=frontSkirt;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.2;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(0,-26);
    ctx.lineTo(0,198);
    ctx.moveTo(-18,64);
    ctx.lineTo(18,64);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // legs, greaves and sabatons
    ctx.save();
    ctx.translate(0,102);
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      const thigh=ctx.createLinearGradient(12,-70,78,160);
      thigh.addColorStop(0,palette.metalMid);
      thigh.addColorStop(1,palette.metalDark);
      ctx.beginPath();
      ctx.moveTo(20,-52);
      ctx.quadraticCurveTo(58,-28,54,38);
      ctx.quadraticCurveTo(46,112,18,142);
      ctx.quadraticCurveTo(6,52,10,-12);
      ctx.closePath();
      ctx.fillStyle=thigh;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.6;
      ctx.stroke();

      const shin=ctx.createLinearGradient(14,-10,74,210);
      shin.addColorStop(0,palette.metalMid);
      shin.addColorStop(1,'rgba(26,26,40,0.92)');
      ctx.beginPath();
      ctx.moveTo(18,18);
      ctx.quadraticCurveTo(60,72,56,156);
      ctx.quadraticCurveTo(42,214,12,204);
      ctx.quadraticCurveTo(0,148,10,36);
      ctx.closePath();
      ctx.fillStyle=shin;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      const sabaton=ctx.createLinearGradient(12,120,76,220);
      sabaton.addColorStop(0,'rgba(34,34,48,0.95)');
      sabaton.addColorStop(1,'rgba(8,8,14,0.92)');
      ctx.beginPath();
      ctx.moveTo(18,154);
      ctx.quadraticCurveTo(66,182,68,210);
      ctx.quadraticCurveTo(46,226,12,214);
      ctx.quadraticCurveTo(0,188,6,164);
      ctx.closePath();
      ctx.fillStyle=sabaton;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(34,-20);
      ctx.quadraticCurveTo(48,72,28,152);
      ctx.moveTo(28,96);
      ctx.quadraticCurveTo(40,138,26,186);
      ctx.stroke();
      ctx.restore();

      ctx.beginPath();
      ctx.moveTo(14,174);
      ctx.quadraticCurveTo(40,188,16,208);
      ctx.strokeStyle=flash ? 'rgba(255,204,170,0.75)' : 'rgba(86,24,20,0.68)';
      ctx.lineWidth=1.6;
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();

    // torso armour layers
    ctx.save();
    ctx.translate(0,-16);
    const chest=ctx.createLinearGradient(-74,-162,74,148);
    chest.addColorStop(0,palette.metalMid);
    chest.addColorStop(1,palette.metalDark);
    ctx.fillStyle=chest;
    ctx.beginPath();
    ctx.moveTo(-64,-68);
    ctx.quadraticCurveTo(0,-136,64,-68);
    ctx.lineTo(82,48);
    ctx.quadraticCurveTo(0,96,-82,48);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const breastplate=ctx.createLinearGradient(-56,-118,56,80);
    breastplate.addColorStop(0,palette.metalDark);
    breastplate.addColorStop(1,palette.metalMid);
    ctx.fillStyle=breastplate;
    ctx.beginPath();
    ctx.moveTo(-48,-46);
    ctx.quadraticCurveTo(-12,-106,0,-112);
    ctx.quadraticCurveTo(12,-106,48,-46);
    ctx.lineTo(40,54);
    ctx.quadraticCurveTo(0,84,-40,54);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.8;
    ctx.stroke();

    const chestCrest=ctx.createLinearGradient(-40,-80,40,32);
    chestCrest.addColorStop(0,palette.metalMid);
    chestCrest.addColorStop(1,palette.metalDark);
    ctx.fillStyle=chestCrest;
    ctx.beginPath();
    ctx.moveTo(-34,-26);
    ctx.quadraticCurveTo(0,-68,34,-26);
    ctx.quadraticCurveTo(18,40,0,64);
    ctx.quadraticCurveTo(-18,40,-34,-26);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const abdomen=ctx.createLinearGradient(-32,-26,32,104);
    abdomen.addColorStop(0,palette.metalMid);
    abdomen.addColorStop(1,palette.metalDark);
    ctx.fillStyle=abdomen;
    ctx.beginPath();
    ctx.moveTo(-30,-6);
    ctx.lineTo(30,-6);
    ctx.quadraticCurveTo(20,84,0,106);
    ctx.quadraticCurveTo(-20,84,-30,-6);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const waistExtension=ctx.createLinearGradient(-38,18,38,160);
    waistExtension.addColorStop(0,palette.metalDark);
    waistExtension.addColorStop(1,palette.metalMid);
    ctx.fillStyle=waistExtension;
    ctx.beginPath();
    ctx.moveTo(-38,32);
    ctx.lineTo(38,32);
    ctx.quadraticCurveTo(26,138,0,158);
    ctx.quadraticCurveTo(-26,138,-38,32);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=2.4;
    ctx.beginPath();
    ctx.moveTo(0,-52);
    ctx.lineTo(0,138);
    ctx.moveTo(-18,34);
    ctx.lineTo(18,34);
    ctx.moveTo(-16,-4);
    ctx.lineTo(16,-4);
    ctx.moveTo(-16,96);
    ctx.lineTo(16,96);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // left arm assembly with shortened proportions
    ctx.save();
    ctx.translate(0,-18);
    const leftArmSwing=Math.sin(now/340 + hoverPhase*0.65);

    ctx.save();
    ctx.translate(-96,36);
    ctx.rotate(-0.12 + Math.sin(hoverPhase*0.6)*0.04);
    ctx.scale(0.9,0.6);
    const leftUpper=ctx.createLinearGradient(-34,-28,44,140);
    leftUpper.addColorStop(0,palette.metalMid);
    leftUpper.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-18,-26);
    ctx.quadraticCurveTo(-58,10,-44,96);
    ctx.quadraticCurveTo(-18,146,12,140);
    ctx.quadraticCurveTo(-4,68,-6,-20);
    ctx.closePath();
    ctx.fillStyle=leftUpper;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-26,-4);
    ctx.lineTo(-12,86);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.translate(-24,112);
    ctx.rotate(-0.18 + Math.sin(now/260 + hoverPhase)*0.06 + leftArmSwing*0.02);
    const leftFore=ctx.createLinearGradient(-32,-20,36,140);
    leftFore.addColorStop(0,palette.metalMid);
    leftFore.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-16,-14);
    ctx.quadraticCurveTo(-46,18,-32,78);
    ctx.quadraticCurveTo(0,114,22,98);
    ctx.quadraticCurveTo(6,20,-16,-14);
    ctx.closePath();
    ctx.fillStyle=leftFore;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(-10,14);
    ctx.lineTo(-6,74);
    ctx.stroke();
    ctx.restore();

    ctx.beginPath();
    ctx.moveTo(-22,78);
    ctx.quadraticCurveTo(-36,108,-10,120);
    ctx.quadraticCurveTo(6,104,-2,84);
    ctx.closePath();
    ctx.fillStyle=flash ? 'rgba(255,222,212,0.9)' : 'rgba(48,22,26,0.9)';
    ctx.fill();
    ctx.restore();
    ctx.restore();

    // left shoulder armour layers (rendered above the arm connection)
    ctx.save();
    ctx.translate(0,-18);
    const leftShoulderBase=ctx.createLinearGradient(-162,-72,-36,124);
    leftShoulderBase.addColorStop(0,palette.metalMid);
    leftShoulderBase.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-82,-18);
    ctx.quadraticCurveTo(-160,-108,-172,12);
    ctx.quadraticCurveTo(-148,112,-90,104);
    ctx.quadraticCurveTo(-70,30,-82,-18);
    ctx.closePath();
    ctx.fillStyle=leftShoulderBase;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const leftShoulderMid=ctx.createLinearGradient(-148,-36,-60,96);
    leftShoulderMid.addColorStop(0,palette.metalDark);
    leftShoulderMid.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(-78,-2);
    ctx.quadraticCurveTo(-128,-48,-134,20);
    ctx.quadraticCurveTo(-118,104,-84,94);
    ctx.closePath();
    ctx.fillStyle=leftShoulderMid;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const leftShoulderRidge=ctx.createLinearGradient(-120,-12,-70,60);
    leftShoulderRidge.addColorStop(0,palette.metalMid);
    leftShoulderRidge.addColorStop(1,palette.metalEdge);
    ctx.beginPath();
    ctx.moveTo(-86,18);
    ctx.quadraticCurveTo(-120,-18,-120,28);
    ctx.quadraticCurveTo(-110,88,-92,82);
    ctx.closePath();
    ctx.fillStyle=leftShoulderRidge;
    ctx.fill();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-110,8);
    ctx.quadraticCurveTo(-98,72,-88,86);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    // right arm assembly with shortened proportions
    ctx.save();
    ctx.translate(0,-18);
    const rightArmSwing=Math.sin(now/320 + hoverPhase*0.8);

    ctx.save();
    ctx.translate(96,36);
    ctx.rotate(0.14 + rightArmSwing*0.06);
    ctx.scale(0.9,0.6);
    const upper=ctx.createLinearGradient(-28,-26,42,140);
    upper.addColorStop(0,palette.metalMid);
    upper.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-14,-26);
    ctx.quadraticCurveTo(44,6,34,102);
    ctx.quadraticCurveTo(10,150,-18,144);
    ctx.quadraticCurveTo(-30,62,-18,-18);
    ctx.closePath();
    ctx.fillStyle=upper;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-2,-4);
    ctx.lineTo(10,86);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.translate(24,118);
    ctx.rotate(0.26 + rightArmSwing*0.1);
    const fore=ctx.createLinearGradient(-30,-18,38,150);
    fore.addColorStop(0,palette.metalMid);
    fore.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-12,-18);
    ctx.quadraticCurveTo(36,16,30,96);
    ctx.quadraticCurveTo(10,126,-16,120);
    ctx.quadraticCurveTo(-32,48,-12,-18);
    ctx.closePath();
    ctx.fillStyle=fore;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    const gauntlet=ctx.createLinearGradient(-18,32,28,120);
    gauntlet.addColorStop(0,palette.metalDark);
    gauntlet.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(-14,40);
    ctx.lineTo(22,40);
    ctx.quadraticCurveTo(26,76,2,96);
    ctx.quadraticCurveTo(-20,78,-14,40);
    ctx.closePath();
    ctx.fillStyle=gauntlet;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.2;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(0,8);
    ctx.lineTo(12,70);
    ctx.stroke();
    ctx.restore();

    ctx.beginPath();
    ctx.moveTo(-4,86);
    ctx.quadraticCurveTo(18,124,30,104);
    ctx.quadraticCurveTo(16,78,6,74);
    ctx.closePath();
    ctx.fillStyle=flash ? 'rgba(255,226,212,0.88)' : 'rgba(54,24,30,0.88)';
    ctx.fill();
    ctx.restore();
    ctx.restore();

    // right shoulder armour layers (rendered above the arm connection)
    ctx.save();
    ctx.translate(0,-18);
    const rightShoulderBase=ctx.createLinearGradient(24,-60,180,120);
    rightShoulderBase.addColorStop(0,palette.metalMid);
    rightShoulderBase.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(68,-12);
    ctx.quadraticCurveTo(150,-94,168,12);
    ctx.quadraticCurveTo(140,116,86,104);
    ctx.quadraticCurveTo(66,36,68,-12);
    ctx.closePath();
    ctx.fillStyle=rightShoulderBase;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const rightShoulderMid=ctx.createLinearGradient(54,-32,156,88);
    rightShoulderMid.addColorStop(0,palette.metalDark);
    rightShoulderMid.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(74,2);
    ctx.quadraticCurveTo(128,-46,134,18);
    ctx.quadraticCurveTo(118,108,90,94);
    ctx.closePath();
    ctx.fillStyle=rightShoulderMid;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.6;
    ctx.stroke();

    const rightShoulderRidge=ctx.createLinearGradient(90,-6,128,66);
    rightShoulderRidge.addColorStop(0,palette.metalMid);
    rightShoulderRidge.addColorStop(1,palette.metalEdge);
    ctx.beginPath();
    ctx.moveTo(84,20);
    ctx.quadraticCurveTo(118,-16,116,30);
    ctx.quadraticCurveTo(110,86,94,82);
    ctx.closePath();
    ctx.fillStyle=rightShoulderRidge;
    ctx.fill();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=palette.accent;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(106,8);
    ctx.quadraticCurveTo(96,70,90,88);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    ctx.restore();
    ctx.restore();
    // chest core glow
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.translate(0,24);
    const core=ctx.createRadialGradient(0,0,4,0,0,30);
    core.addColorStop(0,palette.glowCore);
    core.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=core;
    ctx.beginPath();
    ctx.arc(0,0,24,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // mech helm with angular visor
    ctx.save();
    const headScale=0.7;
    ctx.translate(0,-74);
    ctx.scale(headScale, headScale);
    const helmBase=ctx.createLinearGradient(-48,-90,48,92);
    helmBase.addColorStop(0,palette.metalMid);
    helmBase.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-46,42);
    ctx.lineTo(-30,-12);
    ctx.quadraticCurveTo(-8,-96,0,-104);
    ctx.quadraticCurveTo(8,-96,30,-12);
    ctx.lineTo(46,42);
    ctx.quadraticCurveTo(0,92,-46,42);
    ctx.closePath();
    ctx.fillStyle=helmBase;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=3;
    ctx.stroke();

    const helmPlates=ctx.createLinearGradient(-36,-54,36,68);
    helmPlates.addColorStop(0,palette.metalDark);
    helmPlates.addColorStop(1,palette.metalMid);
    ctx.beginPath();
    ctx.moveTo(-34,28);
    ctx.lineTo(-18,-18);
    ctx.quadraticCurveTo(0,-64,18,-18);
    ctx.lineTo(34,28);
    ctx.quadraticCurveTo(0,70,-34,28);
    ctx.closePath();
    ctx.fillStyle=helmPlates;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=2.4;
    ctx.stroke();

    const facePlate=ctx.createLinearGradient(-26,-12,26,44);
    facePlate.addColorStop(0,'rgba(20,22,34,0.92)');
    facePlate.addColorStop(1,'rgba(10,12,20,0.9)');
    ctx.beginPath();
    ctx.moveTo(-32,14);
    ctx.lineTo(-14,-24);
    ctx.quadraticCurveTo(0,-44,14,-24);
    ctx.lineTo(32,14);
    ctx.quadraticCurveTo(0,48,-32,14);
    ctx.closePath();
    ctx.fillStyle=facePlate;
    ctx.fill();

    const maskRidge=ctx.createLinearGradient(-16,-32,16,28);
    maskRidge.addColorStop(0,palette.metalMid);
    maskRidge.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-18,-12);
    ctx.quadraticCurveTo(0,-28,18,-12);
    ctx.quadraticCurveTo(10,28,0,38);
    ctx.quadraticCurveTo(-10,28,-18,-12);
    ctx.closePath();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=1.8;
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=flash ? 'rgba(255,232,220,0.7)' : 'rgba(210,130,90,0.5)';
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(-16,-6);
    ctx.quadraticCurveTo(0,-22,16,-6);
    ctx.stroke();
    ctx.restore();

    const eyeScale=0.7;
    const eyeBase=28*eyeScale;
    const eyeLength=66*eyeScale;
    const eyeTilt=Math.PI/4;
    ctx.fillStyle=palette.eye;
    ctx.save();
    ctx.translate(-30,-18);
    ctx.rotate(-eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-eyeBase/2,0);
    ctx.lineTo(eyeBase/2,0);
    ctx.lineTo(0,eyeLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.translate(30,-18);
    ctx.rotate(eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-eyeBase/2,0);
    ctx.lineTo(eyeBase/2,0);
    ctx.lineTo(0,eyeLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const eyeGlow=flash ? 'rgba(255,220,210,0.6)' : 'rgba(255,70,40,0.55)';
    ctx.fillStyle=eyeGlow;
    const glowBase=eyeBase*0.6;
    const glowLength=eyeLength*0.6;
    ctx.save();
    ctx.translate(-32,-22);
    ctx.rotate(-eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-glowBase/2,0);
    ctx.lineTo(glowBase/2,0);
    ctx.lineTo(0,glowLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.translate(32,-22);
    ctx.rotate(eyeTilt);
    ctx.beginPath();
    ctx.moveTo(-glowBase/2,0);
    ctx.lineTo(glowBase/2,0);
    ctx.lineTo(0,glowLength);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=flash ? 'rgba(255,236,226,0.8)' : 'rgba(255,80,60,0.75)';
    ctx.beginPath();
    ctx.moveTo(-4,-42);
    ctx.lineTo(0,-50);
    ctx.lineTo(4,-42);
    ctx.lineTo(4,30);
    ctx.quadraticCurveTo(0,40,-4,30);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    const crest=ctx.createLinearGradient(-12,-72,12,-12);
    crest.addColorStop(0,palette.metalEdge);
    crest.addColorStop(1,palette.metalDark);
    ctx.beginPath();
    ctx.moveTo(-12,-58);
    ctx.lineTo(0,-86);
    ctx.lineTo(12,-58);
    ctx.quadraticCurveTo(0,-40,-12,-58);
    ctx.closePath();
    ctx.fillStyle=crest;
    ctx.fill();
    ctx.strokeStyle=palette.metalEdge;
    ctx.lineWidth=1.6;
    ctx.stroke();

    const antenna=ctx.createLinearGradient(0,-120,0,-20);
    antenna.addColorStop(0,palette.metalDark);
    antenna.addColorStop(1,palette.metalMid);
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.beginPath();
      ctx.moveTo(14,-18);
      ctx.lineTo(92,-112);
      ctx.lineTo(54,-12);
      ctx.closePath();
      ctx.fillStyle=antenna;
      ctx.fill();
      ctx.strokeStyle=palette.metalEdge;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=palette.accent;
      ctx.lineWidth=1.4;
      ctx.beginPath();
      ctx.moveTo(44,-42);
      ctx.lineTo(70,-94);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }
    ctx.restore();
    ctx.restore();

    ctx.restore();

    ctx.restore();

    ctx.restore();
  }


  function renderDemonAfterimageFigure(state, now, alpha){
    if(!state) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const baseSize=state.h||state.w||150;
    const size=baseSize/150;
    const t0=state.t0||now;
    const elapsed=Math.max(0, now-t0);
    const hoverPhase=state.hoverPhase||0;
    ctx.save();
    ctx.translate(state.x*scaleX, state.y*scaleY);
    ctx.scale(scaleAvg*size, scaleAvg*size);
    ctx.globalAlpha *= alpha;

    const auraPulse = 0.55 + 0.35*Math.sin(elapsed/220 + hoverPhase*0.6);
    ctx.fillStyle = `rgba(190,140,255,${0.22*auraPulse})`;
    ctx.beginPath();
    ctx.ellipse(0,34,92,164,0,0,Math.PI*2);
    ctx.fill();

    const cloakPhase=state.cloakPhase||0;
    const cloakSwayStrength=state.cloakSway!=null?state.cloakSway:0.2;
    const ragAmplitude=10 + 28*cloakSwayStrength;
    const hoverLift=Math.sin(hoverPhase*0.7 + elapsed*0.0012)*3;

    // spectral cloak trail
    ctx.fillStyle=`rgba(220,60,90,${0.14 + 0.06*Math.sin(elapsed/240)})`;
    ctx.strokeStyle=`rgba(255,120,160,${0.12 + 0.04*Math.sin(elapsed/200)})`;
    ctx.lineWidth=2.2;
    ctx.beginPath();
    ctx.moveTo(-112,-52 + hoverLift*0.4);
    ctx.bezierCurveTo(-174,-6, -182,110 + hoverLift*0.2, -156,212 + hoverLift);
    const hemBase=230 + hoverLift*0.12;
    ctx.lineTo(-156, hemBase + Math.sin(cloakPhase + hoverPhase*0.45)*ragAmplitude - ragAmplitude*0.55);
    for(let i=1;i<8;i++){
      const t=i/8;
      const x=-156 + 312*t;
      const wave=Math.sin(cloakPhase + t*Math.PI*1.6 + hoverPhase*0.45)*ragAmplitude;
      const jag=(i%2===0?-ragAmplitude*0.55:ragAmplitude*0.28);
      ctx.lineTo(x, hemBase + wave + jag);
    }
    ctx.lineTo(156, hemBase + Math.sin(cloakPhase + Math.PI*1.6 + hoverPhase*0.45)*ragAmplitude - ragAmplitude*0.55);
    ctx.bezierCurveTo(182,110 + hoverLift*0.2, 174,-6, 112,-52 + hoverLift*0.4);
    ctx.quadraticCurveTo(36,-126,0,-134);
    ctx.quadraticCurveTo(-36,-126,-112,-52 + hoverLift*0.4);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle=`rgba(255,160,200,${0.1 + 0.04*Math.sin(elapsed/180)})`;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    ctx.moveTo(-46,-60 + hoverLift*0.3);
    ctx.quadraticCurveTo(-32,36, -18,208 + hoverLift*0.1);
    ctx.moveTo(46,-60 + hoverLift*0.3);
    ctx.quadraticCurveTo(32,36, 18,208 + hoverLift*0.1);
    ctx.moveTo(0,-120 + hoverLift*0.3);
    ctx.quadraticCurveTo(-6,18,0,216 + hoverLift*0.1);
    ctx.stroke();
    ctx.restore();

    // elongated armour silhouette
    ctx.fillStyle='rgba(220,170,255,0.26)';
    ctx.beginPath();
    ctx.moveTo(-30,-28);
    ctx.quadraticCurveTo(0,-118,30,-28);
    ctx.quadraticCurveTo(18,164,0,198);
    ctx.quadraticCurveTo(-18,164,-30,-28);
    ctx.closePath();
    ctx.fill();

    // battle skirt glow
    ctx.beginPath();
    ctx.moveTo(-50,10);
    ctx.quadraticCurveTo(-10,-94,50,10);
    ctx.quadraticCurveTo(28,226,0,262);
    ctx.quadraticCurveTo(-28,226,-50,10);
    ctx.closePath();
    ctx.fillStyle='rgba(210,150,255,0.22)';
    ctx.fill();

    const orbPulse = 1 + 0.18*Math.sin(elapsed/260 + hoverPhase*0.9);
    ctx.save();
    ctx.translate(22,84);
    ctx.scale(orbPulse, orbPulse);
    ctx.fillStyle='rgba(255,220,255,0.26)';
    ctx.beginPath();
    ctx.arc(0,0,26,0,Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(255,200,255,0.35)';
    ctx.lineWidth=3.4;
    ctx.beginPath();
    ctx.arc(0,0,20,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();
    ctx.restore();
  }

  function drawDemonAfterimages(now){
    if(!demonAfterimages.length) return;
    for(const ghost of demonAfterimages){
      const life=ghost.life||420;
      const age=now-ghost.t0;
      const alpha=Math.max(0, 1 - age/life);
      if(alpha<=0) continue;
      const ghostState={
        x:ghost.x,
        y:ghost.y + Math.sin((now-ghost.t0)/260)*4,
        w:ghost.w,
        h:ghost.h,
        hoverPhase:ghost.hoverPhase,
        cloakPhase:ghost.cloakPhase,
        cloakSway:ghost.cloakSway,
        t0:ghost.t0
      };
      const fadeAlpha = ghost.fade ? alpha*alpha : alpha;
      renderDemonAfterimageFigure(ghostState, now, fadeAlpha);
    }
  }

  function drawDemonTeleportTrails(now){
    if(!demonTeleportTrails.length) return;
    const scaleAvg=(scaleX+scaleY)/2;
    for(const fx of demonTeleportTrails){
      if(!fx) continue;
      const start=fx.start||now;
      const end=fx.end||start;
      const life=Math.max(1, end-start);
      const elapsed=now-start;
      const t=Math.max(0, Math.min(1, elapsed/life));
      if(t>=1) continue;
      const fadeBase=Math.max(0, 1-t);
      const fade=Math.pow(fadeBase, 0.92);
      const from=fx.from||{x:0,y:0};
      const to=fx.to||from;
      const angle=(fx.angle!=null)?fx.angle:Math.atan2((to.y||0)-(from.y||0),(to.x||0)-(from.x||0));
      const dist=(fx.dist!=null)?fx.dist:Math.hypot((to.x||0)-(from.x||0),(to.y||0)-(from.y||0));
      const nx=Math.sin(angle);
      const ny=-Math.cos(angle);
      const swirlSeed=fx.swirlSeed||0;
      const shimmerPhase=(now-start)/180;
      const steps=Math.max(6, Math.round(8 + dist/70));

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      for(let i=0;i<steps;i++){
        const segT=steps>1?(i/(steps-1)):0;
        const easeOut=Math.max(0, 1 - segT*0.18);
        const segFade=fade*Math.max(0, 1 - segT*0.14);
        if(segFade<=0) continue;
        const wave=Math.sin(swirlSeed + shimmerPhase + segT*7.2);
        const offsetMag=(24 + dist*0.05)*wave*segFade;
        const baseX=from.x + (to.x-from.x)*segT;
        const baseY=from.y + (to.y-from.y)*segT;
        const px=(baseX + nx*offsetMag)*scaleX;
        const py=(baseY + ny*offsetMag)*scaleY;
        const baseSize=(120 + dist*0.22)*scaleAvg*easeOut;
        const width=Math.max(36, baseSize*0.36);
        const height=Math.max(78, baseSize*0.82);
        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(angle);
        ctx.globalAlpha=Math.max(0, Math.min(1, segFade*0.85));
        const glow=ctx.createRadialGradient(0,0,width*0.16,0,0,height);
        glow.addColorStop(0,`rgba(250,240,255,${0.9*segFade})`);
        glow.addColorStop(0.4,`rgba(210,170,255,${0.55*segFade})`);
        glow.addColorStop(0.75,`rgba(120,60,220,${0.18*segFade})`);
        glow.addColorStop(1,'rgba(70,20,160,0)');
        ctx.fillStyle=glow;
        ctx.beginPath();
        ctx.ellipse(0,0,width,height,0,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      const ribbons=Array.isArray(fx.ribbons)?fx.ribbons:[];
      for(const ribbon of ribbons){
        const amp=(ribbon.amplitude||26)*fade;
        const hue=ribbon.hue!=null?ribbon.hue:260;
        const ribbonPhase=swirlSeed + shimmerPhase*0.8 + (ribbon.offset||0)*Math.PI*2;
        const ctrlX=(from.x+to.x)/2 + nx*amp*Math.sin(ribbonPhase);
        const ctrlY=(from.y+to.y)/2 + ny*amp*Math.cos(ribbonPhase*0.9);
        ctx.save();
        ctx.globalAlpha=Math.max(0, fade*0.55);
        ctx.shadowBlur=18*scaleAvg*fade;
        ctx.shadowColor=`hsla(${hue.toFixed(1)}, 90%, 70%, ${0.32*fade})`;
        ctx.strokeStyle=`hsla(${hue.toFixed(1)}, 96%, ${60 - t*20}%, ${0.55*fade})`;
        ctx.lineWidth=Math.max(3, (ribbon.width||0.4)*(14 + dist*0.06)*scaleAvg*fade);
        ctx.lineCap='round';
        ctx.beginPath();
        ctx.moveTo(from.x*scaleX, from.y*scaleY);
        ctx.quadraticCurveTo(ctrlX*scaleX, ctrlY*scaleY, to.x*scaleX, to.y*scaleY);
        ctx.stroke();
        ctx.restore();
      }

      const motes=Array.isArray(fx.motes)?fx.motes:[];
      for(const mote of motes){
        const speed=(mote.speed||0.6);
        const travel=((elapsed/life)*speed + (mote.offset||0))%1;
        const moteFade=Math.max(0, 1 - travel*1.1)*fade;
        if(moteFade<=0) continue;
        const swirl=Math.sin(swirlSeed*1.3 + travel*9.2 + shimmerPhase*1.4)*(mote.drift||0);
        const baseX=from.x + (to.x-from.x)*travel;
        const baseY=from.y + (to.y-from.y)*travel;
        const mx=(baseX + nx*swirl)*scaleX;
        const my=(baseY + ny*swirl)*scaleY;
        const radius=(mote.radius||12)*scaleAvg*0.6;
        ctx.save();
        ctx.translate(mx, my);
        ctx.globalAlpha=moteFade*0.9;
        const glow=ctx.createRadialGradient(0,0,0,0,0,radius);
        glow.addColorStop(0,`rgba(255,255,255,${0.9*moteFade})`);
        glow.addColorStop(0.45,`rgba(220,180,255,${0.6*moteFade})`);
        glow.addColorStop(1,'rgba(120,60,200,0)');
        ctx.fillStyle=glow;
        ctx.beginPath();
        ctx.arc(0,0,radius,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      const portals=Array.isArray(fx.portals)?fx.portals:[];
      for(const portal of portals){
        const anchor=(portal && portal.anchor==='to')?to:from;
        const phase=(portal&&portal.phase!=null)?portal.phase:0;
        const pulse=0.65 + 0.35*Math.sin(shimmerPhase*2 + phase);
        const radius=(72 + dist*0.04)*scaleAvg*pulse*fade;
        if(radius<=0) continue;
        ctx.save();
        ctx.translate(anchor.x*scaleX, anchor.y*scaleY);
        ctx.rotate(phase + shimmerPhase*0.6);
        const aspect=0.78 + 0.18*Math.sin(shimmerPhase + phase*0.6);
        ctx.scale(1, aspect);
        ctx.globalAlpha=fade*0.8;
        const ring=ctx.createRadialGradient(0,0,radius*0.2,0,0,radius);
        ring.addColorStop(0,`rgba(255,255,255,${0.6*fade})`);
        ring.addColorStop(0.5,`rgba(210,170,255,${0.4*fade})`);
        ring.addColorStop(1,'rgba(120,60,210,0)');
        ctx.fillStyle=ring;
        ctx.beginPath();
        ctx.ellipse(0,0,radius*1.22,radius,0,0,Math.PI*2);
        ctx.fill();
        ctx.lineWidth=Math.max(2, radius*0.14);
        ctx.strokeStyle=`rgba(230,210,255,${0.38*fade})`;
        ctx.beginPath();
        ctx.ellipse(0,0,radius*1.08,radius*0.86,0,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
    }
  }

  function drawDemonLayer(now){
    if(level!==20) return;
    const bladeHellHide = demonAttackActive && demonAttackActive.type==='bladeHell' && demonAttackActive.stage==='hell';
    const abyssHide = demonAttackActive && demonAttackActive.type==='abyssShatter' && demonAttackActive.hideBoss;
    const hideCharges = bladeHellHide || abyssHide;
    if(!bladeHellHide && !abyssHide){
      drawDemonCore(now);
      drawDemonAfterimages(now);
      drawDemonTeleportTrails(now);
    }
    const shake = (demonBladeHellCounterstrike && demonBladeHellCounterstrike.activated && demonBladeHellCounterstrike.shakeUntil && now<demonBladeHellCounterstrike.shakeUntil)
      ? (demonBladeHellCounterstrike.shakeMagnitude||6)
      : 0;
    if(demonBoss && (demonPhase==='active' || demonPhase==='dying') && !bladeHellHide && !abyssHide){
      const opts = shake>0 ? {shake} : undefined;
      renderDemonFigure(demonBoss, now, opts);
    }
    if((demonVoidVolleyState || demonVoidProjectiles.length) && (demonVoidProjectiles.length || !hideCharges)){
      drawDemonVoidVolleyEffects(now, {hideCharges});
    }
    if(demonDeathAnim && demonPhase!=='defeated'){
      const anim=demonDeathAnim;
      const elapsed=now-anim.start;
      const life=Math.max(1, (anim.duration||2200));
      const prog=Math.max(0, Math.min(1, elapsed/life));
      const cx=(anim.centerX||550)*scaleX;
      const cy=(anim.centerY|| (layout().top+160))*scaleY;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const outer=200*((scaleX+scaleY)/2)*(1+prog*0.6);
      const glow=ctx.createRadialGradient(cx,cy,0,cx,cy,outer);
      glow.addColorStop(0,`rgba(240,220,255,${0.55*(1-prog)})`);
      glow.addColorStop(0.55,`rgba(180,120,220,${0.4*(1-prog)})`);
      glow.addColorStop(1,'rgba(110,50,200,0)');
      ctx.fillStyle=glow;
      ctx.beginPath();
      ctx.arc(cx,cy,outer,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawDemonCloakWraps(now, layer='front'){
    if(level!==20 || demonPhase!=='active' || !demonBoss) return;
    if(demonAttackActive && demonAttackActive.type==='bladeHell' && demonAttackActive.stage==='hell') return;
    if(!Array.isArray(balls) || !balls.length) return;
    const captured=balls.filter(b=>b && b.demonCloakState==='captured');
    if(!captured.length) return;
    const center=demonCloakCenter();
    if(!center) return;
    const scaleAvg=(scaleX+scaleY)/2;
    const centerX=center.x*scaleX;
    const centerY=center.y*scaleY;
    for(const ball of captured){
      const progress=Math.max(0, Math.min(1, ball.demonCloakWrapProgress||0));
      const ballX=ball.x*scaleX;
      const ballY=ball.y*scaleY;
      const anchor=ball.demonCloakAnchor||{dx:0,dy:0};
      const wrapRadius=Math.max(ball.r*scaleAvg*1.8, Math.hypot((anchor.dx||0)*scaleX, (anchor.dy||0)*scaleY)*0.6, 22*scaleAvg);
      const dx=ballX-centerX;
      const dy=ballY-centerY;
      const baseAngle=Math.atan2(dy, dx);
      const swirl=ball.demonCloakWrapPhase||baseAngle;
      if(layer==='behind'){
        ctx.save();
        ctx.globalAlpha=0.45 + 0.25*progress;
        ctx.lineCap='round';
        ctx.lineJoin='round';
        ctx.strokeStyle=`rgba(140,0,28,${0.55+0.3*progress})`;
        ctx.lineWidth=(16 + 18*progress)*scaleAvg;
        const ctrlX=centerX + dx*0.45 + Math.cos(swirl)*wrapRadius*0.55;
        const ctrlY=centerY + dy*0.45 + Math.sin(swirl)*wrapRadius*0.45;
        const tailX=ballX - Math.cos(baseAngle)*wrapRadius*0.55;
        const tailY=ballY - Math.sin(baseAngle)*wrapRadius*0.35;
        ctx.beginPath();
        ctx.moveTo(centerX - 18*scaleAvg, centerY - 28*scaleAvg);
        ctx.quadraticCurveTo(ctrlX, ctrlY, tailX, tailY);
        ctx.stroke();
        ctx.restore();
        continue;
      }
      if(layer!=='front') continue;
      ctx.save();
      ctx.translate(ballX, ballY);
      ctx.rotate(baseAngle + Math.PI/2);
      const flapW=wrapRadius*(0.85 + 0.45*progress);
      const flapLen=wrapRadius*(1.28 + 0.55*progress);
      const topLift=wrapRadius*(0.68 + 0.24*progress);
      ctx.beginPath();
      ctx.moveTo(-flapW*0.62, -wrapRadius*0.24);
      ctx.quadraticCurveTo(-flapW*1.05, flapLen*0.18, -flapW*0.2, flapLen*0.82);
      ctx.quadraticCurveTo(0, flapLen*(1.1+0.22*progress), flapW*0.2, flapLen*0.82);
      ctx.quadraticCurveTo(flapW*1.05, flapLen*0.18, flapW*0.62, -wrapRadius*0.24);
      ctx.quadraticCurveTo(flapW*0.18, -topLift, 0, -topLift*1.08);
      ctx.quadraticCurveTo(-flapW*0.18, -topLift, -flapW*0.62, -wrapRadius*0.24);
      ctx.closePath();
      const grad=ctx.createLinearGradient(0,-topLift*1.1,0,flapLen*(1.12+0.2*progress));
      grad.addColorStop(0,`rgba(200,48,58,${0.55+0.2*progress})`);
      grad.addColorStop(0.5,`rgba(140,0,24,${0.78+0.18*progress})`);
      grad.addColorStop(1,`rgba(70,0,12,${0.92+0.06*progress})`);
      ctx.fillStyle=grad;
      ctx.shadowColor=`rgba(255,120,150,${0.18+0.22*progress})`;
      ctx.shadowBlur=26*scaleAvg*progress;
      ctx.fill();
      ctx.shadowBlur=0;
      ctx.strokeStyle=`rgba(255,200,210,${0.18+0.18*progress})`;
      ctx.lineWidth=2.4*scaleAvg;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -topLift*0.82);
      ctx.quadraticCurveTo(-flapW*0.12, flapLen*0.34, 0, flapLen*0.96);
      ctx.strokeStyle=`rgba(255,180,200,${0.18+0.2*progress})`;
      ctx.lineWidth=1.2*scaleAvg;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, -topLift*0.82);
      ctx.quadraticCurveTo(flapW*0.12, flapLen*0.34, 0, flapLen*0.96);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,120,140,${0.18+0.24*progress})`;
      ctx.lineWidth=3.2*scaleAvg;
      ctx.beginPath();
      ctx.arc(ballX, ballY, wrapRadius*0.72, baseAngle-0.5, baseAngle+1.05);
      ctx.stroke();
      ctx.restore();
    }
  }

  function activateDemonBoss(){
    if(level!==20) return;
    const now=performance.now();
    const L=layout();
    const cx=1100/2;
    const baseY=L.top + 160;
    resetBossNineCatDrop('demon');
    const pr=paddleRect();
    let lowBaseY=baseY+180;
    if(pr && pr.w>0 && pr.h>0){
      const target=Math.max(L.top+200, pr.y-40);
      lowBaseY=Math.max(baseY+140, Math.min(target, 520));
    }else{
      lowBaseY=Math.min(baseY+220, L.top+360);
    }
    demonBoss={
      x:cx,
      y:baseY,
      baseY,
      w:90,
      h:90,
      hitW:150,
      hitH:220,
      hitOffsetY:10,
      cloakW:260,
      cloakH:260,
      cloakOffsetY:20,
      hp:100,
      maxHp:100,
      hoverPhase:0,
      cloakPhase:Math.random()*Math.PI*2,
      cloakSway:0,
      hitFlashUntil:0,
      hitCooldownUntil:0,
      lastUpdate:now,
      lastAfterimage:0,
      deathFade:1,
      spawnAt:now,
      normalBaseY:baseY,
      lowBaseY,
      descentStart:now,
      descentDuration:DEMON_DESCENT_DURATION,
      mode:'descending',
      lowArrivalAnnounced:false,
      lowKnockbacks:0,
      lastKnockbackAt:0,
      knockbackVX:0,
      knockbackVY:0,
      recoveryDuration:DEMON_RECOVERY_DURATION,
      bloodDrain:null,
      moveTarget:null,
      nextMove:now+1200,
      recentHits:[],
      teleportCooldownUntil:0,
      teleportFlashUntil:0,
      cloakGripSide:0,
      cloakGripTarget:0,
      cloakGripStrength:0,
      cloakGripLastActive:0
    };
    demonPhase='active';
    demonAfterimages=[];
    demonTeleportTrails=[];
    screenShake=Math.max(screenShake,16);
    spawnParticles(cx, baseY, '#dcb6ff', 110, 2.0, 3.2, 3.0);
    spawnParticles(cx, baseY, '#f0e4ff', 80, 1.8, 2.6, 2.4);
    demonEventWave={x:cx,y:baseY,start:now,duration:2000,maxRadius:Math.hypot(1100,700)};
    demonAttackActive=null;
    demonAttackNextAt=now+DEMON_FIRST_ATTACK_DELAY;
    demonVoidVolleyState=null;
    demonVoidProjectiles.length=0;
    demonVoidNextRoll=now+5000;
    demonBlackSpears=[];
    demonAbyssBricks.length=0;
    demonAbyssExplosions.length=0;
    demonBloodEffects.length=0;
  }

  function isDemonTeleportTriggerSource(source){
    if(source==='ball') return true;
    return DEMON_TELEPORT_BUFF_SOURCES.has(source);
  }

  function damageDemonBoss(amount=1, source='generic', impact, options=null){
    if(demonPhase!=='active' || !demonBoss) return false;
    const now=performance.now();
    const opts=options||{};
    if(demonBoss.hitCooldownUntil && now<demonBoss.hitCooldownUntil && !opts.ignoreCooldown) return false;
    if(opts.ignoreCooldown){
      const customCooldown=Math.max(0, opts.cooldown||0);
      demonBoss.hitCooldownUntil=now+customCooldown;
    }else{
      demonBoss.hitCooldownUntil=now+140;
    }
    const dmg=Math.max(0, Math.floor(amount));
    if(!dmg) return false;
    const prevHp=demonBoss.hp;
    demonBoss.hp=Math.max(0, demonBoss.hp-dmg);
    if(demonBoss.hp<prevHp){ incrementCombo(); }
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    demonBoss.hitFlashUntil=now+220;
    const ix=(impact&&impact.x!=null)?impact.x:demonBoss.x;
    const iy=(impact&&impact.y!=null)?impact.y:demonBoss.y;
    spawnParticles(ix,iy,opts.goldenFx?'#ffe07a':'#dcb6ff',24,1.8,3.0,2.8);
    const shakeStrength = opts.screenShake || 4;
    screenShake=Math.max(screenShake,shakeStrength);
    if(demonBoss.recentHits && Array.isArray(demonBoss.recentHits)){
      const hits=demonBoss.recentHits;
      const windowStart=now - DEMON_TELEPORT_HIT_WINDOW;
      while(hits.length && hits[0]<windowStart){ hits.shift(); }
      if(isDemonTeleportTriggerSource(source)){
        hits.push(now);
      }
      if(demonBoss.hp>0 && hits.length>DEMON_TELEPORT_HIT_THRESHOLD && (!demonBoss.teleportCooldownUntil || now>=demonBoss.teleportCooldownUntil)){
        if(performDemonTeleport(now, impact)){
          hits.length=0;
        }
      }
    }
    if(demonBoss.hp<=0){
      defeatDemonBoss();
    }
    return true;
  }

  function selectDemonTeleportDestination(){
    if(!demonBoss) return null;
    const L=layout();
    const margin=140;
    const minX=margin;
    const maxX=1100-margin;
    const spanX=Math.max(1, maxX-minX);
    const hoverOffset=demonBoss.y - demonBoss.baseY;
    const baseRef=demonBoss.mode==='low'
      ? (demonBoss.lowBaseY!=null?demonBoss.lowBaseY:demonBoss.baseY)
      : (demonBoss.normalBaseY!=null?demonBoss.normalBaseY:demonBoss.baseY);
    const baseMin=Math.max(L.top+90, baseRef-140);
    const baseMax=Math.min(L.top+460, baseRef+140);
    const baseSpan=Math.max(1, baseMax-baseMin);
    let pick=null;
    for(let i=0;i<8;i++){
      const candidateX=minX + Math.random()*spanX;
      const candidateBase=baseMin + Math.random()*baseSpan;
      const dist=Math.hypot(candidateX-demonBoss.x, candidateBase-demonBoss.baseY);
      if(dist<120 && i<7) continue;
      pick={x:candidateX, baseY:candidateBase, y:candidateBase + hoverOffset};
      break;
    }
    if(!pick){
      const fallbackX = demonBoss.x + (Math.random()>0.5?220:-220);
      const fallbackBase = baseRef + (Math.random()-0.5)*120;
      const clampX=Math.max(minX, Math.min(maxX, fallbackX));
      const clampBase=Math.max(baseMin, Math.min(baseMax, fallbackBase));
      pick={x:clampX, baseY:clampBase, y:clampBase + hoverOffset};
    }
    return pick;
  }

  function performDemonTeleport(now=performance.now(), impact){
    if(demonPhase!=='active' || !demonBoss) return false;
    const destination=selectDemonTeleportDestination();
    if(!destination) return false;
    const prev={
      x:demonBoss.x,
      y:demonBoss.y,
      baseY:demonBoss.baseY,
      w:demonBoss.w,
      h:demonBoss.h,
      hoverPhase:demonBoss.hoverPhase,
      cloakPhase:demonBoss.cloakPhase,
      cloakSway:demonBoss.cloakSway
    };
    const life=640;
    const trailAngle=Math.atan2(destination.y-prev.y, destination.x-prev.x);
    const trailDist=Math.hypot(destination.x-prev.x, destination.y-prev.y);
    const swirlSeed=Math.random()*Math.PI*2;
    const ribbonCount=3;
    const ribbons=Array.from({length:ribbonCount}, (_,i)=>(
      {
        offset:Math.random(),
        amplitude:18 + i*10 + Math.random()*16,
        width:0.34 + i*0.18,
        hue:250 + i*14 + Math.random()*18
      }
    ));
    const motes=Array.from({length:12}, ()=>({
      offset:Math.random(),
      drift:(Math.random()-0.5)*48,
      radius:10 + Math.random()*18,
      speed:0.5 + Math.random()*0.9
    }));
    const portals=[
      {anchor:'from', phase:Math.random()*Math.PI*2},
      {anchor:'to', phase:Math.random()*Math.PI*2}
    ];
    demonTeleportTrails.push({
      start:now,
      end:now+life,
      from:prev,
      to:destination,
      angle:trailAngle,
      dist:trailDist,
      swirlSeed,
      ribbons,
      motes,
      portals
    });
    if(demonTeleportTrails.length>4){ demonTeleportTrails.splice(0, demonTeleportTrails.length-4); }
    for(let i=0;i<4;i++){
      const t=i/3;
      demonAfterimages.push({
        x:prev.x + (destination.x-prev.x)*t,
        y:prev.y + (destination.y-prev.y)*t,
        baseY:prev.baseY + (destination.baseY-prev.baseY)*t,
        w:prev.w,
        h:prev.h,
        hoverPhase:prev.hoverPhase + t*0.4,
        cloakPhase:prev.cloakPhase,
        cloakSway:prev.cloakSway,
        t0:now - t*60,
        life:360 + t*80,
        fade:true
      });
    }
    if(demonAfterimages.length>10){ demonAfterimages.splice(0, demonAfterimages.length-10); }
    spawnParticles(prev.x, prev.y, '#f4dcff', 48, 2.8, 4.0, 3.8);
    spawnParticles(prev.x, prev.y, '#c9a9ff', 36, 2.2, 3.4, 3.4);
    spawnParticles(destination.x, destination.y, '#d8b7ff', 42, 1.8, 3.0, 3.2);
    spawnParticles(destination.x, destination.y, '#9e6bff', 28, 1.6, 2.6, 3.0);
    playSFX('demonTeleport');
    const hoverOffset = demonBoss.y - demonBoss.baseY;
    demonBoss.x = destination.x;
    demonBoss.baseY = destination.baseY;
    demonBoss.y = destination.baseY + hoverOffset;
    demonBoss.knockbackVX=0;
    demonBoss.knockbackVY=0;
    demonBoss.moveTarget=null;
    demonBoss.teleportCooldownUntil = now + 2000;
    demonBoss.teleportFlashUntil = Math.max(demonBoss.teleportFlashUntil||0, now+360);
    demonBoss.hitCooldownUntil = Math.max(demonBoss.hitCooldownUntil||0, now+200);
    demonBoss.cloakGripTarget=0;
    demonBoss.cloakGripSide=0;
    demonBoss.cloakGripLastActive=now;
    demonBoss.recentHits=[];
    demonBoss.lastUpdate=now;
    demonBoss.lastAfterimage=0;
    screenShake=Math.max(screenShake,5);
    if(impact && impact.x!=null && impact.y!=null){
      spawnParticles(impact.x, impact.y, '#e8d6ff', 24, 1.6, 2.6, 2.6);
    }
    return true;
  }

  function defeatDemonBoss(){
    if(demonPhase==='dying' || demonPhase==='defeated') return;
    const now=performance.now();
    const centerX=demonBoss?demonBoss.x:550;
    const centerY=demonBoss?demonBoss.y:(layout().top+160);
    demonPhase='dying';
    demonDeathAnim={
      start:now,
      duration:2800,
      vanishAt:now+1100,
      lastSpark:0,
      centerX:centerX,
      centerY:centerY,
      bursts:[
        {time:0, scale:1.0, triggered:false},
        {time:360, scale:1.18, triggered:false},
        {time:820, scale:1.38, triggered:false},
        {time:1400, scale:1.65, triggered:false}
      ]
    };
    demonEventWave={x:centerX,y:centerY,start:now,duration:3000,maxRadius:Math.hypot(1100,700)*1.05};
    demonDeathShockwaves=[{start:now, duration:2600, maxRadius:Math.hypot(1100,700)*1.05, x:centerX, y:centerY, palette:{inner:'255,240,255', mid:'210,140,255', outer:'120,40,200'}, easing:0.82, alpha:0.55}];
    demonDeathFlares=[];
    demonTeleportTrails=[];
    demonEventMarquee={text:'成功擊殺Boss: 魔王埃里赫曼!', start:now, fadeStart:now+5000, end:now+5000};
    if(demonBoss){
      demonBoss.hp=0;
      demonBoss.hitFlashUntil=now+260;
    }
    demonAttackActive=null;
    demonAttackNextAt=0;
    demonVoidVolleyState=null;
    demonVoidProjectiles.length=0;
    demonVoidNextRoll=0;
    demonBlackSpears=[];
    demonAbyssBricks.length=0;
    demonAbyssExplosions.length=0;
    demonBladeHellTelegraphs.length=0;
    demonBladeHellSlashes.length=0;
    demonBladeHellCounterSlashes.length=0;
    demonBladeHellCounterstrike=null;
    demonBladeHellLastPaddleCenter={x:550,y:640};
    demonBladeHellTelegraphs.length=0;
    demonBladeHellSlashes.length=0;
    demonBladeHellCounterSlashes.length=0;
    demonBladeHellCounterstrike=null;
    forceReleaseBladeHellBall();
    demonBladeHellPlatformGlow=0;
    demonAbyssBricks.length=0;
    demonAbyssExplosions.length=0;
    addScore(BOSS_DEFEAT_SCORE.demon);
    dropBossCoins(centerX, centerY, 5);
    stats.bossKills++;
    updateHUD();
    screenShake=Math.max(screenShake,32);
    spawnParticles(centerX,centerY,'#fff5ff',260,3.2,4.6,5.2);
    spawnParticles(centerX,centerY,'#c08cff',200,2.6,3.8,4.2);
    spawnParticles(centerX,centerY,'#ffd1ff',180,2.8,4.2,3.9);
    spawnParticles(centerX,centerY,'#ff89d0',140,3.0,4.5,4.4);
    spawnBossNineCatOnce('demon', centerX-12, centerY);
  }

  function updateDemonBoss(){
    if(level!==20) return;
    const now=performance.now();
    if(demonPhase==='intro' && !demonBoss && demonRevealScheduled && now>=demonRevealScheduled){
      activateDemonBoss();
    }
    if(demonPhase==='active' && demonBoss){
      const dt = now - (demonBoss.lastUpdate||now);
      demonBoss.lastUpdate=now;
      const prevX=demonBoss.x;
      const prevBaseY=demonBoss.baseY;
      const attack=demonAttackActive;
      if(!demonVoidNextRoll){ demonVoidNextRoll = now + 5000; }
      if(attack){
        if(attack.type==='blackRitual'){
          updateDemonBlackRitual(now, dt);
        }else if(attack.type==='bladeHell'){
          updateDemonBladeHell(now, dt);
        }else if(attack.type==='abyssShatter'){
          updateDemonAbyssShatter(now, dt);
        }
      }
      const L=layout();
      const minX=210;
      const maxX=890;
      const normalBase=demonBoss.normalBaseY ?? demonBoss.baseY;
      const lowBase=demonBoss.lowBaseY ?? (normalBase+220);
      if(demonBoss.mode==='bloodDrain' && demonBoss.bloodDrain){
        const state=demonBoss.bloodDrain;
        const targetY=(state.targetY!=null)?state.targetY:Math.max(L.top+90, normalBase-90);
        const ascendDur=state.ascendDuration||900;
        const progress=ascendDur>0?Math.max(0, Math.min(1, (now-state.start)/ascendDur)):1;
        const lerp=Math.min(0.5, 0.18 + progress*0.6);
        demonBoss.baseY += (targetY - demonBoss.baseY)*lerp;
        demonBoss.x += ((state.grabX ?? demonBoss.x) - demonBoss.x)*0.08;
        if(!state.burstDone && now>=state.burstAt){
          const burstY=demonBoss.baseY;
          spawnParticles(demonBoss.x, burstY, '#9f0c2e', 120, 3.0, 4.4, 4.0);
          spawnParticles(demonBoss.x, burstY, '#c9184a', 80, 2.6, 3.8, 3.6);
          spawnParticles(demonBoss.x, burstY, '#ff4d6d', 50, 2.4, 3.4, 3.2);
          playSFX('explosion');
          state.burstDone=true;
        }
        if(now>=state.end){
          demonBoss.mode='recovery';
          demonBoss.bloodDrain=null;
          demonBoss.recoverUntil = now + (demonBoss.recoveryDuration || DEMON_RECOVERY_DURATION);
          demonBoss.descentStart = demonBoss.recoverUntil;
        }
      }else if(attack && attack.overrideMovement){
        demonBoss.knockbackVX*=Math.pow(0.8, dt/16);
        demonBoss.knockbackVY*=Math.pow(0.8, dt/16);
      }else{
        if(demonBoss.knockbackVX){
          demonBoss.x += demonBoss.knockbackVX * (dt/16);
          demonBoss.knockbackVX *= Math.pow(0.9, dt/16);
          if(Math.abs(demonBoss.knockbackVX)<0.02) demonBoss.knockbackVX=0;
        }
        if(demonBoss.knockbackVY){
          demonBoss.baseY += demonBoss.knockbackVY * (dt/16);
          demonBoss.knockbackVY *= Math.pow(0.9, dt/16);
          if(Math.abs(demonBoss.knockbackVY)<0.02) demonBoss.knockbackVY=0;
        }
        let desiredBase=demonBoss.baseY;
        if(demonBoss.mode==='descending'){
          const elapsed=now - (demonBoss.descentStart||now);
          const duration=demonBoss.descentDuration || DEMON_DESCENT_DURATION;
          const progress=duration>0?Math.max(0, Math.min(1, elapsed/duration)):1;
          desiredBase = normalBase + (lowBase - normalBase)*progress;
          if(progress>=1){
            demonBoss.mode='low';
            demonBoss.moveTarget=null;
            demonBoss.lowKnockbacks=0;
            demonBoss.lastKnockbackAt=0;
            if(!demonBoss.lowArrivalAnnounced){
              demonEventMarquee={text:'哈哈哈! 你已經在我的攻擊範圍內啦!', start:now, fadeStart:now+3000, end:now+3000, style:'elegant'};
              demonBoss.lowArrivalAnnounced=true;
            }
          }
        }else if(demonBoss.mode==='low'){
          desiredBase=lowBase;
        }else if(demonBoss.mode==='ascending'){
          const elapsed=now - (demonBoss.ascentStart||now);
          const duration=demonBoss.ascentDuration || DEMON_ASCENT_DURATION;
          const progress=duration>0?Math.max(0, Math.min(1, elapsed/duration)):1;
          desiredBase = lowBase + (normalBase - lowBase)*progress;
          if(progress>=1){
            demonBoss.mode='recovery';
            demonBoss.recoverUntil = now + (demonBoss.recoveryDuration || DEMON_RECOVERY_DURATION);
            demonBoss.descentStart = demonBoss.recoverUntil;
          }
        }else if(demonBoss.mode==='recovery'){
          desiredBase=normalBase;
          if(now>= (demonBoss.recoverUntil||now)){
            demonBoss.mode='descending';
            demonBoss.descentStart=now;
          }
        }else{
          desiredBase=normalBase;
        }
        if(desiredBase> demonBoss.baseY){
          const denom=demonBoss.descentDuration || DEMON_DESCENT_DURATION;
          const step = denom>0 ? (Math.abs(lowBase-normalBase)/denom)*dt : (desiredBase-demonBoss.baseY);
          demonBoss.baseY += Math.min(desiredBase - demonBoss.baseY, step);
        }else if(desiredBase < demonBoss.baseY){
          const denom=demonBoss.ascentDuration || DEMON_ASCENT_DURATION;
          const step = denom>0 ? (Math.abs(lowBase-normalBase)/denom)*dt : (demonBoss.baseY - desiredBase);
          demonBoss.baseY -= Math.min(demonBoss.baseY - desiredBase, step);
        }
        if(demonBoss.mode==='low'){
          const {x:targetX} = getPaddleTarget();
          const chaseSpeed = Math.min(0.26, (dt/1000)*0.9);
          demonBoss.x += (targetX - demonBoss.x)*chaseSpeed;
          demonBoss.nextMove = now + 200;
        }else{
          if(!demonBoss.moveTarget || now>=demonBoss.nextMove){
            const targetX=minX + Math.random()*(maxX-minX);
            const targetY=desiredBase + (Math.random()*80 - 40);
            demonBoss.moveTarget={x:targetX, y:targetY};
            demonBoss.nextMove = now + 1400 + Math.random()*1400;
          }
          if(demonBoss.moveTarget){
            const speed=Math.min(0.22, (dt/1000)*0.7);
            demonBoss.x += (demonBoss.moveTarget.x - demonBoss.x)*speed;
            demonBoss.baseY += (demonBoss.moveTarget.y - demonBoss.baseY)*speed*0.35;
          }
        }
      }
      demonBoss.x = Math.max(minX, Math.min(maxX, demonBoss.x));
      const minBase=Math.min(normalBase, lowBase) - 100;
      const maxBase=Math.max(normalBase, lowBase) + 140;
      let minBaseClamp=L.top+80;
      if(attack && attack.overrideMovement){
        if(attack.minBaseClamp!=null){
          minBaseClamp = attack.minBaseClamp;
        }else if(attack.type==='abyssShatter'){
          const vanishY = attack.bossVanishY!=null ? attack.bossVanishY : (attack.bossDepartTo-80);
          const offscreenY = attack.bossOffscreenY!=null ? attack.bossOffscreenY : (vanishY-120);
          minBaseClamp = Math.min(minBaseClamp, vanishY, offscreenY);
        }
      }
      demonBoss.baseY = Math.max(minBaseClamp, Math.min(maxBase, demonBoss.baseY));
      if(demonBoss.mode!=='low' && demonBoss.mode!=='bloodDrain'){
        if(now - (demonBoss.lastKnockbackAt||0) > DEMON_LOW_KNOCKBACK_WINDOW){
          demonBoss.lowKnockbacks=0;
        }
      }
      demonBoss.hoverPhase += dt*0.0026;
      demonBoss.cloakPhase += dt*0.0018;
      const moveDelta=Math.hypot(demonBoss.x-prevX, demonBoss.baseY-prevBaseY);
      const baseSway=0.16 + Math.abs(Math.sin(demonBoss.hoverPhase))*0.1;
      const swayTarget=0.4 + Math.sin(demonBoss.cloakPhase)*0.3 + moveDelta*0.06;
      demonBoss.cloakSway = (demonBoss.cloakSway||0) + (swayTarget - (demonBoss.cloakSway||0))*0.35;
      demonBoss.y = demonBoss.baseY + Math.sin(demonBoss.hoverPhase)*14;
      const gripTarget = (now - (demonBoss.cloakGripLastActive||0) <= 120) ? (demonBoss.cloakGripTarget||0) : 0;
      const currentGrip = demonBoss.cloakGripStrength||0;
      const gripLerp = Math.max(0.08, Math.min(0.35, dt/180));
      demonBoss.cloakGripStrength = currentGrip + (gripTarget - currentGrip)*gripLerp;
      if(gripTarget===0 && Math.abs(demonBoss.cloakGripStrength)<0.01){
        demonBoss.cloakGripStrength=0;
        if(now - (demonBoss.cloakGripLastActive||0) > 240){
          demonBoss.cloakGripSide=0;
        }
      }
      const hideForAbyss = attack && attack.type==='abyssShatter' && attack.hideBoss;
      if(!hideForAbyss && (!demonBoss.lastAfterimage || now - demonBoss.lastAfterimage > 140)){
        demonAfterimages.push({x:demonBoss.x, y:demonBoss.y, baseY:demonBoss.baseY, w:demonBoss.w, h:demonBoss.h, hoverPhase:demonBoss.hoverPhase, cloakPhase:demonBoss.cloakPhase, cloakSway:demonBoss.cloakSway, t0:now, life:420});
        if(demonAfterimages.length>6){ demonAfterimages.splice(0, demonAfterimages.length-6); }
        demonBoss.lastAfterimage=now;
      }
      if(now>=demonVoidNextRoll){
        demonVoidNextRoll = now + 5000;
        const canVolley = !attack && demonBoss.mode!=='bloodDrain' && demonBoss.mode!=='attack' && demonBoss.mode!=='ascending' && demonBoss.mode!=='recovery';
        if(canVolley && !demonVoidVolleyState){
          if(Math.random()<0.10){
            startDemonVoidVolley(now);
          }
        }
      }
      if(!attack && !demonVoidVolleyState && demonBoss.mode!=='bloodDrain' && demonBoss.mode!=='ascending' && demonBoss.mode!=='recovery' && demonBoss.mode!=='attack'){
        if(!demonAttackNextAt){ demonAttackNextAt = now + DEMON_ATTACK_INTERVAL; }
        if(now>=demonAttackNextAt){
          const picks=['blackRitual','bladeHell','abyssShatter'];
          const choice=picks[Math.floor(Math.random()*picks.length)];
          if(choice==='bladeHell'){ startDemonBladeHell(now); }
          else if(choice==='blackRitual'){ startDemonBlackRitual(now); }
          else { startDemonAbyssShatter(now); }
        }
      }
      if(demonBoss.mode!=='bloodDrain' && demonBoss.mode!=='attack'){
        const pr=paddleRect();
        if(pr.w>0 && pr.h>0 && now>=paddleGoneUntil){
          const bounds=getDemonBounds();
          if(bounds && rectsOverlap(bounds, pr)){
            const cx=pr.x+pr.w/2;
            const cy=pr.y+pr.h/2;
            if(!blockDamageIfShielded({x:cx,y:cy})){
              triggerDemonBloodDrain(now, pr);
            }
          }
        }
      }
    }else if(demonPhase==='dying' && demonDeathAnim){
      const anim=demonDeathAnim;
      const elapsed=now-anim.start;
      const fadeDuration=Math.max(1, (anim.vanishAt|| (anim.start+900)) - anim.start);
      const burstX = (anim.centerX!=null)?anim.centerX:(demonBoss?demonBoss.x:550);
      const burstY = (anim.centerY!=null)?anim.centerY:(demonBoss?demonBoss.y:(layout().top+160));
      if(anim.bursts){
        for(const burst of anim.bursts){
          if(!burst.triggered && elapsed>=burst.time){
            burst.triggered=true;
            const scale=Math.max(1, burst.scale||1);
            const radius=Math.hypot(1100,700)*(1.05 + (scale-1)*0.65);
            const paletteIndex=Math.floor(scale*3);
            const palettes=[
              {inner:'255,248,255', mid:'210,150,255', outer:'110,40,200'},
              {inner:'255,238,255', mid:'220,160,255', outer:'130,60,210'},
              {inner:'255,232,255', mid:'200,140,255', outer:'120,50,220'},
              {inner:'255,240,255', mid:'210,160,255', outer:'140,60,220'}
            ];
            const palette=palettes[paletteIndex%palettes.length];
            demonDeathShockwaves.push({
              start:now,
              duration:2200 + scale*240,
              maxRadius:radius,
              x:burstX,
              y:burstY,
              palette,
              easing:0.76,
              alpha:0.58
            });
            const rayCount=Math.min(28, 14 + Math.round(scale*6));
            for(let i=0;i<rayCount;i++){
              const angle=(Math.PI*2/rayCount)*i + Math.random()*0.25;
              const baseWidth=54 + scale*18 + Math.random()*16;
              const length=460 + scale*180 + Math.random()*80;
              const life=1300 + scale*320 + Math.random()*160;
              demonDeathFlares.push({
                start:now,
                life,
                angle,
                baseWidth,
                tipWidth:baseWidth*0.32,
                length,
                x:burstX,
                y:burstY,
                color:'255,220,255',
                glow:'150,60,220'
              });
            }
            screenShake=Math.max(screenShake, 32 + scale*6);
            spawnParticles(burstX,burstY,'#fef5ff',220,3.4,4.8,4.6);
            spawnParticles(burstX,burstY,'#cfa4ff',180,2.6,4.0,4.0);
            spawnParticles(burstX,burstY,'#ff9fe8',160,2.8,4.2,4.2);
          }
        }
      }
      if(demonBoss){
        const dt = now - (demonBoss.lastUpdate||now);
        demonBoss.lastUpdate=now;
        demonBoss.hoverPhase += dt*0.002;
        demonBoss.y = demonBoss.baseY + Math.min(120, elapsed*0.18);
        demonBoss.deathFade = Math.max(0, 1 - elapsed/fadeDuration);
        if(!anim.lastSpark || now-anim.lastSpark>90){
          const ox=(Math.random()-0.5)*demonBoss.w*0.6;
          const oy=(Math.random()-0.5)*demonBoss.h*0.6;
          spawnParticles(demonBoss.x+ox, demonBoss.y+oy, '#dcb6ff', 16, 1.4, 2.4, 2.5);
          anim.lastSpark=now;
        }
        if(elapsed>=fadeDuration){
          demonAfterimages.push({x:demonBoss.x, y:demonBoss.y, baseY:demonBoss.baseY, w:demonBoss.w, h:demonBoss.h, hoverPhase:demonBoss.hoverPhase, cloakPhase:demonBoss.cloakPhase, cloakSway:demonBoss.cloakSway, t0:now, life:600, fade:true});
          if(demonAfterimages.length>8){ demonAfterimages.splice(0, demonAfterimages.length-8); }
          demonVoidVolleyState=null;
          demonVoidProjectiles.length=0;
          demonVoidNextRoll=0;
          demonBoss=null;
        }
      }
      if(elapsed>=(anim.duration||2200)){
        demonPhase='defeated';
        demonDeathAnim=null;
        demonDefeatedAt=now;
      }
    }
    for(let i=demonAfterimages.length-1;i>=0;i--){
      const ghost=demonAfterimages[i];
      const life=ghost.life||520;
      if(now-ghost.t0>=life){ demonAfterimages.splice(i,1); }
    }
    for(let i=demonTeleportTrails.length-1;i>=0;i--){
      const trail=demonTeleportTrails[i];
      if(!trail || now>=trail.end){
        demonTeleportTrails.splice(i,1);
      }
    }
  }

  function demonClampPoint(x, y){
    const bounds=getDemonBounds();
    if(!bounds) return {x, y};
    return {
      x: Math.max(bounds.x, Math.min(x, bounds.x + bounds.w)),
      y: Math.max(bounds.y, Math.min(y, bounds.y + bounds.h))
    };
  }

  function drawDemonWave(now){
    if(level!==20 || !demonEventWave) return;
    const wave=demonEventWave;
    const life = wave.duration||1;
    const prog = Math.max(0, Math.min(1,(now-wave.start)/life));
    const radius = (wave.maxRadius||Math.hypot(1100,700)) * prog;
    const alpha = 0.45*(1-prog);
    if(alpha<=0) return;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const maxR = radius*((scaleX+scaleY)/2);
    const minR = maxR*0.35;
    const grad=ctx.createRadialGradient(wave.x*scaleX, wave.y*scaleY, minR, wave.x*scaleX, wave.y*scaleY, Math.max(minR+1,maxR));
    grad.addColorStop(0,`rgba(210,170,255,${alpha})`);
    grad.addColorStop(0.6,`rgba(160,110,255,${alpha*0.6})`);
    grad.addColorStop(1,'rgba(110,40,200,0)');
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(wave.x*scaleX, wave.y*scaleY, Math.max(minR+1,maxR),0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawDemonDeathAftershock(now){
    if(level!==20) return;
    if(demonDeathShockwaves.length){
      const scaleAvg=(scaleX+scaleY)/2;
      for(let i=demonDeathShockwaves.length-1;i>=0;i--){
        const wave=demonDeathShockwaves[i];
        const life=Math.max(1, wave.duration||2000);
        const elapsed=now-wave.start;
        if(elapsed<0) continue;
        if(elapsed>life){ demonDeathShockwaves.splice(i,1); continue; }
        const prog=Math.max(0, Math.min(1, elapsed/life));
        const ease=Math.pow(prog, wave.easing||0.85);
        const radius=(wave.maxRadius||Math.hypot(1100,700))*ease;
        const alpha=(wave.alpha!=null?wave.alpha:0.55)*(1-prog);
        if(alpha<=0.01) continue;
        const palette=wave.palette||{inner:'255,240,255', mid:'210,150,255', outer:'110,40,200'};
        const cx=(wave.x||550)*scaleX;
        const cy=(wave.y!=null?wave.y:(layout().top+160))*scaleY;
        const maxR=radius*scaleAvg;
        const innerR=Math.max(12, maxR*0.28);
        const grad=ctx.createRadialGradient(cx, cy, innerR*0.3, cx, cy, Math.max(innerR, maxR));
        grad.addColorStop(0,`rgba(${palette.inner},${alpha})`);
        grad.addColorStop(0.55,`rgba(${palette.mid},${alpha*0.7})`);
        grad.addColorStop(1,`rgba(${palette.outer},0)`);
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(cx, cy, Math.max(innerR, maxR),0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    if(demonDeathFlares.length){
      for(let i=demonDeathFlares.length-1;i>=0;i--){
        const flare=demonDeathFlares[i];
        const life=Math.max(1, flare.life||1200);
        const elapsed=now-flare.start;
        if(elapsed<0) continue;
        if(elapsed>life){ demonDeathFlares.splice(i,1); continue; }
        const prog=Math.max(0, Math.min(1, elapsed/life));
        const fade=1-prog;
        const originX=flare.x!=null?flare.x:550;
        const originY=flare.y!=null?flare.y:(layout().top+160);
        const angle=flare.angle||0;
        const dx=Math.cos(angle);
        const dy=Math.sin(angle);
        const len=(flare.length||480)*(0.9 + 0.2*fade);
        const baseWidth=(flare.baseWidth||60)*(0.8 + 0.2*fade);
        const tipWidth=(flare.tipWidth!=null?flare.tipWidth:baseWidth*0.35)*(0.6 + 0.4*fade);
        const px=-dy;
        const py=dx;
        const tipX=originX + dx*len;
        const tipY=originY + dy*len;
        const baseLeftX=originX + px*baseWidth;
        const baseLeftY=originY + py*baseWidth;
        const baseRightX=originX - px*baseWidth;
        const baseRightY=originY - py*baseWidth;
        const tipLeftX=tipX + px*tipWidth;
        const tipLeftY=tipY + py*tipWidth;
        const tipRightX=tipX - px*tipWidth;
        const tipRightY=tipY - py*tipWidth;
        const alpha=(flare.alpha!=null?flare.alpha:0.85)*fade;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const grad=ctx.createLinearGradient(originX*scaleX, originY*scaleY, tipX*scaleX, tipY*scaleY);
        grad.addColorStop(0,`rgba(${flare.glow||'150,60,220'},${alpha*0.65})`);
        grad.addColorStop(0.35,`rgba(${flare.color||'255,220,255'},${alpha})`);
        grad.addColorStop(1,'rgba(255,255,255,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.moveTo(baseLeftX*scaleX, baseLeftY*scaleY);
        ctx.lineTo(tipLeftX*scaleX, tipLeftY*scaleY);
        ctx.lineTo(tipRightX*scaleX, tipRightY*scaleY);
        ctx.lineTo(baseRightX*scaleX, baseRightY*scaleY);
        ctx.closePath();
        ctx.fill();
        const baseGlow=ctx.createRadialGradient(originX*scaleX, originY*scaleY, 0, originX*scaleX, originY*scaleY, baseWidth*((scaleX+scaleY)/2)*0.9);
        baseGlow.addColorStop(0,`rgba(${flare.color||'255,220,255'},${alpha})`);
        baseGlow.addColorStop(1,'rgba(255,255,255,0)');
        ctx.fillStyle=baseGlow;
        ctx.beginPath();
        ctx.arc(originX*scaleX, originY*scaleY, baseWidth*((scaleX+scaleY)/2)*0.9,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
  }

  function drawDemonCore(now){
    if(level!==20 || !demonCore) return;
    const life = demonCore.visibleUntil ? Math.max(1, demonCore.visibleUntil - demonCore.start) : 1;
    const remain = demonCore.visibleUntil ? Math.max(0, demonCore.visibleUntil - now) : life;
    const alpha = Math.max(0, Math.min(1, remain/life));
    const baseRadius = 34*((scaleX+scaleY)/2);
    const pulse = 1 + 0.08*Math.sin(now/160);
    const outer = baseRadius*1.6*pulse;
    const cx=demonCore.x*scaleX;
    const cy=demonCore.y*scaleY;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const glow=ctx.createRadialGradient(cx, cy, 0, cx, cy, outer);
    glow.addColorStop(0,`rgba(230,210,255,${0.6*alpha})`);
    glow.addColorStop(0.45,`rgba(170,100,255,${0.45*alpha})`);
    glow.addColorStop(1,'rgba(90,30,200,0)');
    ctx.fillStyle=glow;
    ctx.beginPath();
    ctx.arc(cx,cy,outer,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.fillStyle=`rgba(200,120,255,${0.9*alpha})`;
    ctx.beginPath();
    ctx.arc(cx,cy,baseRadius*pulse,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  function cyclopsBlastRow(rowIndex){
    const L=layout();
    const rowHeight = brickH + L.pad;
    let removed=false;
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const row=Math.round(((b.y - L.top) / rowHeight));
      if(row!==rowIndex) continue;
      if(b.boss){
        if(b.cyclops && !cyclopsShellBurst){
          cyclopsShellBurst=true;
          startDragonReveal(b);
        }
        continue;
      }
      const cx=b.x+b.w/2, cy=b.y+b.h/2;
      spawnParticles(cx,cy,'#ffe6a1',28,2.4,3.2,3.6);
      spawnParticles(cx,cy,'#ffb46d',18,2.0,2.8,3.2);
      if(!b.fallingTreasure){ revealBrickArea(b); }
      bricks.splice(i,1);
      removed=true;
    }
    if(removed){
      screenShake=Math.max(screenShake,18);
      playSFX('fireExplosion');
      updateHUD();
    }
  }
  let nextBossAtkA=0, nextBossAtkB=0, bossChargeUntil=0, bossChargeColor='', cyclopsShakeUntil=0;

  function updateBossAbilities(){
    const bossLv = (level%5===0)? level : 0;
    if(!bossLv) return;
    if(level===5 && spaceBossPhase!=='inactive') return;
    if(level===15 && (dragonPhase==='dying' || dragonPhase==='defeated' || dragonPhase==='inactive')) return;
    const now=performance.now();
    if(bossLv===5){ if(now>=nextBossAtkA){ spawnLionBeam(); nextBossAtkA = now + 10000; } }
    else if(bossLv===10){ if(now>=nextBossAtkA){ spawnKnightArc(); nextBossAtkA = now + 15000; } }
    else if(bossLv===15){
      if(!cyclopsForcedPetrifyFired && cyclopsForcedPetrifyAt && now>=cyclopsForcedPetrifyAt){
        if(dragonPhase==='awaiting'){ spawnCyclopsColumn(); }
        cyclopsForcedPetrifyFired=true;
      }
      if(dragonPhase!=='awaiting'){ cyclopsForcedPetrifyFired=true; cyclopsForcedPetrifyAt=0; }
      maybeStartDragonAttack(now);
    }
    else if(bossLv===20){ /* 第20關新事件期間暫停原有攻擊 */ }
  }

  function drawAndStepBossProjectiles(){
    const pr=paddleRect();
    // 金/紅雷射
    for(let i=hostileBeams.length-1;i>=0;i--){
      const b = hostileBeams[i];
      b.x += b.vx; b.y += b.vy;
      // render
      const x1 = (b.x - b.vx*2)*scaleX, y1=(b.y - b.vy*2)*scaleY;
      const x2 = b.x*scaleX, y2=b.y*scaleY;
      ctx.save(); ctx.globalCompositeOperation='lighter';
      if(b.color==='gold'){
        const grd=ctx.createLinearGradient(x1,y1,x2,y2);
        grd.addColorStop(0,'rgba(255,240,160,0)');
        grd.addColorStop(1,'rgba(255,220,120,0.95)');
        ctx.strokeStyle=grd; ctx.lineWidth=6; ctx.shadowColor='rgba(255,230,150,0.9)'; ctx.shadowBlur=15;
      }else if(b.color==='red'){
        const grd=ctx.createLinearGradient(x1,y1,x2,y2);
        grd.addColorStop(0,'rgba(255,120,120,0)');
        grd.addColorStop(1,'rgba(255,60,80,0.95)');
        ctx.strokeStyle=grd; ctx.lineWidth=6; ctx.shadowColor='rgba(255,40,60,0.9)'; ctx.shadowBlur=20;
      }else{
        ctx.strokeStyle='rgba(255,80,120,0.8)'; ctx.lineWidth=5;
      }
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
      // hit check
      if(!b.hit && x2>=pr.x*scaleX && x2<= (pr.x+pr.w)*scaleX && y2>=pr.y*scaleY && y2<= (pr.y+pr.h)*scaleY){
        if(blockDamageIfShielded({x:b.x,y:b.y})){
          b.hit=true;
        }else{
          b.hit=true;
          b.onHit?.(pr);
          spawnParticles(b.x,b.y,'#ffd',12,1.6,2.2,2.5);
        }
      }
      // out of bounds
      if(b.x<0||b.x>1100||b.y<0||b.y>700){ hostileBeams.splice(i,1); }
    }
    // 弧形劍氣
    for(let i=hostileArcs.length-1;i>=0;i--){
      const a = hostileArcs[i];
      a.phase += 0.15;
      a.x += a.vx + Math.sin(a.phase)*0.9;
      a.y += a.vy + Math.cos(a.phase)*0.4;
      // render
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const grad=ctx.createLinearGradient((a.x-a.vx*4)*scaleX,(a.y-a.vy*4)*scaleY,a.x*scaleX,a.y*scaleY);
      grad.addColorStop(0,'rgba(200,200,255,0)');
      grad.addColorStop(1,'rgba(220,220,255,0.9)');
      ctx.strokeStyle=grad; ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(a.x*scaleX, a.y*scaleY, 22*((scaleX+scaleY)/2), Math.PI*0.2, Math.PI*1.2);
      ctx.stroke();
      // 粒子
      for(let k=0;k<5;k++){ particles.push({x:a.x, y:a.y, vx:(Math.random()-0.5)*0.8, vy:(Math.random()-0.5)*0.8, life:220, size:1.6, color:'rgba(200,200,255,0.7)'}); }
      ctx.restore();
      // hit
      if(a.x>=pr.x && a.x<=pr.x+pr.w && a.y>=pr.y && a.y<=pr.y+pr.h){
        if(blockDamageIfShielded({x:a.x,y:a.y})){
          hostileArcs.splice(i,1);
        }else{
          a.onHit?.();
          hostileArcs.splice(i,1);
        }
        continue;
      }
      if(a.x<0||a.x>1100||a.y>700||a.y<0){ hostileArcs.splice(i,1); }
    }
    // 石化柱
    for(let i=hostileColumns.length-1;i>=0;i--){
      const c = hostileColumns[i];
      const now=performance.now();
      if(now>c.tEnd){ hostileColumns.splice(i,1); continue; }
      const x = (c.x - c.w/2)*scaleX, y = (layout().top)*scaleY;
      const w = c.w*scaleX, h = (700 - layout().top)*scaleY;
      const alpha = 0.5 + 0.5*Math.sin(now/80);
      ctx.save(); ctx.globalCompositeOperation='lighter';
      const grd = ctx.createLinearGradient(c.x*scaleX, layout().top*scaleY, c.x*scaleX, 700*scaleY);
      grd.addColorStop(0, 'rgba(245,228,150,0.85)'); grd.addColorStop(1, 'rgba(240,210,120,0.35)');
      ctx.fillStyle = grd; ctx.fillRect(x, y, w, h);
      ctx.restore();
      // 命中平台：僵直3秒
      const pr = paddleRect();
      if(!c.applied){
        const inter = !( pr.x+pr.w < (c.x - c.w/2) || pr.x > (c.x + c.w/2) );
        if(inter){ paddleStunUntil = Math.max(paddleStunUntil, performance.now()+3000); screenShake=Math.max(screenShake,7); c.applied=true; }
      }
    }
    // 烏雲
    for(let i=hazardClouds.length-1;i>=0;i--){
      const cl = hazardClouds[i];
      const now=performance.now();
      // draw cloud
      ctx.save();
      const x = cl.x*scaleX, y=cl.y*scaleY;
      ctx.globalAlpha = 0.9 * Math.max(0, (cl.tEnd - now)/1000);
      ctx.fillStyle='rgba(60,60,80,0.9)';
      ctx.beginPath(); ctx.arc(x-20,y,14,0,Math.PI*2); ctx.arc(x,y-6,18,0,Math.PI*2); ctx.arc(x+18,y,16,0,Math.PI*2); ctx.fill();
      ctx.restore();
      if(now>=cl.tEnd && !cl.spawned){
        // 掉落減益道具
        const debuffs = ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type==='debuff');
        const type = debuffs[Math.floor(Math.random()*debuffs.length)] || 'FAST';
        // 生成一個減益道具，速度略快，方向根據當前翻轉狀態
        {
          const baseSpeed = GAME_CONFIG.powerCapsule.fallVy;
          const speed = baseSpeed * 1.4;
          const horizontal = orientLeft;
          let px = cl.x - 12;
          let py = cl.y;
          if(horizontal){
            // 水平掉落：從右側開始
            px = 1100 - 40;
            const L = layout();
            py = L.top + 20 + Math.random() * (700 - 60 - L.top);
          }
          powerups.push({
            x: px,
            y: py,
            w: GAME_CONFIG.powerCapsule.width,
            h: GAME_CONFIG.powerCapsule.height,
            speed: speed,
            horizontal: horizontal,
            type: type,
            isDebuff: true,
            isSpecial: false,
            phase: Math.random()*Math.PI*2
          });
        }
        cl.spawned=true;
      }
      if(now > cl.tEnd + 2000){ hazardClouds.splice(i,1); }
    }
  }

  // 天地翻轉狀態
  let orientLeft=false; // true 時改為左側擋板模式
  let paddleStunUntil=0;
  let paddleGoneUntil=0;
  let flipDecoy=null;


  function spawnParticles(x,y,color,count=10,spread=1.6,speed=3,size=3){
    for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const v=speed*(.4+Math.random()); particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:400+Math.random()*300,size:size*(.6+Math.random()*0.8),color}); }
  }

  function parseColorToRGB(color){
    if(!color){ return {r:200,g:210,b:255}; }
    if(color.startsWith('#')){
      let hex=color.slice(1);
      if(hex.length===3){ hex=hex.split('').map(ch=>ch+ch).join(''); }
      if(hex.length===6){
        const num=parseInt(hex,16);
        if(!Number.isNaN(num)){
          return {r:(num>>16)&255,g:(num>>8)&255,b:num&255};
        }
      }
    }
    const match=color.match(/rgba?\(([^)]+)\)/i);
    if(match){
      const parts=match[1].split(',').map(v=>parseFloat(v.trim()));
      if(parts.length>=3 && parts.every(v=>!Number.isNaN(v))){
        return {r:parts[0], g:parts[1], b:parts[2]};
      }
    }
    return {r:200,g:210,b:255};
  }

  // === 工具 ===
  function getDiff(){ return GAME_CONFIG.difficulty[difficultySel.value]; }
  function brickColor(i){ return [getVar('--brick1'),getVar('--brick2'),getVar('--brick3'),getVar('--brick4')][i%4]; }
  function getVar(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }
  function clampHP(h){ return Math.max(1, Math.min(4, (h|0))); }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo((x+r)*scaleX,y*scaleY); ctx.arcTo((x+w)*scaleX,y*scaleY,(x+w)*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo((x+w)*scaleX,(y+h)*scaleY,x*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo(x*scaleX,(y+h)*scaleY,x*scaleX,y*scaleY,r*scaleX); ctx.arcTo(x*scaleX,y*scaleY,(x+w)*scaleX,y*scaleY,r*scaleX); ctx.closePath(); }

  // === 統一鎖定框（顯示 1 秒） ===
  function pushLockBox(x,y,w,h,kind='target'){ lockBoxes.push({x,y,w,h,until:performance.now()+1000,kind}); }
  function drawLockBoxes(){
    const now=performance.now();
    for(let i=lockBoxes.length-1;i>=0;i--){
      const b=lockBoxes[i];
      if(now>b.until){ lockBoxes.splice(i,1); continue; }
      const t = 1 - Math.max(0, (b.until-now)/1000);
      const pulse = 0.7 + 0.3*Math.sin(now/100);
      let col = b.kind==='paddle' ? 'rgba(120,220,255,'+(0.6*pulse)+')' : 'rgba(255,220,140,'+(0.6*pulse)+')';
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle = col;
      ctx.lineWidth = 2 + 2*pulse;
      drawRoundedRect(b.x, b.y, b.w, b.h, 10);
      ctx.stroke();
      ctx.restore();
    }
  }


  
  function drawBossEmblem(b){
    const cx = (b.x + b.w/2)*scaleX, cy = (b.y + b.h/2)*scaleY;
    if(b.cyclops && b.cyclopsRevealed){
      const pulse = 0.7 + 0.3*Math.sin(performance.now()/240);
      const radius = Math.min(b.w,b.h)*0.36*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.shadowColor=`rgba(255,220,120,${0.5+0.4*pulse})`;
      ctx.shadowBlur=30*((scaleX+scaleY)/2);
      const grad=ctx.createRadialGradient(cx,cy,radius*0.15,cx,cy,radius);
      grad.addColorStop(0,'rgba(255,255,220,0.98)');
      grad.addColorStop(0.45,'rgba(255,230,150,0.9)');
      grad.addColorStop(1,'rgba(255,170,60,0.08)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(cx,cy,radius,0,Math.PI*2);
      ctx.fill();
      ctx.shadowBlur=0;
      ctx.lineWidth=2.4*((scaleX+scaleY)/2);
      ctx.strokeStyle=`rgba(255,245,200,${0.75+0.2*pulse})`;
      ctx.beginPath();
      ctx.arc(cx,cy,radius*0.72,0,Math.PI*2);
      ctx.stroke();
      ctx.strokeStyle=`rgba(255,210,120,${0.25+0.2*Math.sin(performance.now()/180)})`;
      ctx.lineWidth=1.6*((scaleX+scaleY)/2);
      ctx.beginPath();
      const swing=performance.now()/520;
      ctx.arc(cx,cy,radius*1.18,swing, swing+Math.PI*1.1);
      ctx.stroke();
      ctx.restore();
      return;
    }
    const t = performance.now()/600;
    // 裝甲層
    ctx.save();
    const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
    g.addColorStop(0,'#5f0d2a'); g.addColorStop(1,'#130812');
    ctx.fillStyle = g; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.fill();
    // 外框呼吸
    const glow = 0.5 + 0.5*Math.sin(t*2);
    ctx.strokeStyle = 'rgba(255,90,120,'+(0.6*glow)+')'; ctx.lineWidth = 3 + 2*glow;
    drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke();
    // Emblem
    ctx.translate(cx, cy);
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,230,230,0.9)';
    const idx = ['獅','騎','目','魔'].indexOf(b.face);
    if(idx===0){
      // 獅：鬃毛圓環 + 牙
      ctx.beginPath(); ctx.arc(0,0, Math.min(b.w,b.h)*0.22*scaleX, 0, Math.PI*2); ctx.stroke();
      for(let i=0;i<6;i++){ const a = i*Math.PI/3; ctx.beginPath(); ctx.moveTo(Math.cos(a)*18, Math.sin(a)*18); ctx.lineTo(Math.cos(a)*30, Math.sin(a)*30); ctx.stroke(); }
      ctx.beginPath(); ctx.moveTo(-14,8); ctx.lineTo(-6,14); ctx.moveTo(14,8); ctx.lineTo(6,14); ctx.stroke();
    }else if(idx===1){
      // 頭盔 + 羽飾
      ctx.beginPath(); ctx.arc(0,0,22,Math.PI*0.15, Math.PI*0.85); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-14,0); ctx.lineTo(14,0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-10,-10); ctx.lineTo(0,-22); ctx.lineTo(10,-10); ctx.stroke();
    }else if(idx===2){
      // 獨眼：巨眼 + 眼瞼
      ctx.beginPath(); ctx.ellipse(0,0,26,18,0,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,0); ctx.lineTo(26,0); ctx.stroke();
    }else{
      // 五芒星 + 角
      ctx.beginPath();
      for(let i=0;i<5;i++){ const a = -Math.PI/2 + i*2*Math.PI/5; const x = Math.cos(a)*22, y=Math.sin(a)*22;
        const a2 = -Math.PI/2 + ((i*2+2)%10)*Math.PI/5; const x2=Math.cos(a2)*9, y2=Math.sin(a2)*9;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); ctx.lineTo(x2,y2);
      } ctx.closePath(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-26,-18); ctx.lineTo(-10,-30); ctx.moveTo(26,-18); ctx.lineTo(10,-30); ctx.stroke();
    }
    ctx.restore();
  }

  // === Buff/De-buff 顯示 ===
  function badgeIcon(k){ return (GAME_CONFIG.powers[k]?.badge)||'●'; }
  function fitBuffBadges(){
    if(!activeBuffsEl) return;
    activeBuffsEl.style.setProperty('--buff-scale','1');
    const total=activeBuffsEl.scrollWidth;
    const avail=activeBuffsEl.clientWidth;
    const base=window.innerWidth<=430?0.9:1;
    let scale=base;
    if(total*base>avail){ scale=avail/total; }
    activeBuffsEl.style.setProperty('--buff-scale',scale);
  }
  function updateBuffBadges(){ activeBuffsEl.innerHTML=''; const now=performance.now();
    // LONG 堆疊
    const longAct=buffs.LONG.stacks.filter(t=>t>now);
    if(longAct.length){
      const s=document.createElement('span');
      s.className='badge';
      const leftSec=(Math.max(...longAct)-now)/1000;
      s.textContent=`${badgeIcon('LONG')} LONG×${longAct.length} ${leftSec.toFixed(1)}s`;
      activeBuffsEl.appendChild(s);
    }
    // 其它
    for(const key of Object.keys(GAME_CONFIG.powers)){ if(key==='LONG') continue; const b=buffs[key]; if(!b?.active) continue; const left=b.until&&b.until>now?((b.until-now)/1000).toFixed(1)+'s':''; const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon(key)} ${key}${left?' '+left:''}`; activeBuffsEl.appendChild(s); }
    fitBuffBadges();
  }
  window.addEventListener('resize', fitBuffBadges);

  const promptQueue=[];
  function showPrompt(text){
    if(!promptsDock) return;
    const div=document.createElement('div');
    div.className='prompt';
    div.textContent=text;
    promptsDock.appendChild(div);
    promptQueue.push(div);
    while(promptQueue.length>3){ const old=promptQueue.shift(); old.remove(); }
    setTimeout(()=>{ div.classList.add('fade'); setTimeout(()=>{ const idx=promptQueue.indexOf(div); if(idx>=0) promptQueue.splice(idx,1); div.remove(); },400); },5000);
  }

  // === Buff 狀態 ===
  const buffs={WIDE:{active:false,until:0},STICKY:{active:false,until:0},MULTI:{active:false,until:0},SLOW:{active:false,until:0},PIERCE:{active:false,until:0},SHIELD:{active:false,until:0},RAMPAGE:{active:false,until:0},FAST:{active:false,until:0},WAVY:{active:false,until:0,start:0},COMBO:{active:false,until:0},LONG:{active:false,until:0,stacks:[]},PLASMA:{active:false,until:0},FREEZE:{active:false,until:0},HOLY:{active:false,until:0},TRACK:{active:false,until:0},MISSILE:{active:false,until:0},HELL:{active:false,until:0},MEGA:{active:false,until:0,applied:false},CHAIN:{active:false,until:0},NARROW:{active:false,until:0},HOLE:{active:false,until:0},PADSPIN:{active:false,until:0,start:0},PADBOOM:{active:false,until:0,explodeAt:0,returnAt:0,exploded:false},FLIP:{active:false,until:0},GODSPEED:{active:false,until:0},LASER:{active:false,until:0,lastShot:0},GATLING:{active:false,until:0},FIRE:{active:false,until:0},POISON:{active:false,until:0},BLINK:{active:false,until:0},SWORD:{active:false,until:0},STORM:{active:false,until:0},BLACKHOLE:{active:false,until:0,deaths:0},ANNIHIL:{active:false,until:0,start:0,next:0}};

  // === 擋板 & 球 ===
  let diff=getDiff(); const paddle={w:diff.paddleBaseW,h:18,x:1100/2-diff.paddleBaseW/2,y:700-50,speed:12};
let balls=[]; function makeBall(stuck=false,x=null){
  const megaCfg = GAME_CONFIG.powers.MEGA?.mega || {};
  const sizeMul = (buffs.MEGA?.applied && megaCfg.sizeMul) ? megaCfg.sizeMul : 1;
  return {x:x??(1100/2),y:700/2,r:10*sizeMul,vx:5,vy:-5,speedCap:GAME_CONFIG.caps.ballSpeedMax,piercing:false,stuck:stuck,offsetX:0,rampageUntil:0,trail:[],freeze:{state:'idle',t0:0,until:0,oldVX:0,oldVY:0,delay:0,stop:0},blinkAt:0,loopBrick:null,loopHits:0,lastBrickId:null,lastBrickHitTime:0,sameBrickHits:0,lastBounce:null,speedBoostSuppressedUntil:0,lastCeilingBounce:0,capturedByBladeHell:false};
}

  function resetTrackAssignments(){
    trackTargetOwners.clear();
    trackBallTargets=new WeakMap();
  }
function releaseTrackTarget(ball){
  if(!ball) return;
  const key=trackBallTargets.get(ball);
  if(!key) return;
  const owner=trackTargetOwners.get(key);
  if(owner===ball){
    trackTargetOwners.delete(key);
  }
  trackBallTargets.delete(ball);
}
function isTrackTargetStillValid(key){
  if(key==='boss') return isSpecialBossActive();
  if(typeof key==='string' && key.startsWith('brick:')){
    const idStr=key.slice(6);
    const idNum=Number(idStr);
    if(Number.isFinite(idNum)){
      return bricks.some(b=>b && b.id===idNum);
    }
    return bricks.length>0;
  }
  return false;
}
function cleanupTrackAssignments(){
  for(const [key, owner] of Array.from(trackTargetOwners.entries())){
    if(!owner || !balls.includes(owner) || !isTrackTargetStillValid(key)){
      trackTargetOwners.delete(key);
      if(owner){
        trackBallTargets.delete(owner);
      }
    }
  }
}
function maintainTrackAssignments(){
  if(!equipmentTrackUniqueTargets || !buffs.TRACK?.active){
    resetTrackAssignments();
    return;
  }
  cleanupTrackAssignments();
}
function assignTrackTarget(ball,key){
  if(!equipmentTrackUniqueTargets || !ball || !key) return;
  releaseTrackTarget(ball);
  trackBallTargets.set(ball,key);
  trackTargetOwners.set(key,ball);
}

function cloneBallForMulti(base){
  const copy={...base};
  copy.trail=[];
  copy.freeze=base.freeze?{...base.freeze}:{state:'idle',t0:0,until:0,oldVX:0,oldVY:0,delay:0,stop:0};
  copy.lastBounce=null;
  copy.loopBrick=null;
  copy.loopHits=0;
  copy.sameBrickHits=0;
  copy.capturedByBladeHell=false;
  return copy;
}
function ensureBallCount(targetCount){
  const startCount=balls.length;
  if(startCount>=targetCount) return false;
  const source=balls.slice();
  if(!source.length) return false;
  const clones=[];
  let idx=0;
  while(startCount + clones.length < targetCount){
    const base=source[idx % source.length];
    clones.push(cloneBallForMulti(base));
    idx++;
  }
  if(clones.length){
    balls=balls.concat(clones);
    if(equipmentTrackUniqueTargets){
      resetTrackAssignments();
    }
    return true;
  }
  return false;
}

function trackNeighborCount(brick){
  if(!brick) return 0;
  const L=layout();
  const thx=brickW+L.pad+2;
  const thy=brickH+L.pad+2;
  let cnt=0;
  for(const other of bricks){
    if(!other || other===brick) continue;
    const dx=Math.abs((other.x+other.w/2)-(brick.x+brick.w/2));
    const dy=Math.abs((other.y+other.h/2)-(brick.y+brick.h/2));
    if(dx<=thx && dy<=thy) cnt++;
  }
  return cnt;
}
function computeTrackCandidates(ball){
  const srcX=ball?.x??(1100/2);
  const srcY=ball?.y??(layout().top);
  const candidates=[];
  for(let i=0;i<bricks.length;i++){
    const brick=bricks[i];
    if(!brick || brick.unbreakable) continue;
    const iso=trackNeighborCount(brick);
    const cx=brick.x+brick.w/2;
    const cy=brick.y+brick.h/2;
    const dx=cx-srcX;
    const dy=cy-srcY;
    const dist=Math.hypot(dx,dy);
    const score=iso*1000 + dist;
    const key=brick.id!=null?`brick:${brick.id}`:`brick:${i}`;
    candidates.push({type:'brick',targetId:i,x:cx,y:cy,brick,score,key});
  }
  if(isSpecialBossActive()){
    const center=activeBossCenter();
    if(center){
      candidates.push({type:'boss',targetId:'boss',x:center.x,y:center.y,score:-Infinity,key:'boss'});
    }
  }
  candidates.sort((a,b)=>a.score-b.score);
  return candidates;
}
function chooseTrackTargetForBall(ball){
  const candidates=computeTrackCandidates(ball);
  if(!candidates.length){
    return null;
  }
  if(!equipmentTrackUniqueTargets){
    return candidates[0];
  }
  const currentKey=trackBallTargets.get(ball);
  if(currentKey){
    const existing=candidates.find(c=>c.key===currentKey && isTrackTargetStillValid(c.key));
    if(existing) return existing;
  }
  for(const candidate of candidates){
    const owner=trackTargetOwners.get(candidate.key);
    if(!owner || owner===ball){
      return candidate;
    }
  }
  return candidates[0];
}

  function isSpeedSuppressed(ball, now){
    return !!(ball?.speedBoostSuppressedUntil && now < ball.speedBoostSuppressedUntil);
  }

  function suppressSpeedBoost(ball, now, duration=1000){
    if(!ball) return;
    const target = now + duration;
    if(!ball.speedBoostSuppressedUntil || ball.speedBoostSuppressedUntil < target){
      ball.speedBoostSuppressedUntil = target;
    }
  }

  function noteCeilingBounce(ball, now){
    if(!ball) return;
    if(ball.lastCeilingBounce && now - ball.lastCeilingBounce <= 1000){
      suppressSpeedBoost(ball, now);
    }
    ball.lastCeilingBounce = now;
  }

  function applyBounceNudge(ball, axis){
    const sp=Math.hypot(ball.vx,ball.vy);
    if(sp<=0.0001) return;
    const minFrac=0.18;
    if(axis==='y'){
      let sign=Math.sign(ball.vx);
      if(!sign) sign=Math.random()<0.5?-1:1;
      const target=Math.max(Math.abs(ball.vx), sp*minFrac);
      const newVX=sign*target;
      const vySign=Math.sign(ball.vy)||1;
      const remain=Math.sqrt(Math.max(sp*sp - newVX*newVX, 0));
      ball.vx=newVX;
      ball.vy=vySign*remain;
    }else if(axis==='x'){
      let sign=Math.sign(ball.vy);
      if(!sign) sign=Math.random()<0.5?-1:1;
      const target=Math.max(Math.abs(ball.vy), sp*minFrac);
      const newVY=sign*target;
      const vxSign=Math.sign(ball.vx)||1;
      const remain=Math.sqrt(Math.max(sp*sp - newVY*newVY, 0));
      ball.vx=vxSign*remain;
      ball.vy=newVY;
    }
  }

  function noteBounce(ball, x, y, axis, now){
    if(!ball) return;
    const last=ball.lastBounce;
    const maxDist=8;
    const maxInterval=800;
    if(last && last.axis===axis && now-last.time<=maxInterval){
      const dx=x-last.x;
      const dy=y-last.y;
      if(Math.hypot(dx,dy)<=maxDist){
        const count=last.count+1;
        ball.lastBounce={axis,time:now,x,y,count};
        if(count>=3){
          applyBounceNudge(ball, axis);
          ball.lastBounce={axis,time:now,x,y,count:0};
        }
        return;
      }
    }
    ball.lastBounce={axis,time:now,x,y,count:1};
  }

  // === 聲音與BGM ===

  // === BGM 主題依關卡段落 ===
  function bgmThemeForLevel(lv){
    if(lv<=4) return 'picnic';      // 開心郊遊
    if(lv===5) return 'lion';       // 獅子王決戰
    if(lv<=9) return 'castle';      // 攻入城堡
    if(lv===10) return 'duel';      // 騎士對決
    if(lv<=14) return 'valley';     // 潛入巨人山谷
    if(lv===15) return 'giant';     // 決戰巨人
    if(lv<=19) return 'demon';      // 惡魔城
    return 'finale';                // 最終魔王
  }

  // === BGM 變奏資料 ===
  function midi(n){ return 440*Math.pow(2,(n-69)/12); }
  const transposeSeq=(seq,s)=>seq.map(ch=>Array.isArray(ch)?ch.map(n=>n+s):ch+s);
  const rotateSeq=(arr,k)=>arr.slice(k).concat(arr.slice(0,k));

  function buildTheme(tempo, chords, melody){
    const play=(ch,mel,start,tone)=>{
      const beat=60/tempo;
      ch.forEach((c,i)=>c.forEach(n=>tone(midi(n),'triangle', start+i*4*beat, 3.8*beat, 0.04)));
      mel.forEach((m,i)=>tone(midi(m),'sine', start+i*2*beat, 1.6*beat, 0.045));
      for(let i=0;i<32;i++){ tone(100,'square', start+i*beat, 0.05*beat, 0.015); }
      return 32*beat;
    };
    return {
      tempo,
      patterns:[
        (t,tn)=>play(chords, melody, t, tn),
        (t,tn)=>play(transposeSeq(chords,2), melody, t, tn),
        (t,tn)=>play(chords, transposeSeq(melody,2), t, tn),
        (t,tn)=>play(rotateSeq(chords,2), melody, t, tn)
      ]
    };
  }

  const BGM_PATTERNS={
    picnic: buildTheme(100,
      [[60,64,67],[65,69,72],[67,71,74],[60,64,67],[57,60,64],[62,65,69],[67,71,74],[60,64,67]],
      [72,74,76,79,76,74,72,69,72,74,76,74,72,69,67,69]),
    lion: buildTheme(120,
      [[62,65,69],[58,62,65],[60,64,67],[62,65,69],[65,69,72],[60,64,67],[62,65,69],[57,62,65]],
      [74,74,76,74,72,71,72,74,76,74,72,69,67,69,71,72]),
    castle: buildTheme(90,
      [[64,67,71],[60,64,67],[62,65,69],[59,62,67],[64,67,71],[60,64,67],[62,65,69],[64,67,71]],
      [76,74,72,71,72,74,76,78,76,74,72,71,69,71,72,74]),
    duel: buildTheme(110,
      [[67,71,74],[64,67,71],[60,64,67],[62,65,69],[67,71,74],[60,64,67],[57,60,64],[62,65,69]],
      [79,76,74,72,74,76,79,81,79,76,74,72,74,76,77,79]),
    valley: buildTheme(100,
      [[69,73,76],[66,69,73],[62,66,69],[64,69,72],[69,73,76],[64,69,72],[62,66,69],[59,62,66]],
      [81,78,76,74,76,78,81,83,81,78,76,74,76,78,79,81]),
    giant: buildTheme(80,
      [[65,68,72],[63,66,70],[60,63,67],[58,61,65],[65,68,72],[60,63,67],[63,66,70],[65,68,72]],
      [77,75,72,70,72,75,77,79,77,75,72,70,72,75,77,79]),
    demon: buildTheme(140,
      [[71,74,78],[67,71,74],[69,72,76],[65,69,72],[71,74,78],[67,71,74],[69,72,76],[71,74,78]],
      [83,81,78,76,78,81,83,85,83,81,78,76,78,81,83,85]),
    finale: buildTheme(150,
      [[60,63,67],[65,68,72],[70,74,77],[65,68,72],[60,63,67],[65,68,72],[70,74,77],[72,75,79]],
      [72,75,77,79,77,75,72,70,72,75,77,75,72,70,68,70])
  };

  let currentBGMTheme=null;
  let bgmTimer=null;
  function startBGMTheme(theme){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || !bgmOn) return;
    clearInterval(bgmTimer);
    bgmTimer=null;
    stopBGM();
    bgmStarted=true;
    currentBGMTheme=theme;
    const data=BGM_PATTERNS[theme];
    let variant=0;
    const beat=60/data.tempo;
    const patternDur=32*beat;
    const scheduleAhead=0.1;
    function tone(freq,type,start,dur,gain=0.045){
      const o=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value=0; o.connect(g); g.connect(bgmGain);
      o.start(start); g.gain.setTargetAtTime(gain,start,0.015);
      g.gain.setTargetAtTime(0.0001,start+dur-0.03,0.02);
      o.stop(start+dur+0.1);
      // 將 node 記錄於集合中，並在播放結束後移除以避免累積
      bgmNodes.add(o); bgmNodes.add(g);
      o.onended = () => { try{o.disconnect();}catch{} try{g.disconnect();}catch{} bgmNodes.delete(o); bgmNodes.delete(g); };
    }
    function playVariant(){
      if(!bgmOn || !bgmStarted) return;
      const base=audioCtx.currentTime+0.05;
      data.patterns[variant](base, tone);
      variant=(variant+1)%data.patterns.length;
    }
    // 於所有變奏播放完後，自動回到第一種變奏，並持續循環
    playVariant();
    bgmTimer=setInterval(playVariant, Math.max(0,(patternDur-scheduleAhead))*1000);
  }
  function applyBGMThemeForLevel(){
    const theme = bgmThemeForLevel(level);
    if(theme!==currentBGMTheme){ startBGMTheme(theme); }
  }

  function ensureAudio(){ if(!audioCtx){ const AC=(window.AudioContext||window.webkitAudioContext); if(AC){ audioCtx=new AC(); } } if(audioCtx && !bgmGain){ bgmGain=audioCtx.createGain(); bgmGain.gain.value=parseFloat(localStorage.getItem('bgm_vol')||'0.7'); bgmGain.connect(audioCtx.destination); } }
  function beep(freq=600,dur=0.05,vol=0.06){ if(!soundsOn||!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.stop(); }, Math.max(10, dur*1000)); }

  function playSFX(type){
    if(!soundsOn) return; if(!audioCtx) ensureAudio(); if(!audioCtx) return;
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    switch(type){
      case 'explosion':
        o.type='sawtooth';
        o.frequency.setValueAtTime(200, now);
        o.frequency.exponentialRampToValueAtTime(40, now+0.4);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.4);
        o.start(now); o.stop(now+0.4); break;
      case 'coin':
        o.type='sine';
        o.frequency.setValueAtTime(900, now);
        o.frequency.linearRampToValueAtTime(1400, now+0.18);
        g.gain.setValueAtTime(0.045, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.25);
        o.start(now); o.stop(now+0.3); break;
      case 'bladeHellBeamExpand':
        o.type='triangle';
        o.frequency.setValueAtTime(260, now);
        o.frequency.linearRampToValueAtTime(1040, now+1.4);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.linearRampToValueAtTime(0.05, now+0.1);
        g.gain.exponentialRampToValueAtTime(0.0001, now+1.6);
        o.start(now); o.stop(now+1.6);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='sine';
        shimmer.frequency.setValueAtTime(1200, now);
        shimmer.frequency.linearRampToValueAtTime(2000, now+0.6);
        shimmerGain.gain.setValueAtTime(0.015, now);
        shimmerGain.gain.linearRampToValueAtTime(0.04, now+0.25);
        shimmerGain.gain.exponentialRampToValueAtTime(0.0001, now+1.2);
        shimmer.connect(shimmerGain); shimmerGain.connect(audioCtx.destination);
        shimmer.start(now); shimmer.stop(now+1.2);
        const sparkleBuffer=audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*1.4), audioCtx.sampleRate);
        const sparkleData=sparkleBuffer.getChannelData(0);
        for(let i=0;i<sparkleData.length;i++){
          const t=i/sparkleData.length;
          const envelope=1-Math.pow(t,0.35);
          sparkleData[i]=(Math.random()*2-1)*0.35*envelope;
        }
        const sparkle=audioCtx.createBufferSource();
        sparkle.buffer=sparkleBuffer;
        const sparkleFilter=audioCtx.createBiquadFilter();
        sparkleFilter.type='highpass';
        sparkleFilter.frequency.setValueAtTime(1500, now);
        sparkleFilter.Q=1.2;
        const sparkleGain=audioCtx.createGain();
        sparkleGain.gain.setValueAtTime(0.12, now);
        sparkleGain.gain.exponentialRampToValueAtTime(0.0001, now+1.5);
        sparkle.connect(sparkleFilter);
        sparkleFilter.connect(sparkleGain);
        sparkleGain.connect(audioCtx.destination);
        sparkle.start(now);
        sparkle.stop(now+1.5);
        break;
      case 'laser':
        o.type='square';
        o.frequency.setValueAtTime(1200, now);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.15);
        o.start(now); o.stop(now+0.15); break;
      case 'sword':
        o.type='triangle';
        o.frequency.setValueAtTime(900, now);
        o.frequency.linearRampToValueAtTime(600, now+0.1);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.2);
        o.start(now); o.stop(now+0.2); break;
      case 'pierce':
        o.type='square';
        o.frequency.setValueAtTime(700, now);
        g.gain.setValueAtTime(0.04, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.1);
        o.start(now); o.stop(now+0.1); break;
      case 'holy':
        o.type='sine';
        o.frequency.setValueAtTime(880, now);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.5);
        o.start(now); o.stop(now+0.5); break;
      case 'abyssBrickLaunch':{
        o.type='sawtooth';
        o.frequency.setValueAtTime(260, now);
        o.frequency.exponentialRampToValueAtTime(780, now+0.28);
        g.gain.setValueAtTime(0.045, now);
        g.gain.linearRampToValueAtTime(0.06, now+0.12);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.5);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='triangle';
        shimmer.frequency.setValueAtTime(920, now);
        shimmer.frequency.linearRampToValueAtTime(1400, now+0.22);
        shimmerGain.gain.setValueAtTime(0.018, now);
        shimmerGain.gain.exponentialRampToValueAtTime(0.0008, now+0.5);
        shimmer.connect(shimmerGain);
        shimmerGain.connect(audioCtx.destination);
        const noiseBuffer=audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.4), audioCtx.sampleRate);
        const noiseData=noiseBuffer.getChannelData(0);
        for(let i=0;i<noiseData.length;i++){
          const t=i/noiseData.length;
          const env=1-Math.pow(t,0.6);
          noiseData[i]=(Math.random()*2-1)*0.18*env;
        }
        const noise=audioCtx.createBufferSource();
        noise.buffer=noiseBuffer;
        const noiseFilter=audioCtx.createBiquadFilter();
        noiseFilter.type='bandpass';
        noiseFilter.frequency.setValueAtTime(820, now);
        noiseFilter.Q=1.8;
        const noiseGain=audioCtx.createGain();
        noiseGain.gain.setValueAtTime(0.028, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.0001, now+0.45);
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        o.start(now); o.stop(now+0.5);
        shimmer.start(now); shimmer.stop(now+0.5);
        noise.start(now); noise.stop(now+0.45);
        break;
      }
      case 'abyssBrickShatter':{
        o.type='triangle';
        o.frequency.setValueAtTime(720, now);
        o.frequency.exponentialRampToValueAtTime(240, now+0.32);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.34);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='sine';
        shimmer.frequency.setValueAtTime(1600, now);
        shimmer.frequency.exponentialRampToValueAtTime(520, now+0.34);
        shimmerGain.gain.setValueAtTime(0.02, now);
        shimmerGain.gain.exponentialRampToValueAtTime(0.0001, now+0.34);
        shimmer.connect(shimmerGain);
        shimmerGain.connect(audioCtx.destination);
        const crackleBuffer=audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.36), audioCtx.sampleRate);
        const crackle=crackleBuffer.getChannelData(0);
        for(let i=0;i<crackle.length;i++){
          const t=i/crackle.length;
          const envelope=Math.pow(1-t,0.45);
          crackle[i]=(Math.random()*2-1)*0.42*envelope;
        }
        const crackleSrc=audioCtx.createBufferSource();
        crackleSrc.buffer=crackleBuffer;
        const crackleFilter=audioCtx.createBiquadFilter();
        crackleFilter.type='highpass';
        crackleFilter.frequency.setValueAtTime(1800, now);
        crackleFilter.Q=0.8;
        const crackleGain=audioCtx.createGain();
        crackleGain.gain.setValueAtTime(0.08, now);
        crackleGain.gain.exponentialRampToValueAtTime(0.0001, now+0.38);
        crackleSrc.connect(crackleFilter);
        crackleFilter.connect(crackleGain);
        crackleGain.connect(audioCtx.destination);
        o.start(now); o.stop(now+0.34);
        shimmer.start(now); shimmer.stop(now+0.34);
        crackleSrc.start(now); crackleSrc.stop(now+0.38);
        break;
      }
      case 'abyssPlatformBreak':{
        o.type='sawtooth';
        o.frequency.setValueAtTime(240, now);
        o.frequency.exponentialRampToValueAtTime(60, now+0.6);
        g.gain.setValueAtTime(0.085, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.6);
        const sub=audioCtx.createOscillator();
        const subGain=audioCtx.createGain();
        sub.type='sine';
        sub.frequency.setValueAtTime(70, now);
        sub.frequency.exponentialRampToValueAtTime(24, now+0.7);
        subGain.gain.setValueAtTime(0.16, now);
        subGain.gain.exponentialRampToValueAtTime(0.001, now+0.7);
        sub.connect(subGain);
        subGain.connect(audioCtx.destination);
        const sprayBuffer=audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.7), audioCtx.sampleRate);
        const sprayData=sprayBuffer.getChannelData(0);
        for(let i=0;i<sprayData.length;i++){
          const t=i/sprayData.length;
          const envelope=Math.pow(1-t,0.3);
          sprayData[i]=(Math.random()*2-1)*0.6*envelope;
        }
        const spray=audioCtx.createBufferSource();
        spray.buffer=sprayBuffer;
        const sprayFilter=audioCtx.createBiquadFilter();
        sprayFilter.type='bandpass';
        sprayFilter.frequency.setValueAtTime(680, now);
        sprayFilter.Q=1.4;
        const sprayGain=audioCtx.createGain();
        sprayGain.gain.setValueAtTime(0.12, now);
        sprayGain.gain.exponentialRampToValueAtTime(0.0001, now+0.7);
        spray.connect(sprayFilter);
        sprayFilter.connect(sprayGain);
        sprayGain.connect(audioCtx.destination);
        const chime=audioCtx.createOscillator();
        const chimeGain=audioCtx.createGain();
        chime.type='triangle';
        chime.frequency.setValueAtTime(1200, now);
        chime.frequency.exponentialRampToValueAtTime(420, now+0.5);
        chimeGain.gain.setValueAtTime(0.03, now);
        chimeGain.gain.exponentialRampToValueAtTime(0.0001, now+0.5);
        chime.connect(chimeGain);
        chimeGain.connect(audioCtx.destination);
        o.start(now); o.stop(now+0.6);
        sub.start(now); sub.stop(now+0.7);
        spray.start(now); spray.stop(now+0.7);
        chime.start(now); chime.stop(now+0.5);
        break;
      }
      case 'demonTeleport':{
        o.type='sine';
        o.frequency.setValueAtTime(680, now);
        o.frequency.exponentialRampToValueAtTime(1200, now+0.25);
        g.gain.setValueAtTime(0.05, now);
        g.gain.linearRampToValueAtTime(0.022, now+0.12);
        g.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='triangle';
        shimmer.frequency.setValueAtTime(1800, now);
        shimmer.frequency.exponentialRampToValueAtTime(900, now+0.4);
        shimmerGain.gain.setValueAtTime(0.015, now);
        shimmerGain.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
        shimmer.connect(shimmerGain);
        shimmerGain.connect(audioCtx.destination);
        shimmer.start(now);
        shimmer.stop(now+0.6);
        const noise=audioCtx.createBufferSource();
        const noiseBuffer=audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.4), audioCtx.sampleRate);
        const data=noiseBuffer.getChannelData(0);
        for(let i=0;i<data.length;i++){
          const t=i/data.length;
          const envelope=1-Math.pow(t,0.4);
          data[i]=(Math.random()*2-1)*0.25*envelope;
        }
        noise.buffer=noiseBuffer;
        const noiseGain=audioCtx.createGain();
        noiseGain.gain.setValueAtTime(0.02, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.0001, now+0.5);
        noise.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.start(now);
        noise.stop(now+0.5);
        o.start(now);
        o.stop(now+0.6);
        break;
      }
      case 'missile':
        o.type='sawtooth';
        o.frequency.setValueAtTime(1000, now);
        o.frequency.linearRampToValueAtTime(300, now+0.3);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.3);
        o.start(now); o.stop(now+0.3); break;
      case 'blackhole':{
        o.type='sine';
        o.frequency.setValueAtTime(90, now);
        o.frequency.exponentialRampToValueAtTime(28, now+0.8);
        g.gain.setValueAtTime(0.09, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        const sub=audioCtx.createOscillator();
        const subGain=audioCtx.createGain();
        sub.type='sawtooth';
        sub.frequency.setValueAtTime(45, now);
        sub.frequency.exponentialRampToValueAtTime(18, now+0.8);
        subGain.gain.setValueAtTime(0.04, now);
        subGain.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        sub.connect(subGain); subGain.connect(audioCtx.destination);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='triangle';
        shimmer.frequency.setValueAtTime(620, now);
        shimmer.frequency.linearRampToValueAtTime(980, now+0.25);
        shimmer.frequency.exponentialRampToValueAtTime(320, now+0.8);
        shimmerGain.gain.setValueAtTime(0.02, now);
        shimmerGain.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        shimmer.connect(shimmerGain); shimmerGain.connect(audioCtx.destination);
        o.start(now); o.stop(now+0.8);
        sub.start(now); sub.stop(now+0.8);
        shimmer.start(now+0.05); shimmer.stop(now+0.8);
        break;
      }
      case 'phoenix':
        o.type='sine';
        o.frequency.setValueAtTime(800, now);
        o.frequency.linearRampToValueAtTime(1200, now+0.15);
        o.frequency.linearRampToValueAtTime(600, now+0.3);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.4);
        const oP=audioCtx.createOscillator(), gP=audioCtx.createGain();
        oP.type='sine'; gP.gain.value=0.05; oP.connect(gP); gP.connect(audioCtx.destination);
        oP.frequency.setValueAtTime(1200, now);
        oP.frequency.linearRampToValueAtTime(2000, now+0.15);
        oP.frequency.linearRampToValueAtTime(900, now+0.3);
        o.start(now); o.stop(now+0.4); oP.start(now); oP.stop(now+0.4); break;
      case 'spaceBossVolleyCharge':
        o.type='sawtooth';
        o.frequency.setValueAtTime(260, now);
        o.frequency.exponentialRampToValueAtTime(120, now+0.5);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.5);
        o.start(now); o.stop(now+0.5); break;
      case 'spaceBossVolleyShot':
        o.type='triangle';
        o.frequency.setValueAtTime(1400, now);
        o.frequency.exponentialRampToValueAtTime(520, now+0.18);
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.18);
        o.start(now); o.stop(now+0.2); break;
      case 'spaceBossLaserCharge':
        o.type='sine';
        o.frequency.setValueAtTime(320, now);
        o.frequency.linearRampToValueAtTime(960, now+0.8);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.8);
        const oCharge=audioCtx.createOscillator(), gCharge=audioCtx.createGain();
        oCharge.type='sawtooth'; gCharge.gain.value=0.02; oCharge.connect(gCharge); gCharge.connect(audioCtx.destination);
        oCharge.frequency.setValueAtTime(180, now);
        oCharge.frequency.linearRampToValueAtTime(540, now+0.8);
        o.start(now); o.stop(now+0.8); oCharge.start(now); oCharge.stop(now+0.8); break;
      case 'spaceBossLaserSweep':
        o.type='square';
        o.frequency.setValueAtTime(900, now);
        g.gain.setValueAtTime(0.07, now);
        g.gain.linearRampToValueAtTime(0.02, now+0.5);
        const oSweep=audioCtx.createOscillator(), gSweep=audioCtx.createGain();
        oSweep.type='triangle'; gSweep.gain.value=0.03; oSweep.connect(gSweep); gSweep.connect(audioCtx.destination);
        oSweep.frequency.setValueAtTime(400, now);
        oSweep.frequency.exponentialRampToValueAtTime(1200, now+0.5);
        o.start(now); o.stop(now+0.5); oSweep.start(now); oSweep.stop(now+0.5); break;
      case 'annihil':
        o.type='sawtooth';
        o.frequency.setValueAtTime(300, now);
        o.frequency.exponentialRampToValueAtTime(60, now+0.3);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.3);
        o.start(now); o.stop(now+0.3); break;
      case 'steam':
        o.type='sawtooth';
        o.frequency.setValueAtTime(800, now);
        o.frequency.exponentialRampToValueAtTime(200, now+0.4);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.4);
        o.start(now); o.stop(now+0.4); break;
      case 'gatlingShoot':
        o.type='square';
        o.frequency.setValueAtTime(900, now);
        g.gain.setValueAtTime(0.04, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.07);
        o.start(now); o.stop(now+0.07); break;
      case 'gatlingHit':
        o.type='sawtooth';
        o.frequency.setValueAtTime(300, now);
        o.frequency.exponentialRampToValueAtTime(80, now+0.15);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.15);
        o.start(now); o.stop(now+0.15); break;
      case 'plasma':
        o.type='square';
        o.frequency.setValueAtTime(1200, now);
        o.frequency.exponentialRampToValueAtTime(300, now+0.2);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.2);
        o.start(now); o.stop(now+0.2); break;
      case 'plasmaHit':
        o.type='sawtooth';
        o.frequency.setValueAtTime(600, now);
        o.frequency.exponentialRampToValueAtTime(120, now+0.2);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.2);
        o.start(now); o.stop(now+0.2); break;
      case 'dragonAnnihilation':{
        o.type='sawtooth';
        o.frequency.setValueAtTime(160, now);
        o.frequency.exponentialRampToValueAtTime(30, now+1.2);
        g.gain.setValueAtTime(0.12, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+1.2);
        const sub=audioCtx.createOscillator();
        const subGain=audioCtx.createGain();
        sub.type='sine';
        sub.frequency.setValueAtTime(48, now);
        sub.frequency.exponentialRampToValueAtTime(18, now+1.4);
        subGain.gain.setValueAtTime(0.16, now);
        subGain.gain.exponentialRampToValueAtTime(0.001, now+1.4);
        sub.connect(subGain); subGain.connect(audioCtx.destination);
        const shimmer=audioCtx.createOscillator();
        const shimmerGain=audioCtx.createGain();
        shimmer.type='triangle';
        shimmer.frequency.setValueAtTime(960, now);
        shimmer.frequency.exponentialRampToValueAtTime(320, now+0.9);
        shimmerGain.gain.setValueAtTime(0.03, now);
        shimmerGain.gain.exponentialRampToValueAtTime(0.001, now+0.9);
        shimmer.connect(shimmerGain); shimmerGain.connect(audioCtx.destination);
        const buffer=audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*1.2), audioCtx.sampleRate);
        const data=buffer.getChannelData(0);
        for(let i=0;i<data.length;i++){
          const t=i/data.length;
          data[i]=(Math.random()*2-1)*(1-Math.pow(t,0.45))*0.6;
        }
        const noise=audioCtx.createBufferSource();
        const noiseGain=audioCtx.createGain();
        noise.buffer=buffer;
        noiseGain.gain.setValueAtTime(0.18, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, now+1.1);
        noise.connect(noiseGain); noiseGain.connect(audioCtx.destination);
        o.start(now); o.stop(now+1.2);
        sub.start(now); sub.stop(now+1.4);
        shimmer.start(now+0.05); shimmer.stop(now+0.9);
        noise.start(now); noise.stop(now+1.2);
        break;
      }
      case 'fireExplosion':
        o.type='sawtooth';
        o.frequency.setValueAtTime(400, now);
        o.frequency.exponentialRampToValueAtTime(30, now+0.6);
        g.gain.setValueAtTime(0.1, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.6);
        o.start(now); o.stop(now+0.6); break;
      case 'win':
        o.type='triangle';
        g.gain.setValueAtTime(0.04, now);
        o.frequency.setValueAtTime(660, now);
        o.start(now); o.stop(now+0.2);
        const o2=audioCtx.createOscillator(), g2=audioCtx.createGain();
        o2.type='triangle'; g2.gain.value=0.04; o2.connect(g2); g2.connect(audioCtx.destination);
        o2.frequency.setValueAtTime(880, now+0.2);
        o2.start(now+0.2); o2.stop(now+0.5); break;
      case 'lose':
        o.type='sawtooth';
        o.frequency.setValueAtTime(200, now);
        o.frequency.exponentialRampToValueAtTime(60, now+0.6);
        g.gain.setValueAtTime(0.05, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.6);
        o.start(now); o.stop(now+0.6); break;
      default:
        o.type='square';
        o.frequency.setValueAtTime(600, now);
        g.gain.setValueAtTime(0.06, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.1);
    o.start(now); o.stop(now+0.1); break;
    }
  }

  // 專屬齒輪騎士的按鍵蒸汽音效
  document.addEventListener('click', (e) => {
    if(window.currentSkin && window.currentSkin.cssSkin === '機械．齒輪騎士' && e.target.closest('button')){
      playSFX('steam');
    }
  }, {passive:true});

  function startBGM(){
    if(!audioCtx) ensureAudio();
    if(!audioCtx || bgmStarted) return; audioCtx.resume?.(); bgmStarted=true; applyBGMThemeForLevel();
  }
  function stopBGM(){
    clearInterval(bgmTimer);
    bgmTimer=null;
    bgmStarted=false;
    bgmNodes.forEach(n=>{try{n.disconnect?.();}catch{}});
    bgmNodes.clear();
  }

  // === 磚塊與揭示 ===
  let bricks=[]; let brickW=0, brickH=GAME_CONFIG.bricks.brickHeight; let revealRects=[];
  let brickIdCounter=0;
  function layout(){ return {rows:getDiff().rowsBase+Math.floor((level-1)%3), cols:GAME_CONFIG.bricks.cols, pad:GAME_CONFIG.bricks.padding, top:GAME_CONFIG.bricks.topOffset, h:GAME_CONFIG.bricks.brickHeight}; }

  // 取得本關顯示影像（1~10隨機BG/CG；11~20用另一張）
  function getLevelImage(levelNum){
    const idx=((levelNum-1)%10);
    const imgs = loadImagePair(idx);
    let img;
    if(levelNum<=10){
      if(imageChoice[idx]<0){ imageChoice[idx]= Math.random()<0.5 ? 0:1; }
      img = imageChoice[idx]===0? imgs.bg : imgs.cg;
    }else{
      if(imageChoice[idx]<0){ imageChoice[idx]=0; } // 保底
      img = imageChoice[idx]===0? imgs.cg : imgs.bg;
    }
    return img;
  }

  function getLevelImageKey(levelNum){
    const idx=((levelNum-1)%10);
    if(levelNum<=10){
      if(imageChoice[idx]<0){ imageChoice[idx]= Math.random()<0.5 ? 0:1; }
      return imageChoice[idx]===0 ? `bg${idx+1}` : `cg${idx+1}`;
    }else{
      if(imageChoice[idx]<0){ imageChoice[idx]=0; }
      return imageChoice[idx]===0 ? `cg${idx+1}` : `bg${idx+1}`;
    }
  }

  // 特殊磚模板
  function addBrick(list, x,y,w,h, opts={}){
    const id = (opts.id!=null)?opts.id:brickIdCounter++;
    list.push(Object.assign({id,x,y,w,h,hp:opts.unbreakable?Infinity:(opts.hp||1), colorIdx:0, explosive:false, unbreakable:false, strong:false, moving:false, vx:0, vy:0, boss:false, face:''}, opts));
  }

  
  function postAdjustAndDensify(L){
    // 將一般磚血量平滑上限為 4，並補磚至 >= 3/4 面積
    const rows=L.rows, cols=L.cols, pad=L.pad;
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // 佔用網格
    const occ = Array.from({length:rows}, ()=> Array(cols).fill(false));
    function markRect(x,y,w,h){
      const cellW = brickW, cellH = brickH;
      const c0 = Math.max(0, Math.min(cols-1, Math.round((x - L.pad) / (cellW + L.pad)) ));
      const r0 = Math.max(0, Math.min(rows-1, Math.round((y - L.top) / (cellH + L.pad)) ));
      const cellsX = Math.max(1, Math.round((w + L.pad) / (cellW + L.pad)));
      const cellsY = Math.max(1, Math.round((h + L.pad) / (cellH + L.pad)));
      for(let rr=0; rr<cellsY; rr++){
        for(let cc=0; cc<cellsX; cc++){
          const c = Math.min(cols-1, c0 + cc);
          const r = Math.min(rows-1, r0 + rr);
          occ[r][c] = true;
        }
      }
    }
    // 先夾血量 + 標記既有佔用
    for(const b of bricks){
      if(!b.unbreakable && !b.boss){
        b.hp = clampHP(b.hp||1);
      }
      markRect(b.x,b.y,b.w,b.h);
    }
    // 計算覆蓋度
    let filled = 0;
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(occ[r][c]) filled++;
    const target = Math.ceil(rows*cols * 0.75);
    if(filled >= target) return;

    // 由中心往外補磚，維持美感
    const midC = (cols-1)/2, midR = (rows-1)/2;
    const empties = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(!occ[r][c]){
          const score = (c-midC)**2 + (r-midR)**2;
          empties.push({r,c,score});
        }
      }
    }
    

    empties.sort((a,b)=> a.score - b.score);
    const baseHP = Math.min(1 + Math.floor((level-1)/5), 3);
    let idx=0;
    while(filled < target && idx<empties.length){
      const {r,c} = empties[idx++];
      if(occ[r][c]) continue;
      let hp = baseHP + ((level>=13 && r>rows/2)?1:0);
      hp = clampHP(hp);
      const moving = (Math.random()<0.08) && (r%2===0);
      const vx = moving ? ((Math.random()<0.5?-1:1)*0.6) : 0;
      addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp, colorIdx:(r%4), moving, vx});
      occ[r][c] = true  
      filled += 1;
    }
  }

  function initBricks(){
      const L=layout();
      const totalPad=(L.cols+1)*L.pad; brickW=Math.floor((1100-totalPad)/L.cols); brickH=L.h; bricks=[]; revealRects=[]; brickIdCounter=0;
      toxicRebirthTriggered=false;
      toxicRebirthGlowUntil=0;
      nextGodspeedHolyStrike=0;
    finalVictorySequence=null;
    spaceBoss=null;
    spaceBossAnchor=null;
    spaceBossPlaceholder=null;
    spaceBossBursts=[];
    clearActivePlagueTimers();
    starProjectiles.length=0;
    moonProjectiles.length=0;
    solarBurstNextAt=0;
    spaceBossMarquee=null;
    spaceBossRevealScheduled=0;
    spaceBossDefeatedAt=0;
    spaceBossAttack=null;
    spaceBossNextAttackAt=0;
    spaceBossBullets.length=0;
    spaceBossPaddlePenalty=0;
    spaceBossPaddleRespawnAt=0;
    spaceBossDeathAnim=null;
    spaceBossSuppressLifeLossUntil=0;
    spaceBossPhase = (level===5?'awaiting':'inactive');
    reaperBoss=null;
    reaperAnchor=null;
    reaperPlaceholder=null;
    reaperBursts=[];
    reaperAfterimages=[];
    reaperMarquee=null;
    reaperRevealScheduled=0;
    reaperDefeatedAt=0;
    reaperDeathAnim=null;
    reaperTeleportSchedule=null;
    reaperTargetHighlightUntil=0;
    reaperAttackState=null;
    reaperSlashZone=null;
    reaperSlashEffects=[];
    reaperBlackHoleAttack=null;
    reaperLifeLossCooldownUntil=0;
    reaperPaddlePenalty=0;
    reaperPenaltyLastUpdate=0;
    reaperPhase = (level===10?'awaiting':'inactive');
    dragonBoss=null;
    dragonAnchor=null;
    dragonPlaceholder=null;
    dragonBursts=[];
    dragonMarquee=null;
    dragonRevealScheduled=0;
    dragonDefeatedAt=0;
    dragonDeathAnim=null;
    dragonAttackState=null;
    dragonNextAttackAt=0;
    dragonDeathRayOrbs.length=0;
    dragonDeathRayBeams.length=0;
      dragonPhase = (level===15?'awaiting':'inactive');
      // Reset Cyclops/dragon forced petrify trigger so level 15 always re-schedules it
      cyclopsForcedPetrifyAt=0;
      cyclopsForcedPetrifyFired=false;
      cyclopsFirstAttackAt=0;
    cyclopsEventStarted=false;
    cyclopsMarqueeShown=false;
    cyclopsRowBlastIndex=-1;
    cyclopsNextRowBlast=0;
    cyclopsShellBurst=false;
    cyclopsEventComplete=false;
    demonShellBrick=null;
    demonEventPhase = (level===20?'awaiting':'inactive');
    demonEventTimerStart=0;
    demonEventTriggeredAt=0;
    demonEventMarquee=null;
    demonEventWave=null;
    demonDeathShockwaves=[];
    demonDeathFlares=[];
    demonEventRows=[];
    demonEventNextRowAt=0;
    demonFallingDebris=[];
    demonEventShakeUntil=0;
    demonCore=null;
    demonEventTargets=0;
    demonEventCleared=0;
    demonPhase = (level===20?'awaiting':'inactive');
    demonBoss=null;
    demonRevealScheduled=0;
    demonAfterimages=[];
    demonTeleportTrails=[];
    demonDeathAnim=null;
    demonDefeatedAt=0;
    demonAttackActive=null;
    demonAttackNextAt=0;
    demonVoidVolleyState=null;
    demonVoidProjectiles.length=0;
    demonVoidNextRoll=0;
    demonBlackSpears=[];
    const lvlImg = getLevelImage(level);
    if (lvlImg && lvlImg.decode) { lvlImg.decode().catch(()=>{}); }
    // 依關卡設計關卡布局
    generateLevel(level, L);
    postAdjustAndDensify(L);
    // 放置菁英磚（第6關以後，最多2個）
    if(level>=6){ let placed=0; const candidates=bricks.filter(b=>!b.unbreakable && !b.boss);
      const cx=1100/2, cy=(layout().top + (layout().rows* (brickH+layout().pad) - layout().pad))/2;
      candidates.sort((a,b)=> (Math.hypot((a.x+a.w/2)-cx,(a.y+a.h/2)-cy) - Math.hypot((b.x+b.w/2)-cx,(b.y+b.h/2)-cy)) );
      for(const b of candidates){ if(placed>=2) break; b.elite=true; b.hp=Math.min(5, Math.max(3, b.hp||3)); placed++; }
    }
    // 重置 Boss 計時
    nextBossAtkA = nextBossAtkB = bossChargeUntil = cyclopsShakeUntil = 0; bossChargeColor='';
    if(level===15){
      // 進入第15關時預先排程強制石化光束。
      // 石化光束需蓄力3秒，因此預留 5 秒的進場緩衝後立即開始蓄力，
      // 讓光束在倒數結束時（約進場 5 秒）擊中舞台、觸發真身現身。
      const forcedDelay = 5000; // 進場後希望光束命中的時間
      const petrifyCharge = 3000; // 光束施放所需蓄力時間
      cyclopsForcedPetrifyAt = performance.now() + Math.max(0, forcedDelay - petrifyCharge);
    }
  }

  
  
  // === 修正：過關判定改為只看「可破壞磚」是否清空 ===
  function hasBreakables(){
    if(level===5){
      const now=performance.now();
      const breakables = bricks.some(b => !b.unbreakable && !b.treasure);
      if(breakables) return true;
      if(spaceBossPhase==='awaiting'){ startSpaceBossReveal(); return true; }
      if(spaceBossPhase==='intro' || spaceBossPhase==='active' || spaceBossPhase==='dying') return true;
      if(spaceBossPhase==='defeated' && spaceBossDefeatedAt && now < spaceBossDefeatedAt + 3000){
        return true;
      }
      return false;
    }
    if(level===10){
      const now=performance.now();
      const breakables = bricks.some(b => !b.unbreakable && !b.placeholderBoss && !b.treasure);
      if(breakables) return true;
      if(reaperPhase==='awaiting'){ startReaperReveal(); return true; }
      if(reaperPhase==='intro' || reaperPhase==='active' || reaperPhase==='dying') return true;
      if(reaperPhase==='defeated' && reaperDefeatedAt && now < reaperDefeatedAt + 3000){
        return true;
      }
      return false;
    }
    if(level===15){
      const now=performance.now();
      const hasBreakable = bricks.some(b => !b.unbreakable && !b.treasure && !b.placeholderBoss);
      if(hasBreakable) return true;
      if(dragonPhase==='awaiting'){
        if(dragonPlaceholder){ startDragonReveal(); return true; }
        const hasBossShell = bricks.some(b=>b.boss);
        if(hasBossShell) return true;
      }
      if(dragonPhase==='intro' || dragonPhase==='active' || dragonPhase==='dying') return true;
      if(dragonPhase==='defeated' && dragonDefeatedAt && now < dragonDefeatedAt + 3000){
        return true;
      }
      return false;
    }
    if(level===20){
      const now=performance.now();
      const remaining = bricks.some(b => !b.unbreakable && !b.demonShell);
      if(remaining) return true;
      if(demonPhase==='intro' || demonPhase==='event' || demonPhase==='active' || demonPhase==='dying') return true;
      if(demonPhase==='defeated' && demonDefeatedAt && now < demonDefeatedAt + 3000) return true;
      if(demonEventPhase && demonEventPhase!=='inactive' && demonEventPhase!=='complete') return true;
      return false;
    }
    return bricks.some(b => !b.unbreakable);
  }

  // === 第5關太空戰艦 Boss ===
  function startSpaceBossReveal(){
    if(spaceBossPhase!=='awaiting') return;
    const now=performance.now();
    spaceBossPhase='intro';
    let anchor=spaceBossAnchor;
    if(spaceBossPlaceholder){
      anchor={x:spaceBossPlaceholder.x, y:spaceBossPlaceholder.y, w:spaceBossPlaceholder.w, h:spaceBossPlaceholder.h};
      const cx=anchor.x+anchor.w/2;
      const cy=anchor.y+anchor.h/2;
      spawnParticles(cx,cy,'#fff5d6',120,3.2,5.0,5.5);
      spawnParticles(cx,cy,'#8ab6ff',90,2.6,4.2,4.6);
      spawnParticles(cx,cy,'#ff9fde',70,2.3,3.8,4.2);
      spaceBossBursts.push({type:'ring',x:cx,y:cy,r0:24,r1:420,width:18,t0:now,life:1400,color:'255,220,180'});
      spaceBossBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:240,t0:now,life:1100,color:'140,200,255'});
      spaceBossBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:160,t0:now,life:900,color:'255,180,220'});
      const idx=bricks.indexOf(spaceBossPlaceholder);
      if(idx>=0) bricks.splice(idx,1);
      spaceBossPlaceholder=null;
      spaceBossAnchor=anchor;
    }
    if(!spaceBossAnchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      const anchorW=brickW*2+L.pad;
      const anchorH=brickH*2+L.pad;
      const anchorX=L.pad + bx*(brickW+L.pad);
      spaceBossAnchor={x:anchorX,y:L.top,w:anchorW,h:anchorH};
    }
    spaceBossRevealScheduled = now + 900;
    screenShake=Math.max(screenShake,8);
    playSFX('fireExplosion');
  }

  function activateSpaceBoss(){
    if(spaceBossPhase!=='intro' || spaceBoss) return;
    let anchor=spaceBossAnchor;
    if(!anchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      anchor={x:L.pad + bx*(brickW+L.pad), y:L.top, w:brickW*2+L.pad, h:brickH*2+L.pad};
      spaceBossAnchor=anchor;
    }
    const cx=anchor.x+anchor.w/2;
    const baseY=anchor.y+anchor.h+80;
    const now=performance.now();
    resetBossNineCatDrop('space');
    spaceBoss={
      x:cx,
      y:baseY,
      baseY,
      w:220,
      h:120,
      vx:(Math.random()<0.5?-1:1)*2.6,
      hp:SPACE_BOSS_MAX_HP,
      maxHp:SPACE_BOSS_MAX_HP,
      hitCooldownUntil:0,
      hitFlashUntil:0,
      spawnAt:now,
      guns:[
        {offsetX:-70,offsetY:32,phase:0,angle:Math.PI/2,spin:0},
        {offsetX:0,offsetY:42,phase:1.2,angle:Math.PI/2,spin:0},
        {offsetX:70,offsetY:32,phase:2.3,angle:Math.PI/2,spin:0}
      ],
      lasers:[
        {offsetX:-92,offsetY:-4,phase:0.6,angle:Math.PI},
        {offsetX:92,offsetY:-4,phase:1.8,angle:Math.PI}
      ],
      thrusterPhase:0
    };
    spaceBossPhase='active';
    spaceBossBursts.push({type:'halo',x:cx,y:baseY,r0:40,r1:260,t0:now,life:1600,color:'130,200,255'});
    spaceBossAttack=null;
    spaceBossNextAttackAt=now + SPACE_BOSS_FIRST_ATTACK_DELAY;
    spaceBossBullets.length=0;
    spaceBossPaddlePenalty=0;
    spaceBossPaddleRespawnAt=0;
    spaceBossDeathAnim=null;
    spaceBossMarquee={text:'有趣！ 讓你見識我的真面目吧!', start:now, fadeStart:now+2600, end:now+3200, style:'alert'};
    scheduleNextTreasureBrick(now);
  }

  function damageSpaceBoss(amount=1, source='generic', impact, options=null){
    if(spaceBossPhase!=='active' || !spaceBoss) return false;
    const now=performance.now();
    const opts=options||{};
    if(spaceBoss.hitCooldownUntil && now<spaceBoss.hitCooldownUntil) return false;
    const dmg = Math.max(0, Math.floor(amount));
    if(!dmg) return false;
    spaceBoss.hitCooldownUntil = now + 140;
    const prevHp=spaceBoss.hp;
    spaceBoss.hp = Math.max(0, spaceBoss.hp - dmg);
    if(spaceBoss.hp<prevHp){ incrementCombo(); }
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    spaceBoss.hitFlashUntil = now + 220;
    const jitterX=(Math.random()-0.5)*spaceBoss.w*0.4;
    const jitterY=(Math.random()-0.5)*spaceBoss.h*0.3;
    const colorMap={
      laser:'255,210,240',
      missile:'255,215,180',
      gatling:'255,220,180',
      plasma:'190,240,255',
      blackhole:'200,220,255',
      phoenix:'255,210,200',
      sword:'255,240,220'
    };
    let burstColor=colorMap[source]||'160,220,255';
    if(opts.goldenFx){
      burstColor='255,220,140';
    }
    spaceBossBursts.push({type:'spark',x:spaceBoss.x+jitterX,y:spaceBoss.y+jitterY,r0:0,r1:140,t0:now,life:600,color:burstColor});
    if(impact && impact.x!=null && impact.y!=null){
      spawnParticles(impact.x, impact.y, '#b8d6ff', 22, 1.6, 2.6, 2.4);
    }
    spawnParticles(spaceBoss.x+jitterX, spaceBoss.y+jitterY, opts.goldenFx?'#ffd76a':'#8fbaff', 18, 1.5, 2.6, 2.3);
    screenShake=Math.max(screenShake,5);
    const toneMap={laser:820, missile:680, gatling:720, plasma:760, blackhole:640, phoenix:700, ball:780, sword:840};
    const freq=toneMap[source]||760;
    beep(freq,0.04,0.04);
    if(spaceBoss.hp<=0){ defeatSpaceBoss(); }
    return true;
  }

  function defeatSpaceBoss(){
    if(spaceBossPhase!=='active' || !spaceBoss) return;
    const now=performance.now();
    const sb=spaceBoss;
    const fake={x:sb.x-sb.w/2,y:sb.y-sb.h/2,w:sb.w,h:sb.h};
    bossKillEffect(fake);
    dropBossCoins(sb.x, sb.y, 1);
    addScore(BOSS_DEFEAT_SCORE.space);
    stats.bossKills++;
    updateHUD();
    spawnParticles(sb.x, sb.y, '#ffe9b2', 160, 3.2, 5.6, 6.0);
    spaceBossBursts.push({type:'ring',x:sb.x,y:sb.y,r0:40,r1:520,width:24,t0:now,life:2000,color:'255,200,150'});
    spaceBossBursts.push({type:'flare',x:sb.x,y:sb.y,r0:0,r1:320,t0:now,life:1600,color:'255,235,200'});
    spaceBossBursts.push({type:'spark',x:sb.x,y:sb.y,r0:0,r1:200,t0:now,life:1200,color:'200,240,255'});
    screenShake=Math.max(screenShake,12);
    playSFX('fireExplosion');
    spaceBossPhase='dying';
    spaceBossAttack=null;
    spaceBossBullets.length=0;
    spaceBossNextAttackAt=0;
    spaceBossMarquee={text:'成功擊殺Boss: 太空戰艦!', start:now, fadeStart:now+5000, end:now+5000, style:'victory'};
    nextTreasureBrickAt=0;
    spaceBossDeathAnim={
      start:now,
      startY:sb.y,
      dropDistance:220,
      fallDuration:3000,
      explosionAt:now+3000,
      bigExplosionEnd:now+5000,
      vanishAt:now+5000,
      finishAt:now+8000,
      lastBurst:now,
      bigBang:false,
      dropSpawned:false
    };
  }

  function updateSpaceBoss(){
    if(level!==5) return;
    const now=performance.now();
    if(spaceBossPhase==='intro' && !spaceBoss && spaceBossRevealScheduled && now>=spaceBossRevealScheduled){ activateSpaceBoss(); }
    if(spaceBossPhase==='active' && spaceBoss){
      const sb=spaceBoss;
      sb.x += sb.vx;
      const margin=110;
      if(sb.x - sb.w/2 < margin){ sb.x = margin + sb.w/2; sb.vx = Math.abs(sb.vx); }
      if(sb.x + sb.w/2 > 1100 - margin){ sb.x = 1100 - margin - sb.w/2; sb.vx = -Math.abs(sb.vx); }
      sb.y = sb.baseY + Math.sin((now - sb.spawnAt)/650)*28;
      sb.thrusterPhase = (sb.thrusterPhase||0) + 0.08;
      const atkMode = spaceBossAttack?.mode;
      const atkState = spaceBossAttack?.state;
      const {rect:pr, x:targetX, y:targetY} = getPaddleTarget();
      for(const gun of sb.guns){
        gun.spin=(gun.spin||0)+0.28;
        if(atkMode===1 && atkState==='firing'){
          const gx = sb.x + gun.offsetX;
          const gy = sb.y + gun.offsetY;
          const tx = targetX;
          const ty = targetY;
          const dir = Math.atan2(ty-gy, tx-gx);
          gun.angle = dir + Math.PI/2;
        }else{
          gun.angle = Math.PI/2 + Math.sin((now/520)+gun.phase)*0.45;
        }
      }
      for(const laser of sb.lasers){
        if(atkMode===2 && atkState==='sweeping' && spaceBossAttack?.currentTarget){
          const lx = sb.x + laser.offsetX;
          const ly = sb.y + laser.offsetY;
          const target = spaceBossAttack.currentTarget;
          const dir = Math.atan2(target.y-ly, target.x-lx);
          laser.angle = dir + Math.PI/2;
        }else{
          laser.angle = Math.PI + Math.sin((now/900)+laser.phase)*0.22;
        }
      }
      if(sb.hitFlashUntil && now>sb.hitFlashUntil){ sb.hitFlashUntil=0; }
    }
    if(spaceBossPhase==='dying' && spaceBoss){
      const anim=spaceBossDeathAnim;
      if(anim){
        const fallProg=Math.min(1, Math.max(0,(now-anim.start)/anim.fallDuration));
        spaceBoss.y = anim.startY + fallProg*anim.dropDistance;
        const burstInterval = anim.bigBang ? 80 : 110;
        if(now-anim.lastBurst>burstInterval){
          anim.lastBurst=now;
          const jitterX=(Math.random()-0.5)*spaceBoss.w*0.9;
          const jitterY=(Math.random()-0.3)*spaceBoss.h*0.9;
          spawnParticles(spaceBoss.x+jitterX, spaceBoss.y+jitterY, '#ffe6b8', 34, 2.6, 3.8, 3.6);
          spaceBossBursts.push({type:'spark',x:spaceBoss.x+jitterX,y:spaceBoss.y+jitterY,r0:0,r1:260,t0:now,life:850,color:'255,180,120'});
          screenShake=Math.max(screenShake,6);
        }
        if(!anim.bigBang && now>=anim.explosionAt){
          anim.bigBang=true;
          anim.bigBangStart=now;
          screenShake=Math.max(screenShake,22);
          spawnParticles(spaceBoss.x,spaceBoss.y,'#fff2d6',260,3.8,5.6,6.4);
          spawnParticles(spaceBoss.x,spaceBoss.y,'#ffddb8',160,3.4,5.0,5.2);
          spaceBossBursts.push({type:'ring',x:spaceBoss.x,y:spaceBoss.y,r0:90,r1:660,width:36,t0:now,life:2200,color:'255,220,190'});
          spaceBossBursts.push({type:'flare',x:spaceBoss.x,y:spaceBoss.y,r0:0,r1:460,t0:now,life:2400,color:'255,244,220'});
          spaceBossBursts.push({type:'halo',x:spaceBoss.x,y:spaceBoss.y,r0:120,r1:720,t0:now,life:2600,color:'255,200,150'});
          playSFX('explosion');
          if(!anim.dropSpawned){
            spawnBossNineCatOnce('space', spaceBoss.x-12, spaceBoss.y);
            anim.dropSpawned=true;
          }
        }
        if(anim.bigBang && anim.bigBangStart && now-anim.bigBangStart<anim.bigExplosionEnd-anim.explosionAt){
          const theta=Math.random()*Math.PI*2;
          const dist=spaceBoss.w*0.4+Math.random()*spaceBoss.w*0.3;
          const px=spaceBoss.x+Math.cos(theta)*dist;
          const py=spaceBoss.y+Math.sin(theta)*dist;
          spaceBossBursts.push({type:'spark',x:px,y:py,r0:0,r1:320,t0:now,life:900,color:'255,210,180'});
        }
        if(now>=anim.vanishAt){
          spaceBossPhase='defeated';
          spaceBossDefeatedAt=now;
          spaceBoss=null;
          spaceBossDeathAnim=null;
        }
      }
    }
    for(let i=spaceBossBursts.length-1;i>=0;i--){ const fx=spaceBossBursts[i]; const life=fx.life||1000; if(now>fx.t0+life){ spaceBossBursts.splice(i,1); } }
    updateSpaceBossAttack(now);
    updateSpaceBossBullets(now);
    updateSpaceBossPaddleRespawn(now);
  }

  function startSpaceBossAttack(mode, now){
    if(!spaceBoss) return;
    const {rect:pr, x:targetX, y:targetY}=getPaddleTarget();
    spaceBossNextAttackAt=0;
    if(mode===1){
      spaceBossAttack={
        mode:1,
        state:'countdown',
        start:now,
        countdownEnd:now+3000,
        fireStart:now+3000,
        fireEnd:now+3000+SPACE_BOSS_GUN_FIRE_DURATION,
        lastShot:0
      };
      spaceBossMarquee={text:'危險！ 太空戰艦即將進行火力壓制!', start:now, fadeStart:now+3000, end:now+3200, style:'alert', countdownDuration:3000};
      playSFX('spaceBossVolleyCharge');
    }else{
      const baseTarget={x:targetX, y:targetY};
      const movement=spaceBossLastPaddleCenter-spaceBossPrevPaddleCenter;
      let dir=0;
      if(Math.abs(movement)>1){ dir = movement>0?1:-1; }
      spaceBossAttack={
        mode:2,
        state:'countdown',
        start:now,
        countdownEnd:now+3000,
        sweepStart:now+3000,
        sweepEnd:now+3000+SPACE_BOSS_LASER_SWEEP_DURATION,
        baseTarget,
        sweepDir:dir,
        maxSweep:1100/3,
        currentTarget:{...baseTarget},
        hitApplied:false
      };
      spaceBossMarquee={text:'危險！ 太空戰艦即將使出致命雷射!', start:now, fadeStart:now+3000, end:now+3200, style:'alert', countdownDuration:3000};
      playSFX('spaceBossLaserCharge');
    }
  }

  function updateSpaceBossAttack(now){
    if(level!==5) return;
    if(spaceBossPhase!=='active' || !spaceBoss){
      spaceBossAttack=null;
      return;
    }
    if(!spaceBossAttack){
      if(spaceBossNextAttackAt && now>=spaceBossNextAttackAt){
        const mode = Math.random()<0.5 ? 1 : 2;
        startSpaceBossAttack(mode, now);
      }
      return;
    }
    const atk=spaceBossAttack;
    if(atk.state==='countdown'){
      if(now>=atk.countdownEnd){
        if(atk.mode===1){
          atk.state='firing';
          atk.lastShot=0;
        }else{
          atk.state='sweeping';
          atk.currentTarget={...atk.baseTarget};
          playSFX('spaceBossLaserSweep');
        }
        spaceBossMarquee=null;
      }
      return;
    }
    if(atk.mode===1){
      if(now>=atk.fireEnd){
        spaceBossAttack=null;
        spaceBossNextAttackAt=now+SPACE_BOSS_ATTACK_INTERVAL;
        return;
      }
      if(now-atk.lastShot>=SPACE_BOSS_GUN_FIRE_RATE){
        const {rect:pr, x:targetX, y:targetY}=getPaddleTarget();
        let tx=targetX;
        let ty=targetY;
        if((pr.w<=0 || pr.h<=0) && !flipDecoy?.active){
          tx = spaceBossLastPaddleCenter || 1100/2;
          ty = 700-50;
        }
        for(const gun of spaceBoss.guns){
          const originX=spaceBoss.x+gun.offsetX;
          const originY=spaceBoss.y+gun.offsetY;
          const ang=Math.atan2(ty-originY, tx-originX);
          const speed=11;
          spaceBossBullets.push({x:originX, y:originY, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, born:now});
          spaceBossBursts.push({type:'muzzle',x:originX,y:originY,r0:6,r1:60,t0:now,life:220,color:'255,210,120'});
        }
        atk.lastShot=now;
        playSFX('spaceBossVolleyShot');
      }
    }else if(atk.mode===2){
      const sweepProg = Math.min(1, Math.max(0,(now-atk.sweepStart)/SPACE_BOSS_LASER_SWEEP_DURATION));
      const offset = atk.sweepDir * atk.maxSweep * sweepProg;
      atk.currentTarget = {x: atk.baseTarget.x + offset, y: atk.baseTarget.y};
      if(!atk.hitApplied){
        const pr=paddleRect();
        if(pr.w>0 && pr.h>0){
          const mounts=spaceBoss.lasers || [];
          for(const laser of mounts){
            const originX = spaceBoss.x + laser.offsetX;
            const originY = spaceBoss.y + laser.offsetY;
            if(segmentIntersectsRect(originX, originY, atk.currentTarget.x, atk.currentTarget.y, pr)){
              atk.hitApplied=true;
              spaceBossLaserStrike();
              break;
            }
          }
        }
      }
      if(now>=atk.sweepEnd){
        spaceBossAttack=null;
        spaceBossNextAttackAt=now+SPACE_BOSS_ATTACK_INTERVAL;
      }
    }
  }

  function updateSpaceBossBullets(now){
    for(let i=spaceBossBullets.length-1;i>=0;i--){
      const b=spaceBossBullets[i];
      b.x+=b.vx;
      b.y+=b.vy;
      if(b.x<-40||b.x>1140||b.y<-40||b.y>760){ spaceBossBullets.splice(i,1); continue; }
      let removed=false;
      for(let j=bricks.length-1;j>=0;j--){
        const bk=bricks[j];
        if(!bk?.fallingTreasure) continue;
        if(b.x>=bk.x && b.x<=bk.x+bk.w && b.y>=bk.y && b.y<=bk.y+bk.h){
          spawnParticles(b.x, b.y, '#ffe08a', 14, 2.0, 3.0, 2.8);
          damageBrick(j,1,'laser');
          spaceBossBullets.splice(i,1);
          removed=true;
          break;
        }
      }
      if(removed) continue;
      if(now<paddleGoneUntil) continue;
      const pr=paddleRect();
      if(b.x>=pr.x && b.x<=pr.x+pr.w && b.y>=pr.y && b.y<=pr.y+pr.h){
        spaceBossBullets.splice(i,1);
        spaceBossBulletHit(pr);
      }
    }
  }

  function spaceBossBulletHit(pr){
    const centerX=pr.x+pr.w/2;
    const centerY=pr.y+pr.h/2;
    if(blockDamageIfShielded({x:centerX,y:centerY})){
      return;
    }
    spawnParticles(centerX, centerY, '#ffdf9a', 26, 2.4, 3.6, 3.2);
    screenShake=Math.max(screenShake,4);
    const desired=desiredPaddleWidth();
    const effective=Math.max(SPACE_BOSS_PADDLE_MIN_WIDTH, desired - spaceBossPaddlePenalty);
    if(effective-SPACE_BOSS_PADDLE_MIN_WIDTH>0.5){
      spaceBossPaddlePenalty=Math.min(desired - SPACE_BOSS_PADDLE_MIN_WIDTH, spaceBossPaddlePenalty + 10);
      computePaddleWidth();
      return;
    }
    const now=performance.now();
    if(now<paddleGoneUntil) return;
    spaceBossPaddlePenalty=0;
    computePaddleWidth();
    paddleGoneUntil=now+3000;
    spaceBossPaddleRespawnAt=paddleGoneUntil;
    spaceBossSuppressLifeLossUntil = spaceBossPaddleRespawnAt + 200;
    spawnParticles(centerX, centerY, '#ffb347', 80, 3.0, 4.4, 4.2);
    spaceBossBursts.push({type:'ring',x:centerX,y:centerY,r0:20,r1:220,width:18,t0:now,life:600,color:'255,180,90'});
    screenShake=Math.max(screenShake,10);
    lives--; updateHUD();
    if(lives<=0){ running=false; paused=true; showGameOver(); return; }
    balls.length=0;
  }

  function updateSpaceBossPaddleRespawn(now){
    if(spaceBossPaddleRespawnAt && now>=spaceBossPaddleRespawnAt){
      spaceBossPaddleRespawnAt=0;
      if(lives>0 && !paused){ resetBalls(false); startCountdown(); }
      spaceBossSuppressLifeLossUntil=0;
    }
  }

  function spaceBossLaserStrike(){
    if(paddleGoneUntil>performance.now()) return;
    const pr=paddleRect();
    const hitX=pr.x+pr.w/2;
    const hitY=pr.y+pr.h/2;
    if(blockDamageIfShielded({x:hitX,y:hitY})){
      return;
    }
    lives=Math.max(0, lives-1);
    updateHUD();
    screenShake=Math.max(screenShake,12);
    spawnParticles(hitX, hitY, '#ff6a88', 60, 3.0, 4.6, 4.0);
    if(lives<=0){ running=false; paused=true; showGameOver(); return; }
    balls.length=0;
    paddleGoneUntil=performance.now()+1500;
    spaceBossPaddleRespawnAt=paddleGoneUntil+1500;
    spaceBossSuppressLifeLossUntil = spaceBossPaddleRespawnAt + 200;
  }

  function segmentIntersectsRect(x1,y1,x2,y2, rect){
    const rx=rect.x, ry=rect.y, rw=rect.w, rh=rect.h;
    const left=rx, right=rx+rw, top=ry, bottom=ry+rh;
    if(x1>=left && x1<=right && y1>=top && y1<=bottom) return true;
    if(x2>=left && x2<=right && y2>=top && y2<=bottom) return true;
    if(segmentsIntersect(x1,y1,x2,y2,left,top,right,top)) return true;
    if(segmentsIntersect(x1,y1,x2,y2,right,top,right,bottom)) return true;
    if(segmentsIntersect(x1,y1,x2,y2,right,bottom,left,bottom)) return true;
    if(segmentsIntersect(x1,y1,x2,y2,left,bottom,left,top)) return true;
    return false;
  }

  function rectsOverlap(a, b){
    if(!a || !b) return false;
    if(!a.w || !a.h || !b.w || !b.h) return false;
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function segmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4){
    const denom=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
    if(Math.abs(denom)<1e-6) return false;
    const pre=(x1*y2 - y1*x2);
    const post=(x3*y4 - y3*x4);
    const x=(pre*(x3-x4)-(x1-x2)*post)/denom;
    const y=(pre*(y3-y4)-(y1-y2)*post)/denom;
    if(x<Math.min(x1,x2)-1e-6 || x>Math.max(x1,x2)+1e-6) return false;
    if(x<Math.min(x3,x4)-1e-6 || x>Math.max(x3,x4)+1e-6) return false;
    if(y<Math.min(y1,y2)-1e-6 || y>Math.max(y1,y2)+1e-6) return false;
    if(y<Math.min(y3,y4)-1e-6 || y>Math.max(y3,y4)+1e-6) return false;
    return true;
  }

  function drawSpaceBossLayer(){
    if(spaceBossPhase==='inactive' && !spaceBossBursts.length) return;
    const now=performance.now();
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    for(const fx of spaceBossBursts){
      const life=fx.life||1000;
      const prog=Math.max(0, Math.min(1, (now-fx.t0)/life));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      if(fx.type==='ring'){
        const rad=(fx.r0||0)+((fx.r1||200)-(fx.r0||0))*easeOut(prog);
        const alpha=1-prog;
        ctx.strokeStyle=`rgba(${fx.color||'255,255,255'},${0.55*alpha})`;
        ctx.lineWidth=(fx.width||14)*((scaleX+scaleY)/2)*(1-prog*0.7);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2), 0, Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='flare'){
        const rad=(fx.r1||200)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(10, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0, `rgba(${fx.color||'200,220,255'},${0.35*(1-prog)})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='spark'){
        const rad=(fx.r1||80)*prog*((scaleX+scaleY)/2);
        ctx.strokeStyle=`rgba(${fx.color||'160,220,255'},${0.7*(1-prog)})`;
        ctx.lineWidth=2*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.moveTo(fx.x*scaleX-rad, fx.y*scaleY);
        ctx.lineTo(fx.x*scaleX+rad, fx.y*scaleY);
        ctx.moveTo(fx.x*scaleX, fx.y*scaleY-rad);
        ctx.lineTo(fx.x*scaleX, fx.y*scaleY+rad);
        ctx.stroke();
      }else if(fx.type==='halo'){
        const rad=(fx.r0||30)+((fx.r1||220)-(fx.r0||30))*prog;
        ctx.strokeStyle=`rgba(${fx.color||'140,200,255'},${0.25*(1-prog)})`;
        ctx.lineWidth=8*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='muzzle'){
        const rad=(fx.r0||6)+((fx.r1||60)-(fx.r0||6))*prog;
        const alpha=1-prog;
        ctx.fillStyle=`rgba(${fx.color||'255,200,120'},${0.6*alpha})`;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2), 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }
    if(spaceBoss && (spaceBossPhase==='active' || spaceBossPhase==='intro' || spaceBossPhase==='dying')){
      drawSpaceBossShip(spaceBoss, now);
      drawSpaceBossAttacks(now);
    }else if(spaceBossPhase==='intro' && spaceBossAnchor){
      const cx=(spaceBossAnchor.x+spaceBossAnchor.w/2)*scaleX;
      const cy=(spaceBossAnchor.y+spaceBossAnchor.h+60)*scaleY;
      const rad=Math.max(spaceBossAnchor.w, spaceBossAnchor.h)*1.2*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      g.addColorStop(0,'rgba(140,200,255,0.18)');
      g.addColorStop(1,'rgba(140,200,255,0)');
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }else if(spaceBossPhase==='active' && !spaceBoss && spaceBossAttack){
      drawSpaceBossAttacks(now);
    }
  }

  function drawSpaceBossAttacks(now){
    ctx.save();
    for(const b of spaceBossBullets){
      const r=4*((scaleX+scaleY)/2);
      const grad=ctx.createRadialGradient(b.x*scaleX,b.y*scaleY,0,b.x*scaleX,b.y*scaleY,r);
      grad.addColorStop(0,'rgba(255,255,255,0.95)');
      grad.addColorStop(0.6,'rgba(255,200,140,0.8)');
      grad.addColorStop(1,'rgba(255,120,60,0)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(b.x*scaleX,b.y*scaleY,r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    if(spaceBossAttack && spaceBossAttack.mode===2 && spaceBossAttack.state==='sweeping' && spaceBoss){
      const target=spaceBossAttack.currentTarget;
      const mounts=spaceBoss.lasers||[];
      for(const laser of mounts){
        const ox=(spaceBoss.x+laser.offsetX);
        const oy=(spaceBoss.y+laser.offsetY);
        drawSpaceBossLaserBeam(ox, oy, target.x, target.y, now);
      }
    }
  }

  function drawSpaceBossLaserBeam(x1,y1,x2,y2, now){
    const sx1=x1*scaleX, sy1=y1*scaleY, sx2=x2*scaleX, sy2=y2*scaleY;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const pulse=0.7+0.3*Math.sin(now/60);
    ctx.strokeStyle=`rgba(255,90,110,${0.35*pulse})`;
    ctx.lineWidth=10;
    ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    const grad=ctx.createLinearGradient(sx1,sy1,sx2,sy2);
    grad.addColorStop(0,'rgba(255,200,200,0.4)');
    grad.addColorStop(1,'rgba(255,80,120,0.9)');
    ctx.strokeStyle=grad;
    ctx.lineWidth=5;
    ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    ctx.restore();
  }

  function drawSpaceBossShip(sb, now){
    const s=(scaleX+scaleY)/2;
    ctx.save();
    ctx.translate(sb.x*scaleX, sb.y*scaleY);
    const bodyW=sb.w*scaleX;
    const bodyH=sb.h*scaleY;
    const grad=ctx.createLinearGradient(-bodyW*0.5, -bodyH*0.6, bodyW*0.5, bodyH*0.6);
    grad.addColorStop(0,'rgba(130,210,255,0.95)');
    grad.addColorStop(0.45,'rgba(90,110,220,0.95)');
    grad.addColorStop(1,'rgba(24,32,82,0.98)');
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.45, -bodyH*0.45);
    ctx.quadraticCurveTo(0, -bodyH*0.75, bodyW*0.45, -bodyH*0.45);
    ctx.quadraticCurveTo(bodyW*0.62, 0, bodyW*0.45, bodyH*0.5);
    ctx.quadraticCurveTo(0, bodyH*0.8, -bodyW*0.45, bodyH*0.5);
    ctx.quadraticCurveTo(-bodyW*0.62, 0, -bodyW*0.45, -bodyH*0.45);
    ctx.closePath();
    ctx.fillStyle=grad;
    ctx.shadowColor='rgba(90,150,255,'+(0.35+(sb.hitFlashUntil && now<sb.hitFlashUntil?0.45:0))+')';
    ctx.shadowBlur=32*s;
    ctx.fill();
    ctx.shadowBlur=0;
    ctx.strokeStyle='rgba(220,240,255,0.45)';
    ctx.lineWidth=4*s;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-bodyW*0.6, -bodyH*0.05);
    ctx.quadraticCurveTo(-bodyW*0.9, bodyH*0.05, -bodyW*0.5, bodyH*0.55);
    ctx.lineTo(-bodyW*0.35, bodyH*0.3);
    ctx.closePath();
    ctx.fillStyle='rgba(40,60,120,0.85)';
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(bodyW*0.6, -bodyH*0.05);
    ctx.quadraticCurveTo(bodyW*0.9, bodyH*0.05, bodyW*0.5, bodyH*0.55);
    ctx.lineTo(bodyW*0.35, bodyH*0.3);
    ctx.closePath();
    ctx.fill();

    const cockpitGrad=ctx.createRadialGradient(0,-bodyH*0.18,0,0,-bodyH*0.18,bodyW*0.28);
    cockpitGrad.addColorStop(0,'rgba(255,255,255,0.9)');
    cockpitGrad.addColorStop(1,'rgba(90,130,220,0.45)');
    ctx.beginPath();
    ctx.ellipse(0, -bodyH*0.1, bodyW*0.28, bodyH*0.24, 0, 0, Math.PI*2);
    ctx.fillStyle=cockpitGrad;
    ctx.fill();

    const thrusters=[{x:-bodyW*0.25,y:bodyH*0.55},{x:bodyW*0.25,y:bodyH*0.55}];
    const thrusterPhase=sb.thrusterPhase||0;
    for(let i=0;i<thrusters.length;i++){
      const t=thrusters[i];
      const radius=(28+6*Math.sin(thrusterPhase*4+i*Math.PI))*s;
      const tg=ctx.createRadialGradient(t.x,t.y,0,t.x,t.y,Math.max(radius,10));
      tg.addColorStop(0,'rgba(255,240,180,0.95)');
      tg.addColorStop(0.6,'rgba(255,180,60,0.75)');
      tg.addColorStop(1,'rgba(255,120,0,0)');
      ctx.fillStyle=tg;
      ctx.beginPath();
      ctx.arc(t.x,t.y,Math.max(radius,10),0,Math.PI*2);
      ctx.fill();
    }

    for(const gun of sb.guns){
      const gx=gun.offsetX*scaleX;
      const gy=gun.offsetY*scaleY;
      ctx.save();
      ctx.translate(gx, gy);
      ctx.rotate(gun.angle);
      const barrelLen=34*s;
      const barrelWidth=8*s;
      ctx.fillStyle='rgba(160,210,255,0.95)';
      ctx.fillRect(-barrelWidth/2, -barrelLen, barrelWidth, barrelLen);
      ctx.save();
      ctx.translate(0, -barrelLen);
      ctx.rotate(gun.spin||0);
      for(let k=0;k<3;k++){
        const ang=k*Math.PI*2/3;
        ctx.beginPath();
        ctx.fillStyle='rgba(255,255,255,0.9)';
        ctx.arc(Math.cos(ang)*4*s, Math.sin(ang)*4*s, 2.4*s, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      ctx.restore();
      ctx.save();
      ctx.translate(gx, gy);
      ctx.fillStyle='#1c2246';
      ctx.beginPath(); ctx.arc(0,0,12*s,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(120,180,255,0.8)';
      ctx.lineWidth=2*s; ctx.stroke();
      ctx.restore();
    }

    for(const laser of sb.lasers){
      const lx=laser.offsetX*scaleX;
      const ly=laser.offsetY*scaleY;
      ctx.save();
      ctx.translate(lx, ly);
      ctx.rotate(laser.angle);
      const towerW=14*s;
      const towerH=48*s;
      const lg=ctx.createLinearGradient(0,0,0,-towerH);
      lg.addColorStop(0,'rgba(90,150,255,0.9)');
      lg.addColorStop(1,'rgba(220,255,255,0.6)');
      ctx.fillStyle=lg;
      ctx.fillRect(-towerW/2, -towerH, towerW, towerH);
      ctx.beginPath();
      ctx.strokeStyle='rgba(200,240,255,0.5)';
      ctx.lineWidth=2*s;
      ctx.moveTo(0,-towerH);
      ctx.lineTo(0,-towerH-12*s);
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.translate(lx, ly);
      ctx.fillStyle='#121b36';
      ctx.beginPath(); ctx.arc(0,0,14*s,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(80,140,255,0.8)';
      ctx.lineWidth=2*s; ctx.stroke();
      ctx.restore();
    }

    ctx.restore();
  }

  function drawSpaceBossMarquee(){
    if(!spaceBossMarquee) return;
    const now=performance.now();
    const {start, fadeStart, end, text} = spaceBossMarquee;
    const style=spaceBossMarquee.style||'marquee';
    if(now>=end){ spaceBossMarquee=null; return; }
    let alpha=1;
    if(style!=='victory' && now>fadeStart){ alpha = Math.max(0, 1 - (now - fadeStart)/(end - fadeStart||1)); }
    const fallbackCanvasWidth = (typeof canvas!=='undefined' && canvas && canvas.clientWidth) ? canvas.clientWidth : 0;
    const viewW = (typeof window!=='undefined' && window.innerWidth) ? window.innerWidth : fallbackCanvasWidth;
    let deviceBoost=1;
    if(viewW && viewW<=600){ deviceBoost=1.4; }
    else if(viewW && viewW<=900){ deviceBoost=1.18; }
    const scaleAvg=(scaleX+scaleY)/2;
    const textScale=Math.max(0.6, scaleAvg*deviceBoost);
    const numberScale=Math.max(0.6, scaleAvg*(deviceBoost>1?deviceBoost+0.05:1));
    const marqueeScale=Math.max(0.6, scaleAvg*(deviceBoost>1?deviceBoost:1));
    const areaHeightBase=52;
    const areaHeight = deviceBoost>1 ? Math.round(areaHeightBase * 1.18) : areaHeightBase;
    const topBase=Math.max(12, layout().top - areaHeight - 14);
    const x=40;
    const width=1100-80;
    const radius=18;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, topBase, width, areaHeight, radius);
    if(style==='victory'){
      const grad=ctx.createLinearGradient(x*scaleX, topBase*scaleY, x*scaleX, (topBase+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(40,56,104,0.95)');
      grad.addColorStop(1,'rgba(18,28,70,0.95)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,220,180,0.8)';
      ctx.lineWidth=2.4;
      drawRoundedRect(x, topBase, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+12;
      const innerY=topBase+6;
      const innerW=width-24;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-8);
      ctx.save();
      ctx.clip();
      ctx.fillStyle='rgba(255,235,210,0.18)';
      ctx.fillRect(innerX*scaleX, innerY*scaleY, innerW*scaleX, innerH*scaleY);
      ctx.restore();
      ctx.fillStyle='#ffeede';
      const victoryFont=Math.max(24, Math.round(28*marqueeScale));
      ctx.font=`${victoryFont}px 'Playfair Display', serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,220,170,0.6)';
      ctx.shadowBlur=18*marqueeScale;
      ctx.fillText(text, (x+width/2)*scaleX, (topBase+areaHeight/2)*scaleY);
      ctx.shadowBlur=0;
      ctx.strokeStyle='rgba(255,220,170,0.45)';
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo((x+32)*scaleX, (topBase+areaHeight-10)*scaleY);
      ctx.lineTo((x+width-32)*scaleX, (topBase+areaHeight-10)*scaleY);
      ctx.stroke();
    }else{
      const grad=ctx.createLinearGradient(x*scaleX, topBase*scaleY, x*scaleX, (topBase+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(32,48,92,0.9)');
      grad.addColorStop(1,'rgba(16,28,60,0.92)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(160,200,255,0.85)';
      ctx.lineWidth=2;
      drawRoundedRect(x, topBase, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+10;
      const innerY=topBase+6;
      const innerW=width-20;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.save();
      ctx.clip();
      if(style==='alert'){
        const midY=(innerY+innerH/2)*scaleY;
        ctx.fillStyle='#f5f9ff';
        const alertFont=Math.max(18, Math.round(24*textScale));
        ctx.font=`${alertFont}px 'Noto Sans TC','Playfair Display',sans-serif`;
        ctx.textBaseline='middle';
        ctx.textAlign='left';
        ctx.shadowColor='rgba(120,200,255,0.45)';
        ctx.shadowBlur=10*textScale;
        ctx.fillText(text, (innerX+16)*scaleX, midY);
        const cd=spaceBossMarquee.countdownDuration;
        if(cd){
          const remain=Math.max(0, cd - (now-start));
          const num=Math.max(0, Math.ceil(remain/1000));
          if(num>0){
            ctx.shadowBlur=0;
            ctx.fillStyle='rgba(255,180,140,0.9)';
            const countdownFont=Math.max(22, Math.round(32*numberScale));
            ctx.font=`${countdownFont}px 'Playfair Display',serif`;
            ctx.textAlign='right';
            ctx.fillText(String(num), (innerX+innerW-16)*scaleX, midY);
          }
        }
      } else {
        const pxSpeed=180;
        const baseX=(innerX+innerW)*scaleX;
        const midY=(innerY+innerH/2)*scaleY;
        ctx.fillStyle='#f5f9ff';
        const marqueeFont=Math.max(18, Math.round(24*marqueeScale));
        ctx.font=`${marqueeFont}px 'Noto Sans TC','Playfair Display',sans-serif`;
        ctx.textBaseline='middle';
        ctx.shadowColor='rgba(120,200,255,0.55)';
        ctx.shadowBlur=12*marqueeScale;
        const repeated=`✦  ${text}  ✦  `;
        const textWidth=Math.max(1, ctx.measureText(repeated).width);
        let drawX = baseX - ((now-start)/1000*pxSpeed % textWidth);
        while(drawX > (innerX- textWidth/scaleX)*scaleX){ drawX -= textWidth; }
        while(drawX < (innerX + innerW)*scaleX){ ctx.fillText(repeated, drawX, midY); drawX += textWidth; }
      }
    }
    ctx.restore();
    ctx.restore();
  }

  function drawBossNameplate(name, hp, maxHp, x, y, barW, barH, palette){
    const scaleAvg=(scaleX+scaleY)/2;
    const textPrimary=palette.textPrimary||'#f0f4ff';
    const textSecondary=palette.textSecondary||'#f7f9ff';
    const glow=palette.glow||'rgba(120,180,255,0.45)';
    const safeLeft=24*scaleAvg;
    const safeRight=canvas.width - 28*scaleAvg;
    const labelAnchor=(x - 18)*scaleX;
    ctx.save();
    ctx.textAlign='left';

    const baseNameFont=Math.max(10, Math.round(13*1.2*scaleAvg));
    const nameFont=Math.max(10, Math.round(baseNameFont*1.5));
    ctx.font=`${nameFont}px 'Noto Sans TC','Playfair Display',sans-serif`;
    ctx.textBaseline='bottom';
    ctx.fillStyle=textPrimary;
    ctx.shadowColor=glow;
    ctx.shadowBlur=6*scaleAvg;
    const nameMetrics=ctx.measureText(name);
    let nameX=Math.max(safeLeft, Math.min(labelAnchor, safeRight - nameMetrics.width));
    ctx.fillText(name, nameX, (y - 8)*scaleY);
    ctx.shadowBlur=0;

    const hpFont=Math.max(12, Math.round(12*1.5*scaleAvg));
    ctx.font=`${hpFont}px 'Playfair Display','Noto Sans TC',sans-serif`;
    ctx.textBaseline='top';
    ctx.fillStyle=textSecondary;
    ctx.textAlign='center';
    const hpText=`${hp.toLocaleString()}/${maxHp.toLocaleString()}`;
    const hpMetrics=ctx.measureText(hpText);
    const barCenter=(x + barW/2)*scaleX;
    const halfWidth=hpMetrics.width/2;
    const minCenter=safeLeft + halfWidth;
    const maxCenter=safeRight - halfWidth;
    const hpX=Math.max(minCenter, Math.min(barCenter, maxCenter));
    ctx.fillText(hpText, hpX, (y + barH + 8)*scaleY);
    ctx.restore();
  }

  function drawSpaceBossHPBar(){
    if(spaceBossPhase!=='active' || !spaceBoss) return;
    const L=layout();
    const barW=32;
    const maxH = 700 - (L.top + 80);
    const barH=Math.max(180, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, spaceBoss.hp/spaceBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(34,56,104,0.95)');
    frameGrad.addColorStop(1,'rgba(18,26,62,0.9)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(170,210,255,0.55)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(10,18,42,0.92)');
    bg.addColorStop(1,'rgba(20,30,60,0.88)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(255,120,150,0.2)');
      fillGrad.addColorStop(0.4,'rgba(255,140,160,0.55)');
      fillGrad.addColorStop(1,'rgba(255,230,240,0.95)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    const segments=10;
    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - innerH*i/segments)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS 太空戰艦', spaceBoss.hp, spaceBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(32,52,92,0.94)',
      bgBottom:'rgba(18,28,60,0.9)',
      frame:'rgba(170,210,255,0.75)',
      glow:'rgba(140,200,255,0.6)',
      textPrimary:'#000000',
      textSecondary:'#f0f5ff'
    });
    ctx.restore();
  }

  function drawSpaceBossHUD(){
    drawSpaceBossMarquee();
    drawSpaceBossHPBar();
  }

  // === 第10關 暗黑死神 Boss ===
  function startReaperReveal(){
    if(reaperPhase!=='awaiting') return;
    const now=performance.now();
    reaperPhase='intro';
    let anchor=reaperAnchor;
    if(reaperPlaceholder){
      anchor={x:reaperPlaceholder.x, y:reaperPlaceholder.y, w:reaperPlaceholder.w, h:reaperPlaceholder.h};
      const cx=anchor.x+anchor.w/2;
      const cy=anchor.y+anchor.h/2;
      spawnParticles(cx,cy,'#fdf0ff',140,3.2,5.2,5.6);
      spawnParticles(cx,cy,'#c4a6ff',110,2.8,4.4,4.8);
      spawnParticles(cx,cy,'#ff96cf',90,2.4,3.8,4.2);
      reaperBursts.push({type:'ring',x:cx,y:cy,r0:28,r1:420,width:18,t0:now,life:1400,color:'220,140,255'});
      reaperBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:260,t0:now,life:1200,color:'150,110,220'});
      reaperBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:180,t0:now,life:950,color:'255,160,220'});
      const idx=bricks.indexOf(reaperPlaceholder);
      if(idx>=0) bricks.splice(idx,1);
      reaperPlaceholder=null;
      reaperAnchor=anchor;
    }
    if(!reaperAnchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      const anchorW=brickW*2+L.pad;
      const anchorH=brickH*2+L.pad;
      const anchorX=L.pad + bx*(brickW+L.pad);
      reaperAnchor={x:anchorX,y:L.top,w:anchorW,h:anchorH};
    }
    reaperRevealScheduled = now + 900;
    reaperMarquee={text:'有一套！ 讓我親自會會你!', start:now, fadeStart:now+5000, end:now+8000, style:'alert'};
    screenShake=Math.max(screenShake,8);
    playSFX('fireExplosion');
  }

  function activateReaperBoss(){
    if(reaperPhase!=='intro' || reaperBoss) return;
    let anchor=reaperAnchor;
    if(!anchor){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      anchor={x:L.pad + bx*(brickW+L.pad), y:L.top, w:brickW*2+L.pad, h:brickH*2+L.pad};
      reaperAnchor=anchor;
    }
    const cx=anchor.x+anchor.w/2;
    const baseY=anchor.y+anchor.h+140;
    const now=performance.now();
    resetBossNineCatDrop('reaper');
    reaperBoss={
      x:cx,
      y:baseY,
      baseY,
      w:160,
      h:220,
      vx:(Math.random()<0.5?-1:1)*1.6,
      hp:40,
      maxHp:40,
      hitCooldownUntil:0,
      hitFlashUntil:0,
      spawnAt:now,
      cloakPhase:Math.random()*Math.PI*2,
      hiddenUntil:0
    };
    reaperTeleportSchedule={
      nextSingle: now + 10000,
      nextBurst: now + 30000,
      burstRemaining: 0,
      burstInterval: 220,
      nextBurstTeleport: 0,
      burstActive:false
    };
    reaperPhase='active';
    reaperAttackState={nextAttack: now + REAPER_FIRST_ATTACK_DELAY, current:null};
    reaperSlashZone=null;
    reaperBlackHoleAttack=null;
    reaperBursts.push({type:'halo',x:cx,y:baseY-40,r0:60,r1:320,t0:now,life:1700,color:'200,140,255'});
    screenShake=Math.max(screenShake,6);
    scheduleNextTreasureBrick(now);
  }

  function performReaperTeleport(rapid=false){
    if(!reaperBoss) return;
    const now=performance.now();
    const oldX=reaperBoss.x;
    const oldY=reaperBoss.y;
    reaperAfterimages.push({x:oldX,y:oldY,t0:now,life:700,scale:1});
    const L=layout();
    const minX=140, maxX=1100-140;
    const minY=L.top+90, maxY=L.top+320;
    reaperBursts.push({type:'ring',x:oldX,y:oldY,r0:30,r1:260,width:16,t0:now,life:800,color:'210,130,255'});
    reaperBursts.push({type:'flare',x:oldX,y:oldY,r0:0,r1:200,t0:now,life:720,color:'150,110,220'});
    const newX = minX + Math.random()*(maxX-minX);
    const newY = minY + Math.random()*(maxY-minY);
    reaperBoss.x = newX;
    reaperBoss.y = newY;
    reaperAfterimages.push({x:newX,y:newY,t0:now,life:520,scale:1.12,emerge:true});
    reaperBursts.push({type:'flare',x:newX,y:newY,r0:0,r1:240,t0:now,life:760,color:'255,150,210'});
    const freq=rapid?760:680;
    beep(freq,0.04,0.04);
    beep(freq-240,0.03,0.05);
    screenShake=Math.max(screenShake, rapid?4:3);
  }

  function reaperApplyLifeLoss(now, reason='reaper'){
    if(now<reaperLifeLossCooldownUntil) return;
    if(now<paddleGoneUntil) return;
    reaperLifeLossCooldownUntil = now + 600;
    const pr=paddleRect();
    const cx=pr.x+pr.w/2;
    const cy=pr.y+pr.h/2;
    if(blockDamageIfShielded({x:cx,y:cy})) return;
    if(stats.lifeStart){
      const dur=(now-stats.lifeStart)/1000;
      if(dur<stats.fastestDeath) stats.fastestDeath=dur;
      if(dur>stats.longestLife) stats.longestLife=dur;
    }
    stats.livesUsed++;
    if(buffs.BLACKHOLE.active){ buffs.BLACKHOLE.deaths=Math.min(8,(buffs.BLACKHOLE.deaths||0)+1); }
    if(buffs.ANNIHIL.active){ buffs.ANNIHIL.active=false; }
    lives=Math.max(0, lives-1);
    updateHUD();
    spawnParticles(cx, cy, '#ff6a9a', 70, 2.6, 3.8, 3.4);
    screenShake=Math.max(screenShake,12);
    playSFX('explosion');
    balls.length=0;
    if(lives<=0){ running=false; paused=true; showGameOver(); return; }
    resetBalls(false);
    startCountdown();
  }

  function startReaperSlash(now){
    const segment=Math.floor(Math.random()*3);
    const zoneWidth=1100/3;
    const zoneHeight=140;
    const zoneX=segment*zoneWidth;
    const zoneY=700-zoneHeight;
    reaperSlashZone={x:zoneX,y:zoneY,w:zoneWidth,h:zoneHeight,start:now,countdownEnd:now+3000};
    reaperMarquee={text:'危險！ 暗黑死神即將使出死神斬!', start:now, fadeStart:now+3000, end:now+3000, style:'alert'};
    return {
      type:'slash',
      stage:'countdown',
      start:now,
      countdownEnd:now+3000,
      area:{x:zoneX,y:zoneY,w:zoneWidth,h:zoneHeight},
      slashes:0,
      nextSlash:now+3000,
      vanishEnd:0,
      resolved:false,
      reappeared:false
    };
  }

  function spawnReaperSlashStrike(state, now){
    const area=state.area;
    const baseX=area.x + Math.random()*area.w;
    const len=area.h*1.8;
    const angle=-Math.PI/3 + Math.random()*(2*Math.PI/3);
    const cos=Math.cos(angle);
    const sin=Math.sin(angle);
    const centerY=area.y + area.h*0.4;
    const x1=baseX - cos*len;
    const y1=area.y + area.h - sin*len;
    const x2=baseX + cos*len;
    const y2=area.y + area.h + sin*len;
    reaperSlashEffects.push({x1,y1,x2,y2,start:now,life:240});
    reaperBursts.push({type:'flare',x:baseX,y:centerY,r0:0,r1:240,t0:now,life:240,color:'255,80,120'});
    spawnParticles(baseX, centerY, '#ff6a88', 20, 1.6, 2.6, 2.4);
    screenShake=Math.max(screenShake,8);
    playSFX('sword');
    const pr=paddleRect();
    if(pr.w>0 && segmentIntersectsRect(x1,y1,x2,y2, pr)){
      reaperApplyLifeLoss(now,'reaperSlash');
    }
    for(let j=bricks.length-1;j>=0;j--){
      const bk=bricks[j];
      if(!bk?.fallingTreasure) continue;
      if(segmentIntersectsRect(x1,y1,x2,y2, bk)){
        spawnParticles(bk.x+bk.w/2, bk.y+bk.h/2, '#ffd6ff', 16, 2.0, 3.2, 3.0);
        damageBrick(j,1,'sword');
      }
    }
  }

  function updateReaperSlash(state, now){
    if(state.stage==='countdown'){
      if(now>=state.countdownEnd){
        state.stage='slashing';
        state.nextSlash=now;
        state.vanishEnd=now+3000;
        if(reaperBoss){ reaperBoss.hiddenUntil = Math.max(reaperBoss.hiddenUntil||0, state.vanishEnd); }
        reaperSlashZone=null;
      }
    }else if(state.stage==='slashing'){
      if(state.slashes<30 && now>=state.nextSlash){
        spawnReaperSlashStrike(state, now);
        state.slashes++;
        state.nextSlash=now+100;
        if(state.slashes>=30){ state.stage='recover'; }
      }
      if(now>=state.vanishEnd){ state.stage='recover'; }
    }
    if(state.stage==='recover'){
      if(!state.reappeared && reaperBoss && now>=state.vanishEnd){
        state.reappeared=true;
        reaperBoss.hiddenUntil=0;
        reaperAfterimages.push({x:reaperBoss.x,y:reaperBoss.y,t0:now,life:520,scale:1.05,emerge:true});
      }
      if(now>=state.vanishEnd+400){ state.resolved=true; }
    }
    if(state.resolved){
      reaperAttackState.current=null;
      reaperAttackState.nextAttack = now + REAPER_ATTACK_INTERVAL;
    }
  }

  function startReaperBlackHole(now){
    const state={
      type:'blackhole',
      stage:'countdown',
      start:now,
      countdownEnd:now+3000,
      projectile:null,
      projectileTrail:[],
      hole:null,
      resolved:false,
      baseDesiredWidth:desiredPaddleWidth(),
      didKill:false
    };
    reaperMarquee={text:'危險！ 暗黑死神即將使出黑洞吞噬!', start:now, fadeStart:now+3000, end:now+3000, style:'alert'};
    reaperBlackHoleAttack=state;
    return state;
  }

  function applyReaperHolePull(hole, now){
    const pr=paddleRect();
    const px=pr.x+pr.w/2;
    const py=pr.y+pr.h/2;
    const radius = hole?.radius || hole?.r || 0;
    const dx=hole.x - px;
    const dy=hole.y - py;
    const dist=Math.hypot(dx, dy);
    const influence = radius>0 ? Math.max(0, 1 - dist/(radius)) : 1;
    if(!orientLeft){
      paddle.x += dx*0.024*influence;
      paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x));
    }else{
      paddle.y += dy*0.028*influence;
      paddle.y=Math.max(0, Math.min(700-paddle.w, paddle.y));
    }
    const pullRange = radius>0 ? radius*1.35 : 220;
    for(const p of powerups){
      const cx=p.x + p.w/2;
      const cy=p.y + p.h/2;
      const pdx=hole.x - cx;
      const pdy=hole.y - cy;
      const pdist=Math.hypot(pdx, pdy);
      if(pdist>pullRange) continue;
      const weight = Math.max(0, 1 - pdist/pullRange);
      p.x += pdx * 0.06 * weight;
      p.y += pdy * 0.06 * weight;
      p.x = Math.max(-20, Math.min(1100 - p.w + 20, p.x));
      p.y = Math.max(-40, Math.min(720, p.y));
    }
  }

  function updateReaperBlackHole(state, now){
    if(state.stage==='countdown'){
      if(now>=state.countdownEnd){
        state.stage='projectile';
        if(reaperBoss){
          const {x:targetX, y:targetY}=getPaddleTarget();
          const startX=reaperBoss.x;
          const startY=reaperBoss.y-reaperBoss.h*0.2;
          const dx=targetX-startX;
          const dy=(targetY-startY);
          const dist=Math.hypot(dx,dy)||1;
          const speed=4.5;
          state.projectile={x:startX,y:startY,vx:(dx/dist)*speed,vy:(dy/dist)*speed,radius:22};
          state.projectileTrail=[];
          playSFX('blackhole');
        }else{
          state.resolved=true;
        }
      }
    }else if(state.stage==='projectile'){
      const proj=state.projectile;
      if(!proj){
        state.resolved=true;
      }else{
        proj.x+=proj.vx;
        proj.y+=proj.vy;
        state.projectileTrail.push({x:proj.x,y:proj.y,t:now});
        if(state.projectileTrail.length>18) state.projectileTrail.shift();
        if(proj.y>=700-100){
          const holeX=proj.x;
          const holeY=700-90;
          const holeRadius=Math.round(160*0.7);
          const spinDir=(Math.random()>0.5?1:-1);
          state.hole={x:holeX,y:holeY,start:now,end:now+3000,nextTick:now+1000,baseDesired:state.baseDesiredWidth,radius:holeRadius,spinDir,vortexPhase:Math.random()*Math.PI*2};
          reaperBursts.push({type:'ring',x:holeX,y:holeY-60,r0:40,r1:360,width:22,t0:now,life:1600,color:'210,170,255'});
          reaperBursts.push({type:'flare',x:holeX,y:holeY-40,r0:0,r1:320,t0:now,life:1400,color:'170,140,255'});
          blackHoles.push({x:holeX,y:holeY,r:holeRadius,until:now+3000,start:now,spinDir});
          state.stage='hole';
          state.projectile=null;
          state.projectileTrail=[];
        }
      }
    }else if(state.stage==='hole'){
      const hole=state.hole;
      if(!hole){
        state.resolved=true;
      }else{
        applyReaperHolePull(hole, now);
        if(now>=hole.nextTick){
          const prNow=paddleRect();
          const px=prNow.x+prNow.w/2;
          const py=prNow.y+prNow.h/2;
          const radius=hole.radius || hole.r || 0;
          const dist=Math.hypot((hole.x||0)-px, (hole.y||0)-py);
          const inRange = radius<=0 || dist<=radius;
          if(inRange){
            const desired=Math.max(hole.baseDesired||0, desiredPaddleWidth());
            hole.baseDesired=desired;
            const cap=Math.max(0, desired - REAPER_PADDLE_MIN_WIDTH);
            if(reaperPaddlePenalty < cap){
              const before=reaperPaddlePenalty;
              reaperPaddlePenalty=Math.min(cap, reaperPaddlePenalty + 40);
              if(reaperPaddlePenalty!==before){ computePaddleWidth(); }
            }else if(!state.didKill){
              reaperApplyLifeLoss(now,'blackhole');
              state.didKill=true;
            }
          }
          hole.nextTick = now + 1000;
        }
        if(now>=hole.end){ state.resolved=true; }
      }
    }
    if(state.resolved){
      reaperAttackState.current=null;
      reaperAttackState.nextAttack = now + REAPER_ATTACK_INTERVAL;
      reaperBlackHoleAttack=null;
    }
  }

  function updateReaperAttacks(now){
    if(reaperPhase!=='active' || !reaperBoss) return;
    if(!reaperAttackState){ reaperAttackState={nextAttack: now + REAPER_ATTACK_INTERVAL, current:null}; }
    if(reaperAttackState.current){
      const curr=reaperAttackState.current;
      if(curr.type==='slash'){ updateReaperSlash(curr, now); }
      else if(curr.type==='blackhole'){ updateReaperBlackHole(curr, now); }
      return;
    }
    if(now>=reaperAttackState.nextAttack){
      const modes=['slash','blackhole'];
      const pick=modes[Math.floor(Math.random()*modes.length)];
      if(pick==='slash'){ reaperAttackState.current=startReaperSlash(now); }
      else { reaperAttackState.current=startReaperBlackHole(now); }
    }
  }

  function damageReaperBoss(amount=1, source='generic', impact, options=null){
    if(reaperPhase!=='active' || !reaperBoss) return false;
    const now=performance.now();
    const opts=options||{};
    if(reaperBoss.hiddenUntil && now<reaperBoss.hiddenUntil) return false;
    if(reaperBoss.hitCooldownUntil && now<reaperBoss.hitCooldownUntil) return false;
    const dmg = Math.max(0, Math.floor(amount));
    if(!dmg) return false;
    reaperBoss.hitCooldownUntil = now + 160;
    const prevHp=reaperBoss.hp;
    reaperBoss.hp = Math.max(0, reaperBoss.hp - dmg);
    if(reaperBoss.hp<prevHp){ incrementCombo(); }
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    reaperBoss.hitFlashUntil = now + 260;
    const jitterX=(Math.random()-0.5)*reaperBoss.w*0.35;
    const jitterY=(Math.random()-0.5)*reaperBoss.h*0.25;
    const colorMap={
      laser:'240,190,255',
      missile:'255,200,200',
      gatling:'255,210,200',
      plasma:'200,230,255',
      blackhole:'210,220,255',
      phoenix:'255,180,210',
      sword:'255,200,220',
      holy:'255,240,220'
    };
    let burstColor=colorMap[source]||'210,150,255';
    if(opts.goldenFx){
      burstColor='255,215,140';
    }
    reaperBursts.push({type:'spark',x:reaperBoss.x+jitterX,y:reaperBoss.y+jitterY,r0:0,r1:150,t0:now,life:720,color:burstColor});
    spawnParticles(reaperBoss.x+jitterX, reaperBoss.y+jitterY, opts.goldenFx?'#ffe27a':'#d9c7ff', 20, 1.5, 2.6, 2.4);
    if(impact && impact.x!=null && impact.y!=null){
      spawnParticles(impact.x, impact.y, '#ff9bd0', 16, 1.4, 2.4, 2.2);
    }
    screenShake=Math.max(screenShake,5);
    const toneMap={laser:760, missile:680, gatling:720, plasma:780, blackhole:660, phoenix:820, sword:880, ball:800, holy:920};
    const freq=toneMap[source]||780;
    beep(freq,0.04,0.04);
    if(reaperBoss.hp<=0){ defeatReaperBoss(); }
    return true;
  }

  function defeatReaperBoss(){
    if(reaperPhase!=='active' || !reaperBoss) return;
    const now=performance.now();
    const rb=reaperBoss;
    dropBossCoins(rb.x, rb.y, 2);
    addScore(BOSS_DEFEAT_SCORE.reaper);
    stats.bossKills++;
    updateHUD();
    reaperAttackState=null;
    reaperSlashZone=null;
    reaperSlashEffects=[];
    reaperBlackHoleAttack=null;
    reaperPaddlePenalty=0;
    reaperPenaltyLastUpdate=0;
    computePaddleWidth();
    reaperPhase='dying';
    reaperDefeatedAt=now;
    reaperTeleportSchedule=null;
    reaperDeathAnim={
      start:now,
      startY:rb.y,
      dropDistance:260,
      fallDuration:3000,
      bigExplosionStart:now+3000,
      bigExplosionEnd:now+5000,
      vanishAt:now+5000,
      finishAt:now+8000,
      lastBurst:now,
      smallBurstInterval:180,
      bigBang:false,
      lastX:rb.x,
      lastY:rb.y,
      lastW:rb.w,
      lastH:rb.h,
      dropSpawned:false
    };
    reaperBursts.push({type:'ring',x:rb.x,y:rb.y,r0:60,r1:560,width:26,t0:now,life:2200,color:'255,170,230'});
    reaperBursts.push({type:'flare',x:rb.x,y:rb.y,r0:0,r1:360,t0:now,life:1900,color:'210,140,255'});
    spawnParticles(rb.x, rb.y, '#ffe5ff', 180, 3.4, 5.6, 6.2);
    screenShake=Math.max(screenShake,14);
    playSFX('fireExplosion');
    reaperMarquee={text:'成功擊殺Boss: 暗黑死神!', start:now, fadeStart:now+5000, end:now+5000, style:'victorySolid'};
    nextTreasureBrickAt=0;
  }

  function updateReaperBoss(){
    if(level!==10) return;
    const now=performance.now();
    if(reaperPhase==='intro' && !reaperBoss && reaperRevealScheduled && now>=reaperRevealScheduled){ activateReaperBoss(); }
    if(reaperPhase==='active' && reaperBoss){
      reaperBoss.x += reaperBoss.vx;
      const margin=150;
      if(reaperBoss.x - reaperBoss.w/2 < margin){ reaperBoss.x = margin + reaperBoss.w/2; reaperBoss.vx = Math.abs(reaperBoss.vx); }
      if(reaperBoss.x + reaperBoss.w/2 > 1100 - margin){ reaperBoss.x = 1100 - margin - reaperBoss.w/2; reaperBoss.vx = -Math.abs(reaperBoss.vx); }
      reaperBoss.y = reaperBoss.baseY + Math.sin((now - reaperBoss.spawnAt)/780)*42;
      reaperBoss.cloakPhase += 0.03;
      const activeAttack=reaperAttackState && reaperAttackState.current;
      const teleportLocked = !!(activeAttack && activeAttack.stage && activeAttack.stage!=='countdown');
      if(reaperTeleportSchedule && !teleportLocked){
        if(reaperTeleportSchedule.burstActive){
          if(now>=reaperTeleportSchedule.nextBurstTeleport){
            performReaperTeleport(true);
            reaperTeleportSchedule.burstRemaining--;
            if(reaperTeleportSchedule.burstRemaining>0){
              reaperTeleportSchedule.nextBurstTeleport = now + reaperTeleportSchedule.burstInterval;
            }else{
              reaperTeleportSchedule.burstActive=false;
              reaperTeleportSchedule.nextSingle = now + 10000;
              reaperTeleportSchedule.nextBurst = now + 30000;
            }
          }
        }else if(now>=reaperTeleportSchedule.nextBurst){
          reaperTeleportSchedule.burstActive=true;
          reaperTeleportSchedule.burstRemaining=5;
          reaperTeleportSchedule.nextBurstTeleport=now;
          performReaperTeleport(true);
          reaperTeleportSchedule.burstRemaining--;
          if(reaperTeleportSchedule.burstRemaining>0){
            reaperTeleportSchedule.nextBurstTeleport = now + reaperTeleportSchedule.burstInterval;
          }else{
            reaperTeleportSchedule.burstActive=false;
            reaperTeleportSchedule.nextSingle = now + 10000;
            reaperTeleportSchedule.nextBurst = now + 30000;
          }
        }else if(now>=reaperTeleportSchedule.nextSingle){
          performReaperTeleport(false);
          reaperTeleportSchedule.nextSingle = now + 10000;
        }
      }
      updateReaperAttacks(now);
    }else if(reaperAttackState && reaperAttackState.current){
      updateReaperAttacks(now);
    }
    if(reaperPhase==='dying'){
      const anim=reaperDeathAnim;
      if(anim){
        const bossSprite=reaperBoss;
        const elapsed=now-anim.start;
        const prog=Math.max(0, Math.min(1, elapsed/anim.fallDuration));
        if(bossSprite){
          bossSprite.y = anim.startY + anim.dropDistance*prog;
          bossSprite.vx = 0;
          anim.lastX = bossSprite.x;
          anim.lastY = bossSprite.y;
          anim.lastW = bossSprite.w;
          anim.lastH = bossSprite.h;
        }
        if(now-anim.lastBurst>=(anim.smallBurstInterval||220) && now<anim.bigExplosionStart && bossSprite){
          anim.lastBurst=now;
          anim.smallBurstInterval=140+Math.random()*120;
          const sx=bossSprite.x + (Math.random()-0.5)*bossSprite.w*0.7;
          const sy=bossSprite.y + (Math.random()-0.5)*bossSprite.h*0.7;
          reaperBursts.push({type:'spark',x:sx,y:sy,r0:0,r1:200,t0:now,life:920,color:'255,170,220'});
          reaperBursts.push({type:'flare',x:sx,y:sy,r0:0,r1:280,t0:now,life:700,color:'200,120,255'});
          spawnParticles(sx, sy, '#ffd9f1', 34, 1.8, 3.2, 3.6);
        }
        if(!anim.bigBang && now>=anim.bigExplosionStart){
          anim.bigBang=true;
          const bx=anim.lastX;
          const by=anim.lastY;
          spawnParticles(bx, by, '#fff0ff', 280, 3.8, 6.2, 6.6);
          spawnParticles(bx, by, '#ffe0ff', 220, 3.4, 5.6, 6.0);
          reaperBursts.push({type:'ring',x:bx,y:by,r0:80,r1:640,width:34,t0:now,life:2200,color:'255,200,240'});
          reaperBursts.push({type:'flare',x:bx,y:by,r0:0,r1:480,t0:now,life:2000,color:'230,170,255'});
          reaperBursts.push({type:'halo',x:bx,y:by,r0:120,r1:720,t0:now,life:2400,color:'255,180,240'});
          screenShake=Math.max(screenShake,16);
          playSFX('fireExplosion');
          if(!anim.dropSpawned){
            spawnBossNineCatOnce('reaper', bx-12, by);
            anim.dropSpawned=true;
          }
        }
        if(anim.bigBang && now<anim.bigExplosionEnd){
          const theta=Math.random()*Math.PI*2;
          const spanW=(bossSprite?bossSprite.w:(anim.lastW||120));
          const dist=spanW*0.5 + Math.random()*spanW*0.5;
          const px=anim.lastX + Math.cos(theta)*dist;
          const py=anim.lastY + Math.sin(theta)*dist;
          reaperBursts.push({type:'spark',x:px,y:py,r0:0,r1:320,t0:now,life:860,color:'255,190,240'});
        }
        if(bossSprite && now>=anim.vanishAt){
          reaperBoss=null;
        }
        if(now>=anim.finishAt){
          reaperPhase='defeated';
          reaperDefeatedAt=now;
          reaperDeathAnim=null;
        }
      }
    }
    for(let i=reaperBursts.length-1;i>=0;i--){ const fx=reaperBursts[i]; const life=fx.life||1000; if(now>fx.t0+life) reaperBursts.splice(i,1); }
    for(let i=reaperAfterimages.length-1;i>=0;i--){ const af=reaperAfterimages[i]; if(now>af.t0+(af.life||600)) reaperAfterimages.splice(i,1); }
    for(let i=reaperSlashEffects.length-1;i>=0;i--){ const slash=reaperSlashEffects[i]; if(now>slash.start+(slash.life||200)){ reaperSlashEffects.splice(i,1); } }
    if(!reaperPenaltyLastUpdate) reaperPenaltyLastUpdate=now;
    const activeHole = reaperBlackHoleAttack && reaperBlackHoleAttack.stage==='hole';
    if(reaperPaddlePenalty>0){
      if(!activeHole){
        const dt=now - reaperPenaltyLastUpdate;
        if(dt>0){
          const recover=(dt/1000)*120;
          if(recover>0){
            const before=reaperPaddlePenalty;
            reaperPaddlePenalty=Math.max(0, reaperPaddlePenalty - recover);
            if(Math.abs(before-reaperPaddlePenalty)>0.5){ computePaddleWidth(); }
          }
        }
      }
    }
    reaperPenaltyLastUpdate=now;
  }

  function drawReaperBoss(rb, now){
    const s=(scaleX+scaleY)/2;
    ctx.save();
    ctx.translate(rb.x*scaleX, rb.y*scaleY);
    if(rb.hiddenUntil && now<rb.hiddenUntil){
      const fade=1-Math.max(0, Math.min(1,(rb.hiddenUntil-now)/3000));
      const radius=rb.w*0.9*s*(1+0.1*Math.sin(now/160));
      const grad=ctx.createRadialGradient(0,0,radius*0.2,0,0,radius);
      grad.addColorStop(0,`rgba(130,90,200,${0.18+0.22*fade})`);
      grad.addColorStop(1,'rgba(130,90,200,0)');
      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(0,0,radius,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
      return;
    }
    const float=Math.sin((now-rb.spawnAt)/520 + rb.cloakPhase*0.6)*8*s;
    ctx.translate(0, float);

    const bodyW=rb.w*0.58*s;
    const bodyH=rb.h*0.64*s;
    const flutterA=Math.sin(now/340 + rb.cloakPhase)*0.28;
    const flutterB=Math.sin(now/220 + rb.cloakPhase*1.4)*0.22;
    const flutterC=Math.sin(now/180 + rb.cloakPhase*0.8)*0.18;

    ctx.save();
    const cloakPath=new Path2D();
    cloakPath.moveTo(-bodyW*0.5, -bodyH*0.08);
    cloakPath.quadraticCurveTo(-bodyW*0.86, -bodyH*0.86, -bodyW*0.28, -bodyH*1.32);
    cloakPath.quadraticCurveTo(0, -bodyH*1.44, bodyW*0.28, -bodyH*1.32);
    cloakPath.quadraticCurveTo(bodyW*0.86, -bodyH*0.86, bodyW*0.5, -bodyH*0.08);
    const ragged=12;
    for(let i=0;i<=ragged;i++){
      const t=i/ragged;
      const offset=-bodyW*0.5 + t*bodyW;
      const sway=Math.sin(now/540 + rb.cloakPhase*0.7 + t*Math.PI)*bodyW*0.08;
      const drop=bodyH*(1.04 + 0.18*Math.sin(t*Math.PI + now/320));
      const wave=Math.sin(now/280 + rb.cloakPhase*0.6 + t*Math.PI*1.8)*bodyH*0.16;
      const crest=drop - bodyH*(0.16 + 0.12*Math.cos(t*Math.PI*2 + now/360));
      cloakPath.quadraticCurveTo(offset + sway*0.6, crest, offset + sway, drop + wave);
    }
    cloakPath.quadraticCurveTo(bodyW*0.7, bodyH*0.34 + flutterB*bodyH*0.36, bodyW*0.46, bodyH*0.94 + flutterC*bodyH*0.28);
    cloakPath.quadraticCurveTo(bodyW*0.18, bodyH*(1.04+flutterB*0.16), 0, bodyH*(0.88 + flutterA*0.3));
    cloakPath.quadraticCurveTo(-bodyW*0.18, bodyH*(1.04-flutterB*0.16), -bodyW*0.46, bodyH*0.94 - flutterC*bodyH*0.28);
    cloakPath.quadraticCurveTo(-bodyW*0.7, bodyH*0.34 - flutterB*bodyH*0.36, -bodyW*0.5, -bodyH*0.08);
    cloakPath.closePath();
    const cloakGrad=ctx.createLinearGradient(0,-bodyH*1.36,0,bodyH*1.2);
    cloakGrad.addColorStop(0,'rgba(34,18,50,0.98)');
    cloakGrad.addColorStop(0.42,'rgba(18,8,26,0.98)');
    cloakGrad.addColorStop(0.78,'rgba(10,6,20,0.96)');
    cloakGrad.addColorStop(1,'rgba(4,2,12,0.94)');
    ctx.fillStyle=cloakGrad;
    ctx.shadowColor='rgba(200,150,255,0.42)';
    ctx.shadowBlur=30*s;
    ctx.fill(cloakPath);
    ctx.shadowBlur=0;
    ctx.strokeStyle='rgba(150,120,220,0.36)';
    ctx.lineWidth=3.6*s;
    ctx.stroke(cloakPath);
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(255,180,240,0.18)';
    ctx.lineWidth=5*s;
    ctx.stroke(cloakPath);
    ctx.restore();
    if(rb.hitFlashUntil && now<rb.hitFlashUntil){
      ctx.strokeStyle='rgba(255,210,250,0.9)';
      ctx.lineWidth=4.8*s;
      ctx.stroke();
    }
    ctx.save();
    ctx.clip();
    const liningGrad=ctx.createLinearGradient(0,-bodyH,0,bodyH*1.18);
    liningGrad.addColorStop(0,'rgba(160,36,52,0.62)');
    liningGrad.addColorStop(0.52,'rgba(120,18,42,0.5)');
    liningGrad.addColorStop(1,'rgba(70,6,24,0.36)');
    ctx.globalAlpha=0.85;
    ctx.fillStyle=liningGrad;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.34, -bodyH*0.02);
    ctx.quadraticCurveTo(-bodyW*0.22, bodyH*0.56, -bodyW*0.32, bodyH*(0.92+flutterC*0.12));
    ctx.quadraticCurveTo(-bodyW*0.08, bodyH*(0.98+flutterA*0.16), 0, bodyH*(0.82 + flutterB*0.16));
    ctx.quadraticCurveTo(bodyW*0.08, bodyH*(0.98-flutterA*0.16), bodyW*0.32, bodyH*(0.9-flutterC*0.12));
    ctx.quadraticCurveTo(bodyW*0.22, bodyH*0.56, bodyW*0.34, -bodyH*0.02);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.restore();

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.42, -bodyH*0.18);
    ctx.quadraticCurveTo(-bodyW*0.64, -bodyH*0.76, -bodyW*0.18, -bodyH*1.24);
    ctx.quadraticCurveTo(0, -bodyH*1.36, bodyW*0.18, -bodyH*1.24);
    ctx.quadraticCurveTo(bodyW*0.64, -bodyH*0.76, bodyW*0.42, -bodyH*0.18);
    ctx.closePath();
    const hoodGrad=ctx.createLinearGradient(0,-bodyH*1.4,0,-bodyH*0.2);
    hoodGrad.addColorStop(0,'rgba(42,18,56,0.98)');
    hoodGrad.addColorStop(1,'rgba(16,8,28,0.98)');
    ctx.fillStyle=hoodGrad;
    ctx.fill();
    ctx.save();
    ctx.clip();
    const hoodInner=ctx.createRadialGradient(0,-bodyH*0.92, bodyW*0.08, 0,-bodyH*0.92, bodyW*0.46);
    hoodInner.addColorStop(0,'rgba(210,40,70,0.55)');
    hoodInner.addColorStop(1,'rgba(80,0,20,0.25)');
    ctx.fillStyle=hoodInner;
    ctx.fillRect(-bodyW*0.6, -bodyH*1.4, bodyW*1.2, bodyH*1.4);
    ctx.restore();
    ctx.restore();

    const headR=bodyW*0.26;
    const headY=-bodyH*0.84;
    const skullW=headR*2.05;
    const skullH=headR*1.78;
    ctx.save();
    ctx.translate(0, headY);
    ctx.shadowColor='rgba(255,200,240,0.45)';
    ctx.shadowBlur=16*s;
    const skullPath=new Path2D();
    skullPath.moveTo(-skullW*0.5, -skullH*0.05);
    skullPath.quadraticCurveTo(0, -skullH*0.86, skullW*0.5, -skullH*0.05);
    skullPath.quadraticCurveTo(skullW*0.62, skullH*0.44, skullW*0.28, skullH*0.78);
    skullPath.quadraticCurveTo(skullW*0.1, skullH*0.96, -skullW*0.1, skullH*0.96);
    skullPath.quadraticCurveTo(-skullW*0.28, skullH*0.78, -skullW*0.62, skullH*0.44);
    skullPath.closePath();
    const skullGrad=ctx.createLinearGradient(0,-skullH,0,skullH);
    skullGrad.addColorStop(0,'#fffafd');
    skullGrad.addColorStop(0.58,'#f1e6f5');
    skullGrad.addColorStop(1,'#e2d1e6');
    ctx.fillStyle=skullGrad;
    ctx.fill(skullPath);
    ctx.strokeStyle='rgba(110,80,150,0.45)';
    ctx.lineWidth=2.1*s;
    ctx.stroke(skullPath);

    ctx.fillStyle='#1a1325';
    ctx.beginPath();
    ctx.ellipse(-skullW*0.22, -skullH*0.1, skullW*0.2, skullH*0.3, -0.04, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(skullW*0.22, -skullH*0.1, skullW*0.2, skullH*0.3, 0.04, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle='rgba(255,255,255,0.16)';
    ctx.beginPath();
    ctx.ellipse(-skullW*0.28, -skullH*0.26, skullW*0.08, skullH*0.14, -0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(skullW*0.28, -skullH*0.26, skullW*0.08, skullH*0.14, 0.2, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle='#1f1528';
    ctx.beginPath();
    ctx.moveTo(0, skullH*0.12);
    ctx.lineTo(-skullW*0.08, skullH*0.38);
    ctx.lineTo(skullW*0.08, skullH*0.38);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle='rgba(140,100,170,0.65)';
    ctx.lineWidth=1.6*s;
    ctx.beginPath();
    ctx.moveTo(-skullW*0.3, skullH*0.54);
    ctx.lineTo(skullW*0.3, skullH*0.54);
    ctx.stroke();
    ctx.beginPath();
    for(let i=-2;i<=2;i++){
      const ratio=i/2;
      const tx=ratio*skullW*0.12;
      const ty=skullH*0.7 - Math.abs(ratio)*skullH*0.08;
      ctx.moveTo(tx, skullH*0.54);
      ctx.lineTo(tx, ty);
    }
    ctx.stroke();

    ctx.fillStyle='rgba(255,255,255,0.22)';
    ctx.beginPath();
    ctx.ellipse(0, -skullH*0.36, skullW*0.3, skullH*0.32, 0, 0, Math.PI);
    ctx.fill();

    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const skullGlow=ctx.createRadialGradient(0, headY, headR*0.2, 0, headY, headR*1.2);
    skullGlow.addColorStop(0,'rgba(255,210,250,0.45)');
    skullGlow.addColorStop(1,'rgba(255,210,250,0)');
    ctx.fillStyle=skullGlow;
    ctx.beginPath();
    ctx.arc(0, headY, headR*1.25, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    const handleSwing=-0.12 + Math.sin(now/520 + rb.cloakPhase)*0.05;
    ctx.rotate(handleSwing);
    ctx.translate(bodyW*0.32, -bodyH*0.12);
    const handleLen=bodyH*1.46;
    const handleGrad=ctx.createLinearGradient(0,-handleLen,0,bodyH*0.2);
    handleGrad.addColorStop(0,'#360208');
    handleGrad.addColorStop(0.48,'#821123');
    handleGrad.addColorStop(1,'#d12a3a');
    ctx.lineCap='round';
    ctx.lineJoin='round';
    ctx.strokeStyle=handleGrad;
    ctx.lineWidth=7.2*s;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.02,0);
    ctx.quadraticCurveTo(bodyW*0.08, -handleLen*0.32, bodyW*0.02, -handleLen*0.64);
    ctx.quadraticCurveTo(-bodyW*0.02, -handleLen*0.84, bodyW*0.04, -handleLen);
    ctx.stroke();

    ctx.strokeStyle='rgba(255,190,200,0.4)';
    ctx.lineWidth=1.6*s;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.015, -handleLen*0.14);
    ctx.quadraticCurveTo(bodyW*0.04, -handleLen*0.5, -bodyW*0.006, -handleLen*0.9);
    ctx.stroke();

    ctx.fillStyle='rgba(255,140,160,0.75)';
    ctx.beginPath();
    ctx.ellipse(0, -handleLen*0.3, bodyW*0.085, bodyW*0.05, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(0, -handleLen*0.56, bodyW*0.078, bodyW*0.044, 0, 0, Math.PI*2);
    ctx.fill();

    const clampH=bodyW*0.18;
    ctx.fillStyle='#741320';
    ctx.fillRect(-bodyW*0.05, -handleLen-clampH, bodyW*0.1, clampH);
    ctx.fillStyle='rgba(255,200,210,0.35)';
    ctx.fillRect(-bodyW*0.05, -handleLen-clampH, bodyW*0.1, clampH*0.32);

    ctx.save();
    ctx.translate(0, -handleLen-clampH);
    ctx.rotate(-Math.PI/12);
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.28, bodyW*0.08);
    ctx.quadraticCurveTo(bodyW*0.5, -bodyH*0.62, bodyW*0.84, bodyH*0.02);
    ctx.quadraticCurveTo(bodyW*0.34, bodyH*0.34, -bodyW*0.32, bodyH*0.18);
    ctx.quadraticCurveTo(-bodyW*0.12, -bodyH*0.02, -bodyW*0.28, bodyW*0.08);
    ctx.closePath();
    const bladeGrad=ctx.createLinearGradient(-bodyW*0.3, bodyH*0.25, bodyW*0.86, -bodyH*0.46);
    bladeGrad.addColorStop(0,'#fef5ff');
    bladeGrad.addColorStop(0.38,'#f38aa2');
    bladeGrad.addColorStop(0.76,'#7d1628');
    ctx.fillStyle=bladeGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(140,20,46,0.9)';
    ctx.lineWidth=2.6*s;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-bodyW*0.06, bodyW*0.02);
    ctx.quadraticCurveTo(bodyW*0.42, -bodyH*0.36, bodyW*0.68, bodyH*0.06);
    ctx.strokeStyle='rgba(255,240,250,0.78)';
    ctx.lineWidth=2*s;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-bodyW*0.24, bodyW*0.12);
    ctx.quadraticCurveTo(bodyW*0.22, bodyH*0.24, -bodyW*0.12, bodyH*0.24);
    ctx.strokeStyle='rgba(120,0,28,0.35)';
    ctx.lineWidth=3*s;
    ctx.stroke();
    ctx.restore();

    ctx.restore();

    ctx.strokeStyle='rgba(210,160,255,0.32)';
    ctx.lineWidth=2.4*s;
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.44, -bodyH*0.08);
    ctx.quadraticCurveTo(-bodyW*0.28, -bodyH*0.64, -bodyW*0.12, -bodyH*1.04);
    ctx.quadraticCurveTo(0, -bodyH*1.18, bodyW*0.12, -bodyH*1.04);
    ctx.quadraticCurveTo(bodyW*0.28, -bodyH*0.64, bodyW*0.44, -bodyH*0.08);
    ctx.stroke();

    const auraGrad=ctx.createRadialGradient(0, bodyH*0.18, bodyW*0.2, 0, bodyH*0.18, bodyW*1.15);
    auraGrad.addColorStop(0,'rgba(150,100,220,0.32)');
    auraGrad.addColorStop(1,'rgba(150,100,220,0)');
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=auraGrad;
    ctx.beginPath();
    ctx.arc(0, bodyH*0.18, bodyW*1.15, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawReaperLayer(){
    if(level!==10) return;
    if(reaperPhase==='inactive' && !reaperBursts.length && !reaperAfterimages.length) return;
    const now=performance.now();
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    for(const fx of reaperBursts){
      const life=fx.life||1000;
      const prog=Math.max(0, Math.min(1, (now-fx.t0)/life));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      if(fx.type==='ring'){
        const rad=(fx.r0||0)+((fx.r1||220)-(fx.r0||0))*easeOut(prog);
        const alpha=1-prog;
        ctx.strokeStyle=`rgba(${fx.color||'220,150,255'},${0.55*alpha})`;
        ctx.lineWidth=(fx.width||16)*((scaleX+scaleY)/2)*(1-prog*0.7);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='flare'){
        const rad=(fx.r1||220)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(10, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0, `rgba(${fx.color||'200,140,255'},${0.36*(1-prog)})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='spark'){
        const rad=(fx.r1||90)*prog*((scaleX+scaleY)/2);
        ctx.strokeStyle=`rgba(${fx.color||'220,160,255'},${0.7*(1-prog)})`;
        ctx.lineWidth=2.4*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.moveTo(fx.x*scaleX-rad, fx.y*scaleY);
        ctx.lineTo(fx.x*scaleX+rad, fx.y*scaleY);
        ctx.moveTo(fx.x*scaleX, fx.y*scaleY-rad);
        ctx.lineTo(fx.x*scaleX, fx.y*scaleY+rad);
        ctx.stroke();
      }else if(fx.type==='halo'){
        const rad=(fx.r0||40)+((fx.r1||240)-(fx.r0||40))*prog;
        ctx.strokeStyle=`rgba(${fx.color||'200,150,255'},${0.25*(1-prog)})`;
        ctx.lineWidth=8*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }
    if(reaperSlashZone){
      const zone=reaperSlashZone;
      const pulse=0.5+0.5*Math.sin(now/140);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createLinearGradient(zone.x*scaleX, (zone.y+zone.h/2)*scaleY, (zone.x+zone.w)*scaleX, (zone.y+zone.h/2)*scaleY);
      grad.addColorStop(0,`rgba(255,70,100,${0.08+0.12*pulse})`);
      grad.addColorStop(0.5,`rgba(255,90,140,${0.22+0.25*pulse})`);
      grad.addColorStop(1,`rgba(255,70,100,${0.08+0.12*pulse})`);
      ctx.fillStyle=grad;
      ctx.fillRect(zone.x*scaleX, zone.y*scaleY, zone.w*scaleX, zone.h*scaleY);
      ctx.strokeStyle=`rgba(255,150,190,${0.35+0.3*pulse})`;
      ctx.lineWidth=3*((scaleX+scaleY)/2);
      ctx.strokeRect(zone.x*scaleX, zone.y*scaleY, zone.w*scaleX, zone.h*scaleY);
      ctx.restore();
    }
    for(const slash of reaperSlashEffects){
      const life=slash.life||240;
      const prog=Math.max(0, Math.min(1,(now-slash.start)/life));
      const alpha=1-prog;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createLinearGradient(slash.x1*scaleX, slash.y1*scaleY, slash.x2*scaleX, slash.y2*scaleY);
      grad.addColorStop(0,`rgba(255,120,160,${0.08*alpha})`);
      grad.addColorStop(0.5,`rgba(255,80,130,${0.85*alpha})`);
      grad.addColorStop(1,`rgba(255,120,160,${0.08*alpha})`);
      ctx.strokeStyle=grad;
      ctx.lineWidth=4*((scaleX+scaleY)/2)*(1+0.4*(1-prog));
      ctx.beginPath();
      ctx.moveTo(slash.x1*scaleX, slash.y1*scaleY);
      ctx.lineTo(slash.x2*scaleX, slash.y2*scaleY);
      ctx.stroke();
      ctx.restore();
    }
    const countdownAttack=reaperAttackState && reaperAttackState.current;
    if(countdownAttack && countdownAttack.stage==='countdown'){
      const remain=Math.ceil((countdownAttack.countdownEnd-now)/1000);
      if(remain>0){
        const L=layout();
        const anchorY=Math.max(L.top - 36, 68);
        const scaleAvg=(scaleX+scaleY)/2;
        const fontSize=Math.round(74*scaleAvg);
        if(countdownAttack.type==='slash'){
          ctx.save();
          ctx.globalCompositeOperation='lighter';
          const glow=ctx.createRadialGradient(canvas.width/2, anchorY*scaleY, 0, canvas.width/2, anchorY*scaleY, 140*scaleAvg);
          glow.addColorStop(0,'rgba(255,130,200,0.42)');
          glow.addColorStop(1,'rgba(255,130,200,0)');
          ctx.fillStyle=glow;
          ctx.beginPath();
          ctx.arc(canvas.width/2, anchorY*scaleY, 140*scaleAvg, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
        ctx.save();
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
        if(countdownAttack.type==='slash'){
          ctx.fillStyle='rgba(255,235,248,0.95)';
          ctx.shadowColor='rgba(255,160,210,0.85)';
        }else{
          ctx.fillStyle='rgba(230,230,255,0.92)';
          ctx.shadowColor='rgba(180,170,255,0.85)';
        }
        ctx.shadowBlur=(countdownAttack.type==='slash'?26:22)*scaleAvg;
        ctx.fillText(String(remain), canvas.width/2, anchorY*scaleY);
        ctx.restore();
      }
    }
    if(reaperBlackHoleAttack){
      const atk=reaperBlackHoleAttack;
      if(atk.projectile){
        const trail=atk.projectileTrail||[];
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        for(const t of trail){
          const age=Math.max(0, Math.min(1,(now-t.t)/400));
          const alpha=1-age;
          const r=atk.projectile.radius*((scaleX+scaleY)/2)*0.6*alpha;
          ctx.fillStyle=`rgba(150,90,220,${0.18*alpha})`;
          ctx.beginPath();
          ctx.arc(t.x*scaleX, t.y*scaleY, r, 0, Math.PI*2);
          ctx.fill();
        }
        const rad=atk.projectile.radius*((scaleX+scaleY)/2)*(1+0.15*Math.sin(now/120));
        const grad=ctx.createRadialGradient(atk.projectile.x*scaleX, atk.projectile.y*scaleY, rad*0.2, atk.projectile.x*scaleX, atk.projectile.y*scaleY, rad);
        grad.addColorStop(0,'rgba(20,10,40,0.9)');
        grad.addColorStop(0.4,'rgba(130,60,200,0.75)');
        grad.addColorStop(1,'rgba(255,140,220,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(atk.projectile.x*scaleX, atk.projectile.y*scaleY, rad, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      if(atk.stage==='hole' && atk.hole){
        const hole=atk.hole;
        const life=Math.max(1, (hole.end||now) - (hole.start||now));
        const age=Math.max(0, Math.min(1, (now - (hole.start||now))/life));
        const spinDir=hole.spinDir||1;
        const scaleAvg=(scaleX+scaleY)/2;
        const baseR=(hole.radius||160)*scaleAvg;
        const x=hole.x*scaleX;
        const y=hole.y*scaleY;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const warp=ctx.createRadialGradient(x,y,baseR*0.32,x,y,baseR*1.3);
        warp.addColorStop(0,`rgba(30,12,60,${0.85-0.35*age})`);
        warp.addColorStop(0.45,`rgba(110,60,200,${0.65-0.25*age})`);
        warp.addColorStop(0.78,'rgba(220,200,255,0.28)');
        warp.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=warp;
        ctx.beginPath();
        ctx.arc(x,y,baseR*1.3,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle=`rgba(230,210,255,${0.32*(1-age)+0.12*Math.sin(now/160)})`;
        ctx.lineWidth=5.2*scaleAvg;
        ctx.beginPath();
        ctx.arc(x,y,baseR*1.08,0,Math.PI*2);
        ctx.stroke();
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate((now/220 + (hole.vortexPhase||0))*spinDir);
        const armCount=5;
        for(let a=0;a<armCount;a++){
          const theta=a*(Math.PI*2/armCount);
          const armR=baseR*(0.46 + a*0.08);
          ctx.beginPath();
          ctx.strokeStyle=`rgba(255,230,255,${(0.18-0.02*a)*(1-age)})`;
          ctx.lineWidth=(2.4+a*0.6)*scaleAvg;
          ctx.arc(0,0,armR,theta,theta+Math.PI*0.55);
          ctx.stroke();
        }
        ctx.restore();
        ctx.restore();
      }
    }
    for(const af of reaperAfterimages){
      const life=af.life||600;
      const prog=Math.max(0, Math.min(1, (now-af.t0)/life));
      const alpha=(af.emerge?prog:1-prog)*0.4;
      const scale=(af.scale||1)*(1+(af.emerge?0.2*prog:0));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.translate(af.x*scaleX, af.y*scaleY);
      ctx.scale(scale, scale);
      ctx.globalAlpha=alpha;
      ctx.fillStyle='rgba(200,150,255,0.6)';
      ctx.beginPath();
      ctx.ellipse(0,0, reaperBoss?reaperBoss.w*0.28*((scaleX+scaleY)/2):70*((scaleX+scaleY)/2), reaperBoss?reaperBoss.h*0.36*((scaleX+scaleY)/2):90*((scaleX+scaleY)/2),0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    if(reaperBoss && (reaperPhase==='active' || reaperPhase==='intro' || reaperPhase==='dying')){
      drawReaperBoss(reaperBoss, now);
    }else if(reaperPhase==='intro' && reaperAnchor){
      const cx=(reaperAnchor.x+reaperAnchor.w/2)*scaleX;
      const cy=(reaperAnchor.y+reaperAnchor.h+80)*scaleY;
      const rad=Math.max(reaperAnchor.w, reaperAnchor.h)*1.3*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      g.addColorStop(0,'rgba(200,140,255,0.18)');
      g.addColorStop(1,'rgba(200,140,255,0)');
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    if(reaperTargetHighlightUntil && now<reaperTargetHighlightUntil){
      const bounds=getReaperBounds();
      if(bounds){
        const a=Math.max(0, Math.min(1,(reaperTargetHighlightUntil-now)/600));
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle=`rgba(255,160,230,${0.6*a})`;
        ctx.lineWidth=4;
        drawRoundedRect(bounds.x-6,bounds.y-6,bounds.w+12,bounds.h+12,16);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function drawReaperMarquee(){
    if(!reaperMarquee) return;
    const now=performance.now();
    const {start, fadeStart, end, text} = reaperMarquee;
    const style=reaperMarquee.style||'marquee';
    if(now>=end){ reaperMarquee=null; return; }
    let alpha=1;
    if(style!=='victorySolid' && now>fadeStart){ alpha = Math.max(0, 1 - (now - fadeStart)/(end - fadeStart||1)); }
    const scaleAvg=(scaleX+scaleY)/2;
    const textScale=Math.max(0.6, scaleAvg);
    const areaHeight=56;
    const top=Math.max(12, layout().top - areaHeight - 14);
    const x=40;
    const width=1100-80;
    const radius=18;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, top, width, areaHeight, radius);
    if(style==='victorySolid'){
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(46,32,84,0.96)');
      grad.addColorStop(1,'rgba(18,18,54,0.96)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,210,230,0.75)';
      ctx.lineWidth=2.2;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      ctx.fillStyle='#ffe9fa';
      const fontSize=Math.max(24, Math.round(30*textScale));
      ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,190,230,0.6)';
      ctx.shadowBlur=18*textScale;
      ctx.fillText(text, (x+width/2)*scaleX, (top+areaHeight/2)*scaleY);
      ctx.shadowBlur=0;
    }else{
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(34,26,70,0.92)');
      grad.addColorStop(1,'rgba(20,16,46,0.94)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(200,180,255,0.85)';
      ctx.lineWidth=2;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+12;
      const innerY=top+6;
      const innerW=width-24;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.save();
      ctx.clip();
      ctx.fillStyle='#fef7ff';
      const fontSize=Math.max(18, Math.round(24*textScale));
      ctx.font=`${fontSize}px 'Noto Sans TC','Playfair Display',sans-serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(200,160,255,0.5)';
      ctx.shadowBlur=12*textScale;
      ctx.fillText(text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawReaperHPBar(){
    if((reaperPhase!=='active' && reaperPhase!=='dying') || !reaperBoss) return;
    const L=layout();
    const barW=32;
    const maxH=700-(L.top+80);
    const barH=Math.max(200, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, reaperBoss.hp/reaperBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(40,20,60,0.96)');
    frameGrad.addColorStop(1,'rgba(24,12,42,0.92)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(210,160,255,0.6)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(12,10,26,0.92)');
    bg.addColorStop(1,'rgba(26,18,40,0.88)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(255,110,160,0.22)');
      fillGrad.addColorStop(0.35,'rgba(255,120,200,0.6)');
      fillGrad.addColorStop(1,'rgba(255,220,250,0.95)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    ctx.strokeStyle='rgba(255,255,255,0.14)';
    ctx.lineWidth=1;
    const segments=reaperBoss.maxHp;
    const step=innerH/segments;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - step*i)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS 暗黑死神', reaperBoss.hp, reaperBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(40,20,60,0.95)',
      bgBottom:'rgba(24,12,42,0.9)',
      frame:'rgba(210,160,255,0.7)',
      glow:'rgba(200,160,255,0.55)',
      textPrimary:'#eae0ff',
      textSecondary:'#f5ebff'
    });
    ctx.restore();
  }

  function drawReaperHUD(){
    drawReaperMarquee();
    drawReaperHPBar();
  }

  // === 第15關 毀滅之龍 Boss ===
  function startDragonReveal(fromBrick){
    if(level!==15) return;
    if(dragonPhase!=='awaiting' && dragonPhase!=='intro') return;
    const now=performance.now();
    dragonPhase='intro';
    let source=fromBrick || dragonPlaceholder;
    if(fromBrick){
      const idx=bricks.indexOf(fromBrick);
      if(idx>=0) bricks.splice(idx,1);
    }else if(dragonPlaceholder){
      const idx=bricks.indexOf(dragonPlaceholder);
      if(idx>=0) bricks.splice(idx,1);
    }
    dragonPlaceholder=null;
    if(!source){
      const L=layout();
      const bx=Math.floor(L.cols/2)-1;
      const w=brickW*2 + L.pad;
      const h=brickH*2 + L.pad;
      source={x:L.pad + bx*(brickW+L.pad), y:L.top, w, h};
    }
    dragonAnchor={x:source.x, y:source.y, w:source.w, h:source.h};
    const cx=dragonAnchor.x+dragonAnchor.w/2;
    const cy=dragonAnchor.y+dragonAnchor.h/2;
    spawnParticles(cx,cy,'#fff2c7',120,2.8,4.2,4.5);
    spawnParticles(cx,cy,'#ffbc5e',90,2.4,3.8,4.0);
    spawnParticles(cx,cy,'#ffd36f',80,2.0,3.2,3.6);
    dragonBursts.push({type:'ring',x:cx,y:cy,r0:30,r1:460,width:22,t0:now,life:1600,color:'255,215,120'});
    dragonBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:320,t0:now,life:1400,color:'255,210,140'});
    dragonBursts.push({type:'spark',x:cx,y:cy,r0:0,r1:220,t0:now,life:1200,color:'255,240,200'});
    playSFX('fireExplosion');
    screenShake=Math.max(screenShake,24);
    dragonRevealScheduled = now + 1000;
  }

  function activateDragonBoss(){
    if(level!==15) return;
    if(dragonPhase!=='intro' || dragonBoss) return;
    const L=layout();
    let anchor=dragonAnchor;
    if(!anchor){
      const bx=Math.floor(L.cols/2)-1;
      const w=brickW*2 + L.pad;
      const h=brickH*2 + L.pad;
      anchor={x:L.pad + bx*(brickW+L.pad), y:L.top, w, h};
      dragonAnchor=anchor;
    }
    const cx=anchor.x+anchor.w/2;
    const baseY=Math.max(L.top + 160, anchor.y + anchor.h + 140);
    const now=performance.now();
    resetBossNineCatDrop('dragon');
    dragonBoss={
      x:cx,
      y:baseY,
      baseY,
      w:120,
      h:75,
      hp:DRAGON_MAX_HP,
      maxHp:DRAGON_MAX_HP,
      wingPhase:Math.random()*Math.PI*2,
      hoverPhase:Math.random()*Math.PI*2,
      moveTarget:null,
      nextMove:now+800,
      pose:null,
      hitCooldownUntil:0,
      hitFlashUntil:0,
      lastUpdate:now,
      petrifyCharge:null
    };
    dragonPhase='active';
    dragonBursts.push({type:'halo',x:cx,y:baseY-20,r0:80,r1:420,t0:now,life:1800,color:'255,215,140'});
    dragonMarquee={text:'毀滅之龍現身了!', start:now, fadeStart:now+3200, end:now+3600, style:'alert'};
    scheduleNextTreasureBrick(now);
  }

  function dragonImpactPoint(fromX, fromY){
    if(!dragonBoss) return {x:fromX, y:fromY};
    const bounds=getDragonBounds();
    if(!bounds) return {x:fromX, y:fromY};
    const dx=dragonBoss.x - fromX;
    const dy=dragonBoss.y - fromY;
    if(dx===0 && dy===0) return {x:dragonBoss.x, y:dragonBoss.y};
    const halfW=bounds.w/2;
    const halfH=bounds.h/2;
    const scale=Math.sqrt((dx*dx)/(halfW*halfW) + (dy*dy)/(halfH*halfH));
    if(!isFinite(scale) || scale===0) return {x:dragonBoss.x, y:dragonBoss.y};
    const t=1/scale;
    return {x:dragonBoss.x - dx*t, y:dragonBoss.y - dy*t};
  }

  function dragonClampPoint(x, y){
    const bounds=getDragonBounds();
    if(!bounds) return {x, y};
    return {
      x: Math.max(bounds.x, Math.min(x, bounds.x + bounds.w)),
      y: Math.max(bounds.y, Math.min(y, bounds.y + bounds.h))
    };
  }

  function damageDragonBoss(amount=1, source='generic', impact, options=null){
    if(dragonPhase!=='active' || !dragonBoss) return false;
    const now=performance.now();
    const opts=options||{};
    if(dragonBoss.hitCooldownUntil && now<dragonBoss.hitCooldownUntil) return false;
    dragonBoss.hitCooldownUntil=now+140;
    const dmg=Math.max(0, Math.floor(amount));
    if(!dmg) return false;
    const prevHp=dragonBoss.hp;
    dragonBoss.hp=Math.max(0, dragonBoss.hp-dmg);
    if(dragonBoss.hp<prevHp){ incrementCombo(); }
    if(source==='ball'){
      addScore(BOSS_HIT_SCORE);
      updateHUD();
    }
    dragonBoss.hitFlashUntil=now+220;
    const ix=(impact&&impact.x!=null)?impact.x:dragonBoss.x;
    const iy=(impact&&impact.y!=null)?impact.y:dragonBoss.y;
    dragonBursts.push({type:'ember',x:ix,y:iy,t0:now,life:600,color:opts.goldenFx?'255,220,140':undefined});
    spawnParticles(ix,iy,opts.goldenFx?'#ffe07a':'#ffd97a',18,2.0,3.0,3.2);
    screenShake=Math.max(screenShake,4);
    if(dragonBoss.hp<=0){ defeatDragonBoss(); }
    return true;
  }

  function defeatDragonBoss(){
    if(dragonPhase==='dying' || dragonPhase==='defeated') return;
    const now=performance.now();
    dragonPhase='dying';
    dragonMarquee={text:'成功擊殺Boss: 毀滅之龍!', start:now, fadeStart:now+5000, end:now+5000, style:'victorySolid'};
    dragonDeathAnim={start:now, fallDuration:3000, bigExplosionStart:now+3000, bigExplosionEnd:now+5000, lastSmallBurst:0, bigExplosionTriggered:false, finished:false};
    dragonAttackState=null;
    dragonDeathRayOrbs.length=0;
    dragonDeathRayBeams.length=0;
    if(dragonBoss){
      dragonBoss.petrifyCharge=null;
      const cx=dragonBoss.x, cy=dragonBoss.y;
      dragonBursts.push({type:'flare',x:cx,y:cy,r0:0,r1:360,t0:now,life:1500,color:'255,220,150'});
      dragonBursts.push({type:'ring',x:cx,y:cy,r0:60,r1:520,width:26,t0:now,life:1800,color:'255,210,130'});
    }
    addScore(BOSS_DEFEAT_SCORE.dragon);
    if(dragonBoss){ dropBossCoins(dragonBoss.x, dragonBoss.y, 3); }
    stats.bossKills++;
    updateHUD();
    screenShake=Math.max(screenShake,20);
    playSFX('fireExplosion');
    const dropX=(dragonBoss?dragonBoss.x:550)-12;
    const dropY=dragonBoss?dragonBoss.y:300;
    spawnBossNineCatOnce('dragon', dropX, dropY);
  }

  function updateDragonBoss(){
    if(level!==15) return;
    const now=performance.now();
    if(dragonPhase==='intro' && !dragonBoss && dragonRevealScheduled && now>=dragonRevealScheduled){
      activateDragonBoss();
    }
    if(dragonPhase==='active' && dragonBoss){
      const dt = now - (dragonBoss.lastUpdate||now);
      dragonBoss.lastUpdate=now;
      const handledMovement = updateDragonAttackState(now, dt);
      if(!handledMovement){
        if(!dragonBoss.moveTarget || now>=dragonBoss.nextMove){
          const L=layout();
          const minX=170;
          const maxX=930;
          const minY=L.top+140;
          const maxY=Math.min(L.top+300, dragonBoss.baseY+80);
          dragonBoss.moveTarget={x:minX+Math.random()*(maxX-minX), y:minY+Math.random()*(maxY-minY)};
          dragonBoss.nextMove=now+2200+Math.random()*1600;
        }
        if(dragonBoss.moveTarget){
          const speed=Math.min(0.18, (dt/1000)*0.6);
          dragonBoss.x += (dragonBoss.moveTarget.x - dragonBoss.x)*speed;
          dragonBoss.baseY += (dragonBoss.moveTarget.y - dragonBoss.baseY)*speed;
        }
      }
      dragonBoss.hoverPhase += dt*0.002;
      dragonBoss.y = dragonBoss.baseY + Math.sin(dragonBoss.hoverPhase)*10;
      dragonBoss.wingPhase += dt*0.0065;
    }else if(dragonPhase==='dying'){
      const anim=dragonDeathAnim;
      if(anim){
        if(dragonBoss){
          if(now<anim.bigExplosionStart){
            const dur=anim.fallDuration||3000;
            const prog=Math.max(0, Math.min(1,(now-anim.start)/dur));
            const drop=160;
            dragonBoss.y = dragonBoss.baseY + prog*drop;
            if(!anim.lastSmallBurst || now-anim.lastSmallBurst>140){
              anim.lastSmallBurst=now;
              const ox=(Math.random()-0.5)*dragonBoss.w*0.7;
              const oy=(Math.random()-0.4)*dragonBoss.h*0.7;
              const px=dragonBoss.x+ox;
              const py=dragonBoss.y+oy;
              dragonBursts.push({type:'spark',x:px,y:py,r0:0,r1:240,t0:now,life:900,color:'255,210,150'});
              spawnParticles(px,py,'#ffdd9b',24,2.2,3.4,3.6);
            }
          }else if(now<anim.bigExplosionEnd){
            if(!anim.bigExplosionTriggered){
              anim.bigExplosionTriggered=true;
              const cx=dragonBoss.x, cy=dragonBoss.y;
              dragonBursts.push({type:'mega',x:cx,y:cy,r0:140,r1:720,t0:now,life:2000});
              dragonBursts.push({type:'halo',x:cx,y:cy,r0:160,r1:680,t0:now,life:2400,color:'255,220,150'});
              spawnParticles(cx,cy,'#fff2d6',300,3.8,5.6,6.0);
              spawnParticles(cx,cy,'#ffe4a6',200,3.4,4.8,5.2);
              screenShake=Math.max(screenShake,32);
              playSFX('fireExplosion');
            }
          }else{
            dragonBoss=null;
          }
        }else if(!anim.finished && now>=anim.bigExplosionEnd){
          anim.finished=true;
          dragonDefeatedAt=now;
          dragonPhase='defeated';
          dragonDeathAnim=null;
        }
      }
    }
    for(let i=dragonBursts.length-1;i>=0;i--){ const fx=dragonBursts[i]; const life=fx.life||1200; if(now>fx.t0+life){ dragonBursts.splice(i,1); } }
    if(dragonMarquee && now>=dragonMarquee.end){ dragonMarquee=null; }
  }

  function renderDragonBody(boss, now){
    if(dragonAttackState && dragonAttackState.hideDragon){ return; }
    const scaleAvg=(scaleX+scaleY)/2;
    const bodyScale=boss.w/260;
    ctx.save();
    ctx.translate(boss.x*scaleX, boss.y*scaleY);
    ctx.scale(scaleAvg*bodyScale, scaleAvg*bodyScale);
    const wingCycle=boss.wingPhase;
    const sine=Math.sin(wingCycle);
    const downstroke=Math.pow(Math.max(0, sine), 1.6);
    const upstroke=Math.pow(Math.max(0, -sine), 1.2);
    const flap=(downstroke*0.65 - upstroke*0.42) + Math.sin(now*0.0032)*0.08;
    const flash = boss.hitFlashUntil && now<boss.hitFlashUntil;
    const wingLift = 26*flap;
    const wingSpread = 1.38 + flap*0.42;
    const metalGradient=(x0,y0,x1,y1)=>{
      const g=ctx.createLinearGradient(x0,y0,x1,y1);
      g.addColorStop(0, flash?'#fff9ed':'#fcefd6');
      g.addColorStop(0.35, flash?'#ffe4a4':'#f5c86f');
      g.addColorStop(0.7, flash?'#ffc660':'#d88d35');
      g.addColorStop(1, flash?'#ffad40':'#a95c18');
      return g;
    };
    const darkMetal=(alpha=1)=>`rgba(110,64,22,${(flash?0.55:0.38)*alpha})`;

    const tailSwing=Math.sin(now/340 + boss.wingPhase*1.6)*5.8;
    const charge=boss.petrifyCharge;
    let chargeProgress=0;
    if(charge){
      const duration=(charge.end||0)-(charge.start||0) || 1;
      chargeProgress=Math.max(0, Math.min(1,(now-charge.start)/duration));
    }
    if(chargeProgress>0){
      const pulse=0.55+Math.sin(now/140)*0.45;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.shadowColor=`rgba(255,210,160,${0.55+0.35*chargeProgress})`;
      ctx.shadowBlur=36+chargeProgress*32;

      const auraRadius=220 + 160*chargeProgress + pulse*30;
      const coreGlow=ctx.createRadialGradient(0,-32,0,0,-32,auraRadius);
      coreGlow.addColorStop(0,'rgba(255,244,222,0.95)');
      coreGlow.addColorStop(0.35,'rgba(255,208,150,0.8)');
      coreGlow.addColorStop(0.75,'rgba(255,150,60,0.36)');
      coreGlow.addColorStop(1,'rgba(255,90,30,0)');
      ctx.fillStyle=coreGlow;
      ctx.globalAlpha=0.55+0.4*chargeProgress;
      ctx.beginPath();
      ctx.ellipse(0,8,auraRadius*0.55,auraRadius*0.78,0,0,Math.PI*2);
      ctx.fill();

      const haloRadius=140 + 120*chargeProgress + pulse*18;
      ctx.globalAlpha=0.85;
      ctx.lineWidth=6.5 + chargeProgress*3.5;
      ctx.strokeStyle=`rgba(255,220,170,${0.55+0.3*pulse})`;
      ctx.beginPath();
      ctx.ellipse(0,-46,haloRadius*0.6,haloRadius*0.84,0,0,Math.PI*2);
      ctx.stroke();

      const filamentCount=6;
      for(let i=0;i<filamentCount;i++){
        const ang=(now/420) + i*(Math.PI*2/filamentCount);
        const reach=160 + chargeProgress*180 + pulse*20;
        ctx.save();
        ctx.rotate(ang);
        ctx.translate(0,-24);
        ctx.globalAlpha=0.55+0.35*chargeProgress;
        ctx.strokeStyle=`rgba(255,228,190,${0.45+0.25*pulse})`;
        ctx.lineWidth=4.5 + chargeProgress*2.8;
        ctx.beginPath();
        ctx.moveTo(0,-28);
        ctx.quadraticCurveTo(reach*0.28,-reach*0.62,reach,0);
        ctx.quadraticCurveTo(reach*0.36,reach*0.48,reach*0.08,reach*0.74);
        ctx.stroke();
        ctx.restore();
      }

      const sparkCount=12;
      ctx.globalAlpha=0.65;
      for(let i=0;i<sparkCount;i++){
        const ang=(now/260) + i*(Math.PI*2/sparkCount);
        const radius=haloRadius + 50 + Math.sin(now/180 + i)*26*chargeProgress;
        const sx=Math.cos(ang)*radius;
        const sy=Math.sin(ang)*radius*0.88 - 18;
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(ang);
        ctx.fillStyle='rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.ellipse(0,0,6 + chargeProgress*3.2,2.6 + chargeProgress*1.4,0,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }
    ctx.save();
    ctx.translate(0,62);
    const tailBaseSwing=tailSwing;
    const tailRipple=Math.sin(now/260 + boss.wingPhase*2.2)*3.6;
    ctx.rotate(tailBaseSwing*Math.PI/180);
    const tailSegments=12;
    const segmentSpacing=22;
    const tailLength=tailSegments*segmentSpacing;
    for(let i=0;i<tailSegments;i++){
      const prog=i/(tailSegments-1);
      const segOffset=i*segmentSpacing;
      const segWidth=42 - prog*18;
      const segHeight=28 - prog*10;
      ctx.save();
      ctx.translate(0,segOffset);
      ctx.rotate((tailRipple*prog)*Math.PI/180);
      if(i%2===0){
        const outerW=segWidth*0.52;
        const outerH=segHeight*0.5;
        const innerW=outerW*0.56;
        const innerH=outerH*0.58;
        ctx.fillStyle=metalGradient(-outerW, -outerH*0.6, outerW, outerH*1.2);
        ctx.beginPath();
        ctx.ellipse(0,0,outerW,outerH,0,0,Math.PI*2);
        ctx.ellipse(0,0,innerW,innerH,0,0,Math.PI*2,true);
        ctx.fill('evenodd');
        ctx.strokeStyle=`rgba(255,234,208,${flash?0.9:0.72})`;
        ctx.lineWidth=1.8;
        ctx.beginPath();
        ctx.ellipse(0,0,outerW,outerH,0,0,Math.PI*2);
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.85);
        ctx.lineWidth=1.2;
        ctx.beginPath();
        ctx.ellipse(0,0,innerW*1.02,innerH*1.02,0,0,Math.PI*2);
        ctx.stroke();
      }else{
        const bladeW=segWidth*0.6;
        const bladeH=segHeight*1.26;
        ctx.fillStyle=metalGradient(-bladeW*0.8, -bladeH*0.4, bladeW*0.9, bladeH*0.9);
        ctx.beginPath();
        ctx.moveTo(-bladeW*0.46,-bladeH*0.2);
        ctx.quadraticCurveTo(-bladeW*0.62,bladeH*0.38,-bladeW*0.2,bladeH*0.84);
        ctx.lineTo(bladeW*0.2,bladeH*0.84);
        ctx.quadraticCurveTo(bladeW*0.62,bladeH*0.34,bladeW*0.46,-bladeH*0.2);
        ctx.quadraticCurveTo(0,-bladeH*0.82,-bladeW*0.46,-bladeH*0.2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,238,214,${flash?0.92:0.76})`;
        ctx.lineWidth=1.9;
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.88);
        ctx.lineWidth=1.1;
        ctx.beginPath();
        ctx.moveTo(0,-bladeH*0.72);
        ctx.lineTo(0,bladeH*0.74);
        ctx.moveTo(-bladeW*0.24,-bladeH*0.12);
        ctx.lineTo(-bladeW*0.06,bladeH*0.62);
        ctx.moveTo(bladeW*0.24,-bladeH*0.12);
        ctx.lineTo(bladeW*0.06,bladeH*0.62);
        ctx.stroke();
      }
      ctx.restore();

      if(i<tailSegments-1){
        const nodeProg=(i+0.5)/(tailSegments-1);
        ctx.save();
        ctx.translate(0,segOffset+segmentSpacing*0.5);
        ctx.rotate((tailRipple*nodeProg)*Math.PI/180);
        const nodeGrad=metalGradient(-12,-8,12,14);
        ctx.fillStyle=nodeGrad;
        ctx.beginPath();
        ctx.ellipse(0,0,8.4,6.2,0,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle=`rgba(255,244,220,${flash?0.94:0.78})`;
        ctx.lineWidth=1.2;
        ctx.stroke();
        ctx.strokeStyle=`rgba(255,212,150,${flash?0.7:0.56})`;
        ctx.lineWidth=0.9;
        ctx.beginPath();
        ctx.ellipse(0,0,5.4,3.8,0,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }

    ctx.save();
    ctx.translate(0,tailLength+12);
    const spearAngle=tailBaseSwing*0.38 + Math.sin(now/320 + boss.wingPhase*2.6)*6;
    ctx.rotate(spearAngle*Math.PI/180);
    const spearGrad=metalGradient(-22,-36,22,68);
    ctx.fillStyle=spearGrad;
    ctx.beginPath();
    ctx.moveTo(-10,-12);
    ctx.quadraticCurveTo(-22,28,-6,74);
    ctx.lineTo(0,92);
    ctx.lineTo(6,74);
    ctx.quadraticCurveTo(22,28,10,-12);
    ctx.quadraticCurveTo(0,-42,-10,-12);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,236,210,${flash?0.92:0.76})`;
    ctx.lineWidth=2.2;
    ctx.stroke();
    ctx.strokeStyle=darkMetal(0.88);
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(0,-28);
    ctx.lineTo(0,76);
    ctx.stroke();
    for(const side of [-1,1]){
      ctx.beginPath();
      ctx.moveTo(side*4,42);
      ctx.lineTo(side*28,14);
      ctx.lineTo(side*10,68);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    ctx.strokeStyle=`rgba(255,246,228,${flash?0.92:0.8})`;
    ctx.lineWidth=1.1;
    ctx.beginPath();
    ctx.moveTo(-12,52);
    ctx.quadraticCurveTo(0,82,12,52);
    ctx.stroke();
    ctx.restore();
    ctx.restore();

    function drawWing(side){
      ctx.save();
      ctx.scale(side,1);
      ctx.translate(-42,-34);
      ctx.rotate((-32 + flap*18)*Math.PI/180);

      // wing root armor
      ctx.fillStyle=metalGradient(-68,-60,42,110);
      ctx.beginPath();
      ctx.moveTo(-60,-34);
      ctx.lineTo(16,-20);
      ctx.lineTo(22,36);
      ctx.lineTo(-48,68);
      ctx.lineTo(-82,30);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,235,210,${flash?0.9:0.74})`;
      ctx.lineWidth=2.6;
      ctx.stroke();

      const outerBlades=[
        {base:[-24,-14], ctrl:[-150,-148-wingLift*0.5], tip:[-304,-168-wingLift*0.74], width:54, curvature:34, tipWidth:20},
        {base:[-22,10], ctrl:[-188,-112-wingLift*0.32], tip:[-312,-94-wingLift*0.38], width:46, curvature:28, tipWidth:18},
        {base:[-18,36], ctrl:[-228,-52-wingLift*0.16], tip:[-298,26+wingLift*0.04], width:40, curvature:26, tipWidth:16},
        {base:[-14,60], ctrl:[-234,40+wingLift*0.22], tip:[-262,112+wingLift*0.28], width:36, curvature:24, tipWidth:14},
        {base:[-10,84], ctrl:[-202,104+wingLift*0.34], tip:[-226,168+wingLift*0.42], width:32, curvature:22, tipWidth:12}
      ];
      const innerBlades=[
        {base:[-18,4], ctrl:[-120,-46-wingLift*0.22], tip:[-182,-12-wingLift*0.18], width:28, curvature:18, tipWidth:10, serrations:4, serrationDepth:10},
        {base:[-16,24], ctrl:[-148,-4-wingLift*0.12], tip:[-190,42+wingLift*0.04], width:26, curvature:16, tipWidth:10, serrations:5, serrationDepth:9},
        {base:[-12,46], ctrl:[-162,48+wingLift*0.18], tip:[-188,106+wingLift*0.24], width:24, curvature:14, tipWidth:9, serrations:5, serrationDepth:8},
        {base:[-10,68], ctrl:[-150,96+wingLift*0.28], tip:[-174,150+wingLift*0.34], width:22, curvature:12, tipWidth:8, serrations:6, serrationDepth:7},
        {base:[-8,88], ctrl:[-138,138+wingLift*0.36], tip:[-158,188+wingLift*0.46], width:20, curvature:11, tipWidth:7, serrations:6, serrationDepth:6}
      ];

      function drawBladeLayer(blades, palette){
        for(const blade of blades){
          const baseX=blade.base[0];
          const baseY=blade.base[1];
          const ctrlX=blade.ctrl[0]*wingSpread;
          const ctrlY=blade.ctrl[1];
          const tipX=blade.tip[0]*wingSpread;
          const tipY=blade.tip[1];
          const angle=Math.atan2(tipY-baseY, tipX-baseX);
          const perpX=-Math.sin(angle);
          const perpY=Math.cos(angle);
          const leadingBaseX=baseX+perpX*blade.width*0.58;
          const leadingBaseY=baseY+perpY*blade.width*0.58;
          const trailingBaseX=baseX-perpX*blade.width*0.44;
          const trailingBaseY=baseY-perpY*blade.width*0.44;
          const leadingCtrlX=ctrlX+perpX*(blade.curvature||0);
          const leadingCtrlY=ctrlY+perpY*(blade.curvature||0);
          const trailingCtrlX=ctrlX-perpX*((blade.curvature||0)*0.74);
          const trailingCtrlY=ctrlY-perpY*((blade.curvature||0)*0.74);
          const leadingTipX=tipX+perpX*(blade.tipWidth||blade.width*0.32);
          const leadingTipY=tipY+perpY*(blade.tipWidth||blade.width*0.32);
          const trailingTipX=tipX-perpX*(blade.tipWidth||blade.width*0.22);
          const trailingTipY=tipY-perpY*(blade.tipWidth||blade.width*0.22);

          const grad=ctx.createLinearGradient(leadingBaseX, leadingBaseY, leadingTipX, leadingTipY);
          grad.addColorStop(0, palette.light);
          grad.addColorStop(0.45, palette.mid);
          grad.addColorStop(1, palette.edge);
          ctx.fillStyle=grad;

          ctx.beginPath();
          ctx.moveTo(leadingBaseX, leadingBaseY);
          ctx.quadraticCurveTo(leadingCtrlX, leadingCtrlY, leadingTipX, leadingTipY);
          if(blade.serrations){
            ctx.lineTo(trailingTipX, trailingTipY);
            for(let i=blade.serrations;i>=1;i--){
              const t=i/blade.serrations;
              const px=trailingTipX+(trailingBaseX-trailingTipX)*t;
              const py=trailingTipY+(trailingBaseY-trailingTipY)*t;
              const offset=(i%2===0?-1:1)*(blade.serrationDepth||6);
              ctx.lineTo(px+perpX*offset*0.6, py+perpY*offset*0.6);
            }
            ctx.lineTo(trailingBaseX, trailingBaseY);
          }else{
            ctx.quadraticCurveTo(trailingCtrlX, trailingCtrlY, trailingBaseX, trailingBaseY);
          }
          ctx.lineTo(baseX+perpX*blade.width*0.12, baseY+perpY*blade.width*0.12);
          ctx.closePath();
          ctx.fill();

          ctx.strokeStyle=palette.outline;
          ctx.lineWidth=2.2;
          ctx.stroke();

          ctx.strokeStyle=darkMetal();
          ctx.lineWidth=1.4;
          ctx.beginPath();
          ctx.moveTo(baseX, baseY);
          ctx.quadraticCurveTo(ctrlX, ctrlY+(palette.veinLift||0), tipX, tipY);
          ctx.stroke();

          ctx.strokeStyle=palette.highlight;
          ctx.lineWidth=1.1;
          ctx.beginPath();
          ctx.moveTo(leadingBaseX, leadingBaseY);
          ctx.quadraticCurveTo(leadingCtrlX, leadingCtrlY, leadingTipX, leadingTipY);
          ctx.stroke();
        }
      }

      const outerPalette={
        light: flash?'#fff3d8':'#f3d1a2',
        mid: flash?'#f6c98d':'#d9a05e',
        edge: flash?'#ca7e40':'#8f5224',
        outline: flash?'#ffe9cc':'#f2c8a0',
        highlight: flash?'#fff2df':'#f4d7b7',
        veinLift:12
      };
      drawBladeLayer(outerBlades, outerPalette);

      // metallic spars between layers
      ctx.save();
      ctx.strokeStyle=metalGradient(-42,4,-210*wingSpread,152+wingLift*0.36);
      ctx.lineWidth=5.4;
      ctx.beginPath();
      ctx.moveTo(-26,6);
      ctx.quadraticCurveTo(-182*wingSpread,-18-wingLift*0.24,-248*wingSpread,86+wingLift*0.28);
      ctx.quadraticCurveTo(-208*wingSpread,128+wingLift*0.32,-188*wingSpread,170+wingLift*0.4);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`rgba(255,204,148,${flash?0.86:0.52})`;
      ctx.lineWidth=3.6;
      ctx.shadowColor=`rgba(255,220,170,${flash?0.72:0.42})`;
      ctx.shadowBlur=18;
      ctx.beginPath();
      ctx.moveTo(-22,12);
      ctx.quadraticCurveTo(-176*wingSpread,-6-wingLift*0.18,-232*wingSpread,94+wingLift*0.3);
      ctx.quadraticCurveTo(-198*wingSpread,136+wingLift*0.34,-176*wingSpread,180+wingLift*0.46);
      ctx.stroke();
      ctx.restore();

      const innerPalette={
        light: flash?'#ffe9c8':'#ecc190',
        mid: flash?'#f0b272':'#c6864b',
        edge: flash?'#b96a32':'#7c3e19',
        outline: flash?'#ffe3c4':'#f0c09a',
        highlight: flash?'#ffeedf':'#f6dcbc',
        veinLift:18
      };
      drawBladeLayer(innerBlades, innerPalette);

      // trailing edge spikes
      ctx.fillStyle=metalGradient(-210*wingSpread,80+wingLift*0.2,-160*wingSpread,160+wingLift*0.4);
      ctx.beginPath();
      ctx.moveTo(-230*wingSpread,94+wingLift*0.32);
      ctx.lineTo(-190*wingSpread,106+wingLift*0.36);
      ctx.lineTo(-204*wingSpread,140+wingLift*0.42);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,230,200,${flash?0.82:0.7})`;
      ctx.lineWidth=1.8;
      ctx.stroke();
      ctx.restore();
    }
    drawWing(-1);
    drawWing(1);

    ctx.shadowColor='rgba(255,218,150,0.62)';
    ctx.shadowBlur=26;
    ctx.fillStyle=metalGradient(-70,-132,70,132);
    ctx.beginPath();
    ctx.moveTo(-70,108);
    ctx.lineTo(-96,36);
    ctx.quadraticCurveTo(-82,-96,0,-134);
    ctx.quadraticCurveTo(82,-96,96,36);
    ctx.lineTo(70,108);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur=0;
    ctx.strokeStyle=`rgba(255,240,212,${flash?0.94:0.8})`;
    ctx.lineWidth=3.4;
    ctx.stroke();

    const chestSegments=[
      {y:-86, h:36, w0:70, w1:96},
      {y:-40, h:32, w0:66, w1:92},
      {y:6, h:32, w0:58, w1:82},
      {y:44, h:34, w0:52, w1:74}
    ];
    for(const seg of chestSegments){
      ctx.fillStyle=metalGradient(-seg.w1, seg.y-seg.h, seg.w1, seg.y+seg.h*1.4);
      ctx.beginPath();
      ctx.moveTo(-seg.w0, seg.y);
      ctx.lineTo(-seg.w1, seg.y+seg.h);
      ctx.quadraticCurveTo(0, seg.y+seg.h*1.32, seg.w1, seg.y+seg.h);
      ctx.lineTo(seg.w0, seg.y);
      ctx.quadraticCurveTo(0, seg.y-seg.h*0.75, -seg.w0, seg.y);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,232,205,${flash?0.9:0.74})`;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.6;
      ctx.beginPath();
      ctx.moveTo(-seg.w0*0.42, seg.y+seg.h*0.12);
      ctx.quadraticCurveTo(0, seg.y+seg.h*0.46, seg.w0*0.42, seg.y+seg.h*0.12);
      ctx.stroke();
    }

    ctx.save();
    ctx.translate(0,-8);
    ctx.fillStyle=metalGradient(-24,-42,24,52);
    ctx.beginPath();
    ctx.moveTo(-20,-12);
    ctx.lineTo(-34,28);
    ctx.quadraticCurveTo(0,52,34,28);
    ctx.lineTo(20,-12);
    ctx.quadraticCurveTo(0,-32,-20,-12);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,228,190,${flash?0.92:0.78})`;
    ctx.lineWidth=2.2;
    ctx.stroke();
    ctx.strokeStyle=`rgba(255,250,220,${flash?0.96:0.82})`;
    ctx.lineWidth=1.6;
    ctx.beginPath();
    ctx.moveTo(0,-20);
    ctx.lineTo(0,32);
    ctx.stroke();
    ctx.restore();

    // lower limbs
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.translate(44,96);
      const gaitPhase=now/420 + side*0.7;
      const legSwing=side*3 + Math.sin(gaitPhase)*5.4;
      const legLift=Math.sin(gaitPhase+Math.PI/2)*3.2;
      ctx.translate(0,-legLift);
      ctx.rotate(legSwing*Math.PI/180);

      const limbGradient=(x0,y0,x1,y1)=>{
        const g=ctx.createLinearGradient(x0,y0,x1,y1);
        g.addColorStop(0, flash?'#fff7e8':'#fbe8c8');
        g.addColorStop(0.38, flash?'#ffd99c':'#f3c27d');
        g.addColorStop(0.72, flash?'#f0a95a':'#d78a3f');
        g.addColorStop(1, flash?'#b86a28':'#8d4616');
        return g;
      };

      // segmented thigh armor
      ctx.fillStyle=limbGradient(-40,-36,42,96);
      ctx.beginPath();
      ctx.moveTo(-34,-26);
      ctx.lineTo(-56,32);
      ctx.lineTo(-24,96);
      ctx.lineTo(18,88);
      ctx.lineTo(38,24);
      ctx.lineTo(6,-32);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,236,210,${flash?0.92:0.76})`;
      ctx.lineWidth=2.4;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-24,-12,30,76);
      ctx.beginPath();
      ctx.moveTo(-16,-10);
      ctx.lineTo(-36,40);
      ctx.lineTo(-10,76);
      ctx.lineTo(18,62);
      ctx.lineTo(24,18);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,242,220,${flash?0.94:0.8})`;
      ctx.lineWidth=1.8;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.92);
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(-20,8);
      ctx.lineTo(14,60);
      ctx.moveTo(-32,34);
      ctx.lineTo(-4,82);
      ctx.stroke();

      // articulated knee and shin plates
      ctx.fillStyle=limbGradient(-16,66,36,132);
      ctx.beginPath();
      ctx.moveTo(-12,64);
      ctx.lineTo(-24,110);
      ctx.lineTo(12,126);
      ctx.lineTo(24,82);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,238,214,${flash?0.9:0.74})`;
      ctx.lineWidth=1.9;
      ctx.stroke();

      ctx.fillStyle=limbGradient(4,80,48,144);
      ctx.beginPath();
      ctx.moveTo(14,82);
      ctx.lineTo(46,114);
      ctx.lineTo(22,72);
      ctx.lineTo(6,68);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,246,226,${flash?0.94:0.82})`;
      ctx.lineWidth=1.4;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-20,106,30,174);
      ctx.beginPath();
      ctx.moveTo(-18,102);
      ctx.lineTo(-8,150);
      ctx.lineTo(14,162);
      ctx.lineTo(32,128);
      ctx.lineTo(10,108);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,234,208,${flash?0.88:0.72})`;
      ctx.lineWidth=1.8;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-10,124,26,182);
      ctx.beginPath();
      ctx.moveTo(-4,122);
      ctx.lineTo(-2,158);
      ctx.lineTo(16,156);
      ctx.lineTo(22,124);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,220,${flash?0.92:0.78})`;
      ctx.lineWidth=1.4;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.88);
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo(-8,110);
      ctx.lineTo(12,160);
      ctx.moveTo(-2,144);
      ctx.lineTo(20,138);
      ctx.stroke();

      // armored foot with toe blades
      ctx.fillStyle=limbGradient(-26,150,34,206);
      ctx.beginPath();
      ctx.moveTo(-24,148);
      ctx.lineTo(-16,198);
      ctx.lineTo(12,206);
      ctx.lineTo(40,168);
      ctx.lineTo(16,144);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,238,214,${flash?0.9:0.74})`;
      ctx.lineWidth=1.6;
      ctx.stroke();

      ctx.fillStyle=limbGradient(-8,158,20,202);
      ctx.beginPath();
      ctx.moveTo(-6,154);
      ctx.lineTo(10,198);
      ctx.lineTo(26,180);
      ctx.lineTo(18,150);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,224,${flash?0.94:0.8})`;
      ctx.lineWidth=1.3;
      ctx.stroke();

      const toes=[
        {x:-14,y:186,rot:-16},
        {x:2,y:194,rot:0},
        {x:20,y:186,rot:18}
      ];
      for(const toe of toes){
        ctx.save();
        ctx.translate(toe.x,toe.y);
        ctx.rotate(toe.rot*Math.PI/180);
        ctx.fillStyle=limbGradient(-8,-6,22,48);
        ctx.beginPath();
        ctx.moveTo(-6,-2);
        ctx.quadraticCurveTo(-20,12,-14,36);
        ctx.lineTo(20,40);
        ctx.lineTo(14,4);
        ctx.quadraticCurveTo(4,-10,-6,-2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,246,226,${flash?0.94:0.8})`;
        ctx.lineWidth=1.2;
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.84);
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-2,0);
        ctx.lineTo(12,32);
        ctx.stroke();
        ctx.restore();
      }

      const knuckles=[{x:-18,y:172},{x:0,y:178},{x:18,y:170}];
      for(const node of knuckles){
        ctx.save();
        ctx.translate(node.x,node.y);
        const knuckleGrad=ctx.createRadialGradient(0,0,0,0,0,8);
        knuckleGrad.addColorStop(0, flash?'rgba(255,250,236,0.98)':'rgba(255,244,224,0.86)');
        knuckleGrad.addColorStop(1, flash?'rgba(255,204,150,0.4)':'rgba(240,184,120,0.34)');
        ctx.fillStyle=knuckleGrad;
        ctx.beginPath();
        ctx.ellipse(0,0,7,5,0,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }

    // upper arms and claws
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.translate(72,-12);
      const reachPhase=now/360 + side*0.6;
      const shoulderLift=Math.cos(reachPhase)*3.2;
      const armSwing=-6*side + Math.sin(reachPhase)*6.2;
      ctx.translate(0, shoulderLift);
      ctx.rotate(armSwing*Math.PI/180);

      const armGradient=(x0,y0,x1,y1)=>{
        const g=ctx.createLinearGradient(x0,y0,x1,y1);
        g.addColorStop(0, flash?'#fff9ec':'#fce9ce');
        g.addColorStop(0.3, flash?'#ffe0a8':'#f6c47e');
        g.addColorStop(0.68, flash?'#f0a868':'#d1843c');
        g.addColorStop(1, flash?'#b86a2c':'#823f18');
        return g;
      };

      // layered shoulder armor
      ctx.fillStyle=armGradient(-56,-42,44,118);
      ctx.beginPath();
      ctx.moveTo(-54,-24);
      ctx.lineTo(-80,36);
      ctx.lineTo(-46,116);
      ctx.lineTo(6,86);
      ctx.lineTo(34,18);
      ctx.lineTo(-8,-32);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,238,214,${flash?0.92:0.78})`;
      ctx.lineWidth=2.6;
      ctx.stroke();

      ctx.fillStyle=armGradient(-34,-12,32,74);
      ctx.beginPath();
      ctx.moveTo(-24,-8);
      ctx.lineTo(-48,46);
      ctx.lineTo(-18,90);
      ctx.lineTo(14,70);
      ctx.lineTo(26,18);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,224,${flash?0.94:0.82})`;
      ctx.lineWidth=1.9;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(-30,12);
      ctx.lineTo(8,74);
      ctx.moveTo(-44,40);
      ctx.lineTo(-10,92);
      ctx.stroke();

      // forearm plating
      ctx.fillStyle=armGradient(-30,72,34,152);
      ctx.beginPath();
      ctx.moveTo(-22,68);
      ctx.lineTo(-52,130);
      ctx.lineTo(-22,150);
      ctx.lineTo(8,104);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,240,220,${flash?0.92:0.8})`;
      ctx.lineWidth=1.8;
      ctx.stroke();

      ctx.fillStyle=armGradient(-10,108,28,178);
      ctx.beginPath();
      ctx.moveTo(-12,108);
      ctx.lineTo(-34,170);
      ctx.lineTo(-6,184);
      ctx.lineTo(14,132);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,226,${flash?0.94:0.82})`;
      ctx.lineWidth=1.5;
      ctx.stroke();

      ctx.strokeStyle=darkMetal(0.86);
      ctx.lineWidth=1.2;
      ctx.beginPath();
      ctx.moveTo(-38,150);
      ctx.lineTo(-8,100);
      ctx.moveTo(-18,120);
      ctx.lineTo(6,162);
      ctx.stroke();

      // wrist ring and dorsal spike
      ctx.save();
      ctx.translate(-8,132);
      ctx.scale(1.08,1);
      ctx.fillStyle=armGradient(-28,118,28,150);
      ctx.beginPath();
      ctx.ellipse(0,0,24,10,0,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle=`rgba(255,248,232,${flash?0.96:0.84})`;
      ctx.lineWidth=1.4;
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle=armGradient(-6,120,26,186);
      ctx.beginPath();
      ctx.moveTo(10,138);
      ctx.lineTo(32,152);
      ctx.lineTo(18,116);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,248,230,${flash?0.96:0.84})`;
      ctx.lineWidth=1.2;
      ctx.stroke();

      // hand back spike
      ctx.fillStyle=armGradient(-4,150,30,210);
      ctx.beginPath();
      ctx.moveTo(0,160);
      ctx.lineTo(24,200);
      ctx.lineTo(-6,182);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,246,228,${flash?0.94:0.82})`;
      ctx.lineWidth=1.2;
      ctx.stroke();

      // claws with gleaming edges
      const clawOffsets=[-16,-2,12];
      for(const offset of clawOffsets){
        ctx.save();
        ctx.translate(offset,168);
        ctx.fillStyle=armGradient(-18,-4,18,46);
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.quadraticCurveTo(-16,18,-12,46);
        ctx.lineTo(12,38);
        ctx.lineTo(10,4);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,248,234,${flash?0.96:0.84})`;
        ctx.lineWidth=1.3;
        ctx.stroke();
        ctx.strokeStyle=darkMetal(0.84);
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-2,6);
        ctx.lineTo(8,36);
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
    }

    ctx.save();
    ctx.translate(0,-106);
    const neckSegments=4;
    for(let i=0;i<neckSegments;i++){
      const prog=i/(neckSegments-1);
      const segH=26- i*4;
      const segW=34 - prog*8;
      ctx.save();
      ctx.translate(0,i*16);
      ctx.fillStyle=metalGradient(-segW, -segH, segW, segH*1.4);
      ctx.beginPath();
      ctx.moveTo(-segW,-segH*0.4);
      ctx.lineTo(-segW*0.8,segH);
      ctx.lineTo(segW*0.8,segH);
      ctx.lineTo(segW,-segH*0.4);
      ctx.quadraticCurveTo(0,-segH*0.9,-segW,-segH*0.4);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,236,210,${flash?0.9:0.76})`;
      ctx.lineWidth=2;
      ctx.stroke();
      ctx.restore();
    }

    ctx.save();
    ctx.translate(0,-12);
    const headScaleX=0.41;
    const headScaleY=0.38;
    ctx.scale(headScaleX, headScaleY);

    const hornOuterFill=metalGradient(-96,-320,96,-120);
    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.fillStyle=hornOuterFill;
      ctx.beginPath();
      ctx.moveTo(22,-188);
      ctx.quadraticCurveTo(88,-246,154,-338);
      ctx.lineTo(136,-356);
      ctx.quadraticCurveTo(90,-350,54,-290);
      ctx.lineTo(28,-188);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=flash?'rgba(255,236,214,0.96)':'rgba(255,214,176,0.82)';
      ctx.lineWidth=2.3;
      ctx.stroke();

      ctx.fillStyle=flash?'rgba(255,250,234,0.9)':'rgba(255,228,188,0.78)';
      ctx.beginPath();
      ctx.moveTo(32,-192);
      ctx.quadraticCurveTo(92,-250,134,-334);
      ctx.lineTo(110,-336);
      ctx.quadraticCurveTo(74,-296,44,-210);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.3;
      ctx.beginPath();
      ctx.moveTo(36,-200);
      ctx.quadraticCurveTo(98,-260,132,-342);
      ctx.stroke();

      ctx.strokeStyle=flash?'rgba(255,210,170,0.88)':'rgba(255,160,100,0.74)';
      ctx.lineWidth=1.1;
      ctx.beginPath();
      ctx.moveTo(50,-214);
      ctx.quadraticCurveTo(104,-274,124,-344);
      ctx.stroke();
      ctx.restore();
    }

    const crownGrad=metalGradient(-70,-188,70,36);
    ctx.fillStyle=crownGrad;
    ctx.beginPath();
    ctx.moveTo(0,-222);
    ctx.lineTo(-44,-198);
    ctx.quadraticCurveTo(-100,-132,-80,-56);
    ctx.quadraticCurveTo(-40,8,-12,40);
    ctx.lineTo(0,56);
    ctx.lineTo(12,40);
    ctx.quadraticCurveTo(40,8,80,-56);
    ctx.quadraticCurveTo(100,-132,44,-198);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,238,214,${flash?0.96:0.82})`;
    ctx.lineWidth=2.2;
    ctx.stroke();

    ctx.strokeStyle=darkMetal(0.92);
    ctx.lineWidth=1.2;
    ctx.beginPath();
    ctx.moveTo(0,-210);
    ctx.lineTo(0,-34);
    ctx.moveTo(-28,-164);
    ctx.lineTo(-10,-48);
    ctx.moveTo(28,-164);
    ctx.lineTo(10,-48);
    ctx.stroke();

    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.fillStyle=metalGradient(-48,-160,96,-12);
      ctx.beginPath();
      ctx.moveTo(16,-176);
      ctx.lineTo(120,-128);
      ctx.lineTo(94,-62);
      ctx.quadraticCurveTo(46,-8,20,2);
      ctx.lineTo(4,-22);
      ctx.quadraticCurveTo(12,-86,16,-176);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,232,208,${flash?0.94:0.78})`;
      ctx.lineWidth=1.8;
      ctx.stroke();
      ctx.strokeStyle=darkMetal(0.88);
      ctx.lineWidth=1.1;
      ctx.beginPath();
      ctx.moveTo(20,-156);
      ctx.lineTo(78,-66);
      ctx.lineTo(26,-14);
      ctx.stroke();
      ctx.restore();
    }

    for(const side of [-1,1]){
      ctx.save();
      ctx.scale(side,1);
      ctx.fillStyle=metalGradient(-36,-36,72,66);
      ctx.beginPath();
      ctx.moveTo(-2,-12);
      ctx.lineTo(46,12);
      ctx.lineTo(62,64);
      ctx.quadraticCurveTo(30,84,6,64);
      ctx.lineTo(-6,20);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=`rgba(255,244,226,${flash?0.96:0.84})`;
      ctx.lineWidth=1.5;
      ctx.stroke();
      ctx.strokeStyle=darkMetal(0.9);
      ctx.lineWidth=1.1;
      ctx.beginPath();
      ctx.moveTo(18,18);
      ctx.lineTo(46,58);
      ctx.stroke();
      ctx.restore();
    }

    ctx.fillStyle=metalGradient(-44,-76,44,52);
    ctx.beginPath();
    ctx.moveTo(-32,-4);
    ctx.lineTo(-68,-46);
    ctx.quadraticCurveTo(-76,-104,-28,-174);
    ctx.quadraticCurveTo(-6,-206,0,-216);
    ctx.quadraticCurveTo(6,-206,28,-174);
    ctx.quadraticCurveTo(76,-104,68,-46);
    ctx.lineTo(32,-4);
    ctx.quadraticCurveTo(0,20,-32,-4);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,240,220,${flash?0.94:0.8})`;
    ctx.lineWidth=2;
    ctx.stroke();

    ctx.strokeStyle=`rgba(255,228,200,${flash?0.9:0.76})`;
    ctx.lineWidth=1.4;
    ctx.beginPath();
    ctx.moveTo(-34,-54);
    ctx.quadraticCurveTo(0,-92,34,-54);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0,-188);
    ctx.quadraticCurveTo(0,-96,0,18);
    ctx.stroke();

    ctx.fillStyle=metalGradient(-32,6,32,78);
    ctx.beginPath();
    ctx.moveTo(-30,12);
    ctx.lineTo(-14,64);
    ctx.quadraticCurveTo(0,88,14,64);
    ctx.lineTo(30,12);
    ctx.lineTo(12,-18);
    ctx.lineTo(-12,-18);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,236,214,${flash?0.92:0.78})`;
    ctx.lineWidth=1.7;
    ctx.stroke();

    ctx.fillStyle='rgba(32,8,6,0.92)';
    ctx.beginPath();
    ctx.moveTo(-26,-6);
    ctx.quadraticCurveTo(0,-34,26,-6);
    ctx.quadraticCurveTo(10,16,0,24);
    ctx.quadraticCurveTo(-10,16,-26,-6);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle=metalGradient(-24,16,24,70);
    ctx.beginPath();
    ctx.moveTo(-20,10);
    ctx.lineTo(-4,56);
    ctx.quadraticCurveTo(0,64,4,56);
    ctx.lineTo(20,10);
    ctx.lineTo(10,-8);
    ctx.lineTo(-10,-8);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle=`rgba(255,240,224,${flash?0.94:0.82})`;
    ctx.lineWidth=1.3;
    ctx.stroke();

    ctx.fillStyle=flash?'#fffdf0':'#fdf1d2';
    for(const side of [-1,1]){
      for(let i=0;i<3;i++){
        const offset=-12 + i*8;
        ctx.beginPath();
        ctx.moveTo(offset*side,-6);
        ctx.lineTo((offset+3)*side,6);
        ctx.lineTo((offset+1.2)*side,0);
        ctx.closePath();
        ctx.fill();
      }
    }

    ctx.strokeStyle=darkMetal(0.88);
    ctx.lineWidth=1.1;
    ctx.beginPath();
    ctx.moveTo(-18,6);
    ctx.lineTo(-6,48);
    ctx.moveTo(18,6);
    ctx.lineTo(6,48);
    ctx.stroke();

    ctx.save();
    ctx.translate(0,-146);
    const gemGrad=ctx.createRadialGradient(0,0,0,0,0,18);
    gemGrad.addColorStop(0, flash?'#eaffff':'#9effff');
    gemGrad.addColorStop(0.5, flash?'rgba(120,252,255,0.95)':'rgba(60,228,250,0.92)');
    gemGrad.addColorStop(1,'rgba(0,140,180,0)');
    ctx.beginPath();
    ctx.ellipse(0,0,11,16,0,0,Math.PI*2);
    ctx.fillStyle=gemGrad;
    ctx.shadowColor=flash?'rgba(120,252,255,0.86)':'rgba(60,220,240,0.72)';
    ctx.shadowBlur=22;
    ctx.fill();
    ctx.restore();

    ctx.save();
    const eyeGlow=flash?'rgba(255,90,60,0.96)':'rgba(255,36,0,0.92)';

    const drawEyeBase=side=>{
      const isLeft=side<0;
      const tipX=62*side;
      const tipY=-106;
      const innerX=14*side;
      const innerY=-44;
      const lowerX=48*side;
      const lowerY=-18;
      let grad;
      if(isLeft){
        grad=ctx.createLinearGradient(tipX, tipY, innerX, innerY);
        grad.addColorStop(0, flash?'#ff7058':'#ff6a54');
        grad.addColorStop(0.45, flash?'#ff2a00':'#ff2100');
        grad.addColorStop(1, flash?'#a30000':'#450000');
      }else{
        grad=ctx.createLinearGradient(innerX, innerY, tipX, tipY);
        grad.addColorStop(0, flash?'#a30000':'#450000');
        grad.addColorStop(0.55, flash?'#ff2a00':'#ff2100');
        grad.addColorStop(1, flash?'#ff7058':'#ff6a54');
      }
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.moveTo(tipX, tipY);
      ctx.lineTo(innerX, innerY);
      ctx.lineTo(lowerX, lowerY);
      ctx.closePath();
      ctx.shadowColor=eyeGlow;
      ctx.shadowBlur=flash?36:34;
      ctx.fill();
      ctx.strokeStyle=flash?'rgba(255,224,210,0.84)':'rgba(255,120,90,0.66)';
      ctx.lineWidth=1.5;
      ctx.stroke();
      ctx.strokeStyle=flash?'rgba(255,198,184,0.92)':'rgba(255,88,66,0.74)';
      ctx.lineWidth=1.15;
      ctx.beginPath();
      ctx.moveTo(tipX - side*4, tipY+6);
      ctx.lineTo(innerX, innerY-6);
      ctx.stroke();
    };

    const drawEyeHighlights=side=>{
      const isLeft=side<0;
      ctx.shadowBlur=0;
      ctx.fillStyle='rgba(255,255,255,0.42)';
      ctx.beginPath();
      const tipX=62*side;
      const tipY=-106;
      const innerX=14*side;
      const innerY=-44;
      const lowerX=48*side;
      const lowerY=-18;
      const highlightAngle=isLeft?-0.42:0.42;
      const highlightX=tipX - side*10;
      const highlightY=tipY+26;
      ctx.ellipse(highlightX, highlightY, 5.4, 3.4, highlightAngle, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle='rgba(255,255,255,0.28)';
      ctx.beginPath();
      const lowerMidX=(innerX+lowerX)/2;
      const lowerMidY=(innerY+lowerY)/2 + 6;
      const innerHighlightX=innerX + side*6;
      const innerHighlightY=innerY + 8;
      const lowerHighlightX=lowerX + side*4;
      const lowerHighlightY=lowerY + 4;
      ctx.moveTo(lowerMidX, lowerMidY);
      ctx.lineTo(innerHighlightX, innerHighlightY);
      ctx.lineTo(lowerHighlightX, lowerHighlightY);
      ctx.closePath();
      ctx.fill();
    };

    drawEyeBase(-1);
    drawEyeBase(1);
    drawEyeHighlights(-1);
    drawEyeHighlights(1);
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=flash?'rgba(255,132,110,0.35)':'rgba(255,24,0,0.26)';
    ctx.beginPath();
    ctx.ellipse(-30,-46,18,11,-0.32,0,Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(30,-46,18,11,0.32,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.restore();

    ctx.restore();
    ctx.restore();
  }

  function drawDragonAttackVisuals(now){
    if(dragonAttackState && dragonAttackState.type==='deathRay'){
      for(const orb of dragonDeathRayOrbs){
        if(!orb.x || !orb.y) continue;
        const x=orb.x*scaleX;
        const y=orb.y*scaleY;
        const baseR=14*((scaleX+scaleY)/2);
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const grd=ctx.createRadialGradient(x,y,0,x,y,baseR*1.6);
        grd.addColorStop(0,'rgba(255,255,230,0.95)');
        grd.addColorStop(0.4,'rgba(255,236,160,0.85)');
        grd.addColorStop(1,'rgba(255,200,80,0.05)');
        ctx.fillStyle=grd;
        ctx.beginPath();
        ctx.arc(x,y,baseR*1.6,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    for(let i=dragonDeathRayBeams.length-1;i>=0;i--){
      const beam=dragonDeathRayBeams[i];
      if(now>=beam.end){ dragonDeathRayBeams.splice(i,1); continue; }
      const impactAt = beam.impactAt || beam.end;
      const travelSpan = Math.max(1, impactAt - beam.start);
      const travelProg = Math.max(0, Math.min(1, (now - beam.start)/travelSpan));
      const drawX = beam.hit ? beam.x2 : beam.x1 + (beam.x2 - beam.x1)*travelProg;
      const drawY = beam.hit ? beam.y2 : beam.y1 + (beam.y2 - beam.y1)*travelProg;
      const fadeSpan = Math.max(1, beam.end - impactAt);
      const fadeProg = beam.hit ? Math.max(0, Math.min(1, (now - impactAt)/fadeSpan)) : 0;
      const intensity = beam.hit ? 1 - fadeProg : Math.min(1, 0.4 + travelProg*0.6);
      const x1=beam.x1*scaleX, y1=beam.y1*scaleY;
      const x2=drawX*scaleX, y2=drawY*scaleY;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const outer=ctx.createLinearGradient(x1,y1,x2,y2);
      outer.addColorStop(0,'rgba(255,230,150,'+(0.18+0.42*intensity)+')');
      outer.addColorStop(1,'rgba(255,200,120,'+(0.45+0.4*intensity)+')');
      ctx.strokeStyle=outer;
      ctx.lineWidth=10;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      const core=ctx.createLinearGradient(x1,y1,x2,y2);
      core.addColorStop(0,'rgba(255,255,230,'+(0.32+0.52*intensity)+')');
      core.addColorStop(1,'rgba(255,240,180,'+(0.54+0.3*intensity)+')');
      ctx.strokeStyle=core;
      ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      if(!beam.hit){
        const tipR=8*((scaleX+scaleY)/2)*(0.6+travelProg*0.8);
        const tipGrad=ctx.createRadialGradient(x2,y2,0,x2,y2,tipR);
        tipGrad.addColorStop(0,'rgba(255,255,240,'+(0.7+0.3*intensity)+')');
        tipGrad.addColorStop(1,'rgba(255,200,100,0)');
        ctx.fillStyle=tipGrad;
        ctx.beginPath(); ctx.arc(x2,y2,tipR,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
    if(dragonAttackState && dragonAttackState.type==='annihilation'){
      const state=dragonAttackState;
      const L=layout();
      if(state.phase==='challenge'){
        const remain=Math.max(0, state.countdownEnd-now);
        const sec=Math.max(0, Math.ceil(remain/1000));
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.font=`${Math.round(72*((scaleX+scaleY)/2))}px 'Playfair Display',serif`;
        ctx.textAlign='center';
        ctx.textBaseline='top';
        ctx.fillStyle='rgba(255,236,190,0.92)';
        ctx.shadowColor='rgba(255,200,120,0.85)';
        ctx.shadowBlur=24*((scaleX+scaleY)/2);
        let anchorY=Math.max(20, (L.top-60));
        if(dragonMarquee){
          const marqueeHeight=60;
          const marqueeTop=Math.max(16, L.top - marqueeHeight - 14);
          anchorY=Math.max(anchorY, marqueeTop + marqueeHeight + 12, L.top + 12);
        }
        ctx.fillText(String(sec), (1100/2)*scaleX, anchorY*scaleY);
        ctx.restore();
      }else if(state.phase==='detonate'){
        const span=Math.max(1, state.explosionEnd - state.detonateStart);
        const prog=1-Math.max(0, (state.explosionEnd-now)/span);
        const centerX=550*scaleX;
        const L=layout();
        const stageHeight=L.rows*(brickH+L.pad) - L.pad;
        const centerY=(L.top + stageHeight/2)*scaleY;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const maxR=Math.max(canvas.width, canvas.height)*1.2;
        const radial=ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxR);
        radial.addColorStop(0,`rgba(255,255,240,${0.86 - 0.4*prog})`);
        radial.addColorStop(0.35,`rgba(255,240,190,${0.75 - 0.3*prog})`);
        radial.addColorStop(0.7,`rgba(255,210,120,${0.55 - 0.2*prog})`);
        radial.addColorStop(1,'rgba(255,160,60,0)');
        ctx.fillStyle=radial;
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
        ctx.save();
        ctx.globalAlpha=0.32 + 0.22*Math.sin(prog*Math.PI*3);
        ctx.fillStyle='rgba(255,200,120,0.95)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }
    }
  }

  function drawDragonLayer(){
    if(level!==15) return;
    const now=performance.now();
    const easeOut=t=>1-Math.pow(1-Math.max(0,Math.min(1,t)),3);
    if(dragonPhase==='intro' && dragonAnchor){
      const cx=(dragonAnchor.x+dragonAnchor.w/2)*scaleX;
      const cy=(dragonAnchor.y+dragonAnchor.h+80)*scaleY;
      const rad=Math.max(dragonAnchor.w, dragonAnchor.h)*1.3*((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const g=ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      g.addColorStop(0,'rgba(255,220,160,0.18)');
      g.addColorStop(1,'rgba(255,220,160,0)');
      ctx.fillStyle=g;
      ctx.beginPath();
      ctx.arc(cx,cy,rad,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    for(const fx of dragonBursts){
      const life=fx.life||1200;
      const prog=Math.max(0, Math.min(1,(now-fx.t0)/life));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      if(fx.type==='ring'){
        const rad=(fx.r0||0)+((fx.r1||320)-(fx.r0||0))*easeOut(prog);
        ctx.strokeStyle=`rgba(${fx.color||'255,210,140'},${0.4*(1-prog)})`;
        ctx.lineWidth=(fx.width||20)*((scaleX+scaleY)/2)*(1-prog*0.6);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='flare'){
        const rad=(fx.r1||260)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(20, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0,`rgba(${fx.color||'255,215,160'},${0.5*(1-prog)})`);
        grad.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='spark'){
        const rad=(fx.r1||200)*prog*((scaleX+scaleY)/2);
        ctx.strokeStyle=`rgba(${fx.color||'255,210,150'},${0.75*(1-prog)})`;
        ctx.lineWidth=2.6*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.moveTo(fx.x*scaleX-rad, fx.y*scaleY);
        ctx.lineTo(fx.x*scaleX+rad, fx.y*scaleY);
        ctx.moveTo(fx.x*scaleX, fx.y*scaleY-rad*0.6);
        ctx.lineTo(fx.x*scaleX, fx.y*scaleY+rad*0.6);
        ctx.stroke();
      }else if(fx.type==='ember'){
        const size=14*((scaleX+scaleY)/2)*(1-prog);
        ctx.fillStyle=`rgba(255,200,110,${0.7*(1-prog)})`;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, size,0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='halo'){
        const rad=(fx.r0||40)+((fx.r1||320)-(fx.r0||40))*prog;
        ctx.strokeStyle=`rgba(${fx.color||'255,210,140'},${0.25*(1-prog)})`;
        ctx.lineWidth=8*((scaleX+scaleY)/2);
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='mega'){
        const rad=(fx.r1||720)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(40, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0,'rgba(255,250,220,0.95)');
        grad.addColorStop(0.35,'rgba(255,210,140,0.55)');
        grad.addColorStop(1,'rgba(255,180,90,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='apocalypse'){
        const startR=fx.r0||120;
        const endR=fx.r1||900;
        const rad=startR + (endR-startR)*easeOut(prog);
        const grad=ctx.createRadialGradient(fx.x*scaleX, fx.y*scaleY, 0, fx.x*scaleX, fx.y*scaleY, Math.max(60, rad*((scaleX+scaleY)/2)));
        grad.addColorStop(0,`rgba(255,255,250,${0.96 - prog*0.4})`);
        grad.addColorStop(0.25,`rgba(255,240,200,${0.82 - prog*0.3})`);
        grad.addColorStop(0.6,`rgba(255,214,130,${0.65 - prog*0.25})`);
        grad.addColorStop(1,'rgba(255,180,80,0)');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }else if(fx.type==='shockwave'){
        const startR=fx.r0||0;
        const endR=fx.r1||980;
        const rad=startR + (endR-startR)*easeOut(prog);
        const width=(fx.width||32)*((scaleX+scaleY)/2)*(1-prog*0.5);
        ctx.strokeStyle=`rgba(${fx.color||'255,230,190'},${0.55*(1-prog)})`;
        ctx.lineWidth=width;
        ctx.beginPath();
        ctx.arc(fx.x*scaleX, fx.y*scaleY, rad*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.stroke();
      }else if(fx.type==='emberRain'){
        if(!fx.particles){
          const count=fx.count||70;
          fx.particles=Array.from({length:count},()=>({
            angle:Math.random()*Math.PI*2,
            radius:30+Math.random()*200,
            speed:220+Math.random()*320,
            size:9+Math.random()*16,
            drift:(Math.random()*0.6-0.3)
          }));
        }
        const flicker=0.5+0.5*Math.sin(prog*Math.PI*4);
        for(const p of fx.particles){
          const dist = p.radius + p.speed*prog;
          const px = fx.x + Math.cos(p.angle + p.drift*prog)*dist;
          const py = fx.y + Math.sin(p.angle + p.drift*prog)*dist*0.65;
          const size=p.size*((1-prog)*0.8+0.2)*((scaleX+scaleY)/2);
          ctx.fillStyle=`rgba(255,${205+Math.round(35*flicker)},${120+Math.round(25*(1-prog))},${0.55*(1-prog)})`;
          ctx.beginPath();
          ctx.arc(px*scaleX, py*scaleY, size,0,Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
    }
    if(dragonBoss && (dragonPhase==='active' || dragonPhase==='dying')){
      renderDragonBody(dragonBoss, now);
    }
    drawDragonAttackVisuals(now);
  }

  function drawDragonMarquee(){
    if(!dragonMarquee) return;
    const now=performance.now();
    const {start, fadeStart, end, text} = dragonMarquee;
    const style=dragonMarquee.style||'alert';
    if(now>=end){ dragonMarquee=null; return; }
    let alpha=1;
    if(style!=='victorySolid' && fadeStart && now>fadeStart){
      alpha=Math.max(0, 1 - (now - fadeStart)/(end - fadeStart||1));
    }
    const areaHeight=60;
    const top=Math.max(16, layout().top - areaHeight - 14);
    const width=Math.min(560, 1100-120);
    const x=(1100-width)/2;
    const radius=20;
    ctx.save();
    ctx.globalAlpha=alpha;
    drawRoundedRect(x, top, width, areaHeight, radius);
    if(style==='victorySolid'){
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(82,52,10,0.96)');
      grad.addColorStop(1,'rgba(48,26,6,0.96)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,220,160,0.85)';
      ctx.lineWidth=2.6;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      ctx.fillStyle='#fff4d4';
      const fontSize=Math.max(24, Math.round(28*((scaleX+scaleY)/2)));
      ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,200,120,0.6)';
      ctx.shadowBlur=18*((scaleX+scaleY)/2);
      ctx.fillText(text, (x+width/2)*scaleX, (top+areaHeight/2)*scaleY);
      ctx.shadowBlur=0;
    }else if(style==='elegant'){
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(48,22,10,0.9)');
      grad.addColorStop(1,'rgba(28,12,6,0.88)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,210,150,0.85)';
      ctx.lineWidth=2.4;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+10;
      const innerY=top+6;
      const innerW=width-20;
      const innerH=areaHeight-12;
      ctx.save();
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      const innerGrad=ctx.createLinearGradient(innerX*scaleX, innerY*scaleY, innerX*scaleX, (innerY+innerH)*scaleY);
      innerGrad.addColorStop(0,'rgba(140,70,30,0.45)');
      innerGrad.addColorStop(1,'rgba(80,34,14,0.35)');
      ctx.fillStyle=innerGrad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,220,180,0.45)';
      ctx.lineWidth=1.4;
      ctx.stroke();
      ctx.restore();
      ctx.save();
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.clip();
      ctx.fillStyle='#ffeedd';
      const fontSize=Math.max(20, Math.round(26*((scaleX+scaleY)/2)));
      ctx.font=`${fontSize}px 'Playfair Display','Noto Sans TC',serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,150,110,0.55)';
      ctx.shadowBlur=14*((scaleX+scaleY)/2);
      ctx.fillText(text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
      ctx.restore();
    }else{
      const grad=ctx.createLinearGradient(x*scaleX, top*scaleY, x*scaleX, (top+areaHeight)*scaleY);
      grad.addColorStop(0,'rgba(60,32,6,0.95)');
      grad.addColorStop(1,'rgba(32,18,4,0.9)');
      ctx.fillStyle=grad;
      ctx.fill();
      ctx.strokeStyle='rgba(255,210,120,0.75)';
      ctx.lineWidth=2.2;
      drawRoundedRect(x, top, width, areaHeight, radius);
      ctx.stroke();
      const innerX=x+12;
      const innerY=top+6;
      const innerW=width-24;
      const innerH=areaHeight-12;
      drawRoundedRect(innerX, innerY, innerW, innerH, radius-6);
      ctx.save();
      ctx.clip();
      ctx.fillStyle='#fff5d8';
      const fontSize=Math.max(18, Math.round(24*((scaleX+scaleY)/2)));
      ctx.font=`${fontSize}px 'Noto Sans TC','Playfair Display',sans-serif`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(255,200,120,0.55)';
      ctx.shadowBlur=12*((scaleX+scaleY)/2);
      ctx.fillText(text, (innerX+innerW/2)*scaleX, (innerY+innerH/2)*scaleY);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawDragonHPBar(){
    if((dragonPhase!=='active' && dragonPhase!=='dying') || !dragonBoss) return;
    const L=layout();
    const barW=32;
    const maxH=700-(L.top+80);
    const barH=Math.max(200, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, dragonBoss.hp/dragonBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(92,58,12,0.96)');
    frameGrad.addColorStop(1,'rgba(46,28,8,0.9)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(255,210,120,0.8)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(28,18,6,0.92)');
    bg.addColorStop(1,'rgba(42,26,8,0.9)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(255,180,90,0.25)');
      fillGrad.addColorStop(0.4,'rgba(255,210,120,0.65)');
      fillGrad.addColorStop(1,'rgba(255,240,200,0.96)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    const segments=10;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - innerH*i/segments)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS 毀滅之龍', dragonBoss.hp, dragonBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(92,58,12,0.95)',
      bgBottom:'rgba(46,28,8,0.9)',
      frame:'rgba(255,210,120,0.78)',
      glow:'rgba(255,200,120,0.55)',
      textPrimary:'#ffeccd',
      textSecondary:'#fff3da'
    });
    ctx.restore();
  }

  function drawDragonHUD(){
    drawDragonMarquee();
    drawDragonHPBar();
  }

  function drawDemonHUD(){
    if(level!==20) return;
    if((demonPhase!=='active' && demonPhase!=='dying') || !demonBoss) return;
    const L=layout();
    const barW=32;
    const maxH=700-(L.top+80);
    const barH=Math.max(200, Math.min(360, maxH));
    const x=1100 - barW - 26;
    const y=L.top + 30;
    const ratio=Math.max(0, Math.min(1, demonBoss.hp/demonBoss.maxHp));

    ctx.save();
    ctx.globalAlpha=0.96;
    drawRoundedRect(x, y, barW, barH, 16);
    const frameGrad=ctx.createLinearGradient(x*scaleX, y*scaleY, x*scaleX, (y+barH)*scaleY);
    frameGrad.addColorStop(0,'rgba(70,24,120,0.95)');
    frameGrad.addColorStop(1,'rgba(38,12,80,0.9)');
    ctx.fillStyle=frameGrad;
    ctx.fill();
    ctx.strokeStyle='rgba(230,190,255,0.65)';
    ctx.lineWidth=2;
    drawRoundedRect(x, y, barW, barH, 16);
    ctx.stroke();

    const innerX=x+6;
    const innerY=y+10;
    const innerW=barW-12;
    const innerH=barH-20;
    drawRoundedRect(innerX, innerY, innerW, innerH, 12);
    const bg=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, innerY*scaleY);
    bg.addColorStop(0,'rgba(24,12,40,0.92)');
    bg.addColorStop(1,'rgba(34,16,58,0.9)');
    ctx.fillStyle=bg;
    ctx.fill();

    if(ratio>0){
      const fillHeight=innerH*ratio;
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(innerX, innerY, innerW, innerH, 10);
      ctx.clip();
      const fillGrad=ctx.createLinearGradient(innerX*scaleX, (innerY+innerH)*scaleY, innerX*scaleX, (innerY+innerH-fillHeight)*scaleY);
      fillGrad.addColorStop(0,'rgba(180,110,250,0.22)');
      fillGrad.addColorStop(0.45,'rgba(210,150,255,0.62)');
      fillGrad.addColorStop(1,'rgba(255,230,255,0.96)');
      ctx.fillStyle=fillGrad;
      ctx.fillRect(innerX*scaleX, (innerY+innerH-fillHeight)*scaleY, innerW*scaleX, fillHeight*scaleY);
      ctx.restore();
    }

    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    const segments=10;
    for(let i=1;i<segments;i++){
      const sy=(innerY + innerH - innerH*i/segments)*scaleY;
      ctx.beginPath();
      ctx.moveTo(innerX*scaleX, sy);
      ctx.lineTo((innerX+innerW)*scaleX, sy);
      ctx.stroke();
    }

    drawBossNameplate('BOSS 魔王埃里赫曼', demonBoss.hp, demonBoss.maxHp, x, y, barW, barH, {
      bgTop:'rgba(70,24,120,0.95)',
      bgBottom:'rgba(38,12,80,0.9)',
      frame:'rgba(230,190,255,0.7)',
      glow:'rgba(200,150,255,0.55)',
      textPrimary:'#3a0066',
      textSecondary:'#f9efff'
    });
    ctx.restore();
  }


  function isSpecialBossActive(){
    return isSpaceBossActive() || isReaperActive() || isDragonActive() || isDemonActive();
  }

  function activeBossCenter(){
    if(isSpaceBossActive()) return {x:spaceBoss.x, y:spaceBoss.y, type:'space'};
    if(isReaperActive() && reaperBoss) return {x:reaperBoss.x, y:reaperBoss.y, type:'reaper'};
    if(isDragonActive() && dragonBoss) return {x:dragonBoss.x, y:dragonBoss.y, type:'dragon'};
    if(isDemonActive() && demonBoss) return {x:demonBoss.x, y:demonBoss.y, type:'demon'};
    return null;
  }

  function getActiveBossBounds(){
    if(isSpaceBossActive()) return getSpaceBossBounds();
    if(isReaperActive()) return getReaperBounds();
    if(isDragonActive()) return getDragonBounds();
    if(isDemonActive()) return getDemonBounds();
    return null;
  }

  function activeBossImpactPoint(fromX, fromY){
    if(isSpaceBossActive()) return spaceBossImpactPoint(fromX, fromY);
    if(isReaperActive()) return reaperImpactPoint(fromX, fromY);
    if(isDragonActive()) return dragonImpactPoint(fromX, fromY);
    if(isDemonActive()) return demonImpactPoint(fromX, fromY);
    return {x:fromX, y:fromY};
  }

  function damageActiveBoss(amount=1, source='generic', impact, options=null){
    const now=performance.now();
    const opts={...(options||{})};
    let total=Math.max(0, Number(amount)||0);
    total+=getCurseSwordBonus(now);
    total*=getBloodBladeMultiplier(now);
    if(equipmentBossDamageMultiplier>1){
      total*=equipmentBossDamageMultiplier;
    }
    if(equipmentBossDamageFx) opts.goldenFx=true;
    if(isSpaceBossActive()) return damageSpaceBoss(total, source, impact, opts);
    if(isReaperActive()) return damageReaperBoss(total, source, impact, opts);
    if(isDragonActive()) return damageDragonBoss(total, source, impact, opts);
    if(isDemonActive()) return damageDemonBoss(total, source, impact, opts);
    return false;
  }

  function circleIntersectsActiveBoss(cx, cy, radius){
    if(isSpaceBossActive()) return circleIntersectsSpaceBoss(cx, cy, radius);
    if(isReaperActive()) return circleIntersectsReaper(cx, cy, radius);
    if(isDragonActive()) return circleIntersectsDragon(cx, cy, radius);
    if(isDemonActive()) return circleIntersectsDemon(cx, cy, radius);
    return false;
  }

  function activeBossClampPoint(x, y){
    if(isDragonActive()) return dragonClampPoint(x, y);
    if(isDemonActive()) return demonClampPoint(x, y);
    const bounds=getActiveBossBounds();
    if(!bounds) return {x, y};
    return {
      x: Math.max(bounds.x, Math.min(x, bounds.x + bounds.w)),
      y: Math.max(bounds.y, Math.min(y, bounds.y + bounds.h))
    };
  }
  // === 修正：格點對齊地揭示底圖，避免黑洞與浮點誤差 ===
  function revealBrickArea(brick){
    if(!brick || brick.fallingTreasure) return;
    const L = layout();
    const cellW = brickW, cellH = brickH;
    // 以格點定位（四捨五入）
    const c0 = Math.max(0, Math.min(GAME_CONFIG.bricks.cols-1, Math.round((brick.x - L.pad) / (cellW + L.pad)) ));
    const r0 = Math.max(0, Math.min(L.rows-1, Math.round((brick.y - L.top) / (cellH + L.pad)) ));
    // 覆蓋的格數（Boss/大磚可能>1）
    const cellsX = Math.max(1, Math.round((brick.w + L.pad) / (cellW + L.pad)));
    const cellsY = Math.max(1, Math.round((brick.h + L.pad) / (cellH + L.pad)));
    for(let rr=0; rr<cellsY; rr++){
      for(let cc=0; cc<cellsX; cc++){
        const c = Math.min(GAME_CONFIG.bricks.cols-1, c0 + cc);
        const r = Math.min(L.rows-1, r0 + rr);
        const rx = L.pad + c*(cellW + L.pad);
        const ry = L.top + r*(cellH + L.pad);
        revealRects.push({x:rx, y:ry, w:cellW, h:cellH});
      }
    }
  }
function generateLevel(lv, L){
    const cols=L.cols, rows=L.rows, pad=L.pad, top=L.top;
    const baseHP = 1 + Math.floor((lv-1)/3);
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // 關卡區段
    const late = lv>=7;
    const later = lv>=11;
    const endgame = lv>=15;

    // Boss每5關
    const isBoss = (lv%5===0);
    if(isBoss){
      if(lv===5){
        const bx = Math.floor(cols/2)-1;
        const by = 0;
        const w = brickW*2 + pad;
        const h = brickH*2 + pad;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:1, colorIdx:0, boss:true, face:'獅', strong:true, unbreakable:true});
        spaceBossPlaceholder = bricks[placeholderIndex];
        if(spaceBossPlaceholder){
          spaceBossPlaceholder.hp=0;
          spaceBossPlaceholder.placeholderBoss=true;
        }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(c>=bx && c<=bx+1 && r>=by && r<=by+1) continue;
            const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
          }
        }
        return;
      }else if(lv===10){
        const bx = Math.floor(cols/2)-1;
        const by = 0;
        const w = brickW*2 + pad;
        const h = brickH*2 + pad;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:1, colorIdx:0, boss:true, face:'影', strong:true, unbreakable:true});
        reaperPlaceholder = bricks[placeholderIndex];
        if(reaperPlaceholder){
          reaperPlaceholder.hp=0;
          reaperPlaceholder.placeholderBoss=true;
        }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(c>=bx && c<=bx+1 && r>=by && r<=by+1) continue;
            const isTopShield = (r===0 && (c%2===0));
            if(isTopShield){
              addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
              continue;
            }
            const moving = (r%3===0 && c%4===0);
            const hpBoost = baseHP + (r%2===0?1:0);
            const explosive = (!moving && Math.random()<GAME_CONFIG.bricks.explosiveChance*0.6);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:hpBoost, colorIdx:(r%4), moving, vx:moving?((Math.random()<0.5?-1:1)*0.7):0, explosive});
          }
        }
        return;
      }
      // 中央大Boss（2x2磚尺寸一塊）
      const bx = Math.floor(cols/2)-1;
      const w = brickW*2 + pad;
      const h = brickH*2 + pad;
      const hpList=[10,20,30,40];
      const bossIdx = Math.floor(lv/5)-1;
      const bossHP = hpList[Math.max(0,Math.min(3,bossIdx))];
      const faces=['獅','騎','目','魔'];
      if(lv===15){
        const by=0;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:bossHP, colorIdx:0, boss:true, face:faces[bossIdx], strong:true, unbreakable:true, cyclops:true, cyclopsRevealed:false});
        dragonPlaceholder = bricks[placeholderIndex];
        if(dragonPlaceholder){ dragonPlaceholder.placeholderBoss=true; }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(r===0) continue;
            if(r===1 && c>=bx && c<=bx+1) continue;
            const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
          }
        }
        return;
      }else if(lv===20){
        const by = 0;
        const placeholderIndex=bricks.length;
        addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:Infinity, colorIdx:0, boss:true, face:faces[bossIdx], strong:true, unbreakable:true, demonShell:true, hideBossHP:true});
        demonShellBrick = bricks[placeholderIndex];
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(c>=bx && c<=bx+1 && r===by) continue;
            const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
          }
        }
        return;
      }
      const by = Math.max(1, Math.floor(rows/2)-1);
      addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:bossHP, colorIdx:0, boss:true, face:faces[bossIdx], strong:true, unbreakable:true});
      // 周圍護衛磚
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(c>=bx && c<=bx+1 && r>=by && r<=by+1) continue; // 留 Boss 本體
          const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
          addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
        }
      }
      // 加點不可破壞邊框
      for(let c=0;c<cols;c+=2) addBrick(bricks, xAt(c), yAt(0), brickW, brickH, {unbreakable:true});
      return;
    }

    // 非Boss關：設計不同排列
    if(lv<=3){
      // 初學：滿版 + 少量爆炸
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance*0.7;
        addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
      }
    }else if(lv<=6){
      // V 形＋中間走廊
      const mid=Math.floor(cols/2);
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(Math.abs(c-mid)===r%5 && r<rows-1){ // V
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+((r%2)?1:0), colorIdx:r%4});
          }else if(r===Math.floor(rows/2) && (c%3===0)){ // 中線爆炸
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, explosive:true, colorIdx:r%4});
          }
        }
      }
    }else if(lv<=10){
      // 加入不可破壞隔板與少量移動磚
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r%4===0 && c%3===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else{
            const moving = (r%3===0 && c%4===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, moving, vx: moving? ((Math.random()<0.5?-1:1)*0.6) : 0});
          }
        }
      }
    }else if(lv<=14){
      // 交錯棋盤 + 強反彈帶
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if((r+c)%2===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, strong:(r%4===1)});
          }else if(r%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, moving:true, vx: (Math.random()<0.5?-1:1)*0.8});
          }
        }
      }
    }else{
      // 終盤：隧道、移動隊形、強反彈護牆
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r===1 || r===rows-2){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%3===0 && (r%2===0)){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+2, strong:true});
          }else{
            const mv=(r%3===1 && c%2===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, moving:mv, vx: mv?((Math.random()<0.5?-1:1)*1.0):0});
          }
        }
      }
    }
  }


  function canDestroyBrick(b){ const now=performance.now(); if(b.unbreakable) return false; if(b.lockedUntil && now < b.lockedUntil) return false; return true; }
  function damageOrDestroy(i, amount=1){
    const b=bricks[i]; if(!b) return; if(b.unbreakable) return;
    if(b.elite && !b.prompted){ showPrompt('菁英磚'); b.prompted=true; }
    if(b.boss && !b.prompted){ showPrompt('Boss！'); b.prompted=true; }
    const now=performance.now();
    if(b.lockedUntil && now < b.lockedUntil) return;
    b.hp = (b.hp||1) - amount;
    if(b.hp<=0){
      if(b.elite){ stats.eliteKills++; }
      revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); updateHUD();
    }
  }

  function resetBossNineCatDrop(key){
    if(!key) return;
    bossNineCatDrops.delete(key);
  }

  function spawnBossNineCatOnce(key, x, y){
    if(!key) return;
    if(bossNineCatDrops.has(key)) return;
    bossNineCatDrops.add(key);
    spawnPower(x, y, {forceType:'NINE'});
  }

  function bossKillEffect(b, opts={}){
    const cx=b.x+b.w/2, cy=b.y+b.h/2;
    spawnParticles(cx,cy,'#fff5c0',60,2.5,4.0,4.5);
    spawnParticles(cx,cy,'#ff4d6d',40,2.0,3.5,3.5);
    screenShake=Math.max(screenShake,6);
    playSFX('fireExplosion');
    showComboNotice(`成功擊殺第${level}關Boss!`,5000,3000);
    const dropMode = opts.dropNineCat ?? 'never';
    if(dropMode==='always'){
      spawnPower(cx-12,cy,{forceType:'NINE'});
    } else if(dropMode==='default' || dropMode==='chance'){
      if(Math.random()<0.5){ spawnPower(cx-12,cy,{forceType:'NINE'}); }
    }
  }
  function destroyBrick(i, sfx='default'){
    const b=bricks[i]; if(!b) return; if(!canDestroyBrick(b)) return;
    if(b.elite && !b.prompted){ showPrompt('菁英磚'); b.prompted=true; }
    if(b.boss && !b.prompted){ showPrompt('Boss！'); b.prompted=true; }
    if(b.boss){
      b.hp-=1;
      if(b.hp<=0){
        bossKillEffect(b);
        revealBrickArea(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; updateHUD();
      }
      return;
    }
    if(b.elite){ stats.eliteKills++; }
    const bx=b.x+b.w/2, by=b.y+b.h/2;
    const color=b.treasure?'#ffdf6f':b.boss?'#ff4d6d':b.unbreakable?'#888':b.strong?'#bb7aff':b.moving?'#6ec6ff':b.explosive?getVar('--expl'):brickColor(b.colorIdx);
    spawnParticles(bx,by,color,30,2.0,3.2,3.5);
    if(b.treasure){
      spawnParticles(bx,by,'#ffe8a3',20,2.0,3.2,3.6);
      const rainbowBurst=['#ff6ec7','#ff9f43','#ffe066','#8ce99a','#74c0fc','#b197fc','#ff85f5'];
      for(const col of rainbowBurst){ spawnParticles(bx,by,col,8,1.8,3.0,3.2); }
    }
    if(sfx==='default'){ beep(420,0.06,0.08); setTimeout(()=>beep(620,0.05,0.06),40); }
    else if(sfx!=='none'){ playSFX(sfx); }
    revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); updateHUD();
    if(deathLaserActiveUntil>performance.now()){
      triggerDeathLaserAt(bx,by);
    }
  }
  function damageBrick(i, dmg, sfx='default'){
    const brick=bricks[i];
    if(!brick) return;
    const now=performance.now();
    let amount=Math.max(0, Math.floor(dmg));
    if(amount<=0) return;
    if(!brick.boss){
      amount+=getCurseSwordBonus(now);
    }
    amount=Math.max(1, Math.floor(amount*getBloodBladeMultiplier(now)));
    for(let k=0;k<amount;k++){
      if(!bricks[i]) break;
      destroyBrick(i, sfx);
    }
  }
  function destroyNeighbors(idx){
    const b=bricks[idx];
    if(!b) return [];
    const L=layout();
    const destroyed=[];
    for(let j=bricks.length-1;j>=0;j--){
      if(j===idx) continue;
      const t=bricks[j];
      if(!t) continue;
      const dx=Math.abs((t.x+t.w/2)-(b.x+b.w/2));
      const dy=Math.abs((t.y+t.h/2)-(b.y+b.h/2));
      const thx=brickW+L.pad+2;
      const thy=brickH+L.pad+2;
      if(dx<=thx && dy<=thy){
        if(canDestroyBrick(t)){
          const cx=t.x+t.w/2;
          const cy=t.y+t.h/2;
          const radius=Math.max(t.w,t.h)*0.75;
          destroyBrick(j,'none');
          destroyed.push({x:cx,y:cy,radius});
          strikeDemonAbyssBricksAtPoint(cx, cy, radius, 'neighbor');
        }
      }
    }
    return destroyed;
  }

  function explodeAt(cx,cy,opts={}){
    const radius=Math.max(brickW,brickH)*1.3;
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy);
      if(d<=radius){
        if(b.unbreakable){ continue; }
        // Boss：只扣血，不秒殺
        if(b.boss){
          b.hp -= 1;
          if(b.hp<=0){ bossKillEffect(b); revealBrickArea(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; }
        }else{
          revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++;
        }
        spawnParticles(bx,by,'#ffdd99',14,1.7,2.6,3);
      }
    }
    strikeDemonAbyssBricksAtPoint(cx, cy, radius, 'explosion');
    if(circleIntersectsActiveBoss(cx,cy,radius)){
      const center=activeBossCenter();
      const impact=center?{x:center.x,y:center.y}:{x:cx,y:cy};
      damageActiveBoss(1,'fire',impact);
    }
    spawnParticles(cx,cy,'#ffbb55',24,2.1,3.2,4); updateHUD();
    if(opts.sound!==false){
      playSFX('explosion');
    }
  }

  function fireExplosionAt(cx,cy,radius,opts={}){
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy);
      if(d<=radius){
        if(canDestroyBrick(b)){
          if(b.boss){
            b.hp-=1;
            if(b.hp<=0){ bossKillEffect(b); revealBrickArea(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; updateHUD(); }
          }
          else {
            revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++; updateHUD();
          }
        }
        spawnParticles(bx,by,'#ffdd99',20,1.8,2.8,3.5);
      }
    }
    strikeDemonAbyssBricksAtPoint(cx, cy, radius, 'fireExplosion');
    if(circleIntersectsActiveBoss(cx,cy,radius)){
      const center=activeBossCenter();
      const impact=center?{x:center.x,y:center.y}:{x:cx,y:cy};
      damageActiveBoss(1,'fire',impact);
    }
    fireExplosions.push({x:cx,y:cy,r:radius,t0:performance.now(),life:400});
    spawnParticles(cx,cy,'#ff5500',60,2.6,3.8,4.5);
    spawnParticles(cx,cy,'#ffaa33',40,2.8,4.0,3.8);
    spawnParticles(cx,cy,'#fff4cc',20,3.0,4.2,3.0);
    screenShake=Math.max(screenShake,6);
    updateHUD();
    if(equipmentFireScatter && !opts.noScatter){
      queueFireScatterExplosions(radius);
    }
    playSFX('fireExplosion');
  }

  function queueFireScatterExplosions(radius){
    if(!Number.isFinite(radius) || radius<=0) return;
    const now=performance.now();
    const L=layout();
    const pad=L.pad||0;
    const stageLeft=pad;
    const stageRight=1100-pad;
    const stageTop=L.top||0;
    const totalRows=Math.max(1,L.rows||1);
    const totalHeight=totalRows*(brickH+pad)-pad;
    const stageBottom=stageTop+Math.max(totalHeight, 200);
    const candidates=bricks.filter(b=>canDestroyBrick(b));
    const pool=[...candidates];
    for(let i=0;i<FIRE_SCATTER_COUNT;i++){
      let entry=null;
      if(pool.length){
        const idx=Math.floor(Math.random()*pool.length);
        const chosen=pool.splice(idx,1)[0];
        entry={brick:chosen,x:chosen.x+chosen.w/2,y:chosen.y+chosen.h/2};
      }
      if(!entry){
        const x=stageLeft + Math.random()*Math.max(10, stageRight-stageLeft);
        const y=stageTop + Math.random()*Math.max(10, stageBottom-stageTop);
        entry={x,y};
      }
      entry.triggerAt=now+(i+1)*FIRE_SCATTER_DELAY;
      entry.radius=radius;
      fireScatterQueue.push(entry);
    }
  }

  function updateFireScatter(now){
    for(let i=fireScatterQueue.length-1;i>=0;i--){
      const evt=fireScatterQueue[i];
      if(now<evt.triggerAt) continue;
      let x=evt.x;
      let y=evt.y;
      if(evt.brick){
        const idx=bricks.indexOf(evt.brick);
        if(idx>=0){
          const b=bricks[idx];
          x=b.x+b.w/2;
          y=b.y+b.h/2;
        }
      }
      if(Number.isFinite(x) && Number.isFinite(y)){
        fireExplosionAt(x,y,evt.radius,{noScatter:true});
      }
      fireScatterQueue.splice(i,1);
    }
  }

  function triggerBombDevilForBrick(brick){
    if(!brick) return;
    const now=performance.now();
    if(now>=bombDevilActiveUntil) return;
    if(!canDestroyBrick(brick)) return;
    const L=layout();
    const pad=L.pad||0;
    const rowIdx=Math.round((brick.y - (L.top||0))/(brickH + pad));
    if(!Number.isFinite(rowIdx)) return;
    const last=bombDevilRowCooldown.get(rowIdx)||0;
    if(now-last<150) return;
    bombDevilRowCooldown.set(rowIdx,now);
    const rowBricks=[];
    for(const b of bricks){
      if(!b) continue;
      const r=Math.round((b.y - (L.top||0))/(brickH + pad));
      if(r===rowIdx && canDestroyBrick(b)){
        rowBricks.push(b);
      }
    }
    if(!rowBricks.length) return;
    rowBricks.sort((a,b)=>(b.y+b.h/2)-(a.y+a.h/2));
    const events=rowBricks.map((b,i)=>({brick:b,triggerAt:now+i*bombDevilIntervalMs,triggered:false}));
    bombDevilQueues.push({events,playedSound:false});
  }

  function queueBombDevilBossExplosions(cx, cy, startAt){
    const now=startAt!=null?startAt:performance.now();
    if(now>=bombDevilActiveUntil) return;
    const base=Math.max(brickW||0, brickH||0);
    const radius=base>0 ? base*1.5 : 150;
    const events=Array.from({length:BOMB_DEVIL_BOSS_CHAIN_COUNT}, (_,i)=>(
      {x:cx,y:cy,radius,triggerAt:now+i*BOMB_DEVIL_BOSS_CHAIN_DELAY,triggered:false}
    ));
    bombDevilBossQueues.push({events});
  }

  function updateBombDevil(now){
    for(let i=bombDevilQueues.length-1;i>=0;i--){
      const seq=bombDevilQueues[i];
      let done=true;
      for(const evt of seq.events){
        if(evt.triggered){
          continue;
        }
        if(now<evt.triggerAt){
          done=false;
          continue;
        }
        evt.triggered=true;
        const brick=evt.brick;
        if(!brick) continue;
        const idx=bricks.indexOf(brick);
        if(idx<0) continue;
        const target=bricks[idx];
        const cx=target.x+target.w/2;
        const cy=target.y+target.h/2;
        if(target.explosive){
          explodeAt(cx,cy);
          seq.playedSound=true;
        }else{
          destroyBrick(idx,'none');
          spawnParticles(cx,cy,'#ff9966',24,1.8,2.6,3.2);
          if(!seq.playedSound){
            playSFX('explosion');
            seq.playedSound=true;
          }
        }
      }
      if(done || seq.events.every(e=>e.triggered)){
        bombDevilQueues.splice(i,1);
      }
    }
    for(let i=bombDevilBossQueues.length-1;i>=0;i--){
      const burst=bombDevilBossQueues[i];
      let completed=true;
      for(const evt of burst.events){
        if(evt.triggered) continue;
        if(now<evt.triggerAt){
          completed=false;
          continue;
        }
        evt.triggered=true;
        fireExplosionAt(evt.x, evt.y, evt.radius, {noScatter:true});
      }
      if(completed || burst.events.every(evt=>evt.triggered)){
        bombDevilBossQueues.splice(i,1);
      }
    }
    if(now>=bombDevilActiveUntil && bombDevilRowCooldown.size){
      bombDevilRowCooldown.clear();
    }
  }

  function detonateFireballNow(){
    if(!buffs.FIRE?.active) return false;
    if(!balls.length) return false;
    const now=performance.now();
    const ball=balls[0];
    const energy=Math.max(1, fireEnergy||0);
    const radius=energy<=3?100:energy<=8?150:energy<=14?200:300;
    fireExplosionAt(ball.x,ball.y,radius);
    fireEnergy=0;
    updateFireEnergy();
    buffs.FIRE.active=false;
    buffs.FIRE.until=now;
    return true;
  }

  function triggerMassExplosiveDetonation(){
    const coords=[];
    for(const b of bricks){
      if(!b) continue;
      if(!b.explosive) continue;
      if(!canDestroyBrick(b)) continue;
      coords.push({x:b.x+b.w/2,y:b.y+b.h/2});
    }
    if(!coords.length) return false;
    coords.forEach((pos,idx)=>{
      if(idx===0){
        explodeAt(pos.x,pos.y);
      }else{
        explodeAt(pos.x,pos.y,{sound:false});
      }
    });
    return true;
  }

  function poisonTickIntervalMs(){
    const base=GAME_CONFIG.powers.POISON.poison.tickMs||2000;
    if(equipmentPoisonTickInterval>0){
      return equipmentPoisonTickInterval;
    }
    return base;
  }

  function applyPoisonToBrick(brick, now=performance.now()){
    if(!brick) return;
    const duration=Math.max(0, GAME_CONFIG.powers.POISON.durationMs||12000);
    const tickInterval=Math.max(50, poisonTickIntervalMs());
    brick.poisonUntil=now+duration;
    brick.poisonTick=now+tickInterval;
    brick.poisonAppliedAt=now;
    if(equipmentPoisonSpreadDelay>0){
      brick.poisonSpreadAt=now+equipmentPoisonSpreadDelay;
      brick.poisonSpreadTriggered=false;
    }else{
      brick.poisonSpreadAt=0;
      brick.poisonSpreadTriggered=true;
    }
  }

  function clearBrickPoison(brick){
    if(!brick) return;
    delete brick.poisonUntil;
    delete brick.poisonTick;
    delete brick.poisonSpreadAt;
    delete brick.poisonSpreadTriggered;
    delete brick.poisonAppliedAt;
  }

  function brickGridPosition(brick){
    const L=layout();
    if(!L) return null;
    const cols=L.cols||0;
    const rows=L.rows||0;
    if(!cols || !rows) return null;
    const col=Math.max(0, Math.min(cols-1, Math.round((brick.x - L.pad)/(brickW + L.pad))));
    const row=Math.max(0, Math.min(rows-1, Math.round((brick.y - L.top)/(brickH + L.pad))));
    return {row, col};
  }

  function isStandardGridBrick(brick){
    if(!brick) return false;
    if(Math.abs((brick.w||brickW) - brickW) > 1) return false;
    if(Math.abs((brick.h||brickH) - brickH) > 1) return false;
    return true;
  }

  function spreadPoisonFromBrick(brick, now=performance.now()){
    if(!brick) return;
    const origin=brickGridPosition(brick);
    if(!origin) return;
    const neighbors=[];
    for(const other of bricks){
      if(!other || other===brick) continue;
      if(other.fallingTreasure) continue;
      if(other.unbreakable) continue;
      const pos=brickGridPosition(other);
      if(!pos) continue;
      if(Math.abs(pos.row-origin.row)<=1 && Math.abs(pos.col-origin.col)<=1){
        neighbors.push(other);
      }
    }
    if(!neighbors.length) return;
    for(const target of neighbors){
      if(target.poisonUntil && target.poisonUntil>now) continue;
      applyPoisonToBrick(target, now);
      const cx=target.x+target.w/2;
      const cy=target.y+target.h/2;
      spawnParticles(cx,cy,'rgba(90,255,140,0.45)',12,1.4,2.2,2.0);
    }
  }

  function clearActivePlagueTimers(){
    while(activePlagueTimers.length){
      const timer=activePlagueTimers.pop();
      clearTimeout(timer);
    }
  }

  function triggerGreatPlague(cfg={}){
    const candidates=bricks.filter(b=>b && !b.fallingTreasure && canDestroyBrick(b));
    if(!candidates.length) return false;
    clearActivePlagueTimers();
    const count=Math.max(1, Math.min(candidates.length, Math.floor(cfg.count)||15));
    const interval=Math.max(0, Number(cfg.interval)||300);
    const pool=[...candidates];
    const picks=[];
    while(picks.length<count && pool.length){
      const idx=Math.floor(Math.random()*pool.length);
      picks.push(pool.splice(idx,1)[0]);
    }
    picks.forEach((brick,idx)=>{
      const timer=setTimeout(()=>{
        const currentIndex=bricks.indexOf(brick);
        if(currentIndex===-1) return;
        const current=bricks[currentIndex];
        applyPoisonToBrick(current, performance.now());
        const cx=current.x+current.w/2;
        const cy=current.y+current.h/2;
        spawnParticles(cx,cy,'rgba(120,255,120,0.6)',14,1.6,2.4,2.4);
      }, idx*interval);
      activePlagueTimers.push(timer);
    });
    return true;
  }

  function triggerPoisonDetonation(){
    const infected=[];
    for(let i=0;i<bricks.length;i++){
      const brick=bricks[i];
      if(!brick?.poisonUntil) continue;
      infected.push(i);
    }
    if(!infected.length) return false;
    infected.sort((a,b)=>a-b);
    let triggered=false;
    for(let idx=infected.length-1; idx>=0; idx--){
      const i=infected[idx];
      const brick=bricks[i];
      if(!brick) continue;
      if(brick.boss){
        const cx=brick.x+brick.w/2;
        const cy=brick.y+brick.h/2;
        damageActiveBoss(1,'poisonDetonate',{x:cx,y:cy});
        spawnParticles(cx,cy,'rgba(140,255,160,0.85)',26,2.0,3.0,3.2);
        clearBrickPoison(brick);
        triggered=true;
        continue;
      }
      if(!canDestroyBrick(brick)){
        clearBrickPoison(brick);
        continue;
      }
      const cx=brick.x+brick.w/2;
      const cy=brick.y+brick.h/2;
      spawnParticles(cx,cy,'rgba(140,255,160,0.85)',26,2.0,3.0,3.2);
      destroyBrick(i,'none');
      if(equipmentPoisonPlasma){
        spawnPlasmaBurst(cx,cy,{sound:false});
      }
      triggered=true;
    }
    if(triggered){
      playSFX('explosion');
      screenShake=Math.max(screenShake,6);
    }
    return triggered;
  }

  function destroyBricksInArea(brick, radiusCells=1){
    if(!brick) return false;
    const origin=brickGridPosition(brick);
    if(!origin) return false;
    const targets=[];
    for(let i=0;i<bricks.length;i++){
      const candidate=bricks[i];
      if(!candidate) continue;
      if(candidate.fallingTreasure) continue;
      if(!canDestroyBrick(candidate)) continue;
      const pos=brickGridPosition(candidate);
      if(!pos) continue;
      if(Math.abs(pos.row-origin.row)<=radiusCells && Math.abs(pos.col-origin.col)<=radiusCells){
        targets.push(i);
      }
    }
    if(!targets.length) return false;
    targets.sort((a,b)=>a-b);
    let triggered=false;
    for(let idx=targets.length-1; idx>=0; idx--){
      const index=targets[idx];
      const target=bricks[index];
      if(!target) continue;
      const cx=target.x+target.w/2;
      const cy=target.y+target.h/2;
      spawnParticles(cx,cy,'#ffb347',20,2.0,3.2,3.4);
      destroyBrick(index,'none');
      triggered=true;
    }
    if(triggered){
      playSFX('explosion');
      screenShake=Math.max(screenShake,8);
    }
    return triggered;
  }

  function triggerSolarBurst(now=performance.now()){
    if(!equipmentSolarBurst) return false;
    if(window.currentSkin?.cssSkin!=='烈陽．炙金幻焰') return false;
    const candidates=bricks.filter(b=>b && !b.fallingTreasure && canDestroyBrick(b));
    if(!candidates.length) return false;
    const target=candidates[Math.floor(Math.random()*candidates.length)];
    if(!target) return false;
    return destroyBricksInArea(target,1);
  }

  function triggerMirrorSymmetry(){
    const L=layout();
    if(!L) return false;
    const cols=L.cols||0;
    const rows=L.rows||0;
    if(!cols || !rows) return false;
    const grid=new Map();
    let leftCount=0, rightCount=0;
    for(let i=0;i<bricks.length;i++){
      const brick=bricks[i];
      if(!brick) continue;
      if(brick.fallingTreasure) continue;
      if(!isStandardGridBrick(brick)) continue;
      const pos=brickGridPosition(brick);
      if(!pos) continue;
      const key=`${pos.row}:${pos.col}`;
      if(!grid.has(key)) grid.set(key, []);
      grid.get(key).push({index:i, brick});
      if(pos.col < cols/2) leftCount++;
      else if(pos.col > (cols-1)/2) rightCount++;
    }
    const dominant=leftCount>rightCount?'left':leftCount<rightCount?'right':'none';
    const removals=new Set();
    const clones=[];
    for(let col=0; col<Math.floor(cols/2); col++){
      const mirrorCol=cols-1-col;
      for(let row=0; row<rows; row++){
        const leftKey=`${row}:${col}`;
        const rightKey=`${row}:${mirrorCol}`;
        const leftList=grid.get(leftKey)||[];
        const rightList=grid.get(rightKey)||[];
        const leftHas=leftList.some(({brick})=>brick && canDestroyBrick(brick) && !brick.boss && !brick.unbreakable);
        const rightHas=rightList.some(({brick})=>brick && canDestroyBrick(brick) && !brick.boss && !brick.unbreakable);
        if(leftHas && rightHas) continue;
        if(leftHas && !rightHas){
          if(dominant==='left' || dominant==='none'){
            for(const entry of leftList){
              if(entry.brick && canDestroyBrick(entry.brick) && !entry.brick.boss && !entry.brick.unbreakable){
                removals.add(entry.index);
              }
            }
          }else{
            const source=leftList.find(({brick})=>brick && canDestroyBrick(brick) && !brick.boss && !brick.unbreakable);
            if(source){
              clones.push({source:source.brick, col:mirrorCol, row});
            }
          }
        }else if(rightHas && !leftHas){
          if(dominant==='right' || dominant==='none'){
            for(const entry of rightList){
              if(entry.brick && canDestroyBrick(entry.brick) && !entry.brick.boss && !entry.brick.unbreakable){
                removals.add(entry.index);
              }
            }
          }else{
            const source=rightList.find(({brick})=>brick && canDestroyBrick(brick) && !brick.boss && !brick.unbreakable);
            if(source){
              clones.push({source:source.brick, col, row});
            }
          }
        }
      }
    }
    if(!removals.size && !clones.length) return false;
    const removalList=Array.from(removals).sort((a,b)=>a-b);
    for(let idx=removalList.length-1; idx>=0; idx--){
      const index=removalList[idx];
      const brick=bricks[index];
      if(!brick) continue;
      const cx=brick.x+brick.w/2;
      const cy=brick.y+brick.h/2;
      spawnParticles(cx,cy,'rgba(255,180,90,0.9)',22,2.0,3.2,3.2);
      destroyBrick(index,'none');
    }
    for(const entry of clones){
      const source=entry.source;
      if(!source) continue;
      const col=entry.col;
      const row=entry.row;
      const x=L.pad + col*(brickW + L.pad);
      const y=L.top + row*(brickH + L.pad);
      const opts={
        hp:source.boss?source.hp:Math.max(1, source.hp||1),
        colorIdx:source.colorIdx,
        explosive:!!source.explosive,
        strong:!!source.strong,
        moving:false,
        vx:0,
        elite:!!source.elite
      };
      addBrick(bricks, x, y, brickW, brickH, opts);
      spawnParticles(x+brickW/2,y+brickH/2,'rgba(150,200,255,0.8)',18,1.6,2.6,2.6);
    }
    if(removals.size || clones.length){
      playSFX('explosion');
      screenShake=Math.max(screenShake,8);
      updateHUD();
    }
    return true;
  }

  function triggerNuke(cfg={}){
    const bossDamage=Math.max(0, Number(cfg.bossDamage)||0);
    const selfDamage=Math.max(0, Number(cfg.selfDamage)||0);
    for(let i=bricks.length-1;i>=0;i--){
      const brick=bricks[i];
      if(!brick) continue;
      if(brick.boss) continue;
      if(!canDestroyBrick(brick)) continue;
      const cx=brick.x+brick.w/2;
      const cy=brick.y+brick.h/2;
      spawnParticles(cx,cy,'#ffd480',28,2.4,3.6,3.6);
      destroyBrick(i,'none');
    }
    if(bossDamage>0){
      damageActiveBoss(bossDamage,'nuke',{x:550,y:320});
    }
    spawnParticles(550,350,'#fff2a8',160,3.4,4.8,4.8);
    playSFX('explosion');
    screenShake=Math.max(screenShake,18);
    if(selfDamage>0){
      stats.livesUsed+=selfDamage;
      lives=Math.max(0, lives-selfDamage);
      updateHUD();
      if(lives<=0){
        running=false;
        paused=true;
        showGameOver();
      }
    }
    return true;
  }

  function spawnStarProjectiles(count=3, damage=4){
    const L=layout();
    const pad=L?.pad||0;
    const top=L?.top||0;
    for(let i=0;i<count;i++){
      const startX=pad + Math.random()*Math.max(10, 1100-2*pad);
      const startY=top - 80 - Math.random()*60;
      const dir=Math.random()<0.5?-1:1;
      const speed=7+Math.random()*2.5;
      const angle=(Math.PI/2) + dir*(Math.PI/6 + Math.random()*0.25);
      starProjectiles.push({
        x:startX,
        y:startY,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        damage:damage,
        radius:18,
        created:performance.now()
      });
    }
    playSFX('explosion');
  }

  function updateStarProjectiles(now){
    for(let i=starProjectiles.length-1;i>=0;i--){
      const star=starProjectiles[i];
      star.x+=star.vx;
      star.y+=star.vy;
      star.vy+=0.12;
      let hit=false;
      for(let j=bricks.length-1;j>=0;j--){
        const brick=bricks[j];
        if(!brick) continue;
        const rect={x:brick.x,y:brick.y,w:brick.w,h:brick.h};
        if(star.x>=rect.x && star.x<=rect.x+rect.w && star.y>=rect.y && star.y<=rect.y+rect.h){
          if(brick.boss){
            damageActiveBoss(star.damage,'star',{x:star.x,y:star.y});
          }else{
            damageBrick(j, star.damage, 'none');
          }
          spawnParticles(star.x,star.y,'rgba(255,215,120,0.9)',22,2.0,3.2,3.2);
          hit=true;
          break;
        }
      }
      if(!hit && circleIntersectsActiveBoss(star.x, star.y, star.radius||18)){
        damageActiveBoss(star.damage,'star',{x:star.x,y:star.y});
        spawnParticles(star.x,star.y,'rgba(255,215,120,0.9)',22,2.0,3.2,3.2);
        hit=true;
      }
      if(hit || star.y>760 || star.x<-80 || star.x>1180){
        starProjectiles.splice(i,1);
      }
    }
  }

  function drawStarProjectiles(){
    if(!starProjectiles.length) return;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    for(const star of starProjectiles){
      const x=star.x*scaleX;
      const y=star.y*scaleY;
      const r=(star.radius||18)*((scaleX+scaleY)/2);
      const grad=ctx.createRadialGradient(x,y,0,x,y,r);
      grad.addColorStop(0,'rgba(255,255,200,0.95)');
      grad.addColorStop(0.6,'rgba(255,200,90,0.6)');
      grad.addColorStop(1,'rgba(255,180,60,0)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function spawnMoonProjectile(cfg={}){
    const damage=Math.max(1, Number(cfg.damage)||4);
    const maxBounces=Math.max(1, Number(cfg.maxBounces)||9);
    const L=layout();
    const pad=L?.pad||0;
    const top=L?.top||0;
    const startX=pad + Math.random()*Math.max(10, 1100-2*pad);
    const startY=top - 120;
    const dir=Math.random()<0.5?-1:1;
    const speed=6.5;
    const angle=(Math.PI/2) + dir*(Math.PI/8 + Math.random()*0.2);
    moonProjectiles.push({
      x:startX,
      y:startY,
      vx:Math.cos(angle)*speed,
      vy:Math.sin(angle)*speed,
      damage,
      radius:28,
      bounces:0,
      maxBounces
    });
    playSFX('explosion');
  }

  function updateMoonProjectiles(now){
    for(let i=moonProjectiles.length-1;i>=0;i--){
      const moon=moonProjectiles[i];
      const prevX=moon.x;
      const prevY=moon.y;
      moon.x+=moon.vx;
      moon.y+=moon.vy;
      moon.vy+=0.08;
      let bounced=false;
      for(let j=bricks.length-1;j>=0;j--){
        const brick=bricks[j];
        if(!brick) continue;
        const rect={x:brick.x,y:brick.y,w:brick.w,h:brick.h};
        if(circleIntersectsRect(moon.x, moon.y, moon.radius||26, rect)){
          if(brick.boss){
            damageActiveBoss(moon.damage,'moon',{x:moon.x,y:moon.y});
          }else{
            damageBrick(j, moon.damage, 'none');
          }
          spawnParticles(moon.x,moon.y,'rgba(200,210,255,0.9)',26,2.2,3.4,3.4);
          if(prevY < rect.y){
            moon.y = rect.y - (moon.radius||26);
            moon.vy = -Math.abs(moon.vy);
          }else if(prevY > rect.y + rect.h){
            moon.y = rect.y + rect.h + (moon.radius||26);
            moon.vy = Math.abs(moon.vy);
          }else{
            moon.vx *= -1;
          }
          bounced=true;
          break;
        }
      }
      if(!bounced){
        if(moon.x-(moon.radius||26)<0){
          moon.x=(moon.radius||26);
          moon.vx=Math.abs(moon.vx);
          bounced=true;
        }else if(moon.x+(moon.radius||26)>1100){
          moon.x=1100-(moon.radius||26);
          moon.vx=-Math.abs(moon.vx);
          bounced=true;
        }
        if(moon.y-(moon.radius||26)<0){
          moon.y=(moon.radius||26);
          moon.vy=Math.abs(moon.vy);
          bounced=true;
        }else if(moon.y+(moon.radius||26)>700){
          moon.y=700-(moon.radius||26);
          moon.vy=-Math.abs(moon.vy);
          bounced=true;
        }
      }
      if(bounced){
        moon.bounces++;
        screenShake=Math.max(screenShake,4);
      }
      if(circleIntersectsActiveBoss(moon.x, moon.y, moon.radius||26)){
        damageActiveBoss(moon.damage,'moon',{x:moon.x,y:moon.y});
        moon.vy = -Math.abs(moon.vy||6);
        moon.vx *= -1;
        moon.bounces++;
        bounced=true;
      }
      if(moon.bounces>moon.maxBounces || moon.y>780 || moon.y<-200){
        moonProjectiles.splice(i,1);
      }
    }
  }

  function drawMoonProjectiles(){
    if(!moonProjectiles.length) return;
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    for(const moon of moonProjectiles){
      const x=moon.x*scaleX;
      const y=moon.y*scaleY;
      const r=(moon.radius||28)*((scaleX+scaleY)/2);
      ctx.fillStyle='rgba(220,225,255,0.9)';
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle='rgba(170,180,255,0.6)';
      ctx.lineWidth=3;
      ctx.stroke();
    }
    ctx.restore();
  }

  function fireCollide(){ if(buffs.FIRE.active){ fireEnergy++; updateFireEnergy(); } }

  // === 掉落道具 ===
  const powerups=[];
  const coins=[];

  const COIN_DEFS={
    small:{value:1,size:18,chance:0.9,magnetRange:150,seekSpeed:4.6,palette:{inner:'#f9fbff',mid:'#cdd9f0',outer:'#8898c0',rim:'#ffffff',text:'#12203b'},label:'+1'},
    medium:{value:5,size:20,chance:0.09,magnetRange:165,seekSpeed:4.8,palette:{inner:'#f8fbff',mid:'#c5d7ff',outer:'#6e85c7',rim:'#f1f6ff',text:'#102040'},label:'+5'},
    large:{value:10,size:22,chance:0.01,magnetRange:180,seekSpeed:5.0,palette:{inner:'#f6faff',mid:'#bdd0ff',outer:'#5a75be',rim:'#eef5ff',text:'#0c1a36'},label:'+10'},
    extra:{value:30,size:26,chance:0,magnetRange:210,seekSpeed:5.6,palette:{inner:'#fff7f0',mid:'#ffd9a6',outer:'#ffac4c',rim:'#ffe6bb',text:'#2a1700'},label:'+30'}
  };

  function randomCoinType(){
    const r=Math.random();
    if(r<COIN_DEFS.small.chance) return 'small';
    if(r<COIN_DEFS.small.chance+COIN_DEFS.medium.chance) return 'medium';
    return 'large';
  }

  function setCoinDirection(coin, horizontal){
    coin.horizontal=!!horizontal;
    if(coin.horizontal){
      coin.vx = -Math.abs(coin.speed);
      coin.vy = 0;
    }else{
      coin.vx = 0;
      coin.vy = Math.abs(coin.speed);
    }
  }

  function spawnCoinAt(cx, cy, opts={}){
    const type = opts.type || randomCoinType();
    const def = COIN_DEFS[type] || COIN_DEFS.small;
    const size = opts.size || def.size;
    const now = performance.now();
    const coin={
      type,
      value: opts.value ?? def.value,
      size,
      w:size,
      h:size,
      x:(cx ?? 550) - size/2,
      y:(cy ?? (layout().top+40)) - size/2,
      speed: opts.speed ?? 2.6,
      seekSpeed: opts.seekSpeed ?? def.seekSpeed,
      magnetRange: opts.magnetRange ?? def.magnetRange,
      spawnAt: now,
      life: opts.life ?? 14000,
      phase: Math.random()*Math.PI*2,
      vx:0,
      vy:0,
      magnet:false
    };
    const L = layout();
    const stageTop = L?.top ?? 60;
    coin.x = Math.max(8, Math.min(1100 - coin.w - 8, coin.x));
    coin.y = Math.max(stageTop, Math.min(700 - coin.h - 8, coin.y));
    setCoinDirection(coin, orientLeft);
    coins.push(coin);
    return coin;
  }

  function coinDropChanceForLevel(lv){
    const min=0.10, max=0.20;
    const total=Math.max(1, (GAME_CONFIG.totalLevels||1)-1);
    const t=Math.max(0, Math.min(1, (lv-1)/total));
    return min + (max-min)*t;
  }

  function maybeDropCoin(b, rateMul=1){
    if(!b) return;
    if(b.boss) return;
    let chance = coinDropChanceForLevel(level) * (rateMul ?? 1);
    if(b.elite) chance = 1;
    if(chance>1) chance=1;
    if(Math.random()<chance){
      spawnCoinAt(b.x + b.w/2, b.y + b.h/2);
    }
  }

  function dropBossCoins(centerX, centerY, count){
    if(!count || count<=0) return;
    const radius = 32;
    for(let i=0;i<count;i++){
      const ang = (Math.PI*2*i)/count;
      const x = centerX + Math.cos(ang)*radius;
      const y = centerY + Math.sin(ang)*radius;
      spawnCoinAt(x, y, {type:'extra'});
    }
  }

  function awardSilverCoins(amount, opts={}){
    if(!Number.isFinite(amount)) return;
    silverCoins = Math.max(0, Math.floor(silverCoins + amount));
    saveSilverCoins();
    updateHUD();
    refreshStoreAffordability();
    if(opts.x!=null && opts.y!=null){
      const type = opts.type || 'small';
      const primary = type==='extra' ? '#ffe4b0' : '#d5e8ff';
      spawnParticles(opts.x, opts.y, primary, 14, 1.6, 2.4, 2.1);
      spawnParticles(opts.x, opts.y, '#ffffff', 8, 1.4, 2.0, 1.8);
    }
    playSFX('coin');
  }

  function spendSilverCoins(amount){
    if(!Number.isFinite(amount) || amount<=0) return false;
    if(silverCoins < amount) return false;
    silverCoins = Math.max(0, Math.floor(silverCoins - amount));
    saveSilverCoins();
    updateHUD();
    refreshStoreAffordability();
    return true;
  }

  function collectCoin(coin){
    if(!coin) return;
    const cx = coin.x + coin.w/2;
    const cy = coin.y + coin.h/2;
    awardSilverCoins(coin.value, {x:cx, y:cy, type:coin.type});
  }


  // === 天空隨機增益掉落（第1關每25秒 → 第20關每6秒 線性遞減） ===
  let nextSkyDropAt = 0;
  function skyDropIntervalMs(lv){
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const s = 25*1000 * (1-t) + 6*1000 * t;
    return s;
  }
  function scheduleNextSkyDrop(){ nextSkyDropAt = performance.now() + skyDropIntervalMs(level); }
  function spawnBeneficialAtTop(){
    // 從所有非減益的道具中隨機挑選一種作為隨機掉落增益
    // 若畫面已有特殊道具掉落，暫時排除特殊道具
    const goodTypes = ALL_TYPES.filter(k => GAME_CONFIG.powers[k].type !== 'debuff' && k !== 'NINE');
    let pool = goodTypes;
    if(powerups.some(p=>p.isSpecial)){
      pool = pool.filter(k => {
        const t = GAME_CONFIG.powers[k].type;
        return t !== 'special';
      });
    }
    if(!pool.length) return;
    let type;
    if(!powerups.some(p=>p.isSpecial) && equipmentSpecialDropRateMultiplier>1){
      const specials=pool.filter(k=>GAME_CONFIG.powers[k]?.type==='special');
      const nonSpecials=pool.filter(k=>GAME_CONFIG.powers[k]?.type!=='special');
      if(specials.length && nonSpecials.length){
        const baseProb=specials.length/pool.length;
        const targetProb=Math.min(1, baseProb*equipmentSpecialDropRateMultiplier);
        if(Math.random()<targetProb){
          type=specials[Math.floor(Math.random()*specials.length)];
        }else{
          type=nonSpecials[Math.floor(Math.random()*nonSpecials.length)];
        }
      }else if(specials.length){
        type=specials[Math.floor(Math.random()*specials.length)];
      }else{
        type=pool[Math.floor(Math.random()*pool.length)];
      }
    }else{
      type = pool[Math.floor(Math.random()*pool.length)];
    }
    const def = GAME_CONFIG.powers[type];
    if(!def) return;
    const isSpecial = (def.type === 'special');
    // 設定速度：特殊偏慢
    let speed = GAME_CONFIG.powerCapsule.fallVy;
    if(isSpecial) speed *= 0.75;
    // 決定掉落方向
    const horizontal = orientLeft;
    let px, py;
    if(horizontal){
      // 水平掉落：從右側隨機 y 開始
      px = 1100 - 40;
      const L = layout();
      py = L.top + 20 + Math.random() * (700 - 60 - L.top);
    } else {
      // 垂直掉落：從畫面上方隨機 x
      px = 40 + Math.random() * (1100 - 80);
      py = layout().top - 20;
    }
    powerups.push({
      x: px,
      y: py,
      w: GAME_CONFIG.powerCapsule.width,
      h: GAME_CONFIG.powerCapsule.height,
      speed: speed,
      horizontal: horizontal,
      type: type,
      isDebuff: false,
      isSpecial: isSpecial,
      phase: Math.random() * Math.PI * 2
    });
  }

  // 道具掉落率抑制
  let burstStart=0, burstCount=0;
  let pendingGoodDrop=null;
  function activePowerCount(){
    const now=performance.now();
    let cnt=0;
    for(const k in buffs){
      const b=buffs[k];
      if(!b) continue;
      if(Array.isArray(b.stacks)){
        if(b.stacks.some(t=>t>now)) cnt++;
      }else if(b.active && (!b.until || b.until>now)){
        cnt++;
      }
    }
    return cnt;
  }
  function maybeDropFromBrick(b, rateMul=1){
    if(!b || b.unbreakable) return;
    maybeDropCoin(b, rateMul);
    if(b.treasure){
      spawnPower(b.x + b.w/2 - GAME_CONFIG.powerCapsule.width/2, b.y + b.h/2, {forceGood:true});
      return;
    }
    // Boss不會掉落一般增益（保持平衡）
    if(b.boss) return;
    const now=performance.now();
    if(!burstStart || now-burstStart>500){
      burstStart=now; burstCount=1;
    }else{
      burstCount++;
    }
    const actives=activePowerCount();
    if(actives===0){
      if(!pendingGoodDrop){
        const px=b.x+b.w/2-12, py=b.y+b.h/2;
        pendingGoodDrop={x:px,y:py};
        setTimeout(()=>{
          if(pendingGoodDrop && burstCount===1){
            spawnPower(pendingGoodDrop.x, pendingGoodDrop.y, {forceGood:true});
          }
          pendingGoodDrop=null;
        },0);
        return;
      }
      // 已有保底掉落等待確認，後續磚塊走一般掉落計算
    }
    let rate=dropRateForLevel(level);
    if(actives>=5) rate*=0.3;
    if(burstCount>=3){
      let factor;
      if(burstCount===3) factor=0.7;
      else if(burstCount===4) factor=0.4;
      else factor=0.1;
      rate*=factor;
    }
    rate *= rateMul;
    if(Math.random()<rate) spawnPower(b.x + b.w/2 - 12, b.y + b.h/2);
  }

  function dropRateForLevel(lv){
    const diff = getDiff();
    const base = diff.dropRate || 0.5;
    const startBoostAt = 8; // 中期開始提升掉落率
    const incPerLv = 0.02;
    let inc = Math.max(0, (lv - startBoostAt) * incPerLv);
    let max = 0.9;
    const d = (typeof difficultySel!=='undefined') ? difficultySel.value : 'normal';
    if(d==='normal') max = 0.7;
    if(d==='hard') max = 0.5;
    return Math.min(max, base + inc);
  }

  function spawnPower(x,y,opts={}){
    // 隨機挑選一種道具類型（普通或特殊），並根據類型設定掉落速度與顏色標記
    const {forceGood=false, forceType=null} = opts;
    const existingSpecial = powerups.some(p=>p.isSpecial);
    let pool, type;
    if(forceType){
      type = forceType;
    }else{
      if(forceGood){
        pool = ALL_TYPES.filter(k => GAME_CONFIG.powers[k].type !== 'debuff');
        if(existingSpecial){
          pool = pool.filter(k => { const t = GAME_CONFIG.powers[k].type; return t !== 'special'; });
        }
      }else{
        pool = NORMAL_TYPES;
        if(existingSpecial){
          pool = pool.filter(k => { const t = GAME_CONFIG.powers[k].type; return t !== 'special'; });
        }
      }
      if(equipmentPreventDebuffDrops){
        pool = pool.filter(k => (GAME_CONFIG.powers[k]?.type !== 'debuff'));
      }
      pool = pool.filter(k=>k!=='NINE');
      if(!pool.length) return;
      if(!existingSpecial && equipmentSpecialDropRateMultiplier>1){
        const specials = pool.filter(k=>GAME_CONFIG.powers[k]?.type==='special');
        const nonSpecials = pool.filter(k=>GAME_CONFIG.powers[k]?.type!=='special');
        if(specials.length && nonSpecials.length){
          const baseProb = specials.length / pool.length;
          const targetProb = Math.min(1, baseProb * equipmentSpecialDropRateMultiplier);
          if(Math.random()<targetProb){
            type = specials[Math.floor(Math.random()*specials.length)];
          }else{
            type = nonSpecials[Math.floor(Math.random()*nonSpecials.length)];
          }
        }else if(specials.length){
          type = specials[Math.floor(Math.random()*specials.length)];
        }else{
          type = pool[Math.floor(Math.random()*pool.length)];
        }
      }else{
        type = pool[Math.floor(Math.random()*pool.length)];
      }
    }
    const def = GAME_CONFIG.powers[type];
    if(!def) return;
    // 判斷是否為特殊（special）或減益
    const isSpecial = (def.type === 'special');
    const isDebuff = (def.type === 'debuff');
    // 設定基礎速度：特殊偏慢，減益偏快
    let speed = GAME_CONFIG.powerCapsule.fallVy;
    if(isSpecial) speed *= 0.75;
    if(isDebuff) speed *= 1.4;
    // 根據當前天地翻轉狀態決定掉落方向與起始位置
    const horizontal = orientLeft;
    let px = x, py = y;
    if(horizontal){
      // 水平掉落：從右側隨機 y 開始往左移動
      px = 1100 - 40;
      const L = layout();
      // 避免靠近上下邊界，預留 40 像素
      py = L.top + 20 + Math.random() * (700 - 60 - L.top);
    }
    powerups.push({
      x: px,
      y: py,
      w: GAME_CONFIG.powerCapsule.width,
      h: GAME_CONFIG.powerCapsule.height,
      speed: speed,
      horizontal: horizontal,
      type: type,
      isDebuff: isDebuff,
      isSpecial: isSpecial,
      phase: Math.random() * Math.PI * 2
    });
  }

  function applyPower(type){
    const _defC=GAME_CONFIG.powers[type]; if(_defC){ if(_defC.type==='debuff') stats.debuffs++; else if(_defC.type) stats.buffs++; }
    const def=GAME_CONFIG.powers[type]; if(!def) return; const now=performance.now();
    const baseDurationMs=def.durationMs||0;
    let durationMs;
    if(type==='HOLY'){
      durationMs=Math.round(baseDurationMs*equipmentHolyDurationMultiplier);
    }else{
      durationMs=baseDurationMs;
    }
    if(equipmentPowerDurationBonusMs[type]){
      durationMs+=equipmentPowerDurationBonusMs[type];
    }
    const fullLabel = def.label + (def.desc ? `(${def.desc})` : '');
    let promptText='';
    if(def.type==='buff') promptText=`增益：${fullLabel}`;
    else if(def.type==='debuff') promptText=`減益：${fullLabel}`;
    else if(def.type==='special') promptText=`特殊：${fullLabel}`;
    const exist=buffs[type];
    let active=false;
    if(type==='LONG'){ active = exist && exist.stacks && exist.stacks.some(t=>t>now); }
    else active = exist && exist.active && exist.until && exist.until>now;
    if(promptText && !active) showPrompt(promptText);
    // 更新最近取得增益的時間：非減益類型（含特殊）皆視為增益
    if(def.type !== 'debuff'){
      lastBeneficialPickupAt = now;
      nextAutoBeneficialDropAt = now + 10000;
      if(def.type === 'buff') addScore(10);
      else if(def.type === 'special') addScore(50);
      updateHUD();
    }
    // 瞬發特殊增益
    if(def.instant){
      if(type==='PHOENIX'){ // 鳳凰飛過 + 火焰 + 隨機一半消除（Boss只扣1）
        phoenixAnim={x:canvas.width+220,tEnd:now+1200};
        const keep=[]; for(const b of bricks){
          if(Math.random()<0.5){
            if(b.unbreakable){ keep.push(b); continue; }
            if(b.boss){
              b.hp -= 1;
              if(b.hp>0){ keep.push(b);} else { bossKillEffect(b); revealBrickArea(b); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; }
            }
            else {
              revealBrickArea(b); maybeDropFromBrick(b); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++;
            }
            fireBursts.push({x:b.x+b.w/2,y:b.y+b.h/2,life:400+Math.random()*400});
          } else keep.push(b);
        }
        bricks=keep; screenShake=6; playSFX('phoenix'); updateHUD();
        if(isSpecialBossActive()){
          const center=activeBossCenter();
          const impact=center?{x:center.x,y:center.y}:null;
          damageActiveBoss(1,'phoenix',impact);
        }
        if(equipmentPhoenixHeart){
          phoenixHeartGlowUntil=Math.max(phoenixHeartGlowUntil, now+2000);
          const healed=healPlayer(1);
          if(!healed){
            showEquipmentMessage('鳳凰之心閃耀，但 HP 已達上限。','info',2000);
          }
          const pr=paddleRect();
          if(pr){
            spawnParticles(pr.x+pr.w/2, pr.y, '#ffb347', 18, 1.6, 2.6, 2.4);
          }
        }
      } else if(type==='NINE'){ if(nineCatEaten>=3) return; lives=9; nineCatEaten++; updateHUD(); spawnParticles(550,350,'#ffd',40,2.2,3.5,4); beep(880,0.1,0.06); }
      return;
    }
    // 定時類
    if(type==='MEGA'){
      const megaBuff = buffs.MEGA || (buffs.MEGA = { active: false, until: 0, applied: false });
      const sizeMul = GAME_CONFIG.powers.MEGA?.mega?.sizeMul ?? 1;
      if(!megaBuff.applied){
        for(const ball of balls){ ball.r *= sizeMul; }
        megaBuff.applied = true;
      }
    }
    if(durationMs){ if(type!=='LONG'){ const b=buffs[type]||(buffs[type]={active:false,until:0}); b.active=true; b.until=now+durationMs; } }
    if(def.paddleWidthAdd){ buffs.WIDE.active=true; buffs.WIDE.until=now+durationMs; }
    if(def.longPerStackAdd){ const act=buffs.LONG.stacks.filter(t=>t>now); const max=def.stacksMax??2; if(act.length<max){ buffs.LONG.stacks.push(now+durationMs);} else { const earliest=Math.min(...act); const idx=buffs.LONG.stacks.indexOf(earliest); buffs.LONG.stacks[idx]=now+durationMs; } }
    if(def.sticky){ buffs.STICKY.active=true; buffs.STICKY.until=now+durationMs; }
    if(def.multiDuplicate){
      const cap=def.maxBalls??4;
      if(equipmentMultiAlwaysMax){
        ensureBallCount(cap);
      }else if(balls.length<3){
        const desired=Math.min(cap, Math.max(2, balls.length*2 || 2));
        ensureBallCount(desired);
      }
    }
    if(def.speedMul){ buffs.SLOW.active=true; buffs.SLOW.until=now+durationMs; }
    if(def.piercing){
      buffs.PIERCE.active=true;
      buffs.PIERCE.until=now+durationMs;
      for(const b of balls) b.piercing=true;
      if(equipmentPierceGrantPlasma && !applyingPierceLinkedPlasma){
        applyingPierceLinkedPlasma=true;
        try{
          applyPower('PLASMA');
        }finally{
          applyingPierceLinkedPlasma=false;
        }
      }
      if(type==='PIERCE'){
        if(equipmentPierceAlsoMega && !applyingLinkedMega){
          applyingLinkedMega=true;
          try{
            applyPower('MEGA');
          }finally{
            applyingLinkedMega=false;
          }
        }
        if(equipmentPierceAlsoMulti && !applyingLinkedMulti){
          applyingLinkedMulti=true;
          try{
            applyPower('MULTI');
          }finally{
            applyingLinkedMulti=false;
          }
        }
      }
    }
    if(def.oneShotShield){ buffs.SHIELD.active=true; }
    if(def.forcePiercing && def.rampageMs){ buffs.RAMPAGE.active=true; buffs.RAMPAGE.until=now+durationMs; for(const b of balls){ b.rampageUntil=now+def.rampageMs; b.piercing=true; } }
    if(def.globalSpeedMul){ buffs.FAST.active=true; buffs.FAST.until=now+durationMs; if(def.screenShakeOnApply) screenShake=def.screenShakeOnApply; }
    if(def.wavy){ buffs.WAVY.active=true; buffs.WAVY.until=now+durationMs; buffs.WAVY.start=now; }
    if(type==='PLASMA'){ buffs.PLASMA.active=true; buffs.PLASMA.until=now+durationMs; }
    if(type==='FREEZE'){ buffs.FREEZE.active=true; buffs.FREEZE.until=now+durationMs; }
    if(type==='HOLY'){ buffs.HOLY.active=true; buffs.HOLY.until=now+durationMs; }
    if(type==='FIRE'){
      buffs.FIRE.active=true;
      buffs.FIRE.until=now+durationMs;
      fireEnergy=equipmentFireInstantCharge?FIRE_MAX_CHARGE:0;
      updateFireEnergy();
    }
    if(type==='POISON'){
      buffs.POISON.active=true;
      buffs.POISON.until=now+durationMs;
      if(equipmentPoisonAlsoMulti && !applyingLinkedMulti){
        applyingLinkedMulti=true;
        try{
          applyPower('MULTI');
        }finally{
          applyingLinkedMulti=false;
        }
      }
    }
    if(type==='BLINK'){ buffs.BLINK.active=true; buffs.BLINK.until=now+durationMs; }
    if(type==='COMBO'){ buffs.COMBO.active=true; buffs.COMBO.until=now+durationMs; }

    if(type==='TRACK'){
      buffs.TRACK.active=true;
      buffs.TRACK.until=now+durationMs;
      if(equipmentTrackUniqueTargets){
        resetTrackAssignments();
      }
      if(equipmentTrackAlsoMulti && !applyingLinkedMulti){
        applyingLinkedMulti=true;
        try{
          applyPower('MULTI');
        }finally{
          applyingLinkedMulti=false;
        }
      }
    }
    if(type==='MISSILE'){ buffs.MISSILE.active=true; buffs.MISSILE.until=now+durationMs; }
    if(type==='HELL'){
      buffs.HELL.active=true;
      buffs.HELL.until=now+durationMs;
      if(equipmentHellAlsoMulti && !applyingLinkedMulti){
        applyingLinkedMulti=true;
        try{
          applyPower('MULTI');
        }finally{
          applyingLinkedMulti=false;
        }
      }
    }
    if(type==='MEGA'){
      buffs.MEGA.active=true;
      buffs.MEGA.until=now+durationMs;
      if(equipmentMegaAlsoMulti && !applyingLinkedMulti){
        applyingLinkedMulti=true;
        try{
          applyPower('MULTI');
        }finally{
          applyingLinkedMulti=false;
        }
      }
    }
    if(type==='CHAIN'){ buffs.CHAIN.active=true; buffs.CHAIN.until=now+durationMs; }
    if(type==='NARROW'){ buffs.NARROW.active=true; buffs.NARROW.until=now+durationMs; }
    if(type==='HOLE'){ buffs.HOLE.active=true; buffs.HOLE.until=now+durationMs; showComboNotice('注意看! 你破洞啦!',5000,3000); }
    if(type==='PADSPIN'){ buffs.PADSPIN.active=true; buffs.PADSPIN.until=now+durationMs; buffs.PADSPIN.start=now; }
    if(type==='PADBOOM'){ buffs.PADBOOM.active=true; buffs.PADBOOM.explodeAt=now+(def.explosion?.flashMs||3000); buffs.PADBOOM.returnAt=buffs.PADBOOM.explodeAt+(def.explosion?.goneMs||3000); buffs.PADBOOM.until=buffs.PADBOOM.returnAt; buffs.PADBOOM.exploded=false; }
    if(type==='GATLING'){ buffs.GATLING.active=true; buffs.GATLING.until=now+durationMs; const g=GAME_CONFIG.powers.GATLING.gatling; const pr=paddleRect(); gatling={x:pr.x+pr.w/2,y:pr.y,chargeUntil:now+(g.chargeMs||3000),fireStart:now+(g.chargeMs||3000),fireUntil:now+(g.chargeMs||3000)+(g.fireMs||8000),lastShot:0,angle:0}; }
    if(type==='FLIP'){
      // 天地翻轉：延遲啟用並紀錄起止時間。啟用及結束均由 update 中判斷。
      const delay = 2000;
      // 初始化 FLIP buff 狀態
      if(!buffs.FLIP) buffs.FLIP = {};
      const f = buffs.FLIP;
      f.pending = true;
      f.active = false;
      f.startAt = now + delay;
      f.endAt = f.startAt + durationMs;
      // 使用 until 顯示剩餘時間條
      f.until = f.endAt;
      return;
    }
    if(type==='GODSPEED'){
      buffs.GODSPEED.active=true;
      buffs.GODSPEED.until=now+durationMs;
      if(equipmentGodspeedAlsoPierce && !applyingGodspeedLinkedPierce){
        applyingGodspeedLinkedPierce=true;
        try{
          applyPower('PIERCE');
        }finally{
          applyingGodspeedLinkedPierce=false;
        }
      }
    }
    if(type==='LASER'){ buffs.LASER.active=true; buffs.LASER.until=now+durationMs; buffs.LASER.lastShot=0; }
    if(type==='SWORD'){ buffs.SWORD.active=true; buffs.SWORD.until=now+durationMs; swordFireStart=0; }
    if(type==='STORM'){ buffs.STORM.active=true; buffs.STORM.until=now+durationMs; const pr=paddleRect(); stormTurret={x:pr.x+pr.w/2,y:pr.y,chargeUntil:now+3000,fireAt:now+4000,shots:Math.max(0,21-lives),lastShot:0}; }
    if(type==='BLACKHOLE'){
      buffs.BLACKHOLE.active=true;
      buffs.BLACKHOLE.until=now+durationMs;
      buffs.BLACKHOLE.deaths=0;
      if(equipmentBlackholeInstantStrike){
        triggerBlackholeStrike(now,{deactivate:false});
      }
    }
    if(type==='ANNIHIL'){ buffs.ANNIHIL.active=true; buffs.ANNIHIL.start=now; buffs.ANNIHIL.next=now+1000; buffs.ANNIHIL.until=0; }

    updateBuffBadges();
  }

  function drawCoin(c){
    const def = COIN_DEFS[c.type] || COIN_DEFS.small;
    c.phase = (c.phase || 0) + 0.02;
    const cx = (c.x + c.w/2)*scaleX;
    const cy = (c.y + c.h/2)*scaleY;
    const avgScale = (scaleX + scaleY)/2;
    const radius = (c.w/2) * avgScale;
    const palette = def.palette || COIN_DEFS.small.palette;
    ctx.save();
    const grad = ctx.createRadialGradient(cx, cy, radius*0.18, cx, cy, radius);
    grad.addColorStop(0, palette.inner || '#f5faff');
    grad.addColorStop(0.5, palette.mid || '#d0e2ff');
    grad.addColorStop(1, palette.outer || '#7b8fbf');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = Math.max(1, radius*0.18);
    ctx.strokeStyle = palette.rim || '#eef5ff';
    ctx.stroke();
    const glow = 0.35 + 0.25*Math.sin(c.phase || 0);
    ctx.fillStyle = `rgba(255,255,255,${glow})`;
    ctx.beginPath();
    ctx.ellipse(cx - radius*0.3, cy - radius*0.3, radius*0.35, radius*0.25, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.fillStyle = palette.text || '#102040';
    ctx.font = `${Math.max(10, Math.round(radius*1.05))}px 'Playfair Display', serif`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText(def.label || `+${c.value}`, cx, cy + radius*0.06);
    ctx.restore();
  }

  function drawPower(p){ const base=p.isDebuff?getVar('--debuff'):getVar('--power'); const gold1='#f6d365', gold2='#fda085'; const color = p.isSpecial ? gold1 : base; const x=p.x*scaleX, y=p.y*scaleY, w=p.w*scaleX, h=p.h*scaleY; const wobble=Math.sin(p.phase)*1.5; p.phase+=0.04;
    ctx.save(); ctx.translate(0,wobble); const grd=ctx.createLinearGradient(x,y,x,y+h); grd.addColorStop(0,color); grd.addColorStop(1,p.isSpecial?gold2:(p.isDebuff?'#a33':'#3a56a8')); ctx.fillStyle=grd; roundedRect(x,y,w,h,8); ctx.fill(); ctx.strokeStyle=p.isSpecial?'rgba(255,220,150,.8)':'rgba(255,255,255,.25)'; ctx.stroke();
    ctx.fillStyle=p.isSpecial?'#402a00':'#fff'; ctx.font=`${Math.max(10,Math.round(12*scaleY))}px ui-monospace, monospace`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.type[0], x+w/2, y+h/2+0.5); ctx.restore(); }

  function updateFireEnergy(){
    if(!fireEnergyEl) return;
    if(buffs.FIRE?.active || fireEnergy>0){
      fireEnergyEl.style.display='inline-block';
      fireEnergyEl.textContent=`🔥${fireEnergy}`;
    }else{
      fireEnergyEl.style.display='none';
    }
  }

  function updateHUD(){
    // 更新分數、關卡、生命與愛心顯示
    scoreEl.textContent = Math.max(0 | score, 0);
    // 顯示目前關卡數（level 元素）和總關卡數（totalLevels 元素）
    levelEl.textContent = level;
    if (totalLevelsEl) totalLevelsEl.textContent = GAME_CONFIG.totalLevels;
    if(level>maxLevelReached){
      unlockLevel(level);
    }
    if (levelJumpSel){
      if(typeof updateLevelJumpAvailability==='function') updateLevelJumpAvailability();
      levelJumpSel.value = String(level);
      if(typeof refreshLevelJumpVisual==='function') refreshLevelJumpVisual();
    }
    // 更新生命文字與愛心
    livesEl.textContent = lives;
    if (heartsEl) {
      const activeBursts = Array.from(heartsEl.querySelectorAll('.life-blood-burst'));
      heartsEl.innerHTML = '';
      for(const burst of activeBursts){ heartsEl.appendChild(burst); }
      // 依據生命數量新增愛心圖示
      const iconDef = (window.currentSkin && window.currentSkin.lifeIcon) || '❤️';
      for (let i = 0; i < lives; i++) {
        const span = document.createElement('span');
        if (typeof iconDef === 'string' && iconDef.trim().startsWith('<')) {
          span.innerHTML = iconDef.trim();
          const svg = span.querySelector('svg');
          if (svg) {
            if (!svg.hasAttribute('xmlns')) {
              svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            }
            svg.setAttribute('focusable', 'false');
            svg.setAttribute('aria-hidden', 'true');
          }
        } else {
          span.textContent = iconDef;
        }
        span.className = 'life-icon';
        heartsEl.appendChild(span);
      }
      // 過多生命時採用 compact 風格
      heartsEl.classList.toggle('compact', lives > 5);
    }
    if (catsEl) {
      catsEl.innerHTML = '';
      for (let i = 0; i < nineCatEaten; i++) {
        const span = document.createElement('span');
        span.textContent = '🐱';
        span.className = 'cat-icon';
        catsEl.appendChild(span);
      }
      catsEl.style.display = nineCatEaten ? 'flex' : 'none';
    }
    if (silverCoinsEl) {
      silverCoinsEl.textContent = Math.max(0, Math.floor(silverCoins));
    }
    if (storeSilverCoinsEl) {
      storeSilverCoinsEl.textContent = Math.max(0, Math.floor(silverCoins));
    }
    updateFireEnergy();
  }
  window.updateHUD = updateHUD;
  function showCenter(t, txt){
    noteTitle.textContent = t;
    noteText.innerHTML = txt || '';
    centerNote.style.display = 'flex';
  }
  function showGameOver(){
    paused = true; running = false; gameOver = true;
    hideCenter();
    resetCombo();
    const fs2 = document.getElementById('finalScore2'); if(fs2) fs2.textContent = String(Math.max(0|score,0));
    const so  = document.getElementById('statsOver'); if(so)  so.innerHTML = renderStatsHtml();
    gameover?.classList.add('show');
    playSFX('lose');
  }
  function hideCenter(){ centerNote.style.display='none'; }

  function resetGame(load=false){ diff=getDiff(); level=load?level:1; score=load?score:0; lives=load?lives:9; nineCatEaten=load?nineCatEaten:0; scoreUploaded=false; finalVictorySequence=null; if(!load) clearEquipmentSlots(); updateHUD(); initBricks(); resetBalls(); paused=true; running=false; resetCombo();
    bossNineCatDrops.clear();
    stats={catches:0,buffs:0,debuffs:0,eliteKills:0,bossKills:0,lifeStart:0,fastestDeath:Infinity,longestLife:0,livesUsed:0,maxCombo:0};
    for(const k of Object.keys(buffs)){
      if(k!=='LONG'){
        buffs[k].active=false;
        buffs[k].until=0;
      }
    }
    // 重置 LONG buff stacks
    buffs.LONG.stacks=[];
    powerups.length=0;
    coins.length=0;
    particles.length=0;
    plasmas.length=0;
    plasmaChains.length=0;
    holyFlashes.length=0;
    phoenixAnim=null;
    fireBursts.length=0;
    fireExplosions.length=0;
    demonBloodEffects.length=0;
    demonAbyssBricks.length=0;
    demonAbyssExplosions.length=0;
    starProjectiles.length=0;
    moonProjectiles.length=0;
    clearActivePlagueTimers();
    solarBurstNextAt=0;
    if(demonAttackActive && demonAttackActive.type==='abyssShatter'){
      demonAttackActive=null;
      demonAttackNextAt=0;
    }
    forceReleaseBladeHellBall();
    demonBladeHellTelegraphs.length=0;
    demonBladeHellSlashes.length=0;
    demonBladeHellCounterSlashes.length=0;
    demonBladeHellCounterstrike=null;
    demonBladeHellBallCapture=null;
    demonBladeHellPlatformGlow=0;
    swords.length=0;
    swordFireStart=0;
    nextSwordFire=0;
    stormTurret=null;
    gatling=null;
    gatlingBullets.length=0;
    missiles.length=0;
    blackHoles.length=0;
    laserBeams.length=0;
    laserImpacts.length=0;
    bombDevilQueues.length=0;
    bombDevilBossQueues.length=0;
    bombDevilRowCooldown.clear();
    bombDevilActiveUntil=0;
    bombDevilIntervalMs=BOMB_DEVIL_DEFAULTS.intervalMs;
    fireScatterQueue.length=0;
    hostileBeams.length=0;
    hostileArcs.length=0;
    hostileColumns.length=0;
    hazardClouds.length=0;
    lockBoxes.length=0;
    annihilSparks.length=0;
    flipDecoy=null;
    fireEnergy=0; updateFireEnergy();
    // 回復天地翻轉狀態及暫停計時器
    orientLeft=false;
    pauseStartedAt=null;
    // 初始化增益掉落計時
    lastBeneficialPickupAt = performance.now();
    nextAutoBeneficialDropAt = lastBeneficialPickupAt + 10000;
    updateBuffBadges();
    computePaddleWidth();
    paddle.x = 1100/2 - paddle.w/2;
    // 確保 paddle 在水平方向時位於底部
    paddle.y = 700 - 50;
    showCenter('按 Space 或點畫面開始','用 ←/→ 或 A/D 移動；手指拖曳畫面也可。');
    countdownShow=0;
    scheduleNextSkyDrop();
  }

  // === 存讀檔（含音效/BGM與影像選擇） ===
  function saveProgress(){ try{
      const data={level,score,lives,difficulty:difficultySel.value, imageChoice, soundsOn, bgmOn, bgmVol: parseFloat(bgmVol.value), maxLevelReached, equipmentSlots: exportEquipmentSlots()};
      localStorage.setItem('breakout_save_v_final_cfg', JSON.stringify(data)); alert('已存檔！');
    }catch(e){ alert('存檔失敗：'+e); } }
  function loadProgress(){ try{ const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4'); if(!raw){ alert('沒有存檔'); return; } const data=JSON.parse(raw);
      difficultySel.value=data.difficulty||'normal'; level=data.level||1; score=data.score||0; lives=typeof data.lives==='number'?data.lives:9; if(Array.isArray(data.imageChoice)) imageChoice=data.imageChoice;
      const savedMaxLevel=parseInt(data.maxLevelReached,10);
      if(!Number.isNaN(savedMaxLevel)){
        maxLevelReached=Math.max(1, Math.min(GAME_CONFIG.totalLevels, savedMaxLevel));
      }
      maxLevelReached=Math.max(maxLevelReached, level);
      try{ localStorage.setItem('breakout_max_level', String(maxLevelReached)); }catch(e){}
      if(typeof updateLevelJumpAvailability==='function') updateLevelJumpAvailability();
      if(Array.isArray(data.equipmentSlots)) importEquipmentSlots(data.equipmentSlots); else importEquipmentSlots([]);
      soundsOn=!!data.soundsOn; soundBtn.textContent=`音效：${soundsOn?'開':'關'}`;
      if(typeof data.bgmOn==='boolean'){ bgmOn=data.bgmOn; } if(typeof data.bgmVol==='number'){ bgmVol.value=String(data.bgmVol); if(bgmGain) bgmGain.gain.value=data.bgmVol; localStorage.setItem('bgm_vol', data.bgmVol); }
      resetGame(true); updateHUD(); alert(`已讀檔：等級 ${level}，分數 ${score}，生命 ${lives}`);}catch(e){ alert('讀檔失敗：'+e); } }
  function clearSave(){ localStorage.removeItem('breakout_save_v_final_cfg'); localStorage.removeItem('gallery_unlocks'); localStorage.removeItem('dialog_unlocks'); localStorage.removeItem('breakout_max_level'); maxLevelReached=1; if(typeof updateLevelJumpAvailability==='function') updateLevelJumpAvailability(); alert('已清除存檔'); }

  // === 輸入（含觸控） ===
  let keyL=false, keyR=false; let touchActive=false;
  window.addEventListener('keydown',(e)=>{ if(gameOver){ e.preventDefault(); return; }
    if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=true;
    if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=true;
    if(e.code==='Space'){ // 開始 / 暫停 / 倒數
      if(!running){ startGameWithCountdown(); } else { togglePause(); }
      return;
    }
    if((e.code==='ArrowUp' || e.key==='Shift') && !paused && running){
      let released=false;
      for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy = -Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
    if(e.key==='r'||e.key==='R'){ resetGame(); }
    if(e.key==='f'||e.key==='F'){ toggleFullscreen(); }
  });
  window.addEventListener('keyup',(e)=>{ if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=false; if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=false; });
  canvas.addEventListener('mousemove',(e)=>{ const rect=canvas.getBoundingClientRect(); if(performance.now()<=paddleStunUntil) return; if(!orientLeft){ const x=(e.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(e.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } });
  canvas.addEventListener('click',()=>{ if(gameOver){ return; }
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  });
  canvas.addEventListener('touchstart',(e)=>{ if(gameOver){ e.preventDefault(); return; } touchActive=true; 
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  }, {passive:false});
  canvas.addEventListener('touchmove',(e)=>{ if(!touchActive) return; if(performance.now()<=paddleStunUntil) return; const t=e.touches[0]; const rect=canvas.getBoundingClientRect(); if(!orientLeft){ const x=(t.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); } else { const y=(t.clientY-rect.top)*(700/rect.height); paddle.y=Math.max(0, Math.min(700-paddle.w, y - paddle.w/2)); } }, {passive:true});
  canvas.addEventListener('touchend',()=>{ touchActive=false; }, {passive:true});
  pauseBtn.addEventListener('click',()=>togglePause()); resetBtn.addEventListener('click',()=>resetGame()); fsBtn.addEventListener('click',()=>toggleFullscreen());
  soundBtn.addEventListener('click',()=>{ soundsOn=!soundsOn; localStorage.setItem('sfx_on', soundsOn?'1':'0'); soundBtn.textContent=`音效：${soundsOn?'開':'關'}`; ensureAudio(); audioCtx?.resume?.(); beep(880,0.06,0.05); });
  difficultySel.addEventListener('change',()=>{ resetGame(); });
  if(ledStyleSel){ ledStyleSel.value = ledStyle; ledStyleSel.addEventListener('change', ()=>{ ledStyle = ledStyleSel.value; localStorage.setItem('led_style', ledStyle); }); }
  saveBtn.addEventListener('click',saveProgress); loadBtn.addEventListener('click',loadProgress); clearSaveBtn.addEventListener('click',clearSave);
  if(levelJumpSel){
    const updateLevelJumpVisual = ()=>{
      const current=levelJumpSel.options[levelJumpSel.selectedIndex]||null;
      const isBoss=!!current && current.classList.contains('boss-level');
      levelJumpSel.classList.toggle('boss-selected', isBoss);
    };
    const updateLevelJumpAccess = ()=>{
      const options=Array.from(levelJumpSel.options);
      for(const option of options){
        option.disabled=false;
        option.classList.remove('locked');
        option.dataset.locked = 'false';
        option.style.opacity = '1';
      }
      const currentVal=parseInt(levelJumpSel.value,10);
      if(Number.isNaN(currentVal)){
        levelJumpSel.value=String(Math.max(1, Math.min(GAME_CONFIG.totalLevels, level)));
      }
      updateLevelJumpVisual();
    };
    refreshLevelJumpVisual = updateLevelJumpVisual;
    updateLevelJumpAvailability = updateLevelJumpAccess;
    const populateLevelJumpOptions = ()=>{
      levelJumpSel.innerHTML = '';
      for(let i=1;i<=GAME_CONFIG.totalLevels;i++){
        const option=document.createElement('option');
        const isBoss = i%5===0;
        option.value=String(i);
        option.textContent=isBoss ? `第 ${i} 關 ★ Boss` : `第 ${i} 關`;
        if(isBoss){
          option.classList.add('boss-level');
        }
        levelJumpSel.appendChild(option);
      }
      updateLevelJumpAccess();
    };
    populateLevelJumpOptions();
    levelJumpSel.value = String(level);
    updateLevelJumpVisual();
    levelJumpSel.addEventListener('change',()=>{
      updateLevelJumpVisual();
      const target=parseInt(levelJumpSel.value,10);
      if(Number.isNaN(target)) return;
      level = Math.max(1, Math.min(GAME_CONFIG.totalLevels, target));
      gameOver = false;
      gameover?.classList.remove('show');
      paused = true;
      running = false;
      resetCombo();
      initBricks();
      resetBalls();
      applyBGMThemeForLevel();
      updateHUD();
      showCenter(`暫時跳至第 ${level} 關`,`按 Space 或點畫面開始`);
    });
  }
  tutorBtn.addEventListener('click', ()=> toggleHelp('tutor'));
  effectsBtn.addEventListener('click', ()=> toggleHelp('effects'));
  againBtn.addEventListener('click', ()=>{ win.classList.remove('show'); resetGame(); });

  // BGM UI
  bgmBtn.addEventListener('click', ()=>{
    bgmOn=!bgmOn; localStorage.setItem('bgm_on', bgmOn?'1':'0'); bgmBtn.textContent= bgmOn?'開':'關';
    if(bgmOn){ ensureAudio(); startBGM(); } else { stopBGM(); }
  });
  bgmVol.addEventListener('input', ()=>{
    ensureAudio(); const v=parseFloat(bgmVol.value||'0.5'); if(bgmGain) bgmGain.gain.value=v; localStorage.setItem('bgm_vol', v);
  });

  function togglePause(){
    if(!running){ startGameWithCountdown(); return; }
    paused = !paused;
    if(paused){
      // 記錄暫停開始時間，並顯示暫停訊息
      onPauseStart();
      showCenter('已暫停','按 Space / 點畫面繼續');
    } else {
      // 恢復前先調整計時器，再進入倒數
      onResumeFromPause();
      startCountdown();
    }
  }

  function startGameWithCountdown(){
    onResumeFromPause();
    running=true; paused=true; hideCenter();
    if(pendingUnlockNotice){ showComboNotice(pendingUnlockNotice); pendingUnlockNotice=null; }
    ensureAudio(); audioCtx?.resume?.();
    // 音效與BGM設定載入
    // 從 localStorage 載入音效與 BGM 設定
    soundsOn = (localStorage.getItem('sfx_on')||'0') === '1';
    // 同步舊版按鈕與新 UI 複選框
    soundBtn.textContent = `音效：${soundsOn?'開':'關'}`;
    if (sfxOnEl) sfxOnEl.checked = soundsOn;
    bgmOn = (localStorage.getItem('bgm_on')||'0') === '1';
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.7');
    bgmVol.value = String(v);
    ensureAudio(); if (bgmGain) bgmGain.gain.value = v;
    bgmBtn.textContent = bgmOn ? '開' : '關';
    if (bgmOnEl) bgmOnEl.checked = bgmOn;
    if (bgmOn) startBGM(); applyBGMThemeForLevel();
    startCountdown();
  }

  // === 教學/效果說明 ===
  let helpMode=null; // 'tutor' | 'effects' | null
  function toggleHelp(mode){
    if(helpMode===mode){
      // 關閉說明，恢復遊戲
      helpMode=null;
      hideCenter();
      if(menusOpen()) return;
      if(running){
        onResumeFromPause();
        startCountdown();
      } else {
        startGameWithCountdown();
      }
      return;
    }
    helpMode = mode;
    paused = true;
    // 打開說明時開始暫停計時
    onPauseStart();
    if(mode==='tutor'){
      showCenter('教學（按鈕再按一次關閉）', `
        <div class="cols">
          <div>
            <strong>操作</strong><br>
            電腦：<kbd>←</kbd>/<kbd>→</kbd> 或 <kbd>A</kbd>/<kbd>D</kbd> 移動；<kbd>Space</kbd> 開始/暫停。<br>
            釋放黏住的球：<kbd>↑</kbd> 或 <kbd>Shift</kbd>。<br>
            手機：手指拖曳擋板位置即可。<br>
            全螢幕：<kbd>F</kbd>。
          </div>
          <div>
            <strong>目標</strong><br>
            打破所有可破壞磚進入下一關。每 5 關有 Boss（只扣血不會被秒殺）。<br>
            第 1~10 關與 11~20 關會分別顯示同組照片的不同張，20 關結束播放通關畫面。
          </div>
          <div>
            <strong>存讀檔</strong><br>
            可儲存關卡/分數/生命、難度、照片選擇、音效/BGM 設定。
          </div>
        </div>`);
    }else{
      // 效果說明：分類輸出增益、特殊增益、減益與特殊磚
      let html = '<div class="cols">';
      // 增益（buff）
      html += '<div><strong>增益</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'buff'){
          const label = p.label + (p.desc ? `(${p.desc})` : '');
          html += `${badgeIcon(k)} <em>${k}</em>：${label}<br>`;
        }
      }
      html += '</div>';
      // 特殊增益
      html += '<div><strong>特殊增益</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'special'){
          const label = p.label + (p.desc ? `(${p.desc})` : '');
          if(unlockedSpecials.has(k)){
            html += `${badgeIcon(k)} <em>${k}</em>：${label}<br>`;
          }else{
            const req = SPECIAL_UNLOCK_LEVELS[k];
            const hint = req ? `<small class="unlockHint">第${req}關解鎖</small>` : '';
            html += `<span class="sealed">${badgeIcon(k)} <em>${k}</em>：${label}${hint}</span><br>`;
          }
        }
      }
      html += '</div>';
      // 減益（debuff）
      html += '<div><strong>減益</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p = GAME_CONFIG.powers[k];
        if(p.type === 'debuff'){
          const label = p.label + (p.desc ? `(${p.desc})` : '');
          html += `${badgeIcon(k)} <em>${k}</em>：${label}<br>`;
        }
      }
      html += '</div>';
      // 特殊磚說明
      html += '<div><strong>特殊磚</strong><br>';
      html += '不可破壞磚：只反彈不會壞；<br>';
      html += '移動磚：水平移動；<br>';
      html += '強反彈磚：反彈時加速更強；<br>';
      html += 'Boss磚：大尺寸、只扣血，爆炸/神聖/鳳凰也不會被秒殺。';
      html += '</div>';
      html += '</div>';
      showCenter('效果說明（按鈕再按一次關閉）', html);
    }
  }

  /* ---------------- HUD 互動（移植自 index_skin.html） ---------------- */
  (function(){
    const hud = document.querySelector('.hud');
    const sentinel = document.querySelector('.hud-sentinel');
    const sndBtn = document.getElementById('sndBtn');
    const optBtn = document.getElementById('optBtn');
    const soundMenu = document.getElementById('soundMenu');
    const optMenu = document.getElementById('optMenu');
    let scheduled = false;
    function schedule(){ if(scheduled) return; scheduled = true; requestAnimationFrame(() => { scheduled = false; placeHUD(); }); }
    const mobileHudQuery = window.matchMedia('(max-width: 640px)');
    if(mobileHudQuery && typeof mobileHudQuery.addEventListener === 'function'){
      mobileHudQuery.addEventListener('change', schedule, {passive:true});
    }else if(mobileHudQuery && typeof mobileHudQuery.addListener === 'function'){
      mobileHudQuery.addListener(() => schedule());
    }
    function placeHUD(){
      if(!hud) return;
      const hudRect = hud.getBoundingClientRect();
      const styles = window.getComputedStyle(hud);
      const marginBottom = parseFloat(styles.marginBottom || '0');
      const baseBottom = Math.ceil(hudRect.height + marginBottom);
      let bottom = baseBottom;
      if(!mobileHudQuery.matches && sentinel){
        const sentinelRect = sentinel.getBoundingClientRect();
        bottom = Math.max(bottom, Math.ceil(sentinelRect.top));
      }
      const gap = Math.max(0, bottom + 6);
      document.documentElement.style.setProperty('--hudBottom', gap + 'px');
    }
    function toggle(menu, btn){
      const show = !menu.classList.contains('show');
      [soundMenu, optMenu].forEach(m => m.classList.remove('show'));
      document.querySelectorAll('[aria-expanded="true"]').forEach(b => b.setAttribute('aria-expanded', 'false'));
      if(show){
        menu.classList.add('show');
        btn.setAttribute('aria-expanded', 'true');
      }
      // Pause game when any menu is open; resume when none open
      const anyOpen = menusOpen();
      if (typeof window.__setMenuPause === 'function') window.__setMenuPause(anyOpen);
      schedule();
    }
    if(sndBtn) sndBtn.addEventListener('click', (e) => { e.stopPropagation(); toggle(soundMenu, sndBtn); }, {passive:true});
    if(optBtn) optBtn.addEventListener('click', (e) => { e.stopPropagation(); toggle(optMenu, optBtn); }, {passive:true});
    document.addEventListener('click', (e) => {
      if(!e.target.closest('.menu') && !e.target.closest('#optBtn') && !e.target.closest('#sndBtn')){
        const anyOpen = soundMenu.classList.contains('show') || optMenu.classList.contains('show');
        if(anyOpen){
          [soundMenu, optMenu].forEach(m => m.classList.remove('show'));
          if(!menusOpen() && typeof window.__setMenuPause === 'function') window.__setMenuPause(false);
          schedule();
        }
      }
    }, {passive:true});
    ['resize','orientationchange'].forEach(ev => window.addEventListener(ev, schedule, {passive:true}));
    if(document.fonts && document.fonts.ready){ document.fonts.ready.then(schedule); }
    schedule();
  })();

  // === 全螢幕 ===
  async function toggleFullscreen(){
    const elem = document.documentElement;
    try{
      if(!document.fullscreenElement){
        await elem.requestFullscreen();
      }else{
        await document.exitFullscreen();
      }
    }catch(e){
      console.warn('Fullscreen failed:', e);
    }
  }

  // === 擋板寬度 ===
  function desiredPaddleWidth(){
    const now=performance.now();
    buffs.LONG.stacks=buffs.LONG.stacks.filter(t=>t>now);
    const longStacks=Math.min(GAME_CONFIG.powers.LONG.stacksMax, buffs.LONG.stacks.length);
    const addLong=longStacks*(GAME_CONFIG.powers.LONG.longPerStackAdd||0);
    const addWide=(buffs.WIDE.active?(GAME_CONFIG.powers.WIDE.paddleWidthAdd||0):0);
    const base=getDiff().paddleBaseW;
    let width=Math.min(GAME_CONFIG.caps.paddleMaxW, base+addWide+addLong);
    if(buffs.NARROW?.active) width = Math.max(60, width*0.5);
    return width;
  }

  function computePaddleWidth(){
    let desired = desiredPaddleWidth();
    const center=paddle.x+paddle.w/2;
    const reaperCap=Math.max(0, desired - REAPER_PADDLE_MIN_WIDTH);
    if(reaperPaddlePenalty>reaperCap){ reaperPaddlePenalty = reaperCap; }
    let widthAfterReaper=Math.max(REAPER_PADDLE_MIN_WIDTH, desired - reaperPaddlePenalty);
    const penaltyCap=Math.max(0, widthAfterReaper - SPACE_BOSS_PADDLE_MIN_WIDTH);
    if(spaceBossPaddlePenalty>penaltyCap){ spaceBossPaddlePenalty = penaltyCap; }
    let newW=Math.max(SPACE_BOSS_PADDLE_MIN_WIDTH, widthAfterReaper - spaceBossPaddlePenalty);
    paddle.w=newW;
    paddle.x=Math.max(0, Math.min(1100-paddle.w, center - paddle.w/2));
  }

  // 擋板在不同朝向下的實際矩形
  function paddleRect(){
    const now = performance.now();
    if(now < paddleGoneUntil){ return {x:-1000,y:-1000,w:0,h:0}; }
    // 橫向：x,y,w,h；縱向：以 h 為厚度、w 為長度
    if(!orientLeft){
      return {x:paddle.x, y:paddle.y, w:paddle.w, h:paddle.h};
    }else{
      // 左側：固定靠左 40px
      const thick = paddle.h;
      const len = paddle.w;
      const x = 40; // 與牆距
      return {x:x, y:Math.max(0, Math.min(700-len, paddle.y)), w:thick, h:len};
    }
  }

  function getPaddleTarget(pr=null){
    const rect = pr || paddleRect();
    let targetX = rect.x + rect.w/2;
    let targetY = rect.y + rect.h/2;
    if(rect.w<=0 || rect.h<=0){
      targetX = flipDecoy?.x != null ? flipDecoy.x + (flipDecoy.w ?? paddle.w)/2 : 1100/2;
      targetY = flipDecoy?.y != null ? flipDecoy.y + (flipDecoy.h ?? paddle.h)/2 : 700 - 50;
    }
    if(flipDecoy?.active){
      const w = flipDecoy.w ?? paddle.w;
      const h = flipDecoy.h ?? paddle.h;
      targetX = flipDecoy.x + w/2;
      targetY = flipDecoy.y + h/2;
    }
    return {rect, x:targetX, y:targetY};
  }
  // === 背景裝飾 & LED 燈條 ===
  function ledColor(){
    if(buffs.GODSPEED.active) return '#ffe066';
    if(buffs.HOLY.active) return '#ffe08a';
    if(buffs.HELL.active) return '#a08cff';
    if(buffs.PLASMA.active) return '#9fe8ff';
    if(buffs.FREEZE.active) return '#cfe9ff';
    if(buffs.RAMPAGE.active || buffs.PIERCE.active || buffs.TRACK.active) return '#7fd8ff';
    if(buffs.FAST.active) return '#ffb37a';
    if(buffs.WAVY.active) return '#ba8fff';
    const led = window.currentSkin && window.currentSkin.canvas && window.currentSkin.canvas.effects && window.currentSkin.canvas.effects.ledStrip;
    if(led){
      const hi = led.hi || window.currentSkin.canvas.hi || [255,255,255];
      const lo = led.lo || window.currentSkin.canvas.base || [92,136,255];
      const period = led.period || window.currentSkin.canvas.period || 2000;
      const t = performance.now();
      const ph = (t % period) / period;
      const blend = 0.5 + 0.5*Math.sin(ph*2*Math.PI);
      const rgb = hi.map((h,i)=>Math.round(h*blend + (lo[i]||0)*(1-blend)));
      return '#' + rgb.map(v=>{const h=v.toString(16);return h.length===1?'0'+h:h;}).join('');
    }
    // Fallback colour when no special buff is active.  If a skin is
    // currently selected and defines a base colour, derive the border
    // colour from it; otherwise revert to the original blue tint.
    if (window.currentSkin && window.currentSkin.canvas && Array.isArray(window.currentSkin.canvas.base)) {
      const arr = window.currentSkin.canvas.base;
      // Convert RGB triplet to a hex string.  Values are clamped to 0–255.
      const hex = '#' + arr.map((v) => {
        const n = Math.max(0, Math.min(255, Math.round(v)));
        const h = n.toString(16);
        return h.length === 1 ? '0' + h : h;
      }).join('');
      return hex;
    }
    return '#8fb3ff';
  }

  function drawBGDecor(now){ const w=canvas.width,h=canvas.height; bgTime+=0.003;
    const isCyborg = window.currentSkin && window.currentSkin.cssSkin === '科技．賽博格綠';
    const isPhantom = window.currentSkin && window.currentSkin.cssSkin === '科技．魅影幻彩';
    if(isCyborg){
      ctx.save();
      const bg=ctx.createLinearGradient(0,0,0,h); bg.addColorStop(0,'#00140a'); bg.addColorStop(1,'#000b08'); ctx.fillStyle=bg; ctx.fillRect(0,0,w,h);
      const step=40; const offX=(bgTime*20)%step, offY=(bgTime*15)%step; ctx.strokeStyle='rgba(0,255,150,0.15)'; ctx.lineWidth=1;
      for(let x=-step;x<w+step;x+=step){ const xx=x+offX; ctx.beginPath(); ctx.moveTo(xx,0); ctx.lineTo(xx,h); ctx.stroke(); }
      for(let y=-step;y<h+step;y+=step){ const yy=y+offY; ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(w,yy); ctx.stroke(); }
      ctx.fillStyle='rgba(0,255,150,0.15)';
      for(let x=-step;x<w+step;x+=step){ const xx=x+offX; for(let y=-step;y<h+step;y+=step){ const yy=y+offY; ctx.beginPath(); ctx.arc(xx,yy,1.2,0,Math.PI*2); ctx.fill(); } }
      const glow=ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h)*0.7); glow.addColorStop(0,'rgba(0,255,150,0.12)'); glow.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=glow; ctx.fillRect(0,0,w,h);
      ctx.restore();
      if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    } else if(isPhantom){
      ctx.save();
      const grad=ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h));
      const shift=(Math.sin(bgTime*0.4)+1)/2;
      grad.addColorStop(0,`rgba(60,0,90,${0.55+0.25*shift})`);
      grad.addColorStop(1,'#000');
      ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
      ctx.globalCompositeOperation='lighter';
      const cols=['#ff66ff','#ffb366','#fff466','#66ffb3','#66d1ff','#6666ff','#cc66ff'];
      for(let i=0;i<cols.length;i++){
        ctx.save();
        const ang=i/cols.length*Math.PI*2+bgTime*0.2;
        const x=w/2+Math.cos(ang)*w;
        const y=h/2+Math.sin(ang)*h;
        const beam=ctx.createLinearGradient(w/2,h/2,x,y);
        beam.addColorStop(0,'rgba(0,0,0,0)');
        beam.addColorStop(1,cols[i]);
        ctx.strokeStyle=beam; ctx.globalAlpha=0.25; ctx.lineWidth=60;
        ctx.beginPath(); ctx.moveTo(w/2,h/2); ctx.lineTo(x,y); ctx.stroke();
        ctx.restore();
      }
      ctx.globalCompositeOperation='source-over';
      ctx.restore();
      if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    } else {
      ctx.save(); ctx.globalAlpha=0.12; ctx.translate(Math.sin(bgTime)*8, Math.cos(bgTime*0.7)*6); const step=40;

      for(let x=0;x<w;x+=step){ ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(x,0,1,h);} for(let y=0;y<h;y+=step){ ctx.fillStyle='rgba(255,255,255,.025)'; ctx.fillRect(0,y,w,1);} ctx.restore();
      const grad=ctx.createRadialGradient(w/2,h*0.2,0,w/2,h*0.5,Math.max(w,h)); grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
      if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }
    }

    // 鳳凰火焰殘留
    for(let i=fireBursts.length-1;i>=0;i--){ const f=fireBursts[i]; f.life-=16; if(f.life<=0){ fireBursts.splice(i,1); continue; } const a=Math.min(1, f.life/600); const rx= (f.x*scaleX), ry=(f.y*scaleY); const r=60*((scaleX+scaleY)/2); const g=ctx.createRadialGradient(rx,ry,1,rx,ry,r); g.addColorStop(0,`rgba(255,180,0,${0.6*a})`); g.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(rx,ry,r,0,Math.PI*2); ctx.fill(); }

    // 火焰球爆炸範圍特效
    for(let i=fireExplosions.length-1;i>=0;i--){
      const ex = fireExplosions[i];
      const age = performance.now() - ex.t0;
      const prog = age / ex.life;
      if(prog>=1){ fireExplosions.splice(i,1); continue; }
      const alpha = 1 - prog;
      const x = ex.x * scaleX;
      const y = ex.y * scaleY;
      const r = ex.r * ((scaleX+scaleY)/2);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = `rgba(255,80,0,${0.25*alpha})`;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = `rgba(255,200,50,${alpha})`;
      ctx.lineWidth = 4 + 6*(1-prog);
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    drawDemonBloodEffects(now);


    // LED 燈條框（多風格，落球區域無燈條）
    const c=ledColor();
    let spAvg=0; for(const b of balls){ spAvg += Math.hypot(b.vx,b.vy); } spAvg = balls.length? spAvg/balls.length : 8;
    const nowT = performance.now();
    // For the classic LED breathing effect, prefer the period defined by the
    // current skin (if available).  When a skin is selected its period
    // defines the full cycle (in ms).  Otherwise fall back to the original
    // behaviour based on ball speed.
    let __periodClassic;
    if (window.currentSkin && window.currentSkin.canvas && typeof window.currentSkin.canvas.period === 'number') {
      __periodClassic = window.currentSkin.canvas.period;
    } else {
      // Preserve the old dynamic period based on average ball speed (spAvg).
      __periodClassic = (180 - Math.min(120, spAvg * 6));
    }
    // Compute a phase between 0 and 1, wrapping around __periodClassic.
    const __phaseClassic = ((__periodClassic > 0) ? ((nowT % __periodClassic) / __periodClassic) : 0);
    const breathClassic = (Math.sin(__phaseClassic * Math.PI * 2) + 1) / 2;
    const breath5 = (Math.sin(nowT / (5000 / (2*Math.PI)))+1)/2;  // 5s
    const breath3 = (Math.sin(nowT / (3000 / (2*Math.PI)))+1)/2;  // 3s
    const breath8 = (Math.sin(nowT / (8000 / (2*Math.PI)))+1)/2;  // 8s

    function pathThreeSides(){
      ctx.beginPath();
      if(!orientLeft){
        ctx.moveTo(3,3); ctx.lineTo(w-3,3);
        ctx.moveTo(3,3); ctx.lineTo(3,h-3);
        ctx.moveTo(w-3,3); ctx.lineTo(w-3,h-3);
      }else{
        ctx.moveTo(3,3); ctx.lineTo(w-3,3);
        ctx.moveTo(w-3,3); ctx.lineTo(w-3,h-3);
        ctx.moveTo(3,h-3); ctx.lineTo(w-3,h-3);
      }
    }

    ctx.save();
    if(isPhantom){
      const rainbow=['#ff66ff','#ffb366','#fff466','#66ffb3','#66d1ff','#6666ff','#cc66ff'];
      const periodColor=(window.currentSkin&&window.currentSkin.canvas&&window.currentSkin.canvas.period)||2400;
      const step=Math.floor(nowT/periodColor)%rainbow.length;
      const c1=rainbow[step];
      const c2=rainbow[(step+1)%rainbow.length];
      const grad=ctx.createLinearGradient(0,0,w,0);
      grad.addColorStop(0,c1);
      grad.addColorStop(1,c2);
      ctx.globalAlpha=0.55+0.35*breathClassic;
      ctx.strokeStyle=grad; ctx.lineWidth=6;
      ctx.shadowColor=c2; ctx.shadowBlur=24+12*breathClassic;
      pathThreeSides(); ctx.stroke();
      ctx.restore();
    } else switch(ledStyle){
      case 'tech': {
        ctx.globalAlpha = 0.55 + 0.35*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=8; ctx.shadowColor=c; ctx.shadowBlur=28 + 10*breath5;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'arc': {
        ctx.globalAlpha = 0.5 + 0.25*breath5;
        ctx.strokeStyle=c; ctx.lineWidth=5; ctx.shadowColor=c; ctx.shadowBlur=16 + 6*breath5;
        pathThreeSides(); ctx.setLineDash([14,10]); ctx.lineDashOffset = -(nowT/20); ctx.stroke();
        ctx.setLineDash([]); ctx.globalAlpha = 0.3 + 0.2*breath8; ctx.lineWidth=2.5; ctx.shadowBlur=0;
        pathThreeSides(); ctx.stroke();
        break;
      }
      case 'steel': {
        ctx.globalAlpha = 0.65 + 0.25*breath5;
        const g = ctx.createLinearGradient(0,0,w,0);
        g.addColorStop(0, 'rgba(220,230,255,0.85)');
        g.addColorStop(0.5, 'rgba(120,140,180,0.85)');
        g.addColorStop(1, 'rgba(200,210,240,0.85)');
        ctx.strokeStyle=g; ctx.lineWidth=7.5; ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=12;
        pathThreeSides(); ctx.stroke();
        ctx.shadowBlur=0; ctx.fillStyle=c;
        const ends = !orientLeft ? [[3,3],[w-3,3]] : [[w-3,3],[w-3,h-3]];
        for(const [ex,ey] of ends){ ctx.beginPath(); ctx.arc(ex,ey,6 + 2*breath5, 0, Math.PI*2); ctx.fill(); }
        break;
      }
      case 'vivid': {
        ctx.globalAlpha = 0.5 + 0.5*breath3;
        const grad = ctx.createLinearGradient(0,0,w,0);
        grad.addColorStop(0, 'rgba(255,255,255,0.85)');
        grad.addColorStop(1, c);
        ctx.strokeStyle=grad; ctx.lineWidth=4.5;
        for(const off of [-4,0,4]){ ctx.save(); ctx.translate(0,off); pathThreeSides(); ctx.stroke(); ctx.restore(); }
        break;
      }
      default: {
        ctx.globalAlpha = 0.6 + 0.3*breathClassic;
        if(window.currentSkin && window.currentSkin.cssSkin === '科技．賽博格綠'){
          const g = ctx.createLinearGradient(0,0,w,0);
          g.addColorStop(0,'#00ff99');
          g.addColorStop(1,'#00cc66');
          ctx.strokeStyle=g; ctx.lineWidth=6;
          ctx.shadowColor='#00ff99'; ctx.shadowBlur=20 + 10*breathClassic; pathThreeSides(); ctx.stroke();
        }else{
          ctx.strokeStyle=c; ctx.lineWidth=6; ctx.shadowColor=c; ctx.shadowBlur=20 + 10*breathClassic; pathThreeSides(); ctx.stroke();
        }
        break;
      }
    }
    ctx.restore();}

  // 只在磚塊區域揭示圖片切片（依本關影像）
  function drawRevealTiles(){
    const img=getLevelImage(level);
    if(!img || !(img.naturalWidth>0 && img.naturalHeight>0)) return;
    const L=layout();
    const area={x:L.pad,y:L.top,w:1100-L.pad*2,h:L.rows*(brickH+L.pad)-L.pad};
    const rImg=img.naturalWidth/img.naturalHeight;
    const rArea=area.w/area.h;
    let dw,dh;
    if(rImg>rArea){ dh=area.h; dw=dh*rImg; } else { dw=area.w; dh=dw/rImg; }
    const dx=area.x+(area.w-dw)/2;
    const dy=area.y+(area.h-dh)/2;
    ctx.save();
    ctx.scale(scaleX,scaleY);
    for(const r of revealRects){
      let sx=(r.x-dx)/dw*img.naturalWidth;
      let sy=(r.y-dy)/dh*img.naturalHeight;
      let sw=r.w/dw*img.naturalWidth;
      let sh=r.h/dh*img.naturalHeight;
      const sx0=Math.max(0, Math.min(img.naturalWidth, sx));
      const sy0=Math.max(0, Math.min(img.naturalHeight, sy));
      const sw0=Math.max(0, Math.min(img.naturalWidth - sx0, sw));
      const sh0=Math.max(0, Math.min(img.naturalHeight - sy0, sh));
      if(sw0>0 && sh0>0){
        ctx.drawImage(img, sx0,sy0,sw0,sh0, r.x, r.y, r.w, r.h);
      }
    }
    ctx.restore();
  }

  function drawPlasmas(){ const now=performance.now(); const spawnPositions=[]; const spawnKeys=new Set(); const recordSpawn=(sx,sy)=>{ const key=`${Math.round(sx)}:${Math.round(sy)}`; if(!spawnKeys.has(key)){ spawnKeys.add(key); spawnPositions.push({x:sx,y:sy}); } };
    ctx.save(); for(let i=plasmas.length-1;i>=0;i--){ const P=plasmas[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.995; P.vy*=0.995; P.phase=(P.phase||0)+0.2; if(now>P.until){ plasmas.splice(i,1); continue; }
      const x=P.x*scaleX, y=P.y*scaleY, r=P.radius*((scaleX+scaleY)/2); const grd=ctx.createRadialGradient(x,y,0,x,y,r); grd.addColorStop(0,'rgba(200,255,255,0.9)'); grd.addColorStop(0.3,'rgba(150,200,255,0.6)'); grd.addColorStop(0.6,'rgba(120,150,255,0.3)'); grd.addColorStop(1,'rgba(120,150,255,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.save(); ctx.globalCompositeOperation='lighter'; for(let k=0;k<3;k++){ const a=P.phase+k*Math.PI*2/3; ctx.strokeStyle='rgba(180,240,255,0.6)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,r*0.8,a,a+Math.PI/3); ctx.stroke(); } ctx.restore();
      for(let j=bricks.length-1;j>=0;j--){ const b=bricks[j]; const bx=b.x+b.w/2, by=b.y+b.h/2; if(Math.hypot(P.x-bx,P.y-by)<=P.radius){
          if(b.unbreakable) continue;
          if(b.boss){
            b.hp-=1;
            if(b.hp<=0){ bossKillEffect(b); revealBrickArea(b); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(b)); stats.bossKills++; updateHUD(); }
          }
          else {
            revealBrickArea(b); maybeDropFromBrick(b); bricks.splice(j,1); incrementCombo(); addScore(scoreForBrick(b)); if(b.elite) stats.eliteKills++; updateHUD(); playSFX('plasmaHit'); recordSpawn(bx,by);
          }
        }
      }
      strikeDemonAbyssBricksAtPoint(P.x, P.y, Math.max(0, P.radius||0), 'plasma');
      if(circleIntersectsActiveBoss(P.x,P.y,P.radius)){
        const impact=activeBossClampPoint(P.x, P.y);
        damageActiveBoss(1,'plasma',impact);
      }
    } ctx.restore();
    if(equipmentPlasmaChainActive && equipmentPlasmaChainInterval>0){ const chainSpawns=triggerPlasmaChainLightning(now); for(const pos of chainSpawns){ recordSpawn(pos.x,pos.y); } }
    if(equipmentPlasmaSpawnOnKill && spawnPositions.length){ let played=false; for(const pos of spawnPositions){ spawnPlasmaBurst(pos.x,pos.y,{sound:!played}); played=true; } }
  }

  function distancePointToSegment(px,py,x1,y1,x2,y2){ const dx=x2-x1, dy=y2-y1; if(Math.abs(dx)<1e-6 && Math.abs(dy)<1e-6){ return Math.hypot(px-x1, py-y1); } const t=((px-x1)*dx + (py-y1)*dy)/(dx*dx+dy*dy); const clamped=Math.max(0,Math.min(1,t)); const projX=x1+clamped*dx; const projY=y1+clamped*dy; return Math.hypot(px-projX, py-projY); }

  function triggerPlasmaChainLightning(now){ if(!equipmentPlasmaChainActive || equipmentPlasmaChainInterval<=0) return []; if(plasmas.length<2) return []; if(plasmaChainNextAt && now<plasmaChainNextAt) return []; plasmaChainNextAt=now+equipmentPlasmaChainInterval; const range=equipmentPlasmaChainRange>0?equipmentPlasmaChainRange:200; const rangeSq=range*range; const pairs=[];
    for(let i=0;i<plasmas.length;i++){ const a=plasmas[i]; for(let j=i+1;j<plasmas.length;j++){ const b=plasmas[j]; const dx=a.x-b.x, dy=a.y-b.y; if(dx*dx+dy*dy<=rangeSq){ pairs.push({a,b}); } } }
    if(!pairs.length) return []; const toDestroy=new Set(); const destroyedPositions=[]; const threshold=Math.max(brickW, brickH)*0.6;
    for(const {a,b} of pairs){ plasmaChains.push({x1:a.x,y1:a.y,x2:b.x,y2:b.y,until:now+240}); strikeDemonAbyssBricksAlongLine(a.x,a.y,b.x,b.y,'plasmaChain'); for(const brick of bricks){ if(!brick) continue; if(!canDestroyBrick(brick)) continue; const cx=brick.x+brick.w/2; const cy=brick.y+brick.h/2; const dist=distancePointToSegment(cx,cy,a.x,a.y,b.x,b.y); if(dist<=threshold){ toDestroy.add(brick); } } }
    if(!toDestroy.size) return destroyedPositions; screenShake=Math.max(screenShake,3);
    for(let i=bricks.length-1;i>=0;i--){ const brick=bricks[i]; if(!brick || !toDestroy.has(brick)) continue; const spawnable=!brick.boss; const cx=brick.x+brick.w/2; const cy=brick.y+brick.h/2; destroyBrick(i,'plasmaHit'); if(spawnable){ destroyedPositions.push({x:cx,y:cy}); } }
    return destroyedPositions;
  }

  function drawPlasmaChains(){ const now=performance.now(); ctx.save(); ctx.globalCompositeOperation='lighter'; const width=Math.max(2,((scaleX+scaleY)/2)*2.4); for(let i=plasmaChains.length-1;i>=0;i--){ const chain=plasmaChains[i]; if(now>chain.until){ plasmaChains.splice(i,1); continue; } const alpha=Math.max(0,(chain.until-now)/240); ctx.strokeStyle=`rgba(210,240,255,${0.5*alpha})`; ctx.lineWidth=width; ctx.shadowBlur=18; ctx.shadowColor='rgba(210,240,255,0.6)'; ctx.beginPath(); ctx.moveTo(chain.x1*scaleX, chain.y1*scaleY); ctx.lineTo(chain.x2*scaleX, chain.y2*scaleY); ctx.stroke(); }
    ctx.restore(); }

  function drawHoly(){ const now=performance.now(); for(let i=holyFlashes.length-1;i>=0;i--){ const H=holyFlashes[i]; if(now>H.until){ holyFlashes.splice(i,1); continue; } const a=Math.max(0, (H.until-now)/300); const pattern=H.pattern||'cross'; ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle=`rgba(255,240,180,${0.6*a})`; ctx.lineWidth=4;
      const y=H.y*scaleY; const x=H.x*scaleX;
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
      if(pattern==='miz'){
        const computeDiag=(slope)=>{
          const pts=[]; const cx=H.x; const cy=H.y; const xMin=0, xMax=1100, yMin=0, yMax=700; const seen=new Set();
          if(slope===1){ const b=cy-cx; const candidates=[
            {x:xMin, y:b},
            {x:xMax, y:xMax+b},
            {x:cx-cy, y:yMin},
            {x:700-b, y:yMax}
          ];
            for(const p of candidates){ if(p.x>=xMin && p.x<=xMax && p.y>=yMin && p.y<=yMax){ const key=`${p.x.toFixed(2)}:${p.y.toFixed(2)}`; if(!seen.has(key)){ seen.add(key); pts.push(p); } } }
          }else{ const c=cy+cx; const candidates=[
            {x:xMin, y:c},
            {x:xMax, y:c-xMax},
            {x:c, y:yMin},
            {x:c-700, y:yMax}
          ];
            for(const p of candidates){ if(p.x>=xMin && p.x<=xMax && p.y>=yMin && p.y<=yMax){ const key=`${p.x.toFixed(2)}:${p.y.toFixed(2)}`; if(!seen.has(key)){ seen.add(key); pts.push(p); } } }
          }
          if(pts.length<2) return null; pts.sort((p1,p2)=> p1.x===p2.x ? p1.y-p2.y : p1.x-p2.x); return {p1:pts[0], p2:pts[pts.length-1]};
        };
        const diag1=computeDiag(1); const diag2=computeDiag(-1);
        if(diag1){ ctx.beginPath(); ctx.moveTo(diag1.p1.x*scaleX, diag1.p1.y*scaleY); ctx.lineTo(diag1.p2.x*scaleX, diag1.p2.y*scaleY); ctx.stroke(); }
        if(diag2){ ctx.beginPath(); ctx.moveTo(diag2.p1.x*scaleX, diag2.p1.y*scaleY); ctx.lineTo(diag2.p2.x*scaleX, diag2.p2.y*scaleY); ctx.stroke(); }
      }
      ctx.restore(); } }

  function drawPhoenix(){ if(!phoenixAnim) return; const now=performance.now(); const t=phoenixAnim; const prog=1-Math.max(0,(t.tEnd-now)/1200); const logicW=1100; const xLogic=(1-prog)*(logicW+200)-200; const x=xLogic*scaleX;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    // 身形光羽
    const grad=ctx.createLinearGradient((x+120),220*scaleY,x,260*scaleY); grad.addColorStop(0,'rgba(255,180,0,0.9)'); grad.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=grad;
    ctx.beginPath(); ctx.moveTo((x+180), 220*scaleY); ctx.quadraticCurveTo((x+60), 180*scaleY, (x), 230*scaleY); ctx.quadraticCurveTo((x-40), 260*scaleY, (x+120), 260*scaleY); ctx.closePath(); ctx.fill();
    // 羽毛粒子
    for(let i=0;i<3;i++){ fireBursts.push({x:(x-40)+Math.random()*120,y:220+Math.random()*60,life:300+Math.random()*400}); }
    ctx.restore(); if(now>=t.tEnd) phoenixAnim=null; }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(screenShake>0){ const s=screenShake*0.6; ctx.save(); ctx.translate((Math.random()-0.5)*s,(Math.random()-0.5)*s); screenShake*=0.9; }
    const now=performance.now();
    drawBGDecor(now);
    drawDemonDeathAftershock(now);
    drawDemonWave(now);
    if(buffs.ANNIHIL.active){ if(Math.random()<0.5) annihilSparks.push({x:Math.random()*1100,y:0,v:1+Math.random()*1.5}); for(let i=annihilSparks.length-1;i>=0;i--){ const sp=annihilSparks[i]; sp.y+=sp.v; ctx.fillStyle='rgba(255,220,150,0.8)'; ctx.fillRect(sp.x*scaleX, sp.y*scaleY,2*scaleX,2*scaleY); if(sp.y>700) annihilSparks.splice(i,1); } }
    drawRevealTiles();

    // 磚塊
    for(const b of bricks){
      // 移動磚更新
      if(b.moving){
        b.x += b.vx;
        if(b.x<8){ b.x=8; b.vx=Math.abs(b.vx); }
        if(b.x+b.w>1100-8){ b.x=1100-8-b.w; b.vx=-Math.abs(b.vx); }
      }
      // 繪製
      let fillStyle;
      if(b.treasure){
        const gold=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
        gold.addColorStop(0,'#fff5d6');
        gold.addColorStop(0.18,'#ffe38a');
        gold.addColorStop(0.45,'#ffd042');
        gold.addColorStop(0.78,'#d9a326');
        gold.addColorStop(1,'#9f7012');
        fillStyle=gold;
      }else{
        let base = b.boss ? '#ff4d6d' : b.unbreakable ? '#888' : b.strong ? '#bb7aff' : b.moving ? '#6ec6ff' : b.explosive ? getVar('--expl') : brickColor(b.colorIdx);
        const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY);
        g.addColorStop(0,base);
        g.addColorStop(1,'#1a1f3a');
        fillStyle=g;
      }
      ctx.fillStyle=fillStyle;
      drawRoundedRect(b.x,b.y,b.w,b.h,6);
      ctx.fill();
      if(b.treasure){
        const now=performance.now();
        const sheenPos=(now%1400)/1400;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const sheen=ctx.createLinearGradient((b.x-12)*scaleX,(b.y-12)*scaleY,(b.x+b.w+12)*scaleX,(b.y+b.h+12)*scaleY);
        const start=Math.max(0,sheenPos-0.2);
        const peak=sheenPos;
        const end=Math.min(1,sheenPos+0.2);
        sheen.addColorStop(0,'rgba(255,255,255,0)');
        sheen.addColorStop(start,'rgba(255,255,255,0)');
        sheen.addColorStop(peak,'rgba(255,255,255,0.85)');
        sheen.addColorStop(end,'rgba(255,255,255,0)');
        sheen.addColorStop(1,'rgba(255,255,255,0)');
        ctx.globalAlpha=0.55;
        ctx.fillStyle=sheen;
        drawRoundedRect(b.x-4,b.y-4,b.w+8,b.h+8,9);
        ctx.fill();

        const glowPulse=0.65+0.35*Math.sin(now/320);
        const rainbow=ctx.createLinearGradient((b.x-10)*scaleX,(b.y-10)*scaleY,(b.x+b.w+10)*scaleX,(b.y+b.h+10)*scaleY);
        const rainbowColors=['#ff6ec7','#ff9f43','#ffe066','#8ce99a','#74c0fc','#b197fc','#ff85f5'];
        rainbowColors.forEach((col,i)=>rainbow.addColorStop(i/(rainbowColors.length-1),col));
        ctx.globalAlpha=0.8+0.2*Math.sin(now/360);
        ctx.strokeStyle=rainbow;
        ctx.lineWidth=3.5+1.5*glowPulse;
        ctx.shadowBlur=20;
        ctx.shadowColor=`rgba(255,210,120,${0.3+0.25*glowPulse})`;
        drawRoundedRect(b.x-5,b.y-5,b.w+10,b.h+10,10);
        ctx.stroke();
        ctx.restore();
      }
      if(b.placeholderBoss){
        const pulse=0.5+0.5*Math.sin(performance.now()/200);
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle=`rgba(255,210,150,${0.35+0.35*pulse})`;
        ctx.lineWidth=6;
        drawRoundedRect(b.x-6,b.y-6,b.w+12,b.h+12,10);
        ctx.stroke();
        ctx.restore();
      }
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.shadowColor='rgba(120,220,255,0.7)'; ctx.shadowBlur=15; const eg=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x+b.w)*scaleX,(b.y+b.h)*scaleY); eg.addColorStop(0,'rgba(0,255,255,0.9)'); eg.addColorStop(1,'rgba(120,180,255,0.2)'); ctx.strokeStyle=eg; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.shadowBlur=0; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); }
      if(b.poisonUntil && performance.now()<b.poisonUntil){ ctx.fillStyle='rgba(0,255,0,0.25)'; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill(); }
      // 鎖鏈覆蓋
      if(b.lockedUntil && performance.now() < b.lockedUntil){ ctx.fillStyle='rgba(90,0,120,0.35)'; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill();
      if(b.elite){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.shadowColor='rgba(120,220,255,0.7)'; ctx.shadowBlur=15; const eg=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x+b.w)*scaleX,(b.y+b.h)*scaleY); eg.addColorStop(0,'rgba(0,255,255,0.9)'); eg.addColorStop(1,'rgba(120,180,255,0.2)'); ctx.strokeStyle=eg; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.shadowBlur=0; ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo((b.x+6)*scaleX,(b.y+6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+6)*scaleY); ctx.moveTo((b.x+6)*scaleX,(b.y+b.h-6)*scaleY); ctx.lineTo((b.x+b.w-6)*scaleX,(b.y+b.h-6)*scaleY); ctx.stroke(); ctx.restore(); } }
      // 菁英聚氣光
      if(b.elite && b.eliteChargeUntil && performance.now()<b.eliteChargeUntil){ const a=0.5+0.5*Math.sin(performance.now()/80); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,220,255,'+(0.6*a)+')'; ctx.lineWidth=3; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.stroke(); ctx.restore(); }
      // 血條 / 面孔
      if(b.boss){
        drawBossEmblem(b);
        if(!b.cyclops && !b.hideBossHP){
          // 血條
          ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*scaleX,6*scaleY);
          const ratio=Math.max(0, b.hp/40);
          const hpGrad=ctx.createLinearGradient((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.x+b.w-8)*scaleX,(b.y+b.h-8)*scaleY);
          hpGrad.addColorStop(0,'rgba(255,150,150,.95)'); hpGrad.addColorStop(1,'rgba(255,240,240,.95)');
          ctx.fillStyle=hpGrad; ctx.fillRect((b.x+8)*scaleX,(b.y+b.h-8)*scaleY,(b.w-16)*ratio*scaleX,6*scaleY);
        }
      }else if(b.hp>1 && b.hp<99 && b.hp<Infinity){
        ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*scaleX,4*scaleY);
        ctx.fillStyle='rgba(255,255,255,.75)'; const ratio=Math.max(0,(b.hp-1))/3; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*ratio*scaleX,4*scaleY);
      }
    }

    drawStarProjectiles();
    drawMoonProjectiles();

    for(const d of demonFallingDebris){
      ctx.save();
      const cx=(d.x + d.w/2)*scaleX;
      const cy=(d.y + d.h/2)*scaleY;
      ctx.translate(cx, cy);
      ctx.rotate(d.angle);
      const w=d.w*scaleX;
      const h=d.h*scaleY;
      const grad=ctx.createLinearGradient(0,-h/2,0,h/2);
      grad.addColorStop(0,d.color||'#ffffff');
      grad.addColorStop(1,'rgba(26,31,58,0.85)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.moveTo(-w/2,-h/2);
      ctx.lineTo(w/2,-h/2);
      ctx.lineTo(w/2,h/2);
      ctx.lineTo(-w/2,h/2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    drawSpaceBossLayer();
    drawReaperLayer();
    drawDragonLayer();
    drawDemonLayer(now);
    drawDemonBlackSpears(now);
    drawDemonCloakWraps(now,'behind');
    drawPlasmas(); drawPlasmaChains(); drawHoly(); drawPhoenix(); drawSwords();

      // Boss wind-up glow
      if(bossChargeUntil && performance.now()<bossChargeUntil){
      const nowCharge = performance.now();
      const a = 0.5 + 0.5*Math.sin(nowCharge/80);
      const dragonCharging = isDragonActive() && dragonBoss && dragonBoss.petrifyCharge && nowCharge < dragonBoss.petrifyCharge.end;
      for(const b of bricks){ if(b.boss){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba('+bossChargeColor+','+(0.6*a)+')'; ctx.lineWidth=4; drawRoundedRect(b.x,b.y,b.w,b.h,10); ctx.stroke(); ctx.restore(); } }
      if(isDragonActive() && dragonBoss){ const bounds=getDragonBounds(); if(bounds && !dragonCharging){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba('+bossChargeColor+','+(0.6*a)+')'; ctx.lineWidth=4; drawRoundedRect(bounds.x, bounds.y, bounds.w, bounds.h, 18); ctx.stroke(); ctx.restore(); } }
    }


    // 擋板
    const pr=paddleRect();
    const nowPad=performance.now();
    if(nowPad>=paddleGoneUntil){
      if(flipDecoy?.active){
        const ghost=flipDecoy;
        const gw=(ghost.w ?? paddle.w);
        const gh=(ghost.h ?? paddle.h);
        const glowAlpha=0.35 + 0.25*Math.sin(nowPad/180);
        ctx.save();
        ctx.globalAlpha=glowAlpha;
        drawRoundedRect(ghost.x, ghost.y, gw, gh, 10);
        const baseGrad=ctx.createLinearGradient(ghost.x*scaleX, (ghost.y-6)*scaleY, ghost.x*scaleX, (ghost.y+gh+6)*scaleY);
        baseGrad.addColorStop(0,'rgba(200,220,255,0.45)');
        baseGrad.addColorStop(1,'rgba(160,190,255,0.2)');
        ctx.fillStyle=baseGrad;
        ctx.fill();
        ctx.lineWidth=2*Math.min(scaleX,scaleY);
        ctx.strokeStyle='rgba(220,235,255,0.45)';
        ctx.stroke();
        ctx.restore();
      }
      const padGlow=buffs.STICKY.active?'rgba(120,230,220,.6)':((buffs.WIDE.active||buffs.LONG.stacks.length)?'rgba(120,170,255,.6)':'rgba(200,210,255,.4)');
      ctx.shadowColor=padGlow; ctx.shadowBlur=20;
      const padW=pr.w*scaleX, padH=pr.h*scaleY;
      const scaleUnit=Math.min(scaleX,scaleY);
      ctx.save();
      ctx.translate((pr.x+pr.w/2)*scaleX,(pr.y+pr.h/2)*scaleY);
      let ang=0;
      if(buffs.PADSPIN.active){ const period=GAME_CONFIG.powers.PADSPIN.spin.periodMs||8000; ang=((nowPad-(buffs.PADSPIN.start||nowPad))%period)/period*2*Math.PI; }
      ctx.rotate(ang);
      const padSkinName = window.currentSkin?.cssSkin || '';
      const isInfiniteCastle = padSkinName === '和風．無限之城';
      const isCyborg = padSkinName === '科技．賽博格綠';
      const isPhantom = padSkinName === '科技．魅影幻彩';
      const isCosmos = padSkinName === '宇宙．星辰絮語';
      const isSolar = padSkinName === '烈陽．炙金幻焰';
      const isGear = padSkinName === '機械．齒輪騎士';
      const isAurora = padSkinName === '冰雪．極光絲綢';
      const isVerticalAxis = padH>padW;
      const axisCenter = isVerticalAxis ? (pr.y+pr.h/2) : (pr.x+pr.w/2);
      let axisDelta=0;
      if(lastPaddleDrawState.axis!=null && lastPaddleDrawState.vertical===isVerticalAxis && nowPad-lastPaddleDrawState.time<180){
        axisDelta=axisCenter-lastPaddleDrawState.axis;
      }
      const drawPadShape = () => {
        ctx.beginPath();
        ctx.moveTo(-padW/2 + r, -padH/2);
        ctx.arcTo(padW/2, -padH/2, padW/2, padH/2, r);
        ctx.arcTo(padW/2, padH/2, -padW/2, padH/2, r);
        ctx.arcTo(-padW/2, padH/2, -padW/2, -padH/2, r);
        ctx.arcTo(-padW/2, -padH/2, padW/2, -padH/2, r);
        ctx.closePath();
      };
      let padBaseColor = '#9aaeff';
      let padFill = padBaseColor;
      currentPaddleTint=padBaseColor;
      if(isInfiniteCastle){
        const depthGrad = ctx.createLinearGradient(0, -padH/2, 0, padH/2);
        depthGrad.addColorStop(0,'#2d1207');
        depthGrad.addColorStop(0.16,'#55230d');
        depthGrad.addColorStop(0.5,'#c6914a');
        depthGrad.addColorStop(0.84,'#6f2d11');
        depthGrad.addColorStop(1,'#281006');
        padFill = depthGrad;
        padBaseColor = '#c6914a';
        currentPaddleTint=padBaseColor;
      } else if(isCyborg){
        const pulse=0.6+0.4*Math.sin(nowPad/260);
        ctx.shadowColor=`rgba(0,255,190,${0.25+0.35*pulse})`;
        ctx.shadowBlur=26+14*pulse;
        const hull=ctx.createLinearGradient(-padW/2,0,padW/2,0);
        hull.addColorStop(0,'#001810');
        hull.addColorStop(0.18,'#00331f');
        hull.addColorStop(0.5,`rgba(0,90,60,${0.92+0.05*pulse})`);
        hull.addColorStop(0.82,'#00331f');
        hull.addColorStop(1,'#001810');
        padFill=hull;
        padBaseColor='#00f2a0';
        currentPaddleTint=padBaseColor;
      } else if(isPhantom){
        const shimmer=0.45+0.55*Math.sin(nowPad/220);
        const hueBase=(nowPad/900*180)%360;
        const glowHue=(hueBase+60)%360;
        ctx.shadowColor=`hsla(${glowHue},85%,68%,${0.25+0.35*shimmer})`;
        ctx.shadowBlur=24+16*shimmer;
        const neon=ctx.createLinearGradient(-padW/2,-padH*0.35,padW/2,padH*0.35);
        for(let i=0;i<=6;i++){
          const stop=i/6;
          const hue=(hueBase+i*52)%360;
          const light=58+12*Math.sin(nowPad/180+i);
          neon.addColorStop(stop,`hsl(${hue},90%,${light}%)`);
        }
        padFill=neon;
        padBaseColor='hsl('+((hueBase+180)%360)+',80%,60%)';
        currentPaddleTint=padBaseColor;
      } else if(isCosmos){
        const glow=0.55+0.45*Math.sin(nowPad/320);
        ctx.shadowColor=`rgba(210,225,255,${0.22+0.25*glow})`;
        ctx.shadowBlur=22+12*glow;
        const hull=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        hull.addColorStop(0,'#f4f7ff');
        hull.addColorStop(0.28,'#dfe3ee');
        hull.addColorStop(0.5,'#c7cfde');
        hull.addColorStop(0.72,'#dfe4f4');
        hull.addColorStop(1,'#f8faff');
        padFill=hull;
        padBaseColor='#c7d0df';
        currentPaddleTint=padBaseColor;
      } else if(isSolar){
        const pulse=0.5+0.5*Math.sin(nowPad/280);
        ctx.shadowColor=`rgba(255,130,40,${0.3+0.35*pulse})`;
        ctx.shadowBlur=26+16*pulse;
        const magma=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        magma.addColorStop(0,'#2c0500');
        magma.addColorStop(0.25,'#611400');
        magma.addColorStop(0.52,'#d34800');
        magma.addColorStop(0.72,'#ff8c1a');
        magma.addColorStop(1,'#ffd37a');
        padFill=magma;
        padBaseColor='#ff9c2f';
        currentPaddleTint=padBaseColor;
      } else if(isGear){
        const pulse=0.5+0.5*Math.sin(nowPad/420);
        ctx.shadowColor=`rgba(255,210,140,${0.22+0.22*pulse})`;
        ctx.shadowBlur=18+12*pulse;
        const alloy=ctx.createLinearGradient(-padW/2,0,padW/2,0);
        alloy.addColorStop(0,'#241f1a');
        alloy.addColorStop(0.25,'#4a3f31');
        alloy.addColorStop(0.55,'#b08a4a');
        alloy.addColorStop(0.82,'#e0cc9a');
        alloy.addColorStop(1,'#5c472a');
        padFill=alloy;
        padBaseColor='#d2b26c';
        currentPaddleTint=padBaseColor;
      } else if(isAurora){
        const frost=0.55+0.45*Math.sin(nowPad/340);
        ctx.shadowColor=`rgba(200,230,255,${0.28+0.32*frost})`;
        ctx.shadowBlur=24+14*frost;
        const ice=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        ice.addColorStop(0,'#f2fdff');
        ice.addColorStop(0.28,'#d2efff');
        ice.addColorStop(0.55,'#b5dbff');
        ice.addColorStop(0.85,'#d8f1ff');
        ice.addColorStop(1,'#f5feff');
        padFill=ice;
        padBaseColor='#cfe9ff';
        currentPaddleTint=padBaseColor;
      }
      if(buffs.PADBOOM.active && !buffs.PADBOOM.exploded){ ctx.globalAlpha=0.5+0.5*Math.sin(nowPad/100); }
      const r=8*scaleUnit;
      drawPadShape();
      ctx.fillStyle = padFill;
      ctx.fill();
        if(nowPad<phoenixHeartGlowUntil){
          const remaining=Math.max(0, phoenixHeartGlowUntil-nowPad);
          const glow=Math.max(0, Math.min(1, remaining/2000));
          const pulse=0.6+0.4*Math.sin(nowPad/120);
          ctx.save();
        ctx.globalCompositeOperation='lighter';
        const flameGrad=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        flameGrad.addColorStop(0,`rgba(255,210,120,${0.25+0.35*pulse})`);
        flameGrad.addColorStop(1,`rgba(255,80,0,${0.18+0.32*glow})`);
        ctx.fillStyle=flameGrad;
        drawPadShape();
        ctx.fill();
        ctx.strokeStyle=`rgba(255,150,40,${0.35+0.45*pulse})`;
        ctx.lineWidth=3*scaleUnit;
        ctx.stroke();
          ctx.restore();
        }
        if(nowPad<toxicRebirthGlowUntil){
          const remain=Math.max(0, toxicRebirthGlowUntil-nowPad);
          const pulse=0.6+0.4*Math.sin(nowPad/140);
          ctx.save();
          ctx.globalCompositeOperation='lighter';
          const verdant=ctx.createLinearGradient(0,-padH/2,0,padH/2);
          verdant.addColorStop(0,`rgba(140,255,160,${0.18+0.22*pulse})`);
          verdant.addColorStop(1,`rgba(60,200,120,${0.14+0.2*Math.min(1,remain/2000)})`);
          ctx.fillStyle=verdant;
          drawPadShape();
          ctx.fill();
          ctx.strokeStyle=`rgba(160,255,190,${0.3+0.35*pulse})`;
          ctx.lineWidth=Math.max(2.2,3.4*scaleUnit);
          drawPadShape();
          ctx.stroke();
          ctx.restore();
        }
        if(isInfiniteCastle){
          ctx.save();
          drawPadShape();
          ctx.clip();
        const plankCount = Math.max(6, Math.round(padW / (72*scaleUnit)));
        const plankWidth = padW / plankCount;
        const seamWidth = Math.max(1.1, 0.85*scaleUnit);
        for(let i=0;i<plankCount;i++){
          const left = -padW/2 + i*plankWidth;
          const right = left + plankWidth;
          const plankGrad = ctx.createLinearGradient(left, 0, right, 0);
          plankGrad.addColorStop(0,'#371507');
          plankGrad.addColorStop(0.18,'#6d2c10');
          plankGrad.addColorStop(0.52,'#d5a158');
          plankGrad.addColorStop(0.82,'#803914');
          plankGrad.addColorStop(1,'#301207');
          ctx.fillStyle = plankGrad;
          ctx.fillRect(left, -padH/2, plankWidth, padH);

          const inset = plankWidth*0.18;
          const satin = ctx.createLinearGradient(0, -padH/2, 0, padH/2);
          satin.addColorStop(0,'rgba(255,240,210,0.14)');
          satin.addColorStop(0.48,'rgba(255,222,170,0.22)');
          satin.addColorStop(1,'rgba(150,80,40,0.08)');
          ctx.fillStyle = satin;
          ctx.fillRect(left+inset, -padH/2, Math.max(plankWidth-2*inset, seamWidth*2), padH);

          ctx.fillStyle = 'rgba(38,16,8,0.55)';
          ctx.fillRect(right - seamWidth, -padH/2, seamWidth, padH);
          if(i === 0){
            ctx.fillRect(left, -padH/2, seamWidth, padH);
          }
        }

        const crossbandWidth = Math.max(3, 3.6*scaleUnit);
        const crossY1 = -padH/2 + padH*0.26;
        const crossY2 = padH/2 - padH*0.26;
        const crossGrad = ctx.createLinearGradient(-padW/2, 0, padW/2, 0);
        crossGrad.addColorStop(0,'rgba(58,24,12,0.78)');
        crossGrad.addColorStop(0.5,'rgba(176,108,52,0.58)');
        crossGrad.addColorStop(1,'rgba(58,24,12,0.78)');
        ctx.fillStyle = crossGrad;
        ctx.fillRect(-padW/2, crossY1 - crossbandWidth/2, padW, crossbandWidth);
        ctx.fillRect(-padW/2, crossY2 - crossbandWidth/2, padW, crossbandWidth);

        const jewelSize = Math.max(4, 4.6*scaleUnit);
        const jewelOffset = padW/2 - Math.min(padW*0.18, 48*scaleUnit);
        ctx.fillStyle = '#d9b97a';
        ctx.strokeStyle = 'rgba(38,16,8,0.65)';
        ctx.lineWidth = Math.max(0.9, 0.8*scaleUnit);
        for(const y of [crossY1, crossY2]){
          for(const x of [-jewelOffset, jewelOffset]){
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.PI/4);
            ctx.fillRect(-jewelSize/2, -jewelSize/2, jewelSize, jewelSize);
            ctx.strokeRect(-jewelSize/2, -jewelSize/2, jewelSize, jewelSize);
            ctx.restore();
          }
        }

        const lacquer = ctx.createLinearGradient(0, -padH/2, 0, padH/2);
        lacquer.addColorStop(0,'rgba(255,255,255,0.26)');
        lacquer.addColorStop(0.5,'rgba(255,224,180,0.1)');
        lacquer.addColorStop(1,'rgba(120,58,30,0.28)');
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = lacquer;
        ctx.fillRect(-padW/2, -padH/2, padW, padH);

        const halo = ctx.createRadialGradient(0, -padH*0.08, padH*0.18, 0, 0, padW*0.72);
        halo.addColorStop(0,'rgba(255,240,205,0.32)');
        halo.addColorStop(0.6,'rgba(255,210,150,0.12)');
        halo.addColorStop(1,'rgba(90,40,20,0.0)');
        ctx.fillStyle = halo;
        ctx.fillRect(-padW/2, -padH/2, padW, padH);
        ctx.globalCompositeOperation = 'source-over';

        ctx.restore();

        drawPadShape();
        ctx.lineWidth = Math.max(2.8, 3.6*scaleUnit);
        ctx.strokeStyle = 'rgba(222,182,112,0.92)';
        ctx.stroke();

        drawPadShape();
        ctx.lineWidth = Math.max(1.4, 2.1*scaleUnit);
        ctx.strokeStyle = 'rgba(44,20,8,0.85)';
        ctx.stroke();

        drawPadShape();
        ctx.lineWidth = Math.max(0.8, 1.2*scaleUnit);
        ctx.strokeStyle = 'rgba(255,236,204,0.45)';
        ctx.setLineDash([Math.max(6, 12*scaleUnit), Math.max(14, 24*scaleUnit)]);
        ctx.stroke();
        ctx.setLineDash([]);
      } else if(isCyborg){
        const pulse=0.6+0.4*Math.sin(nowPad/260);
        ctx.save();
        drawPadShape();
        ctx.clip();
        const glow=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        glow.addColorStop(0,'rgba(0,255,180,0.15)');
        glow.addColorStop(0.5,`rgba(0,255,200,${0.25+0.2*pulse})`);
        glow.addColorStop(1,'rgba(0,120,80,0.12)');
        ctx.fillStyle=glow;
        ctx.fillRect(-padW/2,-padH/2,padW,padH);
        const gridX=Math.max(18*scaleUnit, padW/10);
        const gridY=Math.max(12*scaleUnit, padH/3);
        ctx.lineWidth=Math.max(1,1.4*scaleUnit);
        ctx.strokeStyle=`rgba(0,255,190,${0.1+0.18*pulse})`;
        for(let x=-padW/2+gridX;x<padW/2;x+=gridX){
          ctx.beginPath();
          ctx.moveTo(x,-padH/2);
          ctx.lineTo(x,padH/2);
          ctx.stroke();
        }
        for(let y=-padH/2+gridY;y<padH/2;y+=gridY){
          ctx.beginPath();
          ctx.moveTo(-padW/2,y);
          ctx.lineTo(padW/2,y);
          ctx.stroke();
        }
        const nodes=[];
        for(let x=-padW/2+gridX;x<padW/2;x+=gridX){
          for(let y=-padH/2+gridY;y<padH/2;y+=gridY){ nodes.push([x,y]); }
        }
        ctx.fillStyle=`rgba(0,255,210,${0.35+0.25*pulse})`;
        const nodeR=Math.max(1.8,2.6*scaleUnit);
        for(const [nx,ny] of nodes){
          ctx.beginPath();
          ctx.arc(nx,ny,nodeR,0,Math.PI*2);
          ctx.fill();
        }
        const scanWidth=Math.max(10*scaleUnit,padW*0.12);
        const scanPos=-padW/2+((nowPad%1600)/1600)*padW;
        const scan=ctx.createLinearGradient(scanPos-scanWidth, -padH/2, scanPos+scanWidth, padH/2);
        scan.addColorStop(0,'rgba(0,255,200,0)');
        scan.addColorStop(0.5,`rgba(0,255,210,${0.25+0.2*pulse})`);
        scan.addColorStop(1,'rgba(0,255,200,0)');
        ctx.globalCompositeOperation='lighter';
        ctx.fillStyle=scan;
        ctx.fillRect(-padW/2,-padH/2,padW,padH);
        ctx.globalCompositeOperation='source-over';
        ctx.restore();
        drawPadShape();
        ctx.lineWidth=Math.max(1.4,2.2*scaleUnit);
        ctx.strokeStyle=`rgba(0,255,210,${0.35+0.25*pulse})`;
        ctx.stroke();
        drawPadShape();
        ctx.lineWidth=Math.max(0.8,1.2*scaleUnit);
        ctx.strokeStyle='rgba(0,80,60,0.55)';
        ctx.stroke();
      } else if(isPhantom){
        const shimmer=0.45+0.55*Math.sin(nowPad/220);
        const hueBase=(nowPad/900*180)%360;
        ctx.save();
        drawPadShape();
        ctx.clip();
        const aura=ctx.createRadialGradient(0,0,padH*0.18,0,0,padW*0.78);
        aura.addColorStop(0,'rgba(255,255,255,0.25)');
        aura.addColorStop(0.45,'rgba(255,255,255,0.1)');
        aura.addColorStop(1,'rgba(120,100,255,0.15)');
        ctx.globalCompositeOperation='lighter';
        ctx.fillStyle=aura;
        ctx.fillRect(-padW/2,-padH/2,padW,padH);
        ctx.globalCompositeOperation='source-over';
        const stripeSpacing=Math.max(22*scaleUnit,padW/8);
        ctx.lineWidth=Math.max(2.2,3*scaleUnit);
        for(let i=-padW;i<=padW;i+=stripeSpacing){
          const alpha=0.08+0.08*Math.sin(nowPad/180+i*0.08);
          ctx.strokeStyle=`rgba(255,255,255,${alpha})`;
          ctx.beginPath();
          ctx.moveTo(i-padH/2,-padH/2);
          ctx.lineTo(i+padH/2,padH/2);
          ctx.stroke();
        }
        const ribbonCount=4;
        for(let i=0;i<ribbonCount;i++){
          const offset=((nowPad/1400)+i*0.25)%1;
          const centerX=-padW/2+offset*padW;
          const width=Math.max(padW*0.08,16*scaleUnit);
          const ribbon=ctx.createLinearGradient(centerX-width,-padH/2,centerX+width,padH/2);
          ribbon.addColorStop(0,'rgba(255,255,255,0)');
          ribbon.addColorStop(0.5,`hsla(${(hueBase+i*80)%360},100%,70%,${0.28+0.18*shimmer})`);
          ribbon.addColorStop(1,'rgba(255,255,255,0)');
          ctx.globalCompositeOperation='lighter';
          ctx.fillStyle=ribbon;
          ctx.fillRect(-padW/2,-padH/2,padW,padH);
        }
        ctx.globalCompositeOperation='source-over';
        ctx.restore();
        drawPadShape();
        ctx.lineWidth=Math.max(1.6,2.4*scaleUnit);
        ctx.strokeStyle=`rgba(255,255,255,${0.55+0.25*shimmer})`;
        ctx.stroke();
        drawPadShape();
        ctx.lineWidth=Math.max(2.4,3.2*scaleUnit);
        ctx.strokeStyle=`hsla(${(hueBase+220)%360},80%,60%,${0.3+0.25*shimmer})`;
        ctx.stroke();
      } else if(isCosmos){
        const glow=0.52+0.32*Math.sin(nowPad/320);
        ctx.save();
        drawPadShape();
        ctx.clip();
        const body=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        body.addColorStop(0,'#fbfdff');
        body.addColorStop(0.24,'#e6eaf4');
        body.addColorStop(0.52,'#cdd4e4');
        body.addColorStop(0.76,'#e4e8f4');
        body.addColorStop(1,'#f9fbff');
        ctx.fillStyle=body;
        ctx.fillRect(-padW/2,-padH/2,padW,padH);
        const keel=ctx.createLinearGradient(-padW/2,0,padW/2,0);
        keel.addColorStop(0,'rgba(80,100,150,0.08)');
        keel.addColorStop(0.5,'rgba(120,150,200,0.38)');
        keel.addColorStop(1,'rgba(80,100,150,0.08)');
        const keelWidth=Math.max(padW*0.08,18*scaleUnit);
        ctx.fillStyle=keel;
        ctx.fillRect(-keelWidth/2,-padH/2,keelWidth,padH);
        const panelCount=Math.max(4,Math.round(padW/(72*scaleUnit)));
        ctx.lineWidth=Math.max(1.1,1.6*scaleUnit);
        ctx.strokeStyle='rgba(120,140,170,0.26)';
        for(let i=1;i<panelCount;i++){
          const x=-padW/2+(padW/panelCount)*i;
          ctx.beginPath();
          ctx.moveTo(x,-padH/2);
          ctx.lineTo(x,padH/2);
          ctx.stroke();
        }
        const windowRows=Math.max(1,Math.round(padH/(36*scaleUnit)));
        const windowCols=Math.max(3,Math.round(padW/(78*scaleUnit)));
        const windowR=Math.min(7.5*scaleUnit,padH*0.18);
        ctx.fillStyle=`rgba(150,190,255,${0.25+0.18*glow})`;
        ctx.strokeStyle='rgba(50,70,110,0.48)';
        ctx.lineWidth=Math.max(0.9,1.2*scaleUnit);
        for(let r=0;r<windowRows;r++){
          const y=-padH/2+(r+0.75)*(padH/(windowRows+1));
          for(let c=0;c<windowCols;c++){
            const x=-padW/2+(c+0.5)*(padW/windowCols);
            ctx.beginPath();
            ctx.arc(x,y,windowR,0,Math.PI*2);
            ctx.fill();
            ctx.stroke();
          }
        }
        const rivetSpacing=Math.max(36*scaleUnit,padW/6);
        ctx.fillStyle='rgba(200,210,225,0.65)';
        ctx.strokeStyle='rgba(80,90,120,0.42)';
        ctx.lineWidth=Math.max(0.7,1*scaleUnit);
        for(let x=-padW/2+rivetSpacing/2; x<=padW/2-rivetSpacing/2; x+=rivetSpacing){
          for(const y of [-padH/2+4*scaleUnit,padH/2-4*scaleUnit]){
            ctx.beginPath();
            ctx.arc(x,y,Math.max(1.5,2.2*scaleUnit),0,Math.PI*2);
            ctx.fill();
            ctx.stroke();
          }
        }
        const seam=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        seam.addColorStop(0,'rgba(160,170,190,0.18)');
        seam.addColorStop(0.5,'rgba(210,220,240,0.3)');
        seam.addColorStop(1,'rgba(160,170,190,0.18)');
        ctx.fillStyle=seam;
        ctx.fillRect(-padW/2,-padH*0.08,padW,padH*0.16);
        ctx.restore();
        drawPadShape();
        ctx.lineWidth=Math.max(1.4,2.1*scaleUnit);
        ctx.strokeStyle=`rgba(120,150,190,${0.35+0.2*glow})`;
        ctx.stroke();
        drawPadShape();
        ctx.lineWidth=Math.max(0.9,1.3*scaleUnit);
        ctx.strokeStyle='rgba(255,255,255,0.45)';
        ctx.stroke();
        const jetWidth=isVerticalAxis?Math.min(padW*0.58,30*scaleUnit):Math.min(padH*0.76,30*scaleUnit);
        const jetLengthBase=Math.min((isVerticalAxis?padH:padW)*0.26,58*scaleUnit);
        const jetOffset=2.6*scaleUnit;
        const leftIntensity=Math.max(0,Math.min(1,axisDelta/6));
        const rightIntensity=Math.max(0,Math.min(1,-axisDelta/6));
        const drawJetAura=(dir,intensity)=>{
          if(intensity <= 0) return;
          const glow=0.2+0.8*intensity;
          ctx.save();
          if(isVerticalAxis){ ctx.translate(0,dir*(padH/2+jetOffset)); }
          else { ctx.translate(dir*(padW/2+jetOffset),0); }
          ctx.globalCompositeOperation='lighter';
          const radiusX=isVerticalAxis?jetWidth*(0.64+0.32*glow):jetWidth*(0.9+0.35*glow);
          const radiusY=isVerticalAxis?jetWidth*(0.92+0.36*glow):jetWidth*(0.56+0.28*glow);
          const grad=ctx.createRadialGradient(0,0,Math.min(radiusX,radiusY)*0.35,0,0,Math.max(radiusX,radiusY));
          grad.addColorStop(0,`rgba(230,240,255,${0.35+0.4*glow})`);
          grad.addColorStop(0.6,`rgba(150,190,255,${0.28+0.35*glow})`);
          grad.addColorStop(1,'rgba(40,30,90,0)');
          ctx.fillStyle=grad;
          ctx.beginPath();
          ctx.ellipse(0,0,radiusX,radiusY,0,0,Math.PI*2);
          ctx.fill();
          ctx.restore();
        };
        const drawJetTrail=(dir,active,intensity)=>{
          if(!active||intensity<=0) return;
          const flicker=0.7+0.3*Math.sin(nowPad/120+dir*1.6);
          const length=jetLengthBase*(0.95+0.75*intensity*flicker);
          ctx.save();
          if(isVerticalAxis){ ctx.translate(0,dir*(padH/2+jetOffset)); }
          else { ctx.translate(dir*(padW/2+jetOffset),0); }
          ctx.globalCompositeOperation='lighter';
          ctx.beginPath();
          if(isVerticalAxis){
            ctx.moveTo(-jetWidth*0.3,0);
            ctx.quadraticCurveTo(0,dir*length*0.32,0,dir*length);
            ctx.quadraticCurveTo(0,dir*length*0.32,jetWidth*0.3,0);
          } else {
            ctx.moveTo(0,-jetWidth*0.32);
            ctx.quadraticCurveTo(dir*length*0.32,-jetWidth*0.18,dir*length,0);
            ctx.quadraticCurveTo(dir*length*0.32,jetWidth*0.18,0,jetWidth*0.32);
          }
          const grad=isVerticalAxis?ctx.createLinearGradient(0,0,0,dir*length):ctx.createLinearGradient(0,0,dir*length,0);
          grad.addColorStop(0,`rgba(240,246,255,${0.5+0.28*intensity})`);
          grad.addColorStop(0.35,`rgba(170,210,255,${0.6+0.28*intensity})`);
          grad.addColorStop(0.7,`rgba(110,140,255,${0.52+0.26*intensity})`);
          grad.addColorStop(1,'rgba(30,20,90,0)');
          ctx.fillStyle=grad;
          ctx.shadowColor=`rgba(160,200,255,${0.36+0.4*intensity})`;
          ctx.shadowBlur=26*(0.7+0.6*intensity);
          ctx.fill();
          const sparkCount=Math.max(4,Math.round(6+8*intensity));
          ctx.fillStyle=`rgba(220,235,255,${0.32+0.28*intensity})`;
          for(let i=0;i<sparkCount;i++){
            const animated=(i+(nowPad/160)+dir*0.35)/sparkCount;
            const t=animated-Math.floor(animated);
            const fade=Math.pow(1-t,0.6);
            const along=length*(0.25+0.7*t);
            const sway=Math.sin(nowPad/140+i*1.8)*jetWidth*0.22*fade;
            if(isVerticalAxis){
              ctx.beginPath();
              ctx.arc(sway,dir*along,Math.max(0.8,1.4*scaleUnit*fade*(0.6+0.8*intensity)),0,Math.PI*2);
              ctx.fill();
            } else {
              ctx.beginPath();
              ctx.arc(dir*along,sway,Math.max(0.8,1.4*scaleUnit*fade*(0.6+0.8*intensity)),0,Math.PI*2);
              ctx.fill();
            }
          }
          ctx.restore();
        };
        drawJetAura(-1,leftIntensity);
        drawJetAura(1,rightIntensity);
        drawJetTrail(-1,axisDelta>0.2,leftIntensity);
        drawJetTrail(1,axisDelta<-0.2,rightIntensity);
      } else if(isSolar){
        const pulse=0.55+0.45*Math.sin(nowPad/360);
        ctx.save();
        drawPadShape();
        ctx.clip();
        const crust=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        crust.addColorStop(0,'rgba(30,10,0,0.68)');
        crust.addColorStop(0.4,'rgba(70,22,0,0.42)');
        crust.addColorStop(1,'rgba(26,6,0,0.58)');
        ctx.fillStyle=crust;
        ctx.fillRect(-padW/2,-padH/2,padW,padH);
        const streams=Math.max(4,Math.round(padW/(74*scaleUnit)));
        const phase=(nowPad/4200)%1;
        for(let i=-1;i<=streams;i++){
          const offset=(phase+i/streams+1)%1;
          const center=-padW/2+offset*padW;
          const width=Math.max(padW*0.12,22*scaleUnit);
          const amplitude=Math.max(padW*0.05,16*scaleUnit);
          const segments=14;
          ctx.beginPath();
          for(let s=0;s<=segments;s++){
            const t=s/segments;
            const y=-padH/2+t*padH;
            const wobble=Math.sin((t*4+offset*2*Math.PI))*amplitude;
            const x=center+wobble-width/2;
            if(s===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          for(let s=segments;s>=0;s--){
            const t=s/segments;
            const y=-padH/2+t*padH;
            const wobble=Math.sin((t*4+offset*2*Math.PI))*amplitude;
            const x=center+wobble+width/2;
            ctx.lineTo(x,y);
          }
          ctx.closePath();
          const lava=ctx.createLinearGradient(center-width/2,-padH/2,center+width/2,padH/2);
          lava.addColorStop(0,'rgba(255,110,28,0.62)');
          lava.addColorStop(0.45,`rgba(255,190,70,${0.62+0.2*pulse})`);
          lava.addColorStop(1,'rgba(220,40,0,0.58)');
          ctx.globalCompositeOperation='lighter';
          ctx.fillStyle=lava;
          ctx.fill();
        }
        ctx.globalCompositeOperation='source-over';
        const emberCount=Math.max(18,Math.round(padW/(16*scaleUnit)));
        ctx.fillStyle=`rgba(255,210,130,${0.18+0.12*pulse})`;
        for(let i=0;i<emberCount;i++){
          const shift=(phase*1.3 + i/emberCount)%1;
          const x=-padW/2+shift*padW;
          const y=-padH/2+((i*37)%emberCount)/emberCount*padH;
          const r=Math.max(1.1,1.6*scaleUnit*(0.6+0.4*Math.sin(nowPad/240+i)));
          ctx.beginPath();
          ctx.arc(x,y,r,0,Math.PI*2);
          ctx.fill();
        }
        const hazeLayers=3;
        for(let h=0;h<hazeLayers;h++){
          const waveOffset=((nowPad/2600)+h*0.22)%1;
          const y=-padH/2 - (h+1)*Math.max(6*scaleUnit,4);
          const height=Math.max(10*scaleUnit,12);
          const width=padW*1.05;
          ctx.save();
          ctx.translate(-padW/2,y);
          ctx.beginPath();
          const crestCount=6;
          for(let s=0;s<=crestCount;s++){
            const t=s/crestCount;
            const wave=Math.sin((t+waveOffset)*Math.PI*2)*Math.max(6*scaleUnit,4);
            const px=t*width;
            if(s===0) ctx.moveTo(px,wave);
            else ctx.lineTo(px,wave);
          }
          for(let s=crestCount;s>=0;s--){
            const t=s/crestCount;
            const wave=Math.sin((t+waveOffset)*Math.PI*2)*Math.max(6*scaleUnit,4);
            const px=t*width;
            ctx.lineTo(px,wave+height);
          }
          ctx.closePath();
          const hazeGrad=ctx.createLinearGradient(0,0,0,height);
          hazeGrad.addColorStop(0,`rgba(255,200,150,${0.16-0.04*h})`);
          hazeGrad.addColorStop(1,'rgba(255,200,150,0)');
          ctx.globalCompositeOperation='screen';
          ctx.fillStyle=hazeGrad;
          ctx.fill();
          ctx.restore();
        }
        const steamCount=Math.max(5,Math.round(padW/(120*scaleUnit)));
        ctx.globalCompositeOperation='lighter';
        for(let s=0;s<steamCount;s++){
          const drift=((nowPad/5200)+s/steamCount)%1;
          const sx=-padW/2+drift*padW;
          const sy=-padH/2- Math.max(22*scaleUnit,18);
          const sr=Math.max(10*scaleUnit,12);
          const sg=ctx.createRadialGradient(sx,sy,0,sx,sy,sr*1.4);
          sg.addColorStop(0,'rgba(255,230,200,0.22)');
          sg.addColorStop(1,'rgba(255,230,200,0)');
          ctx.beginPath();
          ctx.fillStyle=sg;
          ctx.arc(sx,sy,sr,0,Math.PI*2);
          ctx.fill();
        }
        ctx.globalCompositeOperation='source-over';
        const sheen=ctx.createLinearGradient(-padW/2,-padH/2,padW/2,padH/2);
        sheen.addColorStop(0,'rgba(255,255,255,0.08)');
        sheen.addColorStop(0.5,'rgba(255,230,170,0.24)');
        sheen.addColorStop(1,'rgba(120,30,0,0.18)');
        ctx.fillStyle=sheen;
        ctx.fillRect(-padW/2,-padH/2,padW,padH);
        ctx.restore();
        drawPadShape();
        ctx.lineWidth=Math.max(1.6,2.2*scaleUnit);
        ctx.strokeStyle=`rgba(255,170,70,${0.45+0.3*pulse})`;
        ctx.stroke();
        drawPadShape();
        ctx.lineWidth=Math.max(1,1.4*scaleUnit);
        ctx.strokeStyle='rgba(60,10,0,0.65)';
        ctx.stroke();
      } else if(isGear){
        const pulse=0.45+0.55*Math.sin(nowPad/360);
        ctx.save();
        drawPadShape();
        ctx.clip();
        const oak=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        oak.addColorStop(0,'#2d1c12');
        oak.addColorStop(0.4,'#4a2e18');
        oak.addColorStop(1,'#201309');
        ctx.fillStyle=oak;
        ctx.fillRect(-padW/2,-padH/2,padW,padH);
        const brassInset=Math.max(6*scaleUnit,padH*0.12);
        const brassWidth=padW- brassInset*2;
        const brassHeight=padH- brassInset*2;
        ctx.save();
        ctx.translate(-padW/2+brassInset,-padH/2+brassInset);
        const brass=ctx.createLinearGradient(0,0,brassWidth,brassHeight);
        brass.addColorStop(0,'#3b2a18');
        brass.addColorStop(0.18,'#7a5322');
        brass.addColorStop(0.52,'#c89a45');
        brass.addColorStop(0.85,'#f3da9c');
        brass.addColorStop(1,'#8a642b');
        ctx.fillStyle=brass;
        ctx.fillRect(0,0,brassWidth,brassHeight);
        const crossBeam=ctx.createLinearGradient(0,0,brassWidth,0);
        crossBeam.addColorStop(0,'rgba(120,80,40,0.4)');
        crossBeam.addColorStop(0.5,'rgba(250,210,140,0.38)');
        crossBeam.addColorStop(1,'rgba(120,80,40,0.4)');
        ctx.fillStyle=crossBeam;
        ctx.fillRect(0,brassHeight*0.46,brassWidth,brassHeight*0.08);
        ctx.restore();
        const brushed=ctx.createLinearGradient(-padW/2,0,padW/2,0);
        brushed.addColorStop(0,'rgba(200,160,90,0.26)');
        brushed.addColorStop(0.45,'rgba(255,220,150,0.32)');
        brushed.addColorStop(1,'rgba(120,80,45,0.28)');
        ctx.fillStyle=brushed;
        ctx.fillRect(-padW/2,-padH/2,padW,padH);
        const brushLines=Math.max(12,Math.round(padH/(6*scaleUnit)));
        ctx.fillStyle='rgba(255,255,255,0.04)';
        for(let i=0;i<brushLines;i++){
          const y=-padH/2+(i/brushLines)*padH;
          ctx.fillRect(-padW/2,y,padW,Math.max(0.7,scaleUnit));
        }
        const frameCount=Math.max(3,Math.round(padW/(90*scaleUnit)));
        ctx.strokeStyle='rgba(50,38,20,0.62)';
        ctx.lineWidth=Math.max(1.2,1.8*scaleUnit);
        for(let i=1;i<frameCount;i++){
          const x=-padW/2+(padW/frameCount)*i;
          ctx.beginPath();
          ctx.moveTo(x,-padH/2);
          ctx.lineTo(x,padH/2);
          ctx.stroke();
        }
        const gearCount=Math.max(2,Math.round(padW/(170*scaleUnit)));
        for(let g=0; g<gearCount; g++){
          const cx=-padW/2+(g+0.5)*(padW/gearCount);
          const cy=0;
          const r=Math.min(padH*0.32,22*scaleUnit);
          const teeth=12;
          ctx.beginPath();
          for(let t=0;t<teeth;t++){
            const angle=(t/teeth)*Math.PI*2;
            const radius=t%2===0?r*1.18:r;
            const x=cx+Math.cos(angle)*radius;
            const y=cy+Math.sin(angle)*radius;
            if(t===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.closePath();
          const gearGrad=ctx.createRadialGradient(cx,cy,r*0.2,cx,cy,r*1.2);
          gearGrad.addColorStop(0,'#f5e4b6');
          gearGrad.addColorStop(0.45,'#d2b06b');
          gearGrad.addColorStop(1,'#7a5c32');
          ctx.fillStyle=gearGrad;
          ctx.fill();
          ctx.strokeStyle='rgba(40,30,18,0.62)';
          ctx.lineWidth=Math.max(1.1,1.6*scaleUnit);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx,cy,r*0.42,0,Math.PI*2);
          const axle=ctx.createRadialGradient(cx,cy,0,cx,cy,r*0.5);
          axle.addColorStop(0,'#fff5d2');
          axle.addColorStop(1,'#a27c3e');
          ctx.fillStyle=axle;
          ctx.fill();
          ctx.strokeStyle='rgba(60,40,20,0.65)';
          ctx.lineWidth=Math.max(0.9,1.3*scaleUnit);
          ctx.stroke();
        }
        const beamCount=3;
        ctx.strokeStyle='rgba(130,90,44,0.75)';
        ctx.lineWidth=Math.max(1.4,2.2*scaleUnit);
        for(let b=0;b<beamCount;b++){
          const y=-padH/2+(b+0.3)*(padH/(beamCount+0.2));
          ctx.beginPath();
          ctx.moveTo(-padW/2,y);
          ctx.lineTo(padW/2,y-padH*0.03);
          ctx.stroke();
        }
        const pipeCount=2;
        for(let p=0;p<pipeCount;p++){
          const py=-padH/2+padH*(0.25+p*0.4);
          const pipeGrad=ctx.createLinearGradient(-padW/2,py,padW/2,py);
          pipeGrad.addColorStop(0,'#271a10');
          pipeGrad.addColorStop(0.4,'#8c5c26');
          pipeGrad.addColorStop(0.6,'#d4a85a');
          pipeGrad.addColorStop(1,'#3a2614');
          ctx.strokeStyle=pipeGrad;
          ctx.lineWidth=Math.max(3.6,5.2*scaleUnit);
          ctx.beginPath();
          ctx.moveTo(-padW/2+padW*0.05,py);
          ctx.lineTo(padW/2-padW*0.05,py-padH*0.02);
          ctx.stroke();
          ctx.strokeStyle='rgba(255,230,190,0.25)';
          ctx.lineWidth=Math.max(1,1.6*scaleUnit);
          ctx.beginPath();
          ctx.moveTo(-padW/2+padW*0.05,py-1.5*scaleUnit);
          ctx.lineTo(padW/2-padW*0.05,py-padH*0.02-1.5*scaleUnit);
          ctx.stroke();
        }
        const rivetGap=Math.max(32*scaleUnit,padW/7);
        ctx.fillStyle='rgba(255,220,150,0.8)';
        ctx.strokeStyle='rgba(70,50,25,0.6)';
        ctx.lineWidth=Math.max(0.9,1.2*scaleUnit);
        for(let x=-padW/2+rivetGap/2; x<=padW/2-rivetGap/2; x+=rivetGap){
          for(const y of [-padH/2+6*scaleUnit,padH/2-6*scaleUnit]){
            ctx.beginPath();
            ctx.arc(x,y,Math.max(1.6,2.4*scaleUnit),0,Math.PI*2);
            ctx.fill();
            ctx.stroke();
          }
        }
        ctx.restore();
        drawPadShape();
        ctx.lineWidth=Math.max(1.8,2.4*scaleUnit);
        ctx.strokeStyle=`rgba(255,220,150,${0.48+0.22*pulse})`;
        ctx.stroke();
        drawPadShape();
        ctx.lineWidth=Math.max(1,1.4*scaleUnit);
        ctx.strokeStyle='rgba(40,28,14,0.65)';
        ctx.stroke();
      } else if(isAurora){
        const frost=0.55+0.45*Math.sin(nowPad/340);
        ctx.save();
        drawPadShape();
        ctx.clip();
        const sheenCount=3;
        for(let i=0;i<sheenCount;i++){
          const offset=((nowPad/1800)+i*0.33)%1;
          const center=-padW/2+offset*padW;
          const width=Math.max(padW*0.14,22*scaleUnit);
          const aurora=ctx.createLinearGradient(center-width,-padH/2,center+width,padH/2);
          aurora.addColorStop(0,'rgba(255,255,255,0)');
          aurora.addColorStop(0.5,`rgba(190,240,255,${0.18+0.18*frost})`);
          aurora.addColorStop(1,'rgba(255,255,255,0)');
          ctx.globalCompositeOperation='lighter';
          ctx.fillStyle=aurora;
          ctx.fillRect(-padW/2,-padH/2,padW,padH);
        }
        ctx.globalCompositeOperation='source-over';
        const shimmer=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        shimmer.addColorStop(0,'rgba(255,255,255,0.4)');
        shimmer.addColorStop(0.4,'rgba(180,220,255,0.1)');
        shimmer.addColorStop(1,'rgba(100,150,200,0.18)');
        ctx.fillStyle=shimmer;
        ctx.fillRect(-padW/2,-padH/2,padW,padH);
        ctx.lineWidth=Math.max(1.1,1.5*scaleUnit);
        ctx.strokeStyle='rgba(220,240,255,0.25)';
        ctx.beginPath();
        ctx.moveTo(-padW*0.35,padH/2);
        ctx.lineTo(-padW*0.15,padH*0.1);
        ctx.lineTo(-padW*0.05,-padH*0.25);
        ctx.lineTo(padW*0.18,-padH*0.35);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(padW*0.4,padH/2);
        ctx.lineTo(padW*0.2,padH*0.15);
        ctx.lineTo(padW*0.32,-padH*0.18);
        ctx.stroke();
        ctx.restore();
        drawPadShape();
        ctx.lineWidth=Math.max(1.6,2.3*scaleUnit);
        ctx.strokeStyle=`rgba(220,240,255,${0.5+0.25*frost})`;
        ctx.stroke();
        drawPadShape();
        ctx.lineWidth=Math.max(0.9,1.4*scaleUnit);
        ctx.strokeStyle='rgba(120,180,220,0.4)';
        ctx.stroke();
      }
      const platformHighlight=Math.max(0, Math.min(1, demonBladeHellPlatformGlow||0));
      if(platformHighlight>0){
        ctx.save();
        drawPadShape();
        ctx.clip();
        const sheen=ctx.createLinearGradient(-padW/2, -padH/2, padW/2, padH/2);
        sheen.addColorStop(0,`rgba(255,230,240,${0.12+0.18*platformHighlight})`);
        sheen.addColorStop(0.5,`rgba(255,170,210,${0.2+0.28*platformHighlight})`);
        sheen.addColorStop(1,`rgba(255,255,255,${0.12+0.2*platformHighlight})`);
        ctx.globalCompositeOperation='screen';
        ctx.fillStyle=sheen;
        ctx.fillRect(-padW/2, -padH/2, padW, padH);
        const rim=ctx.createLinearGradient(0,-padH/2,0,padH/2);
        rim.addColorStop(0,`rgba(255,200,220,${0.35*platformHighlight})`);
        rim.addColorStop(1,`rgba(255,120,160,${0.4*platformHighlight})`);
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle=rim;
        ctx.lineWidth=Math.max(2.2, 4.2*platformHighlight)*scaleUnit;
        drawPadShape();
        ctx.stroke();
        ctx.restore();
      }
      const shieldActive=shieldState.active && nowPad<shieldState.until;
      if(shieldActive){
        const remain=Math.max(0, shieldState.until-nowPad);
        const fade=Math.min(1, remain/600);
        const activatedAt=shieldState.activatedAt||nowPad;
        const duration=Math.max(1, shieldState.duration|| (shieldState.until-activatedAt));
        const elapsed=Math.max(0, nowPad-activatedAt);
        const progress=Math.max(0, Math.min(1, elapsed/duration));
        const pulse=0.62+0.38*Math.sin(nowPad/160);
        const absorbBoost=Math.max(0, 1-Math.min(1,(nowPad-lastShieldAbsorbAt)/320));
        const intensity=Math.min(1, (pulse*0.6 + absorbBoost*0.8 + (1-progress)*0.3)*fade);
        const padLength=isVerticalAxis?padH:padW;
        const padThickness=isVerticalAxis?padW:padH;
        const dirX=orientLeft?1:0;
        const dirY=orientLeft?0:-1;
        const currentAngle=Math.atan2(dirY,dirX);
        const targetAngle=-Math.PI/2;
        const rotateAngle=targetAngle-currentAngle;
        const baseRadius=Math.max(padLength,padThickness)*0.5;
        const shieldRadius=baseRadius + Math.max(36*scaleUnit, padLength*0.2 + padThickness*0.65);
        const innerRadius=Math.max(baseRadius + Math.max(10*scaleUnit, padThickness*0.25), shieldRadius*0.72);
        const auraRadius=shieldRadius*1.18;
        const coreRadius=Math.max(innerRadius*0.55, baseRadius*0.6);
        ctx.save();
        ctx.rotate(rotateAngle);
        ctx.globalCompositeOperation='lighter';
        const aura=ctx.createRadialGradient(0,0,coreRadius*0.6,0,0,auraRadius);
        aura.addColorStop(0,`rgba(180,255,255,${0.1+0.22*intensity})`);
        aura.addColorStop(0.45,`rgba(120,220,255,${0.16+0.24*intensity})`);
        aura.addColorStop(1,'rgba(120,220,255,0)');
        ctx.fillStyle=aura;
        ctx.beginPath();
        ctx.arc(0,0,auraRadius,0,Math.PI*2);
        ctx.fill();
        const shell=ctx.createRadialGradient(0,0,innerRadius*0.75,0,0,shieldRadius);
        shell.addColorStop(0,`rgba(225,255,255,${0.32+0.22*intensity})`);
        shell.addColorStop(0.5,`rgba(160,235,255,${0.2+0.25*intensity})`);
        shell.addColorStop(1,`rgba(120,210,255,${0.1+0.2*intensity})`);
        ctx.fillStyle=shell;
        ctx.beginPath();
        ctx.arc(0,0,shieldRadius,0,Math.PI*2);
        ctx.fill();
        const innerGlow=ctx.createRadialGradient(0,0,coreRadius*0.4,0,0,innerRadius);
        innerGlow.addColorStop(0,`rgba(220,255,255,${0.2+0.24*intensity})`);
        innerGlow.addColorStop(0.7,`rgba(150,230,255,${0.12+0.2*intensity})`);
        innerGlow.addColorStop(1,'rgba(150,230,255,0)');
        ctx.fillStyle=innerGlow;
        ctx.beginPath();
        ctx.arc(0,0,innerRadius,0,Math.PI*2);
        ctx.fill();
        ctx.lineWidth=Math.max(2.2,3.6*scaleUnit);
        ctx.strokeStyle=`rgba(205,245,255,${0.34+0.36*intensity})`;
        ctx.beginPath();
        ctx.arc(0,0,shieldRadius*0.98,0,Math.PI*2);
        ctx.stroke();
        ctx.lineWidth=Math.max(1.2,2.2*scaleUnit);
        ctx.strokeStyle=`rgba(90,210,255,${0.24+0.3*intensity})`;
        ctx.beginPath();
        ctx.arc(0,0,innerRadius,0,Math.PI*2);
        ctx.stroke();
        const swirlCount=5;
        for(let arcIdx=0; arcIdx<swirlCount; arcIdx++){
          const swirlPhase=((nowPad/900)+arcIdx/swirlCount+progress*0.3)%1;
          const swirlAngle=swirlPhase*Math.PI*2;
          const swirlSpread=Math.PI/18 + Math.PI/24*intensity;
          const swirlRadius=innerRadius*0.55 + Math.sin(nowPad/320+arcIdx*1.7)*innerRadius*0.08;
          ctx.lineWidth=Math.max(0.8,1.3*scaleUnit);
          ctx.strokeStyle=`rgba(210,255,255,${0.18+0.18*intensity})`;
          ctx.beginPath();
          ctx.arc(0,0,swirlRadius,swirlAngle-swirlSpread,swirlAngle+swirlSpread);
          ctx.stroke();
        }
        const rayCount=8;
        for(let i=0;i<rayCount;i++){
          const rayPhase=((nowPad/1200)+i/rayCount)%1;
          const rayAngle=rayPhase*Math.PI*2;
          const rayWidth=Math.max(0.7,1.4*scaleUnit);
          const rayLength=shieldRadius*1.12;
          const rayAlpha=0.08+0.14*intensity;
          ctx.save();
          ctx.rotate(rayAngle);
          const ray=ctx.createLinearGradient(0,0,0,-rayLength);
          ray.addColorStop(0,`rgba(150,220,255,${rayAlpha})`);
          ray.addColorStop(0.45,`rgba(120,220,255,${rayAlpha*0.65})`);
          ray.addColorStop(1,'rgba(120,220,255,0)');
          ctx.fillStyle=ray;
          ctx.beginPath();
          ctx.moveTo(-rayWidth,0);
          ctx.lineTo(-rayWidth*0.2,-rayLength*0.45);
          ctx.lineTo(0,-rayLength);
          ctx.lineTo(rayWidth*0.2,-rayLength*0.45);
          ctx.lineTo(rayWidth,0);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        for(let i=shieldRipples.length-1;i>=0;i--){
          const ripple=shieldRipples[i];
          const age=nowPad-ripple.createdAt;
          if(age>SHIELD_RIPPLE_DURATION){
            shieldRipples.splice(i,1);
            continue;
          }
          const t=Math.max(0,Math.min(1,age/SHIELD_RIPPLE_DURATION));
          const strength=1-Math.pow(t,0.9);
          const phi=-Math.PI/2 + ripple.offset*(Math.PI*0.85);
          const waveSpread=Math.max(Math.PI/36, (Math.PI/12)*strength);
          const waveRadius=shieldRadius*(0.96+0.18*strength);
          ctx.save();
          ctx.rotate(phi);
          ctx.globalCompositeOperation='lighter';
          ctx.lineWidth=Math.max(1.5,3*scaleUnit*strength);
          ctx.strokeStyle=`rgba(225,255,255,${0.26+0.4*strength})`;
          ctx.beginPath();
          ctx.arc(0,0,waveRadius,-waveSpread,waveSpread);
          ctx.stroke();
          const burst=ctx.createLinearGradient(0,0,0,-shieldRadius*1.08);
          burst.addColorStop(0,'rgba(210,250,255,0)');
          burst.addColorStop(0.35,`rgba(210,250,255,${0.18+0.25*strength})`);
          burst.addColorStop(1,'rgba(210,250,255,0)');
          ctx.fillStyle=burst;
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.arc(0,0,shieldRadius*1.08,-waveSpread*1.2,waveSpread*1.2);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }

      if(buffs.HOLE.active){
        if(!orientLeft){ const gapW=padW/3; ctx.clearRect(-padW/2+padW/3, -padH/2, gapW, padH); }
        else { const gapH=padH/3; ctx.clearRect(-padW/2, -padH/2+padH/3, padW, gapH); }
      }
      ctx.restore();
      lastPaddleDrawState.axis=axisCenter;
      lastPaddleDrawState.time=nowPad;
      lastPaddleDrawState.vertical=isVerticalAxis;
      ctx.shadowBlur=0;
      if(nowPad<=paddleStunUntil){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(255,230,160,0.35)'; drawRoundedRect(pr.x,pr.y,pr.w,pr.h,8); ctx.fill(); ctx.restore(); }
    }
    else {
      lastPaddleDrawState.axis=null;
    }
    // 雷射砲展示
    if(buffs.LASER.active){ ctx.fillStyle='rgba(120,255,120,0.8)'; if(!orientLeft){ ctx.fillRect((pr.x-6)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); ctx.fillRect((pr.x+pr.w+2)*scaleX, (pr.y-4)*scaleY, 4*scaleX, (pr.h+8)*scaleY); } else { ctx.fillRect((pr.x-4)*scaleX, (pr.y-6)*scaleY, (pr.w+8)*scaleX, 4*scaleY); ctx.fillRect((pr.x-4)*scaleX, (pr.y+pr.h+2)*scaleY, (pr.w+8)*scaleX, 4*scaleY); } }
    if(stormTurret){ const t=stormTurret; ctx.save(); ctx.fillStyle='rgba(200,255,200,0.8)'; ctx.fillRect((t.x-10)*scaleX,(t.y-20)*scaleY,20*scaleX,20*scaleY); if(performance.now()<t.chargeUntil){ const prog=1-(t.chargeUntil-performance.now())/3000; ctx.globalCompositeOperation='lighter'; ctx.fillStyle=`rgba(120,255,200,${0.3+0.7*prog})`; ctx.beginPath(); ctx.arc(t.x*scaleX,(t.y-20)*scaleY,30*prog*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); } ctx.restore(); }
    if(gatling){
      const t=gatling;
      ctx.save();
      const grad=ctx.createLinearGradient((t.x-8)*scaleX,(t.y-20)*scaleY,(t.x+8)*scaleX,t.y*scaleY);
      grad.addColorStop(0,'#444');
      grad.addColorStop(0.5,'#bbb');
      grad.addColorStop(1,'#444');
      ctx.fillStyle=grad;
      ctx.fillRect((t.x-8)*scaleX,(t.y-20)*scaleY,16*scaleX,20*scaleY);
      ctx.fillStyle='#333';
      ctx.fillRect((t.x-3)*scaleX,(t.y-24)*scaleY,6*scaleX,4*scaleY);
      if(performance.now()<t.chargeUntil){
        const prog=1-(t.chargeUntil-performance.now())/(GAME_CONFIG.powers.GATLING.gatling.chargeMs||3000);
        ctx.globalCompositeOperation='lighter';
        ctx.fillStyle=`rgba(255,200,100,${0.3+0.7*prog})`;
        ctx.beginPath();
        ctx.arc(t.x*scaleX,(t.y-24)*scaleY,20*prog*((scaleX+scaleY)/2),0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    // 球與拖尾
    const nowT=performance.now();
    const bladeHellGlow=(demonAttackActive && demonAttackActive.type==='bladeHell') ? Math.max(0, Math.min(1, demonAttackActive.currentBallGlow||0)) : 0;
    for(const b of balls){
      b.trail.push({x:b.x,y:b.y,t:nowT}); while(b.trail.length>12) b.trail.shift();
      for(let i=b.trail.length-1;i>=0;i--){ const p=b.trail[i]; const age=(nowT-p.t)/200; if(age>1) continue; const alpha=(1-age)*0.6;
        let color=( (b.rampageUntil&&nowT<b.rampageUntil)||b.piercing )?`rgba(120,220,255,${alpha})`:(buffs.FAST.active?`rgba(255,140,90,${alpha})`:`rgba(255,255,255,${alpha*0.6})`);
        if(buffs.PLASMA.active) color=`rgba(160,240,255,${alpha})`; if(buffs.FREEZE.active) color=`rgba(200,230,255,${alpha})`; if(buffs.HOLY.active) color=`rgba(255,240,180,${alpha})`; if(buffs.FIRE.active) color=`rgba(255,150,50,${alpha})`; if(buffs.POISON.active) color=`rgba(120,255,120,${alpha})`; if(buffs.BLINK.active) color=`rgba(180,200,255,${alpha})`; if(buffs.SWORD.active) color=`rgba(${150+100*Math.sin(nowT/80)},${120+60*Math.sin(nowT/60)},255,${alpha})`; if(buffs.BLACKHOLE.active) color=`rgba(80,80,120,${alpha})`; if(buffs.ANNIHIL.active) color=`rgba(255,200,80,${alpha})`;
        if(buffs.TRACK.active) color=`rgba(${Math.floor(128+127*Math.sin(nowT/80))},${Math.floor(128+127*Math.sin(nowT/95+2))},${Math.floor(128+127*Math.sin(nowT/110+4))},${alpha})`;
        if(buffs.GODSPEED.active) color=`rgba(255,224,102,${alpha})`;
        ctx.fillStyle=color; ctx.beginPath(); ctx.arc(p.x*scaleX,p.y*scaleY,(b.r*0.7)*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill();
      }
      const bx=b.x*scaleX, by=b.y*scaleY, br=b.r*((scaleX+scaleY)/2); const grad=ctx.createRadialGradient(bx-3,by-4,2,bx,by,br);
      let edge=(b.piercing||(b.rampageUntil&&nowT<b.rampageUntil))?'#9ff':(buffs.FAST.active?'#ff9a66':'#cbd4ff');
      if(buffs.PLASMA.active) edge='#aff'; if(buffs.FREEZE.active) edge='#e8f8ff'; if(buffs.HOLY.active) edge='#fff0a0'; if(buffs.FIRE.active) edge='#ff6600'; if(buffs.POISON.active) edge='#55ff55'; if(buffs.BLINK.active) edge='#a0b0ff'; if(buffs.GODSPEED.active) edge='#ffe066'; if(buffs.SWORD.active) edge='#d0bbff'; if(buffs.BLACKHOLE.active) edge='#444'; if(buffs.ANNIHIL.active) edge='#ffb347';
      if(b.demonCloakState==='captured') edge='#ff758b';
      grad.addColorStop(0,'#fff'); grad.addColorStop(1, edge); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();
      if(bladeHellGlow>0){
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        const glow=ctx.createRadialGradient(bx,by,0,bx,by,br*2.6);
        glow.addColorStop(0,`rgba(255,240,180,${0.35*bladeHellGlow})`);
        glow.addColorStop(1,'rgba(255,200,60,0)');
        ctx.fillStyle=glow;
        ctx.beginPath();
        ctx.arc(bx,by,br*2.4,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      if(buffs.WAVY.active){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; const r1=br+2+2*Math.sin((nowT/100)+b.x*0.02); ctx.beginPath(); ctx.arc(bx,by,r1,0,Math.PI*2); ctx.stroke(); }
      if(b.stuck && !orientLeft){ ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect((paddle.x+paddle.w/2-12)*scaleX,(paddle.y-6)*scaleY,24*scaleX,4*scaleY); }
    }
    drawBladeHellBallCaptureOverlay(nowT);
    drawDemonCloakWraps(nowT,'front');

    // 黑洞特效
    for(let i=blackHoles.length-1;i>=0;i--){
      const h=blackHoles[i];
      const nowH=performance.now();
      if(nowH>h.until){ blackHoles.splice(i,1); continue; }
      if(h.spinPhase==null){ h.spinPhase=Math.random()*Math.PI*2; }
      const baseR=h.r||40;
      const start=h.start!=null?h.start:(h.until-600);
      const life=Math.max(1, h.until-start);
      const age=Math.max(0, Math.min(1, (nowH-start)/life));
      const spinDir=h.spinDir||1;
      const scaleAvg=(scaleX+scaleY)/2;
      const pulse=0.82+0.18*Math.sin(nowH/150 + h.spinPhase);
      const x=h.x*scaleX, y=h.y*scaleY;
      const coreR=baseR*scaleAvg*pulse;
      const coronaR=coreR*1.5;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      const grad=ctx.createRadialGradient(x,y,0,x,y,coronaR);
      grad.addColorStop(0,'rgba(5,0,10,0.96)');
      grad.addColorStop(0.32,`rgba(50,0,80,${0.92-0.25*age})`);
      grad.addColorStop(0.6,`rgba(140,70,220,${0.65-0.28*age})`);
      grad.addColorStop(0.86,'rgba(220,180,255,0.22)');
      grad.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=grad;
      ctx.beginPath();
      ctx.arc(x,y,coronaR,0,Math.PI*2);
      ctx.fill();
      const horizonR=coreR*1.18;
      ctx.strokeStyle=`rgba(220,190,255,${0.22+0.22*Math.sin(nowH/210 + age*Math.PI)})`;
      ctx.lineWidth=4*scaleAvg*(1-age*0.5);
      ctx.beginPath();
      ctx.arc(x,y,horizonR,0,Math.PI*2);
      ctx.stroke();
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate((nowH/240 + h.spinPhase)*spinDir);
      const swirlLayers=4;
      for(let layer=0; layer<swirlLayers; layer++){
        const theta=layer*(Math.PI/2);
        const rr=coreR*(0.46 + layer*0.12);
        ctx.beginPath();
        ctx.strokeStyle=`rgba(255,230,255,${0.14*(1-layer*0.18)})`;
        ctx.lineWidth=(1.6+layer*0.7)*scaleAvg;
        ctx.arc(0,0,rr,theta,theta+Math.PI*0.65);
        ctx.stroke();
      }
      ctx.restore();
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate((-nowH/320 + h.spinPhase*1.4)*spinDir);
      ctx.strokeStyle=`rgba(160,110,255,${0.2*(1-age)})`;
      ctx.lineWidth=3.6*scaleAvg;
      ctx.beginPath();
      ctx.arc(0,0,coreR*1.32,-Math.PI*0.35,Math.PI*0.35);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    
    // 雷射光束（強化質感）
    for(let i=laserBeams.length-1;i>=0;i--){
      const b=laserBeams[i];
      const nowP=performance.now();
      if(nowP>b.until){ laserBeams.splice(i,1); continue; }
      const x1=b.x1*scaleX, y1=b.y1*scaleY, x2=b.x2*scaleX, y2=b.y2*scaleY;
      const t = Math.max(0, Math.min(1, (b.until-nowP)/200));
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      // Outer glow
      ctx.strokeStyle='rgba(120,255,180,'+(0.25*t)+')';
      ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Mid beam
      const grd = ctx.createLinearGradient(x1,y1,x2,y2);
      grd.addColorStop(0,'rgba(160,255,220,'+(0.7*t)+')');
      grd.addColorStop(1,'rgba(255,255,255,'+(0.9*t)+')');
      ctx.strokeStyle=grd; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      // Core
      ctx.strokeStyle='rgba(255,255,255,'+(1*t)+')'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    }
    // Boss 投射物
    drawAndStepBossProjectiles();

    // 雷射命中散開特效
    for(let i=laserImpacts.length-1;i>=0;i--){
      const it=laserImpacts[i]; const nowI=performance.now();
      if(nowI>it.tEnd){ laserImpacts.splice(i,1); continue; }
      const prog = 1 - Math.max(0, (it.tEnd - nowI)/ (it.tEnd - it.t0));
      const x = it.x*scaleX, y = it.y*scaleY;
      // expanding ring
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='rgba(160,255,200,'+(0.8*(1-prog))+')';
      ctx.lineWidth = 2 + 6*prog;
      ctx.beginPath(); ctx.arc(x,y, 6 + 26*prog, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
      // sparks
      for(let s=0;s<6;s++){
        const ang = (s/6)*Math.PI*2;
        const len = 8 + prog*24;
        ctx.save(); ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle='rgba(180,255,220,'+(0.7*(1-prog))+')';
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(x,y);
        ctx.lineTo(x+Math.cos(ang)*len, y+Math.sin(ang)*len);
        ctx.stroke(); ctx.restore();
      }
    }
    // 火力壓制子彈
    for(const b of gatlingBullets){
      ctx.save();
      const r=4*((scaleX+scaleY)/2);
      const g=ctx.createRadialGradient(b.x*scaleX,b.y*scaleY,0,b.x*scaleX,b.y*scaleY,r);
      g.addColorStop(0,'#fff');
      g.addColorStop(0.3,'#ffec99');
      g.addColorStop(1,'#ff8800');
      ctx.fillStyle=g;
      ctx.shadowBlur=8*((scaleX+scaleY)/2);
      ctx.shadowColor='#ffb347';
      ctx.beginPath(); ctx.arc(b.x*scaleX,b.y*scaleY,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    // 飛彈
    for(const m of missiles){ for(const tr of (m.trail||[])){ const a=Math.max(0,1-(performance.now()-tr.t)/300); ctx.fillStyle=`rgba(255,180,90,${0.6*a})`; ctx.beginPath(); ctx.arc(tr.x*scaleX,tr.y*scaleY,2*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); } ctx.fillStyle='#ddd'; ctx.beginPath(); ctx.arc(m.x*scaleX,m.y*scaleY,4*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    // 掉落道具與銀幣
    for(const c of coins) drawCoin(c);
    for(const p of powerups) drawPower(p);

    // 鎖定框
    drawLockBoxes();

    // 粒子
    for(let i=particles.length-1;i>=0;i--){ const P=particles[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.98; P.vy*=0.98; P.life-=16; if(P.life<=0){ particles.splice(i,1); continue; }
      const a=Math.max(0, Math.min(1, P.life/500)); ctx.fillStyle=P.color||`rgba(255,220,180,${a*0.6})`; ctx.beginPath(); ctx.arc(P.x*scaleX,P.y*scaleY,P.size*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    drawSpaceBossHUD();
    drawReaperHUD();
    drawDragonHUD();
    drawDemonAbyssShatterLayer(now);
    drawDemonBladeHellLayer(now);
    drawDemonHUD();
    drawDemonInlineCountdown(now);
    drawDemonMarquee(now);

    // 倒數提示
    if(countdownShow>0){
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.font=`${Math.round(96*((scaleX+scaleY)/2))}px system-ui, sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(countdownShow), canvas.width/2, canvas.height/2);
      ctx.restore();
    }

    // 天地翻轉提示：啟動前 2 秒與結束前 2 秒顯示旋轉符號，不遮擋球/方塊/平台
    {
      const f = buffs.FLIP;
      const nowT = performance.now();
      let showFlip = false;
      if(f){
        if(f.pending && f.startAt && nowT >= f.startAt - 2000 && nowT < f.startAt){ showFlip = true; }
        if(f.active && f.endAt && nowT >= f.endAt - 2000 && nowT < f.endAt){ showFlip = true; }
      }
      if(showFlip){
        ctx.save();
        // 遮罩輕微暗化背景
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        // 畫旋轉符號（使用 Unicode 符號 ↻）
        ctx.fillStyle = '#aaffaa';
        ctx.font = `${Math.round(80*((scaleX+scaleY)/2))}px system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('↻', canvas.width/2, canvas.height/2);
        ctx.restore();
      }
      }

      if(darkDemonBlackoutUntil>now){
        const remain=Math.max(0,darkDemonBlackoutUntil-now);
        const alphaBase=Math.min(0.92, 0.68 + 0.24*Math.min(1, remain/1000));
        const flicker=0.04*Math.sin(now/90);
        const blackoutAlpha=Math.max(0.65, Math.min(0.95, alphaBase+flicker));
        ctx.save();
        ctx.fillStyle=`rgba(0,0,0,${blackoutAlpha})`;
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.globalCompositeOperation='lighter';
        const pulseStrength=Math.min(1, remain/800);
        ctx.fillStyle=`rgba(120,80,180,${0.08*pulseStrength})`;
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }

      if(screenShake>0){ ctx.restore(); }
  }

  function assignSwordTarget(s){
    if(!s) return false;
    const idx=randomBrick(true);
    if(idx==null) return false;
    if(idx==='boss'){
      if(!isSpecialBossActive()) return false;
      const center=activeBossCenter();
      if(!center) return false;
      const ang=Math.atan2(center.y-s.y, center.x-s.x);
      s.vx=Math.cos(ang)*8;
      s.vy=Math.sin(ang)*8;
      s.state='fire';
      s.target=idx;
      highlightSpaceBossTarget();
      return true;
    }
    const t=bricks[idx];
    if(!t) return false;
    const tx=t.x+t.w/2;
    const ty=t.y+t.h/2;
    const ang=Math.atan2(ty-s.y, tx-s.x);
    s.vx=Math.cos(ang)*8;
    s.vy=Math.sin(ang)*8;
    s.state='fire';
    s.target=idx;
    return true;
  }

  function drawSwords(){
    const now=performance.now();
    const pr=paddleRect();
    for(let i=swords.length-1;i>=0;i--){
      const s=swords[i];
      if(!s){
        swords.splice(i,1);
        continue;
      }
      if(s.state==='wander'){
        s.x+=s.vx;
        s.y+=s.vy;
        if(s.x<20||s.x>1080) s.vx*=-1;
        if(s.y<500||s.y>680) s.vy*=-1;
        if(!buffs.SWORD.active){
          s.state='gather';
          s.t0=now;
          const baseX=pr?pr.x+pr.w/2:550;
          const baseY=pr?pr.y-40:610;
          s.tx=baseX + (i-swords.length/2)*20;
          s.ty=baseY;
        }
      }else if(s.state==='gather'){
        if(!s.t0) s.t0=now;
        const prog=Math.min(1,(now-s.t0)/2000);
        s.x += (s.tx-s.x)*0.15;
        s.y += (s.ty-s.y)*0.15;
        if(prog>=1){
          s.state='ready';
          s.vx=0;
          s.vy=0;
        }
      }else if(s.state==='fire'){
        s.x+=s.vx;
        s.y+=s.vy;
        let hit=false;
        let impactX=s.x;
        let impactY=s.y;
        const idx=s.target;
        if(idx==='boss'){
          const bounds=getActiveBossBounds();
          if(!isSpecialBossActive() || !bounds){
            swords.splice(i,1);
            continue;
          }
          if(s.x>bounds.x && s.x<bounds.x+bounds.w && s.y>bounds.y && s.y<bounds.y+bounds.h){
            playSFX('sword');
            damageActiveBoss(1,'sword',{x:s.x,y:s.y});
            hit=true;
          }
        }else{
          const bk=bricks[idx];
          if(bk && s.x>bk.x && s.x<bk.x+bk.w && s.y>bk.y && s.y<bk.y+bk.h){
            playSFX('sword');
            impactX=bk.x+bk.w/2;
            impactY=bk.y+bk.h/2;
            damageBrick(idx,3,'none');
            hit=true;
          }
        }
        if(hit){
          if(equipmentSwordPlasma){
            spawnPlasmaBurst(impactX,impactY,{sound:false});
          }
          swords.splice(i,1);
          continue;
        }
        if(s.x<0||s.x>1100||s.y<0||s.y>700){
          swords.splice(i,1);
          continue;
        }
      }
      ctx.save();
      ctx.translate(s.x*scaleX, s.y*scaleY);
      ctx.rotate(Math.atan2(s.vy||0.1, s.vx||0.1));
      const bladeGrad = ctx.createLinearGradient(-12, 0, 14, 0);
      bladeGrad.addColorStop(0, '#fdfbff');
      bladeGrad.addColorStop(1, '#c8a8ff');
      ctx.fillStyle = bladeGrad;
      ctx.beginPath();
      ctx.moveTo(-12, -2);
      ctx.lineTo(14, 0);
      ctx.lineTo(-12, 2);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#b090ff';
      ctx.fillRect(-14, -3, 4, 6); // guard
      ctx.fillStyle = '#6c4bb3';
      ctx.fillRect(-18, -1, 4, 2); // handle
      ctx.restore();
    }
    if(!buffs.SWORD.active && swords.length && !swordFireStart){
      swordFireStart=now+2000;
      nextSwordFire=swordFireStart;
    }
    if(swordFireStart && now>=swordFireStart){
      if(now>=nextSwordFire){
        const s=swords.find(z=>z.state==='ready');
        if(s){
          assignSwordTarget(s);
        }
        nextSwordFire=now+300;
        if(!swords.some(z=>z.state==='ready')) swordFireStart=0;
      }
    }
  }

  function randomBrick(includeBoss=false){
    const arr=bricks.map((b,i)=>({b,i})).filter(x=>canDestroyBrick(x.b));
    if(includeBoss && isSpecialBossActive()){ arr.push({boss:true}); }
    if(!arr.length) return null;
    const r=arr[Math.floor(Math.random()*arr.length)];
    return r.boss ? 'boss' : r.i;
  }

  
  function speedForLevel(lv){
    // 更平滑的球速曲線：從 baseSpeed 緩慢增長到 +~3.2
    const base = getDiff().baseSpeed;
    const t = Math.max(0, Math.min(1, (lv-1)/(GAME_CONFIG.totalLevels-1)));
    const ease = t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2; // easeInOutQuad
    const extra = 0.6 + 2.6 * ease; // 0.6 -> 3.2
    return base + extra;
  }

  function paddleHitSpeedMul(lv){
    const maxLevel=20;
    const l=Math.min(Math.max(lv,1),maxLevel);
    const t=(l-1)/(maxLevel-1);
    return 1.04 + 0.02 * t; // 1.04 -> 1.06
  }

  function resetBalls(center=true){ balls=[makeBall(false)]; const base=getDiff().baseSpeed; const speed=speedForLevel(level); const angle=(-60-Math.random()*60)*Math.PI/180;
    balls[0].x=center?1100/2:paddle.x+paddle.w/2; balls[0].y=700-70; balls[0].vx=Math.cos(angle)*speed; balls[0].vy=Math.sin(angle)*speed; balls[0].piercing=buffs.PIERCE.active; }

  function startCountdown(restart=true){
    // 清除先前的倒數計時以避免在選單開啟時仍繼續倒數
    if(countdownTimer){ clearTimeout(countdownTimer); countdownTimer=null; }
    paused=true;
    if(restart || countdownShow<=0){ countdownShow=3; }
    showCenter('', ''); centerNote.style.display='none'; // 用畫面倒數
    resumePending=true;
    const tick=()=>{
      if(countdownShow<=0){
        resumePending=false; paused=false; stats.lifeStart=performance.now(); countdownTimer=null; return;
      }
      beep(600 + (3-countdownShow)*100, 0.07, 0.05);
      countdownTimer = setTimeout(()=>{ countdownShow--; tick(); }, 450);
    };
    tick();
  }


  function update(){
    const now=performance.now();
    updateShieldRuntime(now);
    checkEquipmentExpirations(now);
    updateBloodBladeState(now);
      updateBombDevil(now);
      updateFireScatter(now);
      refreshEquipmentRuntime(now);
      if(darkDemonPulses && darkDemonPulses.length){
        let executed=false;
        for(const pulse of darkDemonPulses){
          if(!pulse || pulse.executed) continue;
          if(now>=pulse.fireAt){
            triggerDarkDemonPulse(now,pulse);
            pulse.executed=true;
            executed=true;
          }
        }
        if(executed){
          darkDemonPulses=darkDemonPulses.filter(p=>p && !p.executed);
        }
      }
      if(gunDevilActiveUntil>0){
        if(now>=gunDevilActiveUntil){
          gunDevilActiveUntil=0;
          gunDevilNextShot=0;
        }else if(gunDevilIntervalMs>0){
          if(!gunDevilNextShot || now>=gunDevilNextShot){
            fireGunDevilVolley(now);
            gunDevilNextShot=now+gunDevilIntervalMs;
          }
        }
      }else{
        gunDevilNextShot=0;
      }
      if(equipmentGodspeedHolyStrike && equipmentGodspeedHolyInterval>0 && buffs.GODSPEED.active){
        if(!nextGodspeedHolyStrike){
          nextGodspeedHolyStrike=now+equipmentGodspeedHolyInterval;
        }else if(now>=nextGodspeedHolyStrike){
          let triggered=false;
          if(Array.isArray(balls)){
            for(const ball of balls){
              if(!ball) continue;
              applyHolyStrike(ball.x, ball.y);
              triggered=true;
            }
          }
          if(triggered){
            screenShake=Math.max(screenShake,4);
          }
          nextGodspeedHolyStrike=now+equipmentGodspeedHolyInterval;
        }
      }else{
        nextGodspeedHolyStrike=0;
      }
      const prevPaddleX=paddle.x;
    if(cyclopsShakeUntil && now<cyclopsShakeUntil){ screenShake=Math.max(screenShake,6); }
    if(comboEl) comboEl.classList.toggle('star', isComboStarActive(now));
    if(combo>0){
      const elapsed=now-comboLastTime;
      const mul=getComboStarTimeMultiplier(now);
      const fadeStart=3000*mul, resetTime=5000*mul;
      if(elapsed>fadeStart && elapsed<resetTime){ comboEl.style.opacity=1-((elapsed-fadeStart)/(resetTime-fadeStart)); }
      else if(elapsed>=resetTime){ resetCombo(); }
      else { comboEl.style.opacity=1; }
    }
    // Buff 過期
    for(const key of Object.keys(GAME_CONFIG.powers)){
      if(key==='LONG' || key==='FLIP') continue;
      const b=buffs[key];
      if(b?.active && b.until && now>b.until){
        if(key==='BLACKHOLE') continue;
        b.active=false;
        if(key==='GODSPEED'){
          for(const ball of balls){
            const ang=Math.atan2(ball.vy,ball.vx);
            const sp=ball.speedCap*0.5;
            ball.vx=Math.cos(ang)*sp;
            ball.vy=Math.sin(ang)*sp;
          }
        }
        if(key==='PIERCE'){ for(const ball of balls) ball.piercing=false; }
        if(key==='STICKY'){ for(const ball of balls){ if(ball.stuck){ ball.stuck=false; ball.vy = -Math.abs(ball.vy||6); } } }
        if(key==='MEGA' && buffs.MEGA.applied){ for(const ball of balls){ ball.r/=GAME_CONFIG.powers.MEGA.mega.sizeMul; } buffs.MEGA.applied=false; }
        if(key==='FIRE'){
          if(fireEnergy>0 && balls.length){
            const b0=balls[0];
            const e=fireEnergy;
            const radius = e<=3?100:e<=8?150:e<=14?200:300;
            fireExplosionAt(b0.x,b0.y,radius);
          }
          fireEnergy=0; updateFireEnergy();
        }
        if(key==='COMBO' && comboEl){ comboEl.classList.remove('star'); }
        if(key==='GATLING'){ gatling=null; gatlingBullets.length=0; }
      }
    }
    computePaddleWidth(); updateBuffBadges();
    updateSpaceBoss();
    updateReaperBoss();
    updateDragonBoss();
    updateDemonEvent(now);
    updateDemonBoss();
    updateDemonVoidVolley(now);
    updateDemonVoidProjectiles(now);
    updateDemonBlackSpears(now);
    updateDemonBladeHellCounterstrike(now);

    if(isTrueBossFightActive()){
      if(!nextTreasureBrickAt){
        scheduleNextTreasureBrick(now);
      }else if(now>=nextTreasureBrickAt){
        spawnBossTreasureBrick();
        scheduleNextTreasureBrick(now);
      }
    }else{
      nextTreasureBrickAt=0;
    }

    let treasureRemoved=false;
    for(let i=bricks.length-1;i>=0;i--){
      const bk=bricks[i];
      if(!bk?.fallingTreasure) continue;
      const vy=bk.vy || GAME_CONFIG.powerCapsule.fallVy || 2.2;
      bk.y += vy;
      if(bk.y>710){ bricks.splice(i,1); treasureRemoved=true; }
    }
    if(treasureRemoved){ updateHUD(); }

    for(let i=demonFallingDebris.length-1;i>=0;i--){
      const d=demonFallingDebris[i];
      d.vy += d.gravity;
      d.y += d.vy;
      if(d.vx){ d.x += d.vx; d.vx*=0.99; }
      d.angle += d.spin;
      if(d.y>720){ demonFallingDebris.splice(i,1); }
    }

    // 劇毒磚持續扣血
      let poisonCount=0;
      for(let i=bricks.length-1;i>=0;i--){
        const bk=bricks[i];
        if(!bk?.poisonUntil) continue;
        if(now>=bk.poisonUntil){
          clearBrickPoison(bk);
          continue;
        }
        poisonCount++;
        if(equipmentPoisonSpreadDelay>0 && bk.poisonSpreadAt && !bk.poisonSpreadTriggered && now>=bk.poisonSpreadAt){
          spreadPoisonFromBrick(bk, now);
          bk.poisonSpreadTriggered=true;
        }
      if(!bk.poisonTick) bk.poisonTick = now + poisonTickIntervalMs();
      if(now >= bk.poisonTick){
        bk.poisonTick += poisonTickIntervalMs();
        if(canDestroyBrick(bk)){
          const cx=bk.x+bk.w/2;
          const cy=bk.y+bk.h/2;
          if(bk.boss){
            bk.hp-=1;
            spawnParticles(cx,cy,'rgba(120,255,120,0.9)',12,1.6,2.4,2.2);
            if(bk.hp<=0){ bossKillEffect(bk); revealBrickArea(bk); bricks.splice(i,1); incrementCombo(); addScore(scoreForBrick(bk)); stats.bossKills++; updateHUD(); }
            strikeDemonAbyssBricksAtPoint(cx, cy, Math.max(bk.w, bk.h)*0.75, 'poison');
            continue;
          }
          bk.hp=(bk.hp||1)-1;
          spawnParticles(cx,cy,'rgba(120,255,120,0.9)',12,1.6,2.4,2.2);
          strikeDemonAbyssBricksAtPoint(cx, cy, Math.max(bk.w, bk.h)*0.75, 'poison');
          if(bk.hp<=0){
            if(equipmentPoisonPlasma){ spawnPlasmaBurst(cx,cy,{sound:false}); }
            revealBrickArea(bk);
            maybeDropFromBrick(bk);
            bricks.splice(i,1);
            incrementCombo();
            addScore(scoreForBrick(bk));
            if(bk.elite) stats.eliteKills++;
            updateHUD();
          }
        }
      }
      }

      if(equipmentToxicRebirthConfig){
        if(!toxicRebirthTriggered){
          const threshold=Math.max(1, equipmentToxicRebirthConfig.threshold||0);
          if(poisonCount>=threshold){
            toxicRebirthTriggered=true;
            toxicRebirthGlowUntil=now+2200;
            const pr=paddleRect();
            if(pr){
              spawnParticles(pr.x+pr.w/2, pr.y+pr.h/2, 'rgba(120,255,140,0.9)', 26, 1.6, 2.4, 2.2);
            }
            const heal=Math.max(0, equipmentToxicRebirthConfig.heal||0);
            let messageHandled=false;
            if(heal>0){
              const prevHP=lives;
              const maxHP=9;
              const gained=Math.min(maxHP-prevHP, heal);
              if(gained>0){
                lives=prevHP+gained;
                updateHUD();
                beep(720,0.08,0.05);
                showEquipmentMessage(`劇毒轉生啟動！平台恢復 ${gained} 點 HP。`,'success',2600);
                messageHandled=true;
              }else{
                showEquipmentMessage('劇毒轉生觸發，但 HP 已達上限。','info',2400);
                messageHandled=true;
              }
            }
            if(!messageHandled){
              showEquipmentMessage('劇毒轉生觸發！劇毒化為力量。','success',2400);
            }
          }
        }
      }else{
        if(toxicRebirthGlowUntil && now>=toxicRebirthGlowUntil){
          toxicRebirthGlowUntil=0;
        }
        toxicRebirthTriggered=false;
      }

      updateStarProjectiles(now);
    updateMoonProjectiles(now);
    if(equipmentSolarBurst && equipmentSolarBurstInterval>0 && window.currentSkin?.cssSkin==='烈陽．炙金幻焰'){
      if(!solarBurstNextAt){
        solarBurstNextAt = now + equipmentSolarBurstInterval;
      }else if(now >= solarBurstNextAt){
        const triggered=triggerSolarBurst(now);
        solarBurstNextAt = now + equipmentSolarBurstInterval;
        if(!triggered){
          solarBurstNextAt = now + Math.max(2000, equipmentSolarBurstInterval);
        }
      }
    }else{
      solarBurstNextAt=0;
    }

    // === 天地翻轉狀態處理 ===
    if(buffs.FLIP){
      const f = buffs.FLIP;
      // 啟動翻轉：pending 狀態進入 active
      if(f.pending && f.startAt && now >= f.startAt){
        f.pending = false;
        f.active = true;
        // 更新 until 供 HUD 顯示
        if(f.endAt) f.until = f.endAt;
        const decoyW = paddle.w;
        const decoyH = paddle.h;
        flipDecoy = {
          active:true,
          x:1100/2 - decoyW/2,
          y:700 - 50,
          w:decoyW,
          h:decoyH,
          until:f.endAt
        };
        // 切換為左側模式
        orientLeft = true;
        // 將擋板置於畫面中央（垂直模式）
        paddle.y = (700 - paddle.w) / 2;
        paddle.x = 0;
        // 將現有掉落道具改為水平移動
        for(const p of powerups){ p.horizontal = true; }
        for(const coin of coins){
          if(coin.magnet){ coin.horizontal = true; }
          else { setCoinDirection(coin, true); }
        }
        // 重新鎖定所有球以瞄準擋板中心
        const pr = paddleRect();
        const tx = pr.x + pr.w/2;
        const ty = pr.y + pr.h/2;
        for(const b of balls){
          const sp = Math.max(6, Math.hypot(b.vx, b.vy));
          const ang = Math.atan2(ty - b.y, tx - b.x);
          b.vx = Math.cos(ang) * sp;
          b.vy = Math.sin(ang) * sp;
        }
        // 加入鎖定框提示擋板位置
        pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
      }
      if(f.active && flipDecoy?.active){
        flipDecoy.w = paddle.w;
        flipDecoy.h = paddle.h;
        flipDecoy.x = 1100/2 - flipDecoy.w/2;
        flipDecoy.y = 700 - 50;
        flipDecoy.until = f.endAt;
      }
      // 結束翻轉：active 狀態到期後恢復正常
      if(f.active && f.endAt && now >= f.endAt){
        f.active = false;
        // 重置 until
        f.until = 0;
        flipDecoy=null;
        // 恢復水平方向
        orientLeft = false;
        // 擋板置於底部中央
        paddle.y = 700 - 50;
        paddle.x = 1100/2 - paddle.w/2;
        // 將現有掉落道具改為垂直移動
        for(const p of powerups){ p.horizontal = false; }
        for(const coin of coins){
          if(coin.magnet){ coin.horizontal = false; }
          else { setCoinDirection(coin, false); }
        }
        // 球重新瞄準擋板中心
        const pr2 = paddleRect();
        const tx2 = pr2.x + pr2.w/2;
        const ty2 = pr2.y + pr2.h/2;
        for(const b of balls){
          const sp = Math.max(6, Math.hypot(b.vx, b.vy));
          const ang = Math.atan2(ty2 - b.y, tx2 - b.x);
          b.vx = Math.cos(ang) * sp;
          b.vy = Math.sin(ang) * sp;
        }
        // 顯示鎖定框
        pushLockBox(pr2.x, pr2.y, pr2.w, pr2.h, 'paddle');
      }
    }
    else if(flipDecoy){
      flipDecoy=null;
    }


    if(buffs.PADBOOM.active){
      if(!buffs.PADBOOM.exploded && now >= buffs.PADBOOM.explodeAt){
        const pr = paddleRect();
        const cx = pr.x+pr.w/2, cy = pr.y+pr.h/2;
        spawnParticles(cx, cy, '#ffdd99', 80, 3.5, 5.0, 5);
        spawnParticles(cx, cy, '#ffeeaa', 60, 3.8, 4.8, 4.5);
        spawnParticles(cx, cy, '#ffffff', 40, 3.2, 4.2, 3.5);
        screenShake = Math.max(screenShake,10);
        playSFX('explosion');
        showComboNotice('哈哈你爆掉啦? 道具不能亂吃呀!',5000,3000);
        paddleGoneUntil = buffs.PADBOOM.returnAt;
        buffs.PADBOOM.exploded = true;
      }
      if(buffs.PADBOOM.exploded && now >= buffs.PADBOOM.returnAt){
        buffs.PADBOOM.active = false;
        buffs.PADBOOM.until = 0;
        paddleGoneUntil = 0;
      }
    }

    // 菁英磚技能：每30秒發射，發射前聚氣2秒
    for(const b of bricks){ if(!b.elite) continue; if(b.eliteChargeUntil && now<b.eliteChargeUntil){ /* charging */ } else { if(!b.eliteNext) b.eliteNext = now+30000; if(now>=b.eliteNext){ b.eliteChargeUntil = now+2000; b.eliteNext = now+30000; setTimeout(()=>{ const idx = bricks.indexOf(b); if(idx!==-1){ spawnLionBeamFrom(b.x+b.w/2, b.y+b.h/2); } }, 2000); } } }
// 鍵盤移動：天地翻轉時改為上下移動（仍使用左右鍵）
    if(!orientLeft){ if(performance.now()>paddleStunUntil){ if(keyL) paddle.x-=paddle.speed; if(keyR) paddle.x+=paddle.speed; } paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x)); }
    else{ if(performance.now()>paddleStunUntil){ if(keyL) paddle.y-=paddle.speed; if(keyR) paddle.y+=paddle.speed; } paddle.y=Math.max(0, Math.min(700-paddle.w, paddle.y)); }
    applyDemonSpearPaddleBlock(prevPaddleX);

    // 雷射發射
    if(buffs.LASER.active){
      const baseInterval = GAME_CONFIG.powers.LASER.laser.intervalMs;
      const interval = Math.max(50, Math.round(baseInterval*equipmentLaserIntervalMultiplier));
      if(!buffs.LASER.lastShot || now - buffs.LASER.lastShot >= interval){
        buffs.LASER.lastShot = now;
        const pr=paddleRect();
        const barrels = !orientLeft
          ? [{x:pr.x, y:pr.y+pr.h/2},{x:pr.x+pr.w, y:pr.y+pr.h/2}]
          : [{x:pr.x+pr.w/2, y:pr.y},{x:pr.x+pr.w/2, y:pr.y+pr.h}];
        if(equipmentLaserExtraTurret){
          const centerOrigin={x:pr.x+pr.w/2, y:pr.y+pr.h/2};
          barrels.push(centerOrigin);
        }
        for(const s of barrels){
          const target=pickLaserTarget(s.x, s.y);
          fireLaserFromSource(s.x, s.y, target, now);
        }
      }
    }

    if(gatling){
      const pr=paddleRect();
      gatling.x=pr.x+pr.w/2; gatling.y=pr.y;
      if(now>=gatling.fireStart){
        if(now>=gatling.fireUntil){ gatling=null; buffs.GATLING.active=false; }
        else if(now-gatling.lastShot>=(GAME_CONFIG.powers.GATLING.gatling.intervalMs||100)){
          gatling.lastShot=now;
          gatling.angle=(gatling.angle||0)+0.3;
          const cfg=GAME_CONFIG.powers.GATLING.gatling;
          const x=gatling.x+Math.cos(gatling.angle)*5;
          const vx=Math.cos(gatling.angle)*0.5;
          gatlingBullets.push({x:x,y:gatling.y-10,vx:vx,vy:-(cfg.bulletSpeed||10)});
          spawnParticles(x, gatling.y-10, '#ffbb55', 8, 1.2, 2.5, 2);
          playSFX('gatlingShoot');
        }
      }
    }
    for(let i=gatlingBullets.length-1;i>=0;i--){
      const bl=gatlingBullets[i];
      bl.x+=bl.vx; bl.y+=bl.vy;
      if(bl.y<0){ gatlingBullets.splice(i,1); continue; }
      if(strikeDemonSpearsAtPoint(bl.x, bl.y, 6, 'gatling') || strikeDemonAbyssBricksAtPoint(bl.x, bl.y, 6, 'gatling')){
        gatlingBullets.splice(i,1);
        continue;
      }
      let removed=false;
      for(let j=bricks.length-1;j>=0;j--){
        const bk=bricks[j];
        if(bl.x>bk.x && bl.x<bk.x+bk.w && bl.y>bk.y && bl.y<bk.y+bk.h){
          spawnParticles(bl.x, bl.y, '#ffdd77', 8, 1.6, 3.2, 2.5);
          playSFX('gatlingHit');
          if(canDestroyBrick(bk) && !(bk.lockedUntil && now<bk.lockedUntil)){
            bk.hp=(bk.hp||1)-1; incrementCombo();
            if(bk.hp<=0){
              addScore(scoreForBrick(bk)); updateHUD();
              const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
              revealBrickArea(bk); maybeDropFromBrick(bk);
              spawnParticles(cx, cy, '#eeeeee', 24, 2.4, 4.0, 3.5);
              if(bk.explosive){ explodeAt(cx,cy); } else { bricks.splice(j,1); }
            } else updateHUD();
          }
          gatlingBullets.splice(i,1);
          removed=true;
          break;
        }
      }
      if(!removed && isSpecialBossActive()){
        const bounds=getActiveBossBounds();
        if(bounds && bl.x>bounds.x && bl.x<bounds.x+bounds.w && bl.y>bounds.y && bl.y<bounds.y+bounds.h){
          spawnParticles(bl.x, bl.y, '#ffdd77', 8, 1.6, 3.2, 2.5);
          playSFX('gatlingHit');
          damageActiveBoss(1,'gatling',{x:bl.x,y:bl.y});
          gatlingBullets.splice(i,1);
        }
      }
    }

    if(stormTurret){
      if(now>=stormTurret.fireAt){
        if(stormTurret.shots<=0){
          stormTurret=null;
          buffs.STORM.active=false;
        }else{
          const interval=Math.max(50, Math.round(200*equipmentLaserIntervalMultiplier));
          if(now-stormTurret.lastShot>=interval){
            const idx=randomBrick(true);
            if(idx!=null){
              let target=null;
              if(idx==='boss'){
                if(isSpecialBossActive()){
                  const center=activeBossCenter();
                  if(center){
                    target={type:'boss', x:center.x, y:center.y};
                  }
                }
              }else{
                const t=bricks[idx];
                if(t){
                  target={type:'brick', idx, x:t.x+t.w/2, y:t.y+t.h/2};
                }
              }
              if(target){
                const fired=fireLaserFromSource(stormTurret.x, stormTurret.y, target, now);
                if(fired && equipmentLaserExtraTurret){
                  const pr=paddleRect();
                  if(pr){
                    const extraTarget=pickLaserTarget(pr.x+pr.w/2, pr.y+pr.h/2);
                    fireLaserFromSource(pr.x+pr.w/2, pr.y+pr.h/2, extraTarget, now);
                  }
                }
                if(fired){
                  stormTurret.shots--;
                  stormTurret.lastShot=now;
                }
              }
            }
          }
        }
      }
    }

    if(buffs.BLACKHOLE.active && now>buffs.BLACKHOLE.until){ triggerBlackholeStrike(now); }

    if(buffs.ANNIHIL.active && now>=buffs.ANNIHIL.next){ let cand=bricks.filter(b=>canDestroyBrick(b)&&!b.boss); if(!cand.length) cand=bricks.filter(b=>canDestroyBrick(b)); if(cand.length){ const target=cand[Math.floor(Math.random()*cand.length)]; const idx=bricks.indexOf(target); destroyBrick(idx,'annihil'); } else if(isSpecialBossActive()){ const center=activeBossCenter(); damageActiveBoss(1,'annihil',center?{x:center.x,y:center.y}:null); } buffs.ANNIHIL.next+=1000; }

    // 全局速度倍率（GODSPEED 時忽略其它）
    function effectiveMul(){
      if(buffs.GODSPEED.active) return 1.0;
      let mul=1.0;
      if(buffs.SLOW.active){ mul*=(GAME_CONFIG.powers.SLOW.speedMul??1.0); }
      if(buffs.FAST.active){ mul*=(GAME_CONFIG.powers.FAST.globalSpeedMul??1.0); }
      if(buffs.WAVY.active){ const w=GAME_CONFIG.powers.WAVY.wavy||{amp:0.6,base:1.2,periodMs:200}; const phase=(now-(buffs.WAVY.start||now))/(w.periodMs); mul*=(w.base+w.amp*Math.sin(phase)); }
      if(buffs.HELL.active){ mul*=(GAME_CONFIG.powers.HELL.hell.speedMul); }
      if(buffs.MEGA.active){ mul*=(GAME_CONFIG.powers.MEGA.mega.speedMul); }

      // 天地翻轉：啟動前 2 秒與結束前 2 秒期間略微減速（降低不適感）
      const f = buffs.FLIP;
      if(f){
        // 前延遲
        if(f.pending && f.startAt && now >= f.startAt - 2000 && now < f.startAt){
          mul *= 0.8;
        }
        // 結束前
        if(f.active && f.endAt && now >= f.endAt - 2000 && now < f.endAt){
          mul *= 0.8;
        }
      }
      return mul;
    }

    const mulGlobal=effectiveMul();

    // Boss 能力排程
    updateBossAbilities();
    updateCyclopsEvent();
    updateBladeHellBallCapture(now);
    const megaCfg = GAME_CONFIG.powers.MEGA?.mega || {};
    const megaDamageMul = (buffs.MEGA?.active && megaCfg.damageMul) ? megaCfg.damageMul : 1;
    maintainTrackAssignments();
    for(const b of balls){
      if(b.rampageUntil && now>b.rampageUntil){ b.rampageUntil=0; if(!buffs.PIERCE.active) b.piercing=false; }

      // FREEZE 狀態
      if(b.freeze.state==='delay'){
        if(now - b.freeze.t0 >= b.freeze.delay){
          b.freeze.state = 'stopped';
          b.freeze.until = now + b.freeze.stop;
          b.vx = 0; b.vy = 0;
          spawnParticles(b.x,b.y,'rgba(230,247,255,0.9)',16,1.2,1.0,2.5);
        }
      }
      if(b.freeze.state==='stopped'){
        if(now < b.freeze.until){
          continue;
        }else{
          b.freeze.state = 'idle';
          let vx = b.freeze.oldVX, vy = b.freeze.oldVY;
          const tiny = Math.abs(vx)+Math.abs(vy) < 0.2;
          if(tiny){ vx = (Math.random()<0.5?-1:1) * 4; vy = -Math.max(4, speedForLevel(level)*0.8); }
          const sp = Math.max(4, Math.hypot(vx, vy));
          const ang = Math.atan2(vy, vx);
          b.vx = Math.cos(ang)*sp;
          b.vy = Math.sin(ang)*sp;
        }
      }

      if(handleDemonCloakState(b, now)){
        continue;
      }

      if(b.blinkAt && now>=b.blinkAt){
        spawnParticles(b.x,b.y,'rgba(180,200,255,0.8)',20,1.8,2.6,2.5);
        b.y=b.r+0.1; b.vy=Math.abs(b.vy)||Math.abs(speedForLevel(level));
        spawnParticles(b.x,b.y,'rgba(180,200,255,0.8)',20,1.8,2.6,2.5);
        b.blinkAt=0;
      }

      if(b.capturedByBladeHell){
        if(demonBladeHellBallCapture && demonBladeHellBallCapture.ball===b){
          b.x = demonBladeHellBallCapture.holdX ?? b.x;
          b.y = demonBladeHellBallCapture.holdY ?? b.y;
        }
        continue;
      }

      if(b.stuck){ if(!orientLeft){ b.x=paddle.x+paddle.w/2+b.offsetX; b.y=paddle.y-b.r-0.1; } else { const pr=paddleRect(); b.x=pr.x+pr.w+b.r+0.1; b.y=pr.y+pr.h/2; } continue; }
      // 移動
      let speedMul = mulGlobal;
      b.x+=b.vx*speedMul; b.y+=b.vy*speedMul;
      handleBallVsDemonSpears(b, now);

      // GODSPEED：速度鎖定到上限
      if(buffs.GODSPEED.active){
        const sp=Math.hypot(b.vx,b.vy); const cap=b.speedCap;
        if(sp<cap*0.98){ const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*cap; b.vy=Math.sin(ang)*cap; }
      }

      // 牆壁
      const r=b.r;
      if(!orientLeft){
        if(b.x-r<0){ b.x=r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
        if(b.y-r<0){ b.y=r; b.vy*=-1; beep(700,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); fireCollide(); noteCeilingBounce(b, now); noteBounce(b,b.x,b.y,'y',now); }
        if(b.y-r>700){
          // 底部：GODSPEED 不落地 / SHIELD 擋一次
          if(buffs.GODSPEED.active){ b.y=700-r; b.vy=-Math.abs(b.vy); noteBounce(b,b.x,b.y,'y',now); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.y=700-r-1; b.vy=-Math.abs(b.vy); noteBounce(b,b.x,b.y,'y',now); }
          else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; }
        }
      }else{
        // 左側模式：上下為牆，左側為落點；GODSPEED 無落地
        if(b.y-r<0){ b.y=r; b.vy*=-1; fireCollide(); noteCeilingBounce(b, now); noteBounce(b,b.x,b.y,'y',now); }
        if(b.y+r>700){ b.y=700-r; b.vy*=-1; fireCollide(); noteBounce(b,b.x,b.y,'y',now); }
        if(b.x+r>1100){ b.x=1100-r; b.vx*=-1; fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
        if(b.x-r<0){
          if(buffs.GODSPEED.active){ b.x=r; b.vx=Math.abs(b.vx); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
          else if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.x=r+1; b.vx=Math.abs(b.vx); fireCollide(); noteBounce(b,b.x,b.y,'x',now); }
          else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; }
        }
      }

      // 擋板碰撞
      const pr=paddleRect();
      // 擋板有空洞：拆成兩段
      let hitPaddle=false;
      if(!orientLeft){
        const gap = buffs.HOLE.active ? pr.w/3 : 0;
        const l1=pr.x, r1=pr.x+pr.w*(gap?1/3:1);
        const l2=pr.x+pr.w*(gap?2/3:1), r2=pr.x+pr.w;
        const inSeg1 = (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l1 && b.x<=r1);
        const inSeg2 = gap? (b.y+r>=pr.y && b.y+r<=pr.y+pr.h && b.x>=l2 && b.x<=r2):false;
        hitPaddle = inSeg1 || inSeg2;
      }else{
        const gap = buffs.HOLE.active ? pr.h/3 : 0;
        const t1=pr.y, b1=pr.y+pr.h*(gap?1/3:1);
        const t2=pr.y+pr.h*(gap?2/3:1), b2=pr.y+pr.h;
        const inSeg1 = (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t1 && b.y<=b1);
        const inSeg2 = gap? (b.x-r<=pr.x+pr.w && b.x-r>=pr.x && b.y>=t2 && b.y<=b2):false;
        hitPaddle = inSeg1 || inSeg2;
      }
      if(hitPaddle){ stats.catches++;
        const baseSpeed=Math.hypot(b.vx,b.vy);
        const speedMul = isSpeedSuppressed(b, now) ? 1 : paddleHitSpeedMul(level);
        const sp=Math.min(baseSpeed*speedMul, b.speedCap);
        if(!orientLeft){
          const hitPos=(b.x-(pr.x+pr.w/2))/(pr.w/2); const angle=hitPos*(Math.PI/3);
          b.vx=Math.sin(angle)*sp; b.vy=-Math.cos(angle)*sp; b.y=pr.y-b.r-0.1;
          noteBounce(b,b.x,b.y,'y',now);
        }else{
          const hitPos=(b.y-(pr.y+pr.h/2))/(pr.h/2); const angle=hitPos*(Math.PI/3);
          b.vx=Math.cos(angle)*sp; b.vy=Math.sin(angle)*sp; b.x=pr.x+pr.w+b.r+0.1;
          noteBounce(b,b.x,b.y,'x',now);
        }
        if(b.demonCloakState==='launched'){
          const restore=Math.min(b.demonCloakStoredSpeed||Math.hypot(b.vx,b.vy), b.speedCap);
          const ang=Math.atan2(b.vy,b.vx);
          b.vx=Math.cos(ang)*restore;
          b.vy=Math.sin(ang)*restore;
          b.demonCloakState=null;
          b.demonCloakStoredSpeed=0;
          b.demonCloakAnchor=null;
          b.demonCloakStayStart=0;
        }
        beep(880,0.03); spawnParticles(b.x,b.y,'#caddff',8,1.3,1.5,2.5); fireCollide();
        screenShake=Math.max(screenShake, orientLeft?4:3);
        if(buffs.STICKY.active){ b.stuck=true; b.offsetX= (!orientLeft) ? (b.x-(paddle.x+paddle.w/2)) : 0; }
        if(buffs.BLINK.active){ b.blinkAt=performance.now()+ (GAME_CONFIG.powers.BLINK.blink.delayMs||1000); }

        // MISSILE：擋板彈出時發射追蹤飛彈
        if(buffs.MISSILE.active){
          emitMissilesFromSource({x:b.x,y:b.y});
        }

        // 追蹤球：擋板彈出後瞄準目標
        if(buffs.TRACK.active){
          const candidate=chooseTrackTargetForBall(b);
          let targetX;
          let targetY;
          if(candidate){
            targetX=candidate.x;
            targetY=candidate.y;
            assignTrackTarget(b,candidate.key);
            if(candidate.type==='boss'){
              highlightSpaceBossTarget();
            }else if(candidate.brick){
              pushLockBox(candidate.brick.x, candidate.brick.y, candidate.brick.w, candidate.brick.h, 'target');
            }
          }else{
            const L=layout();
            targetX=1100/2;
            targetY=L.top;
            releaseTrackTarget(b);
          }
          const sp=Math.hypot(b.vx,b.vy);
          const ang=Math.atan2(targetY-b.y,targetX-b.x);
          b.vx=Math.cos(ang)*sp;
          b.vy=Math.sin(ang)*sp;
        }
        if(buffs.SWORD.active){ spawnSwordBatch(Math.max(1, computeSwordSpawnCount())); }
      }

      // 碰磚
      const inRampage = !!(b.rampageUntil && now<b.rampageUntil);
      let collidedWithBrick=false;
      let hit=-1; for(let i=0;i<bricks.length;i++){ const bk=bricks[i]; if(b.x+r>bk.x && b.x-r<bk.x+bk.w && b.y+r>bk.y && b.y-r<bk.y+bk.h){ hit=i; break; } }
      if(hit>=0){
        const bk=bricks[hit];
        collidedWithBrick=true;
        fireCollide();
        let silverAssaultTriggered=false;
        let silverAssaultDamageApplied=0;
        if((inRampage || b.piercing) && bk.unbreakable){
          if(b.loopBrick===bk){ b.loopHits++; } else { b.loopBrick=bk; b.loopHits=1; }
          if(b.loopHits>=20){
            const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
            const dx=b.x-cx, dy=b.y-cy;
            const len=Math.hypot(dx,dy)||1;
            const pushDist=Math.max(bk.w,bk.h)/2 + b.r + 4;
            b.x=cx + (dx/len)*pushDist;
            b.y=cy + (dy/len)*pushDist;
            const sp=Math.max(4, Math.hypot(b.vx,b.vy));
            const jitter=(Math.random()>0.5?1:-1)*(Math.PI/12);
            const ang=Math.atan2(b.vy,b.vx)+jitter;
            b.vx=Math.cos(ang)*sp || (Math.random()>0.5?4:-4);
            b.vy=Math.sin(ang)*sp || (Math.random()>0.5?4:-4);
            b.loopBrick=null;
            b.loopHits=0;
          }
        }else{ b.loopBrick=null; b.loopHits=0; }
        let suppressBrickAccel=false;
        let shouldSuppressSpeedBoost=false;
        if(bk.id!=null){
          const prevId=b.lastBrickId;
          const prevTime=b.lastBrickHitTime||0;
          if(prevId===bk.id && now-prevTime<=1000){
            b.sameBrickHits=(b.sameBrickHits||1)+1;
            if(b.sameBrickHits>=2){ suppressBrickAccel=true; shouldSuppressSpeedBoost=true; }
          }else{
            b.sameBrickHits=1;
          }
          b.lastBrickId=bk.id;
          b.lastBrickHitTime=now;
        }else{
          b.sameBrickHits=0;
          b.lastBrickId=null;
          b.lastBrickHitTime=0;
        }
        if(b.loopBrick===bk && b.loopHits>=3){ suppressBrickAccel=true; shouldSuppressSpeedBoost=true; }
        if(shouldSuppressSpeedBoost){ suppressSpeedBoost(b, now); }
        // 反彈
        let bounceAxis=null;
        const oL=(b.x+r)-bk.x, oR=(bk.x+bk.w)-(b.x-r), oT=(b.y+r)-bk.y, oB=(bk.y+bk.h)-(b.y-r); const m=Math.min(oL,oR,oT,oB);
        if(!inRampage && !b.piercing){
          if(m===oL){ b.x=bk.x-r; b.vx=-Math.abs(b.vx); bounceAxis='x'; } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=Math.abs(b.vx); bounceAxis='x'; } else if(m===oT){ b.y=bk.y-r; b.vy=-Math.abs(b.vy); bounceAxis='y'; } else { b.y=bk.y+bk.h+r; b.vy=Math.abs(b.vy); bounceAxis='y'; }
        }else{
          if(m===oL){ b.x=bk.x-r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; } else if(m===oR){ b.x=bk.x+bk.w+r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; } else if(m===oT){ b.y=bk.y-r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; } else { b.y=bk.y+bk.h+r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
          b.piercing=true;
        }
        if(bounceAxis){ noteBounce(b,b.x,b.y,bounceAxis,now); }

        // 強反彈加速
        if(bk.strong){ const skipAccel = suppressBrickAccel || isSpeedSuppressed(b, now); if(!skipAccel){ const sp=Math.min(Math.hypot(b.vx,b.vy)*1.08, b.speedCap); const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp; } screenShake=Math.max(screenShake,3); }

        // 特效觸發
        if(buffs.PLASMA.active){ spawnPlasmaBurst(bk.x+bk.w/2, bk.y+bk.h/2); }
        if(now<bombDevilActiveUntil){ triggerBombDevilForBrick(bk); }
        if(buffs.FREEZE.active && (b.freeze.state==='idle' || !b.freeze.state)){ const f=GAME_CONFIG.powers.FREEZE.freeze; b.freeze.state = 'delay'; b.freeze.t0 = now; b.freeze.delay = f.delayMs; b.freeze.stop = f.stopMs; b.freeze.oldVX = b.vx; b.freeze.oldVY = b.vy; }
        if(buffs.HOLY.active){ applyHolyStrike(bk.x+bk.w/2, bk.y+bk.h/2); }
        if(buffs.CHAIN.active){ bk.lockedUntil = now + GAME_CONFIG.powers.CHAIN.chain.lockMs; }
        if(buffs.HELL.active){ const holeSpin=(Math.random()>0.5?1:-1); const volleyReady=buffs.MISSILE.active && equipmentMissileVolleyOnBreak; const holeRadius=40; const cx=bk.x+bk.w/2; const cy=bk.y+bk.h/2; blackHoles.push({x:cx,y:cy,r:holeRadius,until:now+GAME_CONFIG.powers.HELL.hell.haloMs,start:performance.now(),spinDir:holeSpin}); playSFX('blackhole'); strikeDemonAbyssBricksAtPoint(cx, cy, holeRadius, 'blackhole'); const destroyedNeighbors=destroyNeighbors(hit); destroyBrick(hit,'none'); if(equipmentBlackholePlasma){ spawnPlasmaBurst(cx,cy,{sound:false}); for(const pos of destroyedNeighbors){ if(pos) spawnPlasmaBurst(pos.x,pos.y,{sound:false}); } } if(silverAssaultCharge){ silverAssaultCharge=null; silverAssaultSlotIndex=null; silverAssaultTriggered=true; } if(volleyReady){ emitMissilesFromSource({x:b.x,y:b.y}); } }
        if(buffs.POISON.active){ applyPoisonToBrick(bk, now); }

        // 當前磚扣血（若已在上面被處理則略過）
        if(!buffs.HELL.active && !buffs.HOLY.active){
          // 不可破壞／鎖鏈狀態下不扣血
          if(bk.unbreakable || (bk.lockedUntil && now<bk.lockedUntil)){
            if(silverAssaultCharge){
              silverAssaultDamageApplied=0;
              silverAssaultCharge=null;
              silverAssaultSlotIndex=null;
              silverAssaultTriggered=true;
            }
            if(bk.boss){ updateHUD(); }
          }else{
            const currentHp = (typeof bk.hp === 'number') ? bk.hp : 1;
            const bonusDamage = bk.boss ? 0 : brickDamageBonus;
            const curseBonus = bk.boss ? 0 : getCurseSwordBonus(now);
            let appliedDamage = megaDamageMul + bonusDamage + curseBonus;
            appliedDamage = Math.max(1, Math.floor(appliedDamage * getBloodBladeMultiplier(now)));
            if(silverAssaultCharge){
              silverAssaultDamageApplied=Math.max(1, silverAssaultCharge.damage||1);
              appliedDamage+=silverAssaultDamageApplied;
              silverAssaultCharge=null;
              silverAssaultSlotIndex=null;
              silverAssaultTriggered=true;
            }
            bk.hp = currentHp - appliedDamage;
            incrementCombo();
            if(bk.hp<=0){
              const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
              if(!bk.explosive){
                if(bk.boss){ bossKillEffect(bk); stats.bossKills++; addScore(scoreForBrick(bk)); }
                else { if(bk.elite) stats.eliteKills++; addScore(scoreForBrick(bk)); }
              } else {
                addScore(scoreForBrick(bk));
              }
              revealBrickArea(bk);
              if(inRampage || b.piercing) playSFX('pierce');
              if(!bk.boss) maybeDropFromBrick(bk);
              const volleyReady=buffs.MISSILE.active && equipmentMissileVolleyOnBreak;
              const volleyOrigin={x:b.x,y:b.y};
              if(bk.explosive){ explodeAt(cx,cy); }
              else { bricks.splice(hit,1); updateHUD(); }
              if(volleyReady){
                emitMissilesFromSource(volleyOrigin);
              }
            } else updateHUD();
          }
        }

        if((buffs.HELL.active || buffs.HOLY.active) && silverAssaultCharge){
          silverAssaultDamageApplied=0;
          silverAssaultCharge=null;
          silverAssaultSlotIndex=null;
          silverAssaultTriggered=true;
        }
        if(silverAssaultTriggered){
          const msg = silverAssaultDamageApplied>0
            ? `銀幣攻勢命中，額外造成 ${silverAssaultDamageApplied} 點傷害！`
            : '銀幣攻勢觸發，但目標未受傷。';
          showEquipmentMessage(msg,'success',2200);
        }

        // 追蹤球：撞磚後瞄準擋板中心
        if(buffs.TRACK.active){
          const pr=paddleRect(); const tx = pr.x + (orientLeft? (pr.w + 60) : pr.w/2); const ty = pr.y + pr.h/2;
          const sp=Math.hypot(b.vx,b.vy); const ang=Math.atan2(ty-b.y, tx-b.x); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        
          pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
}

        if(equipmentSwordOnHit && buffs.SWORD.active){
          spawnSwordBatch(Math.max(1, computeSwordSpawnCount()));
        }
        beep(520+Math.random()*200,0.03,0.05);
      }

      if(!collidedWithBrick && demonAbyssBricks.length){
        const nowAttack=demonAttackActive && demonAttackActive.type==='abyssShatter' ? demonAttackActive : null;
        for(const brick of demonAbyssBricks){
          if(!brick || brick.destroyed) continue;
          if(nowAttack && nowAttack.stage==='cleanup' && brick.state==='destroyed') continue;
          const radius=brick.hitRadius||24;
          const dx=b.x - brick.x;
          const dy=b.y - brick.y;
          const combined=r + radius;
          if(dx*dx + dy*dy <= combined*combined){
            const dist=Math.sqrt(dx*dx + dy*dy) || 0.0001;
            const nx=dx/dist;
            const ny=dy/dist;
            const overlap=combined - dist;
            if(overlap>0){ b.x += nx*overlap; b.y += ny*overlap; }
            const dot=b.vx*nx + b.vy*ny;
            if(!inRampage && !b.piercing){
              b.vx -= 2*dot*nx;
              b.vy -= 2*dot*ny;
            }else{
              const sp=Math.max(4, Math.hypot(b.vx,b.vy));
              const ang=Math.atan2(b.vy,b.vx);
              let rvx=Math.cos(ang)*sp, rvy=Math.sin(ang)*sp;
              const reflectVX = b.vx - 2*dot*nx;
              const reflectVY = b.vy - 2*dot*ny;
              if(Math.hypot(reflectVX, reflectVY) > 0.1){ rvx=reflectVX; rvy=reflectVY; }
              b.vx=rvx;
              b.vy=rvy;
              b.piercing=true;
            }
            const bounceAxis=Math.abs(nx)>Math.abs(ny)?'x':'y';
            noteBounce(b,b.x,b.y,bounceAxis,now);
            fireCollide();
            destroyDemonAbyssBrick(brick,'ball', now);
            collidedWithBrick=true;
            break;
          }
        }
      }

      if(!collidedWithBrick && isSpecialBossActive()){
        if(isDragonActive() && dragonBoss){
          const result=resolveDragonBallCollision(b, r, inRampage);
          if(result){
            fireCollide();
            if(result.bounceAxis){ noteBounce(b,b.x,b.y,result.bounceAxis,now); }
            spawnParticles(result.impactX, result.impactY, '#b8d6ff', 20, 1.4, 2.4, 2.2);
              triggerBallBuffEffectsOnBossHit(b, result.impactX, result.impactY, now);
              let bossDamage=megaDamageMul;
              let silverAssaultTriggeredBoss=false;
              let silverAssaultBonusBoss=0;
              if(silverAssaultCharge){
                silverAssaultBonusBoss=Math.max(1, silverAssaultCharge.damage||1);
                bossDamage+=silverAssaultBonusBoss;
                silverAssaultCharge=null;
                silverAssaultSlotIndex=null;
                silverAssaultTriggeredBoss=true;
              }
              const dragonHit=damageActiveBoss(bossDamage,'ball',{x:result.impactX,y:result.impactY});
              if(silverAssaultTriggeredBoss){
                if(!dragonHit){
                  silverAssaultBonusBoss=0;
                }
                const msg=silverAssaultBonusBoss>0
                  ? `銀幣攻勢命中，額外造成 ${silverAssaultBonusBoss} 點傷害！`
                  : '銀幣攻勢觸發，但目標未受傷。';
                showEquipmentMessage(msg,'success',2200);
              }
            if(buffs.TRACK.active){
              const pr=paddleRect();
              const tx = pr.x + (orientLeft? (pr.w + 60) : pr.w/2);
              const ty = pr.y + pr.h/2;
              const sp=Math.hypot(b.vx,b.vy);
              const ang=Math.atan2(ty-b.y, tx-b.x);
              b.vx=Math.cos(ang)*sp;
              b.vy=Math.sin(ang)*sp;
              pushLockBox(pr.x, pr.y, pr.w, pr.h, 'paddle');
            }
            beep(520+Math.random()*200,0.03,0.05);
            collidedWithBrick=true;
          }
        }else if(isDemonActive() && demonBoss){
          const result=resolveDemonBallCollision(b, r);
          if(result){
            const zone=result.zone;
            let bounceAxis=null;
            const incomingVX=b.vx;
            const incomingVY=b.vy;
            if(!inRampage && !b.piercing){
              if(result.penetration===result.oL){ b.x=zone.x-r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
              else if(result.penetration===result.oR){ b.x=zone.x+zone.w+r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
              else if(result.penetration===result.oT){ b.y=zone.y-r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
              else { b.y=zone.y+zone.h+r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
            }else{
              if(result.penetration===result.oL){ b.x=zone.x-r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
              else if(result.penetration===result.oR){ b.x=zone.x+zone.w+r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
              else if(result.penetration===result.oT){ b.y=zone.y-r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
              else { b.y=zone.y+zone.h+r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
              b.piercing=true;
            }
            if(bounceAxis){ noteBounce(b,b.x,b.y,bounceAxis,now); }
            const impactX=Math.max(zone.x, Math.min(b.x, zone.x+zone.w));
            const impactY=Math.max(zone.y, Math.min(b.y, zone.y+zone.h));
            const hitLeftSide = result.penetration===result.oL && incomingVX>0;
            const hitRightSide = result.penetration===result.oR && incomingVX<0;
            const fromBelow = result.penetration===result.oB && incomingVY<0;
            const approachingFromAbove = incomingVY>0.3;
            const diagFromBelow = (incomingVY<-0.2) && (hitLeftSide || hitRightSide);
            const sideImpact = (hitLeftSide || hitRightSide) && incomingVY<=0.2;
            let knockX=0, knockY=0;
            if(fromBelow){ knockY=-1; }
            if(diagFromBelow){
              knockX = hitLeftSide ? 1 : -1;
              if(knockY===0) knockY=-0.6;
            }else if(sideImpact && !approachingFromAbove){
              knockX = hitLeftSide ? 1 : -1;
              if(incomingVY<-0.05){ knockY=Math.min(knockY,-0.4); }
            }
            spawnParticles(impactX, impactY, '#dcb6ff', 20, 1.6, 2.6, 2.4);
            fireCollide();
            if(!approachingFromAbove && (fromBelow || diagFromBelow || sideImpact)){
              applyDemonKnockback(knockX, knockY);
            }
            triggerBallBuffEffectsOnBossHit(b, impactX, impactY, now);
            damageActiveBoss(megaDamageMul,'ball',{x:impactX,y:impactY});
            collidedWithBrick=true;
          }
        }else{
          const bounds=getActiveBossBounds();
          if(bounds){
            const rx=bounds.x, ry=bounds.y, rw=bounds.w, rh=bounds.h;
            if(b.x+r>rx && b.x-r<rx+rw && b.y+r>ry && b.y-r<ry+rh){
              const oL=(b.x+r)-rx, oR=(rx+rw)-(b.x-r), oT=(b.y+r)-ry, oB=(ry+rh)-(b.y-r);
              const m=Math.min(oL,oR,oT,oB);
              let bounceAxis=null;
              if(!inRampage && !b.piercing){
                if(m===oL){ b.x=rx-r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
                else if(m===oR){ b.x=rx+rw+r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
                else if(m===oT){ b.y=ry-r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
                else { b.y=ry+rh+r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
              }else{
                if(m===oL){ b.x=rx-r; b.vx=Math.abs(b.vx)||4; bounceAxis='x'; }
                else if(m===oR){ b.x=rx+rw+r; b.vx=-Math.abs(b.vx)||-4; bounceAxis='x'; }
                else if(m===oT){ b.y=ry-r; b.vy=Math.abs(b.vy)||4; bounceAxis='y'; }
                else { b.y=ry+rh+r; b.vy=-Math.abs(b.vy)||-4; bounceAxis='y'; }
                b.piercing=true;
              }
              if(bounceAxis){ noteBounce(b,b.x,b.y,bounceAxis,now); }
              const impactX = Math.max(rx, Math.min(b.x, rx+rw));
              const impactY = Math.max(ry, Math.min(b.y, ry+rh));
              spawnParticles(impactX, impactY, '#b8d6ff', 20, 1.4, 2.4, 2.2);
              fireCollide();
              triggerBallBuffEffectsOnBossHit(b, impactX, impactY, now);
                let bossDamage=megaDamageMul;
                let silverAssaultTriggeredBoss=false;
                let silverAssaultBonusBoss=0;
                if(silverAssaultCharge){
                  silverAssaultBonusBoss=Math.max(1, silverAssaultCharge.damage||1);
                  bossDamage+=silverAssaultBonusBoss;
                  silverAssaultCharge=null;
                  silverAssaultSlotIndex=null;
                  silverAssaultTriggeredBoss=true;
                }
                const bossHit=damageActiveBoss(bossDamage,'ball',{x:impactX,y:impactY});
                if(silverAssaultTriggeredBoss){
                  if(!bossHit){
                    silverAssaultBonusBoss=0;
                  }
                  const msg=silverAssaultBonusBoss>0
                    ? `銀幣攻勢命中，額外造成 ${silverAssaultBonusBoss} 點傷害！`
                    : '銀幣攻勢觸發，但目標未受傷。';
                  showEquipmentMessage(msg,'success',2200);
                }
              collidedWithBrick=true;
            }
          }
        }
      }

      // 安全保底速度
      const sp2 = Math.hypot(b.vx,b.vy);
      if(sp2 < 0.2 && !b.stuck && b.freeze.state==='idle'){
        b.vx = (Math.random()<0.5?-1:1) * 4;
        b.vy = -Math.max(4, speedForLevel(level)*0.8);
      }
    }

    // 飛彈更新
    for(let i=missiles.length-1;i>=0;i--){
      const m=missiles[i];
      if(now>m.lifeUntil){ missiles.splice(i,1); continue; }
      let tx,ty, rect=null;
      if(m.targetType==='boss'){
        if(!isSpecialBossActive()){ missiles.splice(i,1); continue; }
        const bounds=getActiveBossBounds();
        const center=activeBossCenter();
        if(!bounds || !center){ missiles.splice(i,1); continue; }
        rect=bounds;
        tx=center.x; ty=center.y;
      }else{
        const t=bricks[m.targetId];
        if(!t){ missiles.splice(i,1); continue; }
        tx=t.x+t.w/2; ty=t.y+t.h/2;
        rect={x:t.x,y:t.y,w:t.w,h:t.h};
      }
      const ang=Math.atan2(ty-m.y, tx-m.x);
      const sp=GAME_CONFIG.powers.MISSILE.missile.speed;
      // 轉向
      const curAng=Math.atan2(m.vy, m.vx);
      let diff=ang-curAng; while(diff>Math.PI) diff-=2*Math.PI; while(diff<-Math.PI) diff+=2*Math.PI;
      const maxTurn=GAME_CONFIG.powers.MISSILE.missile.turn;
      const newAng = curAng + Math.max(-maxTurn, Math.min(maxTurn, diff));
      m.vx=Math.cos(newAng)*sp; m.vy=Math.sin(newAng)*sp;
      m.x+=m.vx; m.y+=m.vy;
      (m.trail||(m.trail=[])).push({x:m.x,y:m.y,t:now}); if(m.trail.length>20) m.trail.shift();
      // 命中判定
      if(strikeDemonSpearsAtPoint(m.x, m.y, 10, 'missile') || strikeDemonAbyssBricksAtPoint(m.x, m.y, 10, 'missile')){ missiles.splice(i,1); continue; }
      if(rect && m.x>rect.x && m.x<rect.x+rect.w && m.y>rect.y && m.y<rect.y+rect.h){
        const impactX=m.x;
        const impactY=m.y;
        let explosionPlayed=false;
        if(m.targetType==='boss'){
          damageActiveBoss(1,'missile',{x:impactX,y:impactY});
          if(equipmentMissileExplosion){
            explodeAt(impactX,impactY,{sound:false});
            playSFX('explosion');
            explosionPlayed=true;
          }
          handleMissileImpact(impactX,impactY);
        }else{
          const target=bricks[m.targetId];
          if(target){
            const ref=target;
            let idx=bricks.indexOf(ref);
            const cx=ref.x+ref.w/2;
            const cy=ref.y+ref.h/2;
            if(equipmentMissileExplosion && idx>=0){
              destroyNeighbors(idx);
              if(!explosionPlayed){
                playSFX('explosion');
                explosionPlayed=true;
              }
              idx=bricks.indexOf(ref);
            }
            if(idx>=0){
              destroyBrick(idx,'missile');
            }
            handleMissileImpact(cx,cy);
          }
        }
        missiles.splice(i,1); spawnParticles(impactX,impactY,'#ffbb66',12,1.8,2.2,3);
      }
    }

    // 球全沒了
    if(balls.length===0){
      const nowL=performance.now();
      if(nowL<=spaceBossSuppressLifeLossUntil){
        // skip automatic life loss triggered by Space Boss abilities
      }else{
        const pr=paddleRect();
        const cx=pr.x+pr.w/2;
        const cy=pr.y+pr.h/2;
        if(blockDamageIfShielded({x:cx,y:cy})){
          resetBalls(false);
          startCountdown();
          return;
        }
        if(stats.lifeStart){ const dur=(nowL-stats.lifeStart)/1000; if(dur<stats.fastestDeath) stats.fastestDeath=dur; if(dur>stats.longestLife) stats.longestLife=dur; }
        stats.livesUsed++;
        if(buffs.BLACKHOLE.active){ buffs.BLACKHOLE.deaths=Math.min(8,(buffs.BLACKHOLE.deaths||0)+1); }
        if(buffs.ANNIHIL.active){ buffs.ANNIHIL.active=false; }
        lives--; updateHUD();
        if(lives<=0){ running=false; paused=true; showGameOver(); return; }
        else { resetBalls(false); startCountdown(); return; }
      }
    }

    // 銀幣掉落與拾取
    for(let i=coins.length-1;i>=0;i--){
      const coin=coins[i];
      coin.phase = (coin.phase || 0) + 0.08;
      if(!coin.magnet){
        if(coin.horizontal){ coin.x += coin.vx; }
        else { coin.y += coin.vy; }
      }
      const pr = paddleRect();
      const prCenterX = pr.x + pr.w/2;
      const prCenterY = pr.y + pr.h/2;
      const cx = coin.x + coin.w/2;
      const cy = coin.y + coin.h/2;
      if(!coin.magnet){
        const dist = Math.hypot(cx - prCenterX, cy - prCenterY);
        if(dist <= (coin.magnetRange || 150)){ coin.magnet = true; }
      }
      if(coin.magnet){
        const dx = prCenterX - cx;
        const dy = prCenterY - cy;
        const dist = Math.hypot(dx, dy) || 1;
        const seek = Math.max(coin.seekSpeed || 5, Math.abs(coin.speed||2.6)*1.5);
        coin.x += (dx/dist) * seek;
        coin.y += (dy/dist) * seek;
      }
      const hit = (!orientLeft)
        ? (coin.y + coin.h >= pr.y && coin.x + coin.w >= pr.x && coin.x <= pr.x + pr.w && coin.y <= pr.y + pr.h)
        : (coin.x <= pr.x + pr.w && coin.x + coin.w >= pr.x && coin.y + coin.h >= pr.y && coin.y <= pr.y + pr.h);
      if(hit){
        collectCoin(coin);
        coins.splice(i,1);
        continue;
      }
      if(coin.magnet){
        const dist = Math.hypot((coin.x + coin.w/2) - prCenterX, (coin.y + coin.h/2) - prCenterY);
        if(dist < Math.max(14, coin.w*0.6)){
          collectCoin(coin);
          coins.splice(i,1);
          continue;
        }
      }
      if(now - coin.spawnAt > coin.life){ coins.splice(i,1); continue; }
      if(!coin.magnet){
        if(!coin.horizontal && coin.y > 720){ coins.splice(i,1); continue; }
        if(coin.horizontal && coin.x + coin.w < -50){ coins.splice(i,1); continue; }
      }else{
        if(cx < -120 || cx > 1220 || cy < -120 || cy > 820){ coins.splice(i,1); continue; }
      }
    }

    // 掉落道具移動/撿取
    for(let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      // 根據方向更新位置
      if(p.horizontal){
        p.x -= p.speed;
      } else {
        p.y += p.speed;
      }
      const pr = paddleRect();
      if(pr){
        const paddleCx = pr.x + pr.w/2;
        const paddleCy = pr.y + pr.h/2;
        const centerX = p.x + p.w/2;
        const centerY = p.y + p.h/2;
        const dx = centerX - paddleCx;
        const dy = centerY - paddleCy;
        const dist = Math.hypot(dx, dy) || 1;
        if(equipmentAttractBeneficial && !p.isDebuff){
          const range = 220;
          if(dist < range){
            const pull = 1 - dist/range;
            const seek = p.speed + 2.2 * pull;
            p.x -= (dx/dist) * seek * 0.6;
            p.y -= (dy/dist) * seek * 0.85;
          }
        }
        if(equipmentRepelDebuff && p.isDebuff){
          const range = 220;
          if(dist < range){
            const push = 1 - dist/range;
            const repel = p.speed + 2.6 * push;
            p.x += (dx/dist) * repel * 0.7;
            p.y += (dy/dist) * repel * 0.9;
          }
        }
      }
      // 命中檢查：根據擋板方向檢查碰撞
      const hit = (!orientLeft)
        ? (p.y + p.h >= pr.y && p.x + p.w >= pr.x && p.x <= pr.x + pr.w && p.y <= pr.y + pr.h)
        : (p.x + p.w >= pr.x && p.x <= pr.x + pr.w && p.y + p.h >= pr.y && p.y <= pr.y + pr.h);
      if(hit){
        applyPower(p.type);
        // 撿到增益/特殊增益時更新最後拾取時間，以便自動掉落計時
        const def = GAME_CONFIG.powers[p.type];
        if(def && def.type !== 'debuff'){
          lastBeneficialPickupAt = performance.now();
          nextAutoBeneficialDropAt = lastBeneficialPickupAt + 10000;
        }
        powerups.splice(i,1);
        continue;
      }
      // 超出畫面則移除
      if(p.horizontal){
        if(p.x + p.w < 0){ powerups.splice(i,1); }
      } else {
        if(p.y > 710){ powerups.splice(i,1); }
      }
    }

    {
      const prNow = paddleRect();
      const {x:centerX} = getPaddleTarget(prNow);
      spaceBossPrevPaddleCenter = spaceBossLastPaddleCenter;
      spaceBossLastPaddleCenter = centerX;
    }

        // 天空定時掉落
    if(performance.now() >= nextSkyDropAt){ spawnBeneficialAtTop(); scheduleNextSkyDrop(); }
    // 若距上次取得增益已逾 10 秒，則自動從天空掉落一個增益
    if(running && !paused && !resumePending && !gameOver){
      const nowAuto = performance.now();
      if(nowAuto >= nextAutoBeneficialDropAt){
        spawnBeneficialAtTop();
        lastBeneficialPickupAt = nowAuto;
        nextAutoBeneficialDropAt = lastBeneficialPickupAt + 10000;
      }
    }

    // 清關（進入畫廊或通關）
    if(!hasBreakables()){
      unlockSpecials(level);
      const idx=((level-1)%10);
      const type = (level<=10 ? (imageChoice[idx]===0?'bg':'cg') : (imageChoice[idx]===0?'cg':'bg'));
      markImageUnlocked(type, idx);
      paused=true; running=false; onPauseStart();
      if(level>=GAME_CONFIG.totalLevels){
        startFinalVictorySequence();
        return;
      }else{
        const key = getLevelImageKey(level);
        galleryImg.src=getLevelImage(level).src;
        galleryDialog.style.display='none';
        if(galleryHint) galleryHint.textContent='點一下顯示台詞 ▶';
        gallery.style.display='flex'; requestAnimationFrame(()=>gallery.classList.add('show'));
        const proceed=()=>{
          gallery.classList.remove('show');
          const nextLevel=Math.min(GAME_CONFIG.totalLevels, level+1);
          setTimeout(()=>{
            gallery.style.display='none';
            gallery.removeEventListener('click',proceed);
            galleryDialog.style.display='none';
            if(level < GAME_CONFIG.totalLevels){
              openStore(nextLevel);
            }else{
              prepareNextLevel(nextLevel);
            }
          },200);
        };
        const showLine=()=>{ const dlg=getRandomDialog(key); unlockDialog(key, dlg.idx); galleryDialog.textContent=dlg.text; galleryDialog.style.display='block'; if(galleryHint) galleryHint.textContent='點一下進入補給商店 ▶'; gallery.removeEventListener('click',showLine); gallery.addEventListener('click',proceed,{once:true}); };
        gallery.addEventListener('click',showLine); return;
      }
    }
  }


  function loop(){ if(!paused && running) update(); draw(); requestAnimationFrame(loop); }
  
  // 菜單暫停控制：當音效或選項菜單開啟時停住遊戲，關閉時恢復（不影響 Game Over / 倒數邏輯）
  (function(){
    let menuPaused = false;
    window.__setMenuPause = function(flag){
      menuPaused = !!flag;
      if(menuPaused){
        // 開啟選單：立即暫停遊戲並記錄暫停開始時間
        paused = true;
        // 若正在倒數，停止計時以免在選單開啟期間自動恢復
        if(countdownTimer){ clearTimeout(countdownTimer); countdownTimer=null; }
        onPauseStart();
      } else {
        // 關閉選單：只要遊戲尚在進行且未 Game Over，立即修正計時並重新倒數
        if(running && !gameOver){
          // 確保即便先前已有倒數排程也能正確恢復
          resumePending = false;
          onResumeFromPause();
          // 繼續先前的倒數而非重置
          startCountdown(false);
        }
      }
    };
    // 保護性：若 UI 在小尺寸下重排導致狀態不同步，定時校正
    setInterval(()=>{
      const anyOpen = menusOpen();
      if(anyOpen !== menuPaused){ window.__setMenuPause(anyOpen); }
    }, 400);
  })();
function boot(){
    resetGame(); updateHUD(); loop();
    // 自動讀取音效/BGM偏好
    soundsOn = (localStorage.getItem('sfx_on')||'0')==='1'; soundBtn.textContent=`音效：${soundsOn?'開':'關'}`;
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.7'); bgmVol.value=String(v);
    bgmOn = (localStorage.getItem('bgm_on')||'0')==='1'; bgmBtn.textContent = bgmOn?'開':'關';
    // 若有存檔給提示
    const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4');
    if(raw){ setTimeout(()=>{ if(confirm('偵測到存檔，要讀取進度嗎？')) loadProgress(); }, 400); }
  }
  boot();
  // Ensure audio context unlock on first user gesture (mobile safe)
  try{ document.addEventListener('pointerdown', function(){ try{ ensureAudio(); }catch(e){} }, { once:true, passive:true}); }catch(_e){}
})();
</script>


<script>
(function(){
  const $ = sel => document.querySelector(sel);
  const skinSel = $('#skinSel');
  const skinTitle = $('#skinTitle');

  function populateSkinOptions(){
    if (!skinSel || !window.SKINS) return;
    while (skinSel.firstChild) skinSel.removeChild(skinSel.firstChild);
    const order = Object.keys(window.SKINS);
    for (const key of order){
      const def = window.SKINS[key];
      if (!def) continue;
      const opt = document.createElement('option');
      opt.value = key;
      opt.textContent = def.selectLabel || def.label || key;
      skinSel.appendChild(opt);
    }
  }

  window.updateSkinUI = function(skin){
    if (skinTitle) skinTitle.textContent = skin.label || skin.selectLabel || '經典風格';
  };

  function restoreAndApply(){
    let key = 'classic';
    try {
      const saved = localStorage.getItem('selected_skin');
      if (saved && window.SKINS && window.SKINS[saved]) key = saved;
    } catch(e){}
    if (skinSel) skinSel.value = key;
    if (typeof window.applySkin === 'function') window.applySkin(key);
  }

  function init(){
    if (!window.SKINS) { console.warn('[skin] SKINS not ready yet.'); return; }
    populateSkinOptions();
    restoreAndApply();
  }

  // 監聽選擇
  if (skinSel) {
    skinSel.addEventListener('change', function(){
      const key = skinSel.value;
      if (typeof window.applySkin === 'function') window.applySkin(key);
    }, { passive: true });
  }

  // 若 skin.js 較晚載入，這裡用 DOMContentLoaded 後再 init，多次呼叫也安全
  document.addEventListener('DOMContentLoaded', init, { once:true });
  // 如果已過 DOMContentLoaded，直接 init
  if (document.readyState === 'interactive' || document.readyState === 'complete') { init(); }
})();
</script>


<script>
// === Prism / Rainbow FX 引擎 ===
(function(){
  let rafId = 0, ctx = null, cvs = null;
  let t0 = 0, prevTs = 0;
  let stars=[], snows=[], clouds=[], embers=[], sparks=[], shards=[], slicers=[], flames=[], gears=[], balloons=[];
  let hexagram=null, scriptRing=null, pulse=null, sunOpt=null, flameOpt=null, ruins=[], webOpt=null, balloonOpt=null;
  let nukeAt=0, nukeEnd=0, diffusePhase=0;

  function resize(){
    if (!cvs) return;
    const parent = cvs.parentElement;
    const rect = parent.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    cvs.width  = Math.max(1, Math.floor(rect.width  * ratio));
    cvs.height = Math.max(1, Math.floor((parent.querySelector('#game')?.getBoundingClientRect().height || rect.width*0.56) * ratio));
    cvs.style.height = (cvs.height/ratio)+'px';
  }

  function drawRainbowWash(w, h, time){
    const g = ctx.createLinearGradient(0,0,w,0);
    const hueShift = (time*0.02)%360;
    for(let i=0;i<=6;i++){
      const hue = (hueShift + i*60)%360;
      g.addColorStop(i/6, `hsla(${hue},80%,60%,0.035)`);
    }
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
  }

  function initEffects(eff){
    const w=cvs.width, h=cvs.height;
    stars=[]; snows=[]; clouds=[]; embers=[]; sparks=[]; shards=[]; slicers=[]; flames=[]; balloons=[]; ruins=[]; gears=[];
    hexagram=scriptRing=pulse=null; sunOpt=null; flameOpt=null; balloonOpt=null; nukeAt=0; nukeEnd=0; diffusePhase=0; webOpt=null;
    if(!eff) return;
    if(eff.web) webOpt=eff.web;
    if(eff.stars){
      const count = Math.round( (eff.stars.countScale||1) * 140 );
      for(let i=0;i<count;i++) stars.push({x:Math.random()*w,y:Math.random()*h,r:(eff.stars.sizeMin||1)+Math.random()*((eff.stars.sizeMax||3)-(eff.stars.sizeMin||1)),ph:Math.random()*Math.PI*2});
    }
    if(eff.snow){
      const count = eff.snow.countScale||100;
      for(let i=0;i<count;i++) snows.push({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*0.3,vy:(eff.snow.speed||0.3)+Math.random()*((eff.snow.speedMax||0.8)-(eff.snow.speed||0.3)),ph:Math.random()*Math.PI*2});
    }
    if(eff.clouds){
      for(let i=0;i<eff.clouds.count;i++) clouds.push({x:Math.random()*w,y:Math.random()*h,sz:eff.clouds.sizePx||200,ph:Math.random()*Math.PI*2});
    }
    if(eff.balloons){
      balloonOpt = Object.assign({intervalMs:10000, lifeMs:40000, colors:['#ff8aa0','#ffd966','#9ad0f5','#cfa0ff','#ffe599'], last:0}, eff.balloons);
    }
    if(eff.embers){
      const N = eff.embers.count||200;
      for(let i=0;i<N;i++) embers.push({x:Math.random()*w,y:Math.random()*h,ph:Math.random()*Math.PI*2});
    }
    if(eff.shards){
      for(let i=0;i<eff.shards.count;i++) shards.push({x:Math.random()*w,y:Math.random()*h,ang:(eff.shards.angleDeg||-28)*Math.PI/180});
    }
    if(eff.sparks){
      for(let i=0;i<eff.sparks.count;i++) sparks.push({x:Math.random()*w,y:Math.random()*h});
    }
    if(eff.flames){
      flameOpt=eff.flames;
      const N=flameOpt.count||40;
      for(let i=0;i<N;i++){
        flames.push({
          x:Math.random()*w,
          y:h*(flameOpt.baseY||0.8)+Math.random()*h*0.2,
          size:(flameOpt.sizeMin||2)+Math.random()*((flameOpt.sizeMax||6)-(flameOpt.sizeMin||2)),
          alpha:0.5+Math.random()*0.5,
          speed:(flameOpt.speedMin||0.3)+Math.random()*((flameOpt.speedMax||0.8)-(flameOpt.speedMin||0.3)),
          ph:Math.random()*Math.PI*2
        });
      }
    }
    if(eff.gears){
      const period=eff.gears.rotationMs||30000;
      if(eff.gears.layout){
        const minDim=Math.min(w,h);
        gears=eff.gears.layout.map((g,i)=>{
          const r=g.r*minDim;
          const x=g.x*w;
          const y=g.y*h;
          const inner=g.inner||0.6;
          const dir=g.dir!=null?g.dir:(i%2? -1:1);
          const teeth=g.teeth||12;
          return {x,y,r,teeth,inner,rot:0,omega:dir*2*Math.PI/period};
        });
      }else{
        for(let i=0;i<eff.gears.count;i++){
          const r=(eff.gears.sizeMin||40)+Math.random()*((eff.gears.sizeMax||120)-(eff.gears.sizeMin||40));
          const omega=(Math.random()<0.5?-1:1)*2*Math.PI/period;
          const x=Math.random()*w;
          const y=h*0.55 + Math.random()*h*0.45; // avoid upper brick area
          const inner=0.55+Math.random()*0.2;
          gears.push({x,y,r,teeth:8+Math.floor(Math.random()*5),inner,rot:Math.random()*Math.PI*2,omega});
        }
      }
    }
    if(eff.sun) sunOpt=eff.sun;
    if(eff.hexagram) hexagram=eff.hexagram;
    if(eff.scriptRing) scriptRing=eff.scriptRing;
    if(eff.pulse) pulse=eff.pulse;
    if(eff.ruins){
      for(let i=0;i<eff.ruins.layers;i++) ruins.push({off:Math.random()*w});
    }
    if(eff.nuke) nukeAt=performance.now()+ (eff.nuke.intervalMs||12000);
    if(eff.slicer){
      // start immediately
      slicers.push({t:0});
    }
  }

  function drawPrismBeams(w,h,time,opt){
    const beams=opt.beams||6;const speed=opt.speed||0.0005;const alpha=opt.alpha||0.1;const spread=opt.spread||0.85;const hueShift=opt.hueShift||40;
    const cx=w*0.5,cy=h*0.2;const r=Math.hypot(w,h);const base=time*speed*2*Math.PI;
    for(let i=0;i<beams;i++){
      const a=base+i*(2*Math.PI/beams);const hue=(hueShift+i*(360/beams))%360;const x2=cx+Math.cos(a)*r;const y2=cy+Math.sin(a)*r;
      const grad=ctx.createLinearGradient(cx,cy,x2,y2);
      grad.addColorStop(0,`hsla(${hue},95%,65%,0)`);grad.addColorStop(0.15,`hsla(${hue},95%,65%,${alpha})`);grad.addColorStop(spread,`hsla(${hue},95%,65%,0)`);
      ctx.strokeStyle=grad;ctx.lineWidth=Math.max(1,r*0.012);ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(x2,y2);ctx.stroke();
    }
  }

  function drawCobweb(w,h,time,opt){
    const period = opt.period || 30000;
    const phase = (time % period) / period;
    const rMax = Math.hypot(w,h)*0.6;
    const r = phase * rMax;
    const flash = Math.pow(Math.sin(time*0.0002), 8);
    const shimmer = 0.1 + 0.9*flash;
    const alpha = (opt.alpha || 0.05) * shimmer * (1 - phase);
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.strokeStyle = opt.color || '#e0e0e0';
    ctx.globalAlpha = alpha;
    ctx.lineWidth = opt.lineWidth || 1.2;
    const radials = opt.radials || 12;
    for(let i=0;i<radials;i++){
      const ang = i*(2*Math.PI/radials);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
      ctx.stroke();
    }
    const rings = opt.rings || 6;
    for(let j=1;j<=rings;j++){
      const rr = r*(j/rings);
      ctx.beginPath();
      ctx.arc(0,0,rr,0,Math.PI*2);
      ctx.stroke();
    }
    if(opt.dew){
      const count = opt.dew.count || 20;
      const radius = opt.dew.radius || 2;
      const dewColor = opt.dew.color || '#ffffff';
      const spin = opt.dew.spin || 0.0004;
      for(let i=0;i<count;i++){
        const ang = i*(2*Math.PI/count) + time*spin;
        const rr = r*((i%rings)+1)/(rings+1);
        ctx.save();
        const a = (0.4+0.6*Math.sin(time*0.002+i))*(opt.dew.alpha||0.8)*(1-phase);
        ctx.globalAlpha = a;
        ctx.fillStyle = dewColor;
        ctx.beginPath();
        ctx.arc(Math.cos(ang)*rr, Math.sin(ang)*rr, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    ctx.restore();
  }

  function drawSun(w,h,time,opt){
    const rot=(time%(opt.rotationPeriodMs||30000))/(opt.rotationPeriodMs||30000)*2*Math.PI;
    const scalePeriod=opt.scalePeriodMs||120000;
    const frac=(time%scalePeriod)/scalePeriod;
    const prog=frac<0.5?frac*2:(1-frac)*2;
    const r=Math.min(w,h)*((opt.sizeMin||0.05)+prog*((opt.sizeMax||0.3)-(opt.sizeMin||0.05)));
    const cx=w/2,cy=h*(opt.centerY||0.55);
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(rot);

    if(opt.scatter){
      const count = opt.scatter.count || 16;
      const far = Math.hypot(w,h);
      const near = r;
      const wNear = near * (opt.scatter.widthNear || 0.02);
      const wFar = far * (opt.scatter.widthFar || 0.1);
      const alpha = opt.scatter.alpha || 0.05;
      ctx.globalAlpha = alpha;
      for(let i=0;i<count;i++){
        const ang = i * (2*Math.PI/count);
        const angNear = wNear/near;
        const angFar = wFar/far;
        ctx.beginPath();
        ctx.moveTo(Math.cos(ang-angNear/2)*near, Math.sin(ang-angNear/2)*near);
        ctx.lineTo(Math.cos(ang-angFar/2)*far, Math.sin(ang-angFar/2)*far);
        ctx.lineTo(Math.cos(ang+angFar/2)*far, Math.sin(ang+angFar/2)*far);
        ctx.lineTo(Math.cos(ang+angNear/2)*near, Math.sin(ang+angNear/2)*near);
        ctx.closePath();
        const grad = ctx.createLinearGradient(
          Math.cos(ang)*near, Math.sin(ang)*near,
          Math.cos(ang)*far, Math.sin(ang)*far
        );
        grad.addColorStop(0,'rgba(255,240,200,0)');
        grad.addColorStop(0.2,'rgba(255,240,200,1)');
        grad.addColorStop(1,'rgba(255,240,200,0)');
        ctx.fillStyle = grad;
        ctx.fill();
      }
    }

    ctx.globalAlpha=opt.alpha||0.4;

    const rayCount=opt.rayCount||20;
    const inner=r*0.6;
    const outerLong=r;
    const outerShort=r*0.8;
    ctx.fillStyle='rgba(255,200,80,0.35)';
    ctx.beginPath();
    for(let i=0;i<rayCount*2;i++){
      const ang=i*Math.PI/rayCount;
      let rad;
      if(i%2===0){
        rad = i%4===0?outerLong:outerShort;
      }else{
        rad = inner;
      }
      const x=Math.cos(ang)*rad;
      const y=Math.sin(ang)*rad;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();

    const g=ctx.createRadialGradient(0,0,0,0,0,inner);
    g.addColorStop(0,'rgba(255,255,220,0.9)');
    g.addColorStop(0.7,'rgba(255,180,40,0.4)');
    g.addColorStop(1,'rgba(255,140,0,0)');
    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.arc(0,0,inner,0,Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function loop(ts){
    if(!ctx||!cvs)return;
    if(!t0){ t0=ts; prevTs=ts; }
    const t=ts-t0;
    const dt=ts-prevTs; prevTs=ts;
    const w=cvs.width,h=cvs.height; ctx.clearRect(0,0,w,h);
    const eff=window.currentSkin&&window.currentSkin.canvas&&window.currentSkin.canvas.effects;
    drawRainbowWash(w,h,t);
    if(eff){
      ctx.globalCompositeOperation='screen';
      if(webOpt) drawCobweb(w,h,t,webOpt);
      if(eff.prism) drawPrismBeams(w,h,t,eff.prism);
      if(stars.length){for(const s of stars){const tw=eff.stars&&eff.stars.twinkle?0.5+0.5*Math.sin(t*0.002+s.ph):1;ctx.fillStyle=`rgba(255,255,255,${0.6*tw})`;ctx.beginPath();ctx.arc(s.x,s.y,s.r,0,Math.PI*2);ctx.fill();}}
      if(snows.length){for(const f of snows){f.y+=f.vy;f.x+=f.vx;f.x+=Math.sin(f.ph+t*0.001)*(eff.snow.sway||0.5);if(f.y>h)f.y=-10;if(f.x>w)f.x=0;if(f.x<0)f.x=w;ctx.fillStyle='rgba(255,255,255,0.8)';ctx.beginPath();ctx.arc(f.x,f.y,2,0,Math.PI*2);ctx.fill();}}
      if(clouds.length){
        ctx.globalAlpha = eff.clouds.alpha || 0.25;
        for(const c of clouds){
          c.x += Math.sin(t*0.00005 + c.ph) * (eff.clouds.speed || 0.002) * 50;
          if(c.x > w + c.sz) c.x = -c.sz;
          const grad = ctx.createRadialGradient(c.x, c.y, c.sz*0.2, c.x, c.y, c.sz);
          grad.addColorStop(0,'#ffffff');
          grad.addColorStop(1,'#ffe6f5');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(c.x - c.sz*0.4, c.y, c.sz*0.6, 0, Math.PI*2);
          ctx.arc(c.x, c.y - c.sz*0.2, c.sz*0.7, 0, Math.PI*2);
          ctx.arc(c.x + c.sz*0.4, c.y, c.sz*0.6, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
        if(balloonOpt){
          const interval = balloonOpt.intervalMs || 10000;
          if(t - balloonOpt.last >= interval){
            balloonOpt.last = t;
            const cols = balloonOpt.colors || ['#ff8aa0','#ffd966','#9ad0f5','#cfa0ff','#ffe599'];
            const col = cols[Math.floor(Math.random()*cols.length)];
            balloons.push({x:Math.random()*w,y:h+30,color:col});
          }
          for(let i=balloons.length-1;i>=0;i--){
            const b=balloons[i];
            const life=balloonOpt.lifeMs||40000;
            b.y -= h*dt/life;
            ctx.fillStyle=b.color;
            ctx.beginPath();
            ctx.ellipse(b.x,b.y,20,26,0,0,Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(b.x,b.y+26);
            ctx.lineTo(b.x,b.y+40);
            ctx.strokeStyle='rgba(0,0,0,0.15)';
            ctx.lineWidth=2;
            ctx.stroke();
            if(b.y<-30) balloons.splice(i,1);
          }
        }
      if(embers.length){const cx=w*(eff.embers.center?eff.embers.center[0]:0.5), cy=h*(eff.embers.center?eff.embers.center[1]:0.5);for(const p of embers){p.ph+=eff.embers.omega||0.002;const r=Math.hypot(p.x-cx,p.y-cy);const ang=Math.atan2(p.y-cy,p.x-cx)+ (eff.embers.omega||0.002);p.x=cx+Math.cos(ang)*r; p.y=cy+Math.sin(ang)*r; ctx.fillStyle='rgba(255,120,40,0.8)';ctx.beginPath();ctx.arc(p.x,p.y,2,0,Math.PI*2);ctx.fill();}}
      if(gears.length){
        for(const g of gears){
          g.rot+=g.omega*dt;
          ctx.save();
          ctx.translate(g.x,g.y);
          ctx.rotate(g.rot);
          ctx.globalAlpha=0.6;
          const step=2*Math.PI/g.teeth;
          // 讓齒槽寬度與輪齒寬度一致，因此每齒佔一半角度
          const tooth=step*0.5;
          const root=g.r*0.75;
          ctx.beginPath();
          ctx.moveTo(root,0);
          for(let i=0;i<g.teeth;i++){
            const a=i*step;
            ctx.lineTo(root*Math.cos(a), root*Math.sin(a));
            ctx.lineTo(g.r*Math.cos(a), g.r*Math.sin(a));
            ctx.lineTo(g.r*Math.cos(a+tooth), g.r*Math.sin(a+tooth));
            ctx.lineTo(root*Math.cos(a+tooth), root*Math.sin(a+tooth));
          }
          ctx.closePath();
          const grad=ctx.createRadialGradient(0,0,g.r*0.2,0,0,g.r);
          grad.addColorStop(0,'rgba(255,240,220,0.1)');
          grad.addColorStop(0.6,'rgba(200,170,120,0.05)');
          grad.addColorStop(1,'rgba(90,70,50,0.03)');
          ctx.fillStyle=grad;
          ctx.fill();
          ctx.lineWidth=g.r*0.04;
          ctx.strokeStyle='rgba(255,220,170,0.15)';
          ctx.stroke();
          ctx.globalCompositeOperation='destination-out';
          ctx.beginPath();
          ctx.arc(0,0,g.r*0.4,0,Math.PI*2);
          ctx.fill();
          ctx.globalCompositeOperation='source-over';
          ctx.beginPath();
          ctx.arc(0,0,g.r*0.4,0,Math.PI*2);
          ctx.lineWidth=g.r*0.025;
          ctx.strokeStyle='rgba(255,220,170,0.1)';
          ctx.stroke();
          ctx.restore();
        }
      }
      if(sparks.length){for(const sp of sparks){ctx.fillStyle='rgba(255,210,122,0.8)';ctx.fillRect(sp.x,sp.y,2,2);}}
      if(flames.length){for(const f of flames){f.y-=f.speed;f.x+=Math.sin(t*0.002+f.ph)*(flameOpt?.drift||0.3);f.alpha-=0.004;f.size*=0.98;if(f.alpha<=0||f.y<h*(flameOpt?.dieY||0.55)){f.x=Math.random()*w;f.y=h*(flameOpt?.baseY||0.8)+Math.random()*h*0.2;f.size=(flameOpt?.sizeMin||2)+Math.random()*((flameOpt?.sizeMax||6)-(flameOpt?.sizeMin||2));f.alpha=0.5+Math.random()*0.5;f.speed=(flameOpt?.speedMin||0.3)+Math.random()*((flameOpt?.speedMax||0.8)-(flameOpt?.speedMin||0.3));f.ph=Math.random()*Math.PI*2;}ctx.fillStyle=`rgba(255,220,150,${f.alpha})`;ctx.beginPath();ctx.arc(f.x,f.y,f.size,0,Math.PI*2);ctx.fill();}}
      if(sunOpt) drawSun(w,h,t,sunOpt);
      if(hexagram){const R=Math.min(w,h)*(hexagram.radiusMul||0.44);const rot=(t%(hexagram.rotationPeriodMs||24000))/(hexagram.rotationPeriodMs||24000)*2*Math.PI;ctx.save();ctx.translate(w/2,h*0.48);ctx.rotate(rot);ctx.strokeStyle=hexagram.color||'#FFD27A';ctx.lineWidth=(hexagram.strokePx||2);ctx.beginPath();for(let i=0;i<6;i++){const a=i*Math.PI/3;ctx.lineTo(Math.cos(a)*R,Math.sin(a)*R);}ctx.closePath();ctx.stroke();ctx.restore();}
      if(scriptRing){const R=Math.min(w,h)*(scriptRing.radiusMul||0.58);const rot=-(t%(scriptRing.rotationPeriodMs||24000))/(scriptRing.rotationPeriodMs||24000)*2*Math.PI;ctx.save();ctx.translate(w/2,h*0.48);ctx.rotate(rot);ctx.strokeStyle=scriptRing.strokeColor||'#FFD27A';ctx.lineWidth=(scriptRing.strokePx||1.6);ctx.globalAlpha=scriptRing.alpha||0.7;ctx.beginPath();ctx.arc(0,0,R,0,Math.PI*2);ctx.stroke();ctx.restore();}
      if(pulse){const cx=w/2,cy=h*0.48;const r=(t%(pulse.intervalMul?skin.canvas.period*(pulse.intervalMul):skin.canvas.period))/ (skin.canvas.period||2000);const rad=r*Math.min(w,h);ctx.strokeStyle=`rgba(${pulse.color.join(',')},0.3)`;ctx.lineWidth=pulse.thickness||4;ctx.beginPath();ctx.arc(cx,cy,rad,0,Math.PI*2);ctx.stroke();}
      if(ruins.length){ctx.fillStyle='rgba(0,0,0,'+(eff.ruins.haze||0.2)+')';for(const r0 of ruins){ctx.fillRect((r0.off+t*0.01)%w - w,h*0.6,w,h*0.4);}}
      if(eff.nuke){const now=performance.now(); if(now>nukeAt){nukeEnd=now+(eff.nuke.flashMs||200); nukeAt=now+(eff.nuke.intervalMs||12000);} if(now<nukeEnd){ctx.fillStyle='rgba(255,255,255,0.3)';ctx.fillRect(0,0,w,h);} }
      if(eff.diffuse){
        diffusePhase=(diffusePhase+0.001)%1;
        const rr=Math.max(w,h)*diffusePhase;
        const col=eff.diffuse.color||[255,69,0];
        const alpha=eff.diffuse.alpha||0.05;
        const g=ctx.createRadialGradient(w/2,h/2,rr*0.2,w/2,h/2,rr);
        g.addColorStop(0,`rgba(${col[0]},${col[1]},${col[2]},${alpha})`);
        g.addColorStop(1,`rgba(${col[0]},${col[1]},${col[2]},0)`);
        ctx.fillStyle=g;
        ctx.fillRect(0,0,w,h);
      }
      if(eff.slicer){const now=performance.now(); if(!slicers.length||now-slicers[slicers.length-1].t>(eff.slicer.intervalMs||3000)){slicers.push({t:now,x:Math.random()*w});}
        ctx.strokeStyle=eff.slicer.color||'rgba(190,0,30,0.35)';ctx.lineWidth=(eff.slicer.widthMul||0.3)*10; for(let i=slicers.length-1;i>=0;i--){const s=slicers[i]; const age=now-s.t; if(age>(eff.slicer.lifeMs||500)){slicers.splice(i,1);continue;} const y=age*0.5; ctx.beginPath(); ctx.moveTo(s.x,y); ctx.lineTo(s.x+w,y+h); ctx.stroke();}}
      ctx.globalCompositeOperation='source-over';
    }
    rafId=requestAnimationFrame(loop);
  }

  function start(skin){
    if(!cvs){cvs=document.getElementById('fx'); if(!cvs) return; ctx=cvs.getContext('2d',{alpha:true}); window.addEventListener('resize',resize);} resize(); cancelAnimationFrame(rafId); t0=0; initEffects(skin.canvas&&skin.canvas.effects); rafId=requestAnimationFrame(loop);
  }
  function stop(){ cancelAnimationFrame(rafId); if(ctx&&cvs){ctx.clearRect(0,0,cvs.width,cvs.height);} }
  window.fxStart=start; window.fxStop=stop;
})();
</script>

</body>
</html>
