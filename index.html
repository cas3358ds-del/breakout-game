<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rock打磚塊 Breakout（最終增強版）</title>
  <style>
    :root {
      --bg:#0b1022; --bg2:#0a0f1e; --fg:#e9ecf1; --accent:#66b2ff;
      --brick1:#ff6b6b; --brick2:#ffd166; --brick3:#06d6a0; --brick4:#4cc9f0;
      --expl:#ff8c00; --power:#7aa2ff; --debuff:#ff6aa3;
      --glass: rgba(255,255,255,.06); --glass-stroke: rgba(255,255,255,.12);
      --btn:#1a2448; --btn-stroke:#2a3974; --pill:#121a36;
      --led:#8fb3ff;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 800px at 50% -10%, #152040, #0a0f1e 60%); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;}
    body{min-height:100svh; display:flex; align-items:flex-start; justify-content:center;}
    .wrap{display:flex; gap:12px; align-items:center; justify-content:center; flex-direction:column; padding:12px; width:100%; max-width:1200px}
    h1{margin:4px 0 2px 0; font-weight:800; letter-spacing:.3px; text-shadow:0 2px 20px #0008;
       font-size:clamp(16px,3.2vw,28px)}
    .hud{
      position:sticky; top:0; z-index:5;
      display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; font-weight:650;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--glass-stroke); border-radius:14px; padding:8px 10px;
      box-shadow: 0 6px 24px rgba(0,0,0,.25); backdrop-filter: blur(6px);
    }
    .pill{padding:6px 10px; background:var(--pill); border:1px solid var(--glass-stroke); border-radius:999px; font-size:14px}
    .btn{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg);
      border:1px solid var(--btn-stroke); border-radius:10px; padding:6px 10px; cursor:pointer; user-select:none; font-size:14px}
    .btn:active{transform:translateY(1px)}
    select,input[type="range"]{background:linear-gradient(180deg, var(--btn), #111a34); color:var(--fg); border:1px solid var(--btn-stroke); border-radius:8px; padding:6px 10px}
    .range{display:flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid var(--glass-stroke); border-radius:999px; background:var(--pill); font-size:12px}
    canvas{background:linear-gradient(180deg, #0d1126, #0b1022 55%, #091022);
      border:1px solid #1a2348; border-radius:16px; max-width:min(1120px, 98vw); width: min(1120px, 98vw); height: auto; display:block;
      box-shadow: 0 30px 80px rgba(0,0,0,.35), inset 0 0 120px rgba(255,255,255,.02); touch-action:none;}
    .overlay{position:relative}
    .center-note{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:3}
    .note-box{background:linear-gradient(180deg, rgba(8,12,28,.9), rgba(8,12,28,.85));
      border:1px solid var(--glass-stroke); padding:16px 18px; border-radius:14px; text-align:center; max-width:min(90vw,860px);
      box-shadow: 0 12px 60px rgba(0,0,0,.5); font-size:14px}
    .note-box h2{margin:0 0 8px 0; font-size:18px}
    .note-box p{margin:6px 0; line-height:1.6}
    .note-box .cols{display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:10px; text-align:left}
    kbd{background:#0e1836; border:1px solid #2a356a; border-radius:6px; padding:2px 6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:90%}

    .badges{display:flex; gap:6px; flex-wrap:wrap; align-items:center; justify-content:center}
    .badge{background:linear-gradient(180deg, rgba(18,32,68,.9), rgba(10,20,48,.9));
      border:1px solid var(--glass-stroke); padding:4px 8px; border-radius:999px; font-size:12px; display:flex; gap:6px; align-items:center}
    .legend{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; font-size:12px}
    .legend .box{width:14px; height:14px; display:inline-block; border-radius:3px; margin-right:4px; vertical-align:middle}
    .legend .item{padding:4px 8px; border-radius:10px; background:rgba(255,255,255,.05); border:1px solid var(--glass-stroke)}

    /* 清關畫廊 overlay */ 
    .gallery{position:absolute; inset:0; display:none; align-items:center; justify-content:center; flex-direction:column; z-index:4;}
    .gallery .backdrop{position:absolute; inset:0; background:rgba(0,0,0,.75); opacity:0; transition:opacity .6s;}
    .gallery img{max-width:min(94vw,1040px); max-height:min(88vh,680px); border-radius:16px; box-shadow:0 30px 120px rgba(0,0,0,.6); opacity:0; transform:translateY(12px) scale(.98); transition:opacity .6s, transform .6s;}
    .gallery .hint{position:absolute; bottom:24px; color:#fff; font-size:16px; opacity:0; text-shadow:0 2px 10px rgba(0,0,0,.6);}
    .gallery.show .backdrop{opacity:1;}
    .gallery.show img{opacity:1; transform:translateY(0) scale(1);} 
    .gallery.show .hint{opacity:.9;}

    /* 勝利畫面 */
    .win{position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:6;}
    .win.show{display:flex;}
    .win .backdrop{position:absolute; inset:0; background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.88));}
    .thumb-ring{position:absolute; inset:16px; pointer-events:none; display:grid; grid-template-columns:repeat(10,1fr); gap:6px; opacity:.95}
    .thumb-ring img{width:100%; height:100%; object-fit:cover; border-radius:10px; box-shadow:0 8px 30px rgba(0,0,0,.5);}
    .win .center{position:relative; z-index:2; text-align:center; background:linear-gradient(180deg, rgba(10,14,30,.85), rgba(10,14,30,.75)); padding:18px 22px; border:1px solid var(--glass-stroke); border-radius:16px; box-shadow:0 20px 90px rgba(0,0,0,.5)}
    .win h2{margin:4px 0 6px; font-size:28px; letter-spacing:2px}
    .win .small{opacity:.8; font-size:12px; margin-top:6px}
    .win .again{margin-top:10px}

    @media (max-width: 768px){
      .wrap{padding:8px}
      .pill,.btn{font-size:12px; padding:5px 8px}
      .legend{display:none}
      .hud{gap:6px}
      .thumb-ring{grid-template-columns:repeat(5,1fr)}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Rock打磚塊 Breakout（最終增強版）</h1>
    <div class="hud">
      <div class="pill">分數 <span id="score">0</span></div>
      <div class="pill">關卡 <span id="level">1</span>/20</div>
      <div class="pill">生命 <span id="lives">3</span></div>
      <label>難度
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </label>
      <button class="btn" id="pauseBtn">開始 / 暫停 (<kbd>Space</kbd>)</button>
      <button class="btn" id="resetBtn">重開 (<kbd>R</kbd>)</button>
      <button class="btn" id="fsBtn">全螢幕 (<kbd>F</kbd>)</button>
      <button class="btn" id="tutorBtn">教學</button>
      <button class="btn" id="effectsBtn">效果說明</button>
      <button class="btn" id="soundBtn">音效：關</button>
      <span class="range">BGM
        <button class="btn" id="bgmBtn">關</button>
        <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.5" style="width:120px">
      </span>
      <button class="btn" id="saveBtn">存檔</button>
      <button class="btn" id="loadBtn">讀檔</button>
      <button class="btn" id="clearSaveBtn">清除存檔</button>
    </div>

    <div class="legend">
      <span class="item"><span class="box" style="background:var(--expl)"></span>爆炸磚</span>
      <span class="item"><span class="box" style="background:var(--brick2)"></span>一般磚</span>
      <span class="item"><span class="box" style="background:#888"></span>不可破壞磚</span>
      <span class="item"><span class="box" style="background:#bb7aff"></span>強反彈磚</span>
      <span class="item"><span class="box" style="background:#6ec6ff"></span>移動磚</span>
      <span class="item"><span class="box" style="background:#ff4d6d"></span>Boss磚</span>
      <span class="item"><span class="box" style="background:var(--power)"></span>增益道具</span>
      <span class="item"><span class="box" style="background:var(--debuff)"></span>減益道具</span>
    </div>
    <div class="badges" id="activeBuffs"></div>

    <div class="overlay">
      <div class="gallery" id="gallery">
        <div class="backdrop"></div>
        <img id="galleryImg" src="" alt="關卡大圖" />
        <div class="hint">點一下進入下一關 ▶</div>
      </div>

      <div class="win" id="win">
        <div class="backdrop"></div>
        <div class="thumb-ring" id="ring"></div>
        <div class="center">
          <h2>恭喜過關！</h2>
          <div>總分數：<span id="finalScore">0</span></div>
          <div class="small">作者： ChatGPT　／　指導者： Rock</div>
          <div class="again"><button class="btn" id="againBtn">再玩一次</button></div>
        </div>
      </div>

      <canvas id="game" width="1100" height="700"></canvas>
      <div class="center-note" id="centerNote">
        <div class="note-box" id="noteBox">
          <h2 id="noteTitle">按 <kbd>Space</kbd> 或點畫面開始</h2>
          <p id="noteText">
            操作：<kbd>←</kbd>/<kbd>→</kbd> 或 <kbd>A</kbd>/<kbd>D</kbd>；手指拖曳畫面也可移動平台。<br>
            已整合：背景逐步揭示 + 清關畫廊、增益/減益（含電漿球/凍結球/神聖球/鳳凰審判/9命怪貓）、爆炸磚、音效、難度、存讀檔、BGM、教學/效果說明、Boss與進階磚。
          </p>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // === 設定 ===
  const GAME_CONFIG = {
    totalLevels: 20,
    difficulty: {
      easy:   { paddleBaseW: 220, baseSpeed: 4, rowsBase: 6, dropRate: 0.72 },
      normal: { paddleBaseW: 180, baseSpeed: 4.5, rowsBase: 7, dropRate: 0.52 },
      hard:   { paddleBaseW: 140, baseSpeed: 6, rowsBase: 8, dropRate: 0.32 },
    },
    bricks: { explosiveChance: 0.18, brickHeight: 30, padding: 9, topOffset: 60, cols: 12 },
    powers: {
      // 既有
      WIDE:{label:'平台變寬',type:'buff',durationMs:30000,paddleWidthAdd:50,badge:'↔️'},
      LONG:{label:'平台變長(可疊)',type:'buff',durationMs:30000,longPerStackAdd:40,stacksMax:2,badge:'📏'},
      STICKY:{label:'黏性平台(上彈可暫黏)',type:'buff',durationMs:5000,sticky:true,badge:'🧲'},
      MULTI:{label:'多球',type:'buff',multiDuplicate:true,maxBalls:4,badge:'✨'},
      SLOW:{label:'全局慢速',type:'buff',durationMs:15000,speedMul:0.6,badge:'🐢'},
      PIERCE:{label:'穿透球',type:'buff',durationMs:12000,piercing:true,badge:'🎯'},
      SHIELD:{label:'護盾(掉球擋一次)',type:'buff',oneShotShield:true,badge:'🛡'},
      RAMPAGE:{label:'暴走球(短暫強穿)',type:'buff',durationMs:5000,forcePiercing:true,rampageMs:5000,badge:'🔥'},
      FAST:{label:'快速球',type:'debuff',durationMs:5000,globalSpeedMul:2.0,screenShakeOnApply:6,badge:'⚡'},
      WAVY:{label:'變速球',type:'debuff',durationMs:5000,wavy:{amp:0.6,base:1.2,periodMs:200},badge:'〰️'},
      // 新增
      PLASMA:{label:'電漿球(擊中放出電漿圈清列)',type:'buff',durationMs:10000,plasma:{drift:1.2,radius:38,lifeMs:3000},badge:'⚡️'},
      FREEZE:{label:'凍結球(延遲停頓一下)',type:'buff',durationMs:10000,freeze:{delayMs:300,stopMs:2000},badge:'❄️'},
      HOLY:{label:'神聖球(十字清線)',type:'buff',durationMs:5000,holy:{},badge:'✝️'},
      PHOENIX:{label:'鳳凰審判(消半場/不秒殺Boss)',type:'rare',rareFactor:0.08,instant:true,badge:'🪽'},
      NINE:{label:'9命怪貓(生命變9)',type:'rare',rareFactor:0.08,instant:true,badge:'🐱'}
    },
    powerCapsule:{width:24,height:16,fallVy:2.2},
    caps:{paddleMaxW:300,ballSpeedMax:16}
  };

  // === 影像載入（支援 .png / .jpg） ===
  const IMG_PAIRS = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.png`, cg:`images/cg${i}.png`}));
  // 準備 jpg 後備
  const IMG_PAIRS_FALLBACK = Array.from({length:10}, (_,i)=> i+1).map(i=>({bg:`images/bg${i}.jpg`, cg:`images/cg${i}.jpg`}));

  function makeImg(src, fallback){
    const im = new Image(); im.decoding='async'; im.loading='eager'; im.src=src;
    if(fallback){
      im.onerror=()=>{ if(im.src!==fallback) im.src=fallback; };
    }
    return im;
  }
  const IMG_MAP = []; // 0..9: {bg:Image, cg:Image}
  for(let i=0;i<10;i++){
    IMG_MAP[i] = {
      bg: makeImg(IMG_PAIRS[i].bg, IMG_PAIRS_FALLBACK[i].bg),
      cg: makeImg(IMG_PAIRS[i].cg, IMG_PAIRS_FALLBACK[i].cg),
    };
  }

  // === 參考 DOM ===
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const scoreEl=document.getElementById('score'), levelEl=document.getElementById('level'), livesEl=document.getElementById('lives');
  const pauseBtn=document.getElementById('pauseBtn'), resetBtn=document.getElementById('resetBtn'), fsBtn=document.getElementById('fsBtn');
  const soundBtn=document.getElementById('soundBtn'), saveBtn=document.getElementById('saveBtn'), loadBtn=document.getElementById('loadBtn'), clearSaveBtn=document.getElementById('clearSaveBtn');
  const tutorBtn=document.getElementById('tutorBtn'), effectsBtn=document.getElementById('effectsBtn');
  const centerNote=document.getElementById('centerNote'), noteTitle=document.getElementById('noteTitle'), noteText=document.getElementById('noteText'), noteBox=document.getElementById('noteBox');
  const difficultySel=document.getElementById('difficulty'), activeBuffsEl=document.getElementById('activeBuffs');
  const gallery=document.getElementById('gallery'), galleryImg=document.getElementById('galleryImg');
  const win=document.getElementById('win'), ring=document.getElementById('ring'), finalScore=document.getElementById('finalScore'), againBtn=document.getElementById('againBtn');
  const bgmBtn=document.getElementById('bgmBtn'), bgmVol=document.getElementById('bgmVol');

  // === DPR 縮放 ===
  function resizeCanvasDPR(){ const dpr=Math.min(window.devicePixelRatio||1,2); const cssW=canvas.clientWidth; const cssH=Math.round(cssW*(700/1100)); canvas.style.height=cssH+'px'; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); scaleX=canvas.width/1100; scaleY=canvas.height/700; }
  let scaleX=1, scaleY=1; window.addEventListener('resize', resizeCanvasDPR, {passive:true}); resizeCanvasDPR();

  // === 狀態 ===
  let running=false, paused=true, level=1, score=0, lives=3, soundsOn=false;
  let bgTime=0; let screenShake=0;
  let countdownTimer=null, countdownShow=0, resumePending=false;
  // 影像選擇：1~10 隨機 bg/cg，11~20 用對應未用者
  let imageChoice = new Array(10).fill(-1); // 0=bg,1=cg; -1: 未決
  // BGM
  let audioCtx=null, bgmGain=null, bgmOn=false, bgmStarted=false;
  let bgmNodes=[]; // 便於停播

  // 粒子 / 特效容器
  const particles=[]; // {x,y,vx,vy,life,size,color}
  const plasmas=[];   // {x,y,vx,vy,until,radius}
  const holyFlashes=[]; // {x,y,until}
  let phoenixAnim=null; // {x, tEnd}
  const fireBursts=[];  // 火焰片段 {x,y,life}

  function spawnParticles(x,y,color,count=10,spread=1.6,speed=3,size=3){
    for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const v=speed*(.4+Math.random()); particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:400+Math.random()*300,size:size*(.6+Math.random()*0.8),color}); }
  }

  // === 工具 ===
  function getDiff(){ return GAME_CONFIG.difficulty[difficultySel.value]; }
  function brickColor(i){ return [getVar('--brick1'),getVar('--brick2'),getVar('--brick3'),getVar('--brick4')][i%4]; }
  function getVar(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo((x+r)*scaleX,y*scaleY); ctx.arcTo((x+w)*scaleX,y*scaleY,(x+w)*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo((x+w)*scaleX,(y+h)*scaleY,x*scaleX,(y+h)*scaleY,r*scaleX); ctx.arcTo(x*scaleX,(y+h)*scaleY,x*scaleX,y*scaleY,r*scaleX); ctx.arcTo(x*scaleX,y*scaleY,(x+w)*scaleX,y*scaleY,r*scaleX); ctx.closePath(); }

  // === Buff/De-buff 顯示 ===
  function badgeIcon(k){ return (GAME_CONFIG.powers[k]?.badge)||'●'; }
  function updateBuffBadges(){ activeBuffsEl.innerHTML=''; const now=performance.now();
    // LONG 堆疊
    const longAct=buffs.LONG.stacks.filter(t=>t>now); if(longAct.length){ const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon('LONG')} LONG×${longAct.length} ${Math.max(0,Math.max(...longAct)-now|0)}ms`; activeBuffsEl.appendChild(s); }
    // 其它
    for(const key of Object.keys(GAME_CONFIG.powers)){ if(key==='LONG') continue; const b=buffs[key]; if(!b?.active) continue; const left=b.until&&b.until>now?((b.until-now)/1000).toFixed(1)+'s':''; const s=document.createElement('span'); s.className='badge'; s.textContent=`${badgeIcon(key)} ${key}${left?' '+left:''}`; activeBuffsEl.appendChild(s); }
  }

  // === Buff 狀態 ===
  const buffs={WIDE:{active:false,until:0},STICKY:{active:false,until:0},MULTI:{active:false,until:0},SLOW:{active:false,until:0},PIERCE:{active:false,until:0},SHIELD:{active:false,until:0},RAMPAGE:{active:false,until:0},FAST:{active:false,until:0},WAVY:{active:false,until:0,start:0},LONG:{active:false,until:0,stacks:[]},PLASMA:{active:false,until:0},FREEZE:{active:false,until:0},HOLY:{active:false,until:0}};

  // === 擋板 & 球 ===
  let diff=getDiff(); const paddle={w:diff.paddleBaseW,h:18,x:1100/2-diff.paddleBaseW/2,y:700-50,speed:12};
  let balls=[]; function makeBall(stuck=false,x=null){ return {x:x??(1100/2),y:700/2,r:10,vx:5,vy:-5,speedCap:GAME_CONFIG.caps.ballSpeedMax,piercing:false,stuck:stuck,offsetX:0,rampageUntil:0,trail:[],freeze:{until:0,oldVX:0,oldVY:0,pending:false}}; }

  // === 聲音與BGM ===
  function ensureAudio(){ if(!audioCtx){ const AC=(window.AudioContext||window.webkitAudioContext); if(AC){ audioCtx=new AC(); } } if(audioCtx && !bgmGain){ bgmGain=audioCtx.createGain(); bgmGain.gain.value=parseFloat(localStorage.getItem('bgm_vol')||'0.5'); bgmGain.connect(audioCtx.destination); } }
  function beep(freq=600,dur=0.05,vol=0.06){ if(!soundsOn||!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.stop(); }, Math.max(10, dur*1000)); }

  function startBGM(){
    if(!audioCtx) ensureAudio();
    if(!audioCtx) return;
    if(bgmStarted) return;
    audioCtx.resume?.();
    bgmStarted=true;
    // 輕量 Lo-Fi loop（兩層）：無外部音檔
    const now=audioCtx.currentTime;
    const tempo=92/60; // beats/sec
    function tone(freq, type='sine', start, dur, gain=0.03){
      const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value=0; o.connect(g); g.connect(bgmGain);
      o.start(now+start); g.gain.setTargetAtTime(gain, now+start, 0.02);
      g.gain.setTargetAtTime(0.0001, now+start+dur-0.04, 0.02);
      o.stop(now+start+dur+0.1); bgmNodes.push(o,g);
    }
    function loop(){
      if(!bgmOn) return;
      const base=audioCtx.currentTime;
      bgmNodes=[];
      // 和弦墊（Cmaj7 - Am7 - Fmaj7 - Gsus）
      const prog=[[261.63,329.63,392.00,493.88],[220.00,261.63,329.63,392.00],[174.61,220.00,261.63,349.23],[196.00,246.94,392.00,392.00]];
      for(let i=0;i<4;i++){
        const chord=prog[i];
        for(const f of chord){ tone(f,'sine', i*4/tempo, 3.6/tempo, 0.015); }
      }
      // 簡單主旋律
      const mel=[523.25,587.33,659.25,587.33,523.25,659.25,698.46,659.25,587.33];
      mel.forEach((f,idx)=> tone(f,'triangle', idx*0.5/tempo, 0.35/tempo, 0.025));
      // 下一次排程
      setTimeout(()=>{ if(bgmOn) loop(); }, 4000);
    }
    loop();
  }
  function stopBGM(){ bgmStarted=false; bgmNodes.forEach(n=>{try{n.disconnect?.()}catch{} }); bgmNodes.length=0; }

  // === 磚塊與揭示 ===
  let bricks=[]; let brickW=0, brickH=GAME_CONFIG.bricks.brickHeight; let revealRects=[];
  function layout(){ return {rows:getDiff().rowsBase+Math.floor((level-1)%3), cols:GAME_CONFIG.bricks.cols, pad:GAME_CONFIG.bricks.padding, top:GAME_CONFIG.bricks.topOffset, h:GAME_CONFIG.bricks.brickHeight}; }

  // 取得本關顯示影像（1~10隨機BG/CG；11~20用另一張）
  function getLevelImage(levelNum){
    const idx=((levelNum-1)%10);
    if(levelNum<=10){
      if(imageChoice[idx]<0){ imageChoice[idx]= Math.random()<0.5 ? 0:1; }
      return imageChoice[idx]===0? IMG_MAP[idx].bg : IMG_MAP[idx].cg;
    }else{
      if(imageChoice[idx]<0){ imageChoice[idx]=0; } // 保底
      return imageChoice[idx]===0? IMG_MAP[idx].cg : IMG_MAP[idx].bg;
    }
  }

  // 特殊磚模板
  function addBrick(list, x,y,w,h, opts={}){
    list.push(Object.assign({x,y,w,h,hp:opts.unbreakable?Infinity:(opts.hp||1), colorIdx:0, explosive:false, unbreakable:false, strong:false, moving:false, vx:0, vy:0, boss:false, face:''}, opts));
  }

  function initBricks(){
    const L=layout();
    const totalPad=(L.cols+1)*L.pad; brickW=Math.floor((1100-totalPad)/L.cols); brickH=L.h; bricks=[]; revealRects=[];
    // 依關卡設計關卡布局
    generateLevel(level, L);
  }

  
  // === 修正點：判定剩餘可破壞磚（避開不可破壞磚導致無法過關） ===
  function hasBreakables(){
    // 有任何「非不可破壞」的磚（包含Boss未被擊倒）則尚未清關
    return bricks.some(b => !b.unbreakable);
  }

  // === 修正點：以格點對齊的方式揭示圖片，避免偶發性黑洞 ===
  function revealBrickArea(brick){
    const L = layout();
    const cellW = brickW, cellH = brickH;
    // 嘗試將實際座標對齊到格點，避免移動磚或浮點誤差
    const c0 = Math.Math.max(0, Math.min(GAME_CONFIG.bricks.cols-1, Math.round((brick.x - L.pad) / (cellW + L.pad)) ));
    const r0 = Math.Math.max(0, Math.min(L.rows-1, Math.round((brick.y - L.top) / (cellH + L.pad)) ));
    // 估算覆蓋幾個cell（Boss 寬/高>1）
    const cellsX = max1 = Math.max(1, Math.round((brick.w + L.pad) / (cellW + L.pad)));
    const cellsY = Math.max(1, Math.round((brick.h + L.pad) / (cellH + L.pad)));
    for(let rr=0; rr<cellsY; rr++){
      for(let cc=0; cc<cellsX; cc++){
        const c = Math.min(GAME_CONFIG.bricks.cols-1, c0 + cc);
        const r = Math.min(L.rows-1, r0 + rr);
        const rx = L.pad + c*(cellW + L.pad);
        const ry = L.top + r*(cellH + L.pad);
        revealRects.push({x:rx, y:ry, w:cellW, h:cellH});
      }
    }
  }
function generateLevel(lv, L){
    const cols=L.cols, rows=L.rows, pad=L.pad, top=L.top;
    const baseHP = 1 + Math.floor((lv-1)/3);
    const xAt = c=> L.pad + c*(brickW+L.pad);
    const yAt = r=> L.top + r*(brickH+L.pad);
    // 關卡區段
    const late = lv>=7;
    const later = lv>=11;
    const endgame = lv>=15;

    // Boss每5關
    const isBoss = (lv%5===0);
    if(isBoss){
      // 中央大Boss（2x2磚尺寸一塊）
      const bx = Math.floor(cols/2)-1;
      const by = Math.max(1, Math.floor(rows/2)-1);
      const w = brickW*2 + pad;
      const h = brickH*2 + pad;
      const hpList=[10,20,30,40];
      const bossIdx = Math.floor(lv/5)-1;
      const bossHP = hpList[Math.max(0,Math.min(3,bossIdx))];
      const faces=['獅','騎','目','魔'];
      addBrick(bricks, xAt(bx), yAt(by), w, h, {hp:bossHP, colorIdx:0, boss:true, face:faces[bossIdx], strong:true});
      // 周圍護衛磚
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(c>=bx-2 && c<=bx+3 && r>=by-2 && r<=by+3) continue; // 留 Boss 區域
          const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance;
          addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
        }
      }
      // 加點不可破壞邊框
      for(let c=0;c<cols;c+=2) addBrick(bricks, xAt(c), yAt(0), brickW, brickH, {unbreakable:true});
      return;
    }

    // 非Boss關：設計不同排列
    if(lv<=3){
      // 初學：滿版 + 少量爆炸
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const explosive=Math.random()<GAME_CONFIG.bricks.explosiveChance*0.7;
        addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, colorIdx:(r%4), explosive});
      }
    }else if(lv<=6){
      // V 形＋中間走廊
      const mid=Math.floor(cols/2);
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(Math.abs(c-mid)===r%5 && r<rows-1){ // V
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+((r%2)?1:0), colorIdx:r%4});
          }else if(r===Math.floor(rows/2) && (c%3===0)){ // 中線爆炸
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, explosive:true, colorIdx:r%4});
          }
        }
      }
    }else if(lv<=10){
      // 加入不可破壞隔板與少量移動磚
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r%4===0 && c%3===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else{
            const moving = (r%3===0 && c%4===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, moving, vx: moving? ((Math.random()<0.5?-1:1)*0.6) : 0});
          }
        }
      }
    }else if(lv<=14){
      // 交錯棋盤 + 強反彈帶
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if((r+c)%2===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, colorIdx:r%4, strong:(r%4===1)});
          }else if(r%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%5===0){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP, moving:true, vx: (Math.random()<0.5?-1:1)*0.8});
          }
        }
      }
    }else{
      // 終盤：隧道、移動隊形、強反彈護牆
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(r===1 || r===rows-2){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {unbreakable:true});
          }else if(c%3===0 && (r%2===0)){
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+2, strong:true});
          }else{
            const mv=(r%3===1 && c%2===0);
            addBrick(bricks, xAt(c), yAt(r), brickW, brickH, {hp:baseHP+1, moving:mv, vx: mv?((Math.random()<0.5?-1:1)*1.0):0});
          }
        }
      }
    }
  }

  function explodeAt(cx,cy){
    const radius=Math.max(brickW,brickH)*1.3;
    for(let i=bricks.length-1;i>=0;i--){
      const b=bricks[i];
      const bx=b.x+b.w/2, by=b.y+b.h/2; const d=Math.hypot(bx-cx,by-cy);
      if(d<=radius){
        if(b.unbreakable){ continue; }
        // Boss：只扣血，不秒殺
        if(b.boss){
          b.hp -= 1;
          if(b.hp<=0){ revealBrickArea(b); bricks.splice(i,1); score+=50; }
        }else{
          revealBrickArea(b); bricks.splice(i,1); score+=10;
        }
        spawnParticles(bx,by,'#ffdd99',14,1.7,2.6,3);
      }
    }
    spawnParticles(cx,cy,'#ffbb55',24,2.1,3.2,4); updateHUD(); beep(200,0.08,0.08);
  }

  // === 掉落道具 ===
  const powerups=[]; const ALL_TYPES=Object.keys(GAME_CONFIG.powers); const NORMAL_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type!=='rare'); const RARE_TYPES=ALL_TYPES.filter(k=>GAME_CONFIG.powers[k].type==='rare');
  function spawnPower(x,y){ const rareChance=(GAME_CONFIG.powers.PHOENIX?.rareFactor)||0.1; const pickRare=RARE_TYPES.length && Math.random()<rareChance; const pool=pickRare?RARE_TYPES:NORMAL_TYPES; const type=pool[Math.floor(Math.random()*pool.length)]; const def=GAME_CONFIG.powers[type];
    powerups.push({x,y,w:GAME_CONFIG.powerCapsule.width,h:GAME_CONFIG.powerCapsule.height,vy:GAME_CONFIG.powerCapsule.fallVy,type,isDebuff:(def.type==='debuff'),phase:Math.random()*Math.PI*2}); }

  function applyPower(type){
    const def=GAME_CONFIG.powers[type]; if(!def) return; const now=performance.now();
    // 罕見瞬發
    if(def.instant && def.type==='rare'){
      if(type==='PHOENIX'){ // 鳳凰飛過 + 火焰 + 隨機一半消除（Boss只扣1）
        phoenixAnim={x:canvas.width+220,tEnd:now+1200};
        const keep=[]; for(const b of bricks){
          if(Math.random()<0.5){
            if(b.unbreakable){ keep.push(b); continue; }
            if(b.boss){ b.hp -= 1; if(b.hp>0){ keep.push(b);} else { revealBrickArea(b); score+=50; } }
            else { revealBrickArea(b); score+=10; }
            fireBursts.push({x:b.x+b.w/2,y:b.y+b.h/2,life:400+Math.random()*400});
          } else keep.push(b);
        }
        bricks=keep; screenShake=6; beep(180,0.12,0.1);
      } else if(type==='NINE'){ lives=9; updateHUD(); spawnParticles(550,350,'#ffd',40,2.2,3.5,4); beep(880,0.1,0.06); }
      return;
    }
    // 定時類
    if(def.durationMs){ if(type!=='LONG'){ const b=buffs[type]||(buffs[type]={active:false,until:0}); b.active=true; b.until=now+def.durationMs; } }
    if(def.paddleWidthAdd){ buffs.WIDE.active=true; buffs.WIDE.until=now+def.durationMs; }
    if(def.longPerStackAdd){ const act=buffs.LONG.stacks.filter(t=>t>now); const max=def.stacksMax??2; if(act.length<max){ buffs.LONG.stacks.push(now+def.durationMs);} else { const earliest=Math.min(...act); const idx=buffs.LONG.stacks.indexOf(earliest); buffs.LONG.stacks[idx]=now+def.durationMs; } }
    if(def.sticky){ buffs.STICKY.active=true; buffs.STICKY.until=now+def.durationMs; }
    if(def.multiDuplicate){ if(balls.length<3){ const news=[]; for(const b of balls){ const b1={...b}; b1.trail=[]; news.push(b1);} balls=balls.concat(news); const cap=def.maxBalls??4; if(balls.length>cap) balls.length=cap; } }
    if(def.speedMul){ buffs.SLOW.active=true; buffs.SLOW.until=now+def.durationMs; }
    if(def.piercing){ buffs.PIERCE.active=true; buffs.PIERCE.until=now+def.durationMs; for(const b of balls) b.piercing=true; }
    if(def.oneShotShield){ buffs.SHIELD.active=true; }
    if(def.forcePiercing && def.rampageMs){ buffs.RAMPAGE.active=true; buffs.RAMPAGE.until=now+def.durationMs; for(const b of balls){ b.rampageUntil=now+def.rampageMs; b.piercing=true; } }
    if(def.globalSpeedMul){ buffs.FAST.active=true; buffs.FAST.until=now+def.durationMs; if(def.screenShakeOnApply) screenShake=def.screenShakeOnApply; }
    if(def.wavy){ buffs.WAVY.active=true; buffs.WAVY.until=now+def.durationMs; buffs.WAVY.start=now; }
    if(type==='PLASMA'){ buffs.PLASMA.active=true; buffs.PLASMA.until=now+def.durationMs; }
    if(type==='FREEZE'){ buffs.FREEZE.active=true; buffs.FREEZE.until=now+def.durationMs; }
    if(type==='HOLY'){ buffs.HOLY.active=true; buffs.HOLY.until=now+def.durationMs; }
    updateBuffBadges();
  }

  function drawPower(p){ const color=p.isDebuff?getVar('--debuff'):getVar('--power'); const x=p.x*scaleX, y=p.y*scaleY, w=p.w*scaleX, h=p.h*scaleY; const wobble=Math.sin(p.phase)*1.5; p.phase+=0.04;
    ctx.save(); ctx.translate(0,wobble); const grd=ctx.createLinearGradient(x,y,x,y+h); grd.addColorStop(0,color); grd.addColorStop(1,p.isDebuff?'#a33':'#3a56a8'); ctx.fillStyle=grd; roundedRect(x,y,w,h,8); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.stroke();
    ctx.fillStyle='#fff'; ctx.font=`${Math.max(10,Math.round(12*scaleY))}px ui-monospace, monospace`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.type[0], x+w/2, y+h/2+0.5); ctx.restore(); }

  function updateHUD(){ scoreEl.textContent=Math.max(0|score,0); levelEl.textContent=level + '/'+ GAME_CONFIG.totalLevels; livesEl.textContent=lives; }
  function showCenter(t,txt){ noteTitle.textContent=t; noteText.innerHTML=txt||''; centerNote.style.display='flex'; }
  function hideCenter(){ centerNote.style.display='none'; }

  function resetGame(load=false){ diff=getDiff(); level=load?level:1; score=load?score:0; lives=load?lives:3; updateHUD(); initBricks(); resetBalls(); paused=true; running=false;
    for(const k of Object.keys(buffs)){ if(k!=='LONG'){ buffs[k].active=false; buffs[k].until=0; } } buffs.LONG.stacks=[]; powerups.length=0; particles.length=0; plasmas.length=0; holyFlashes.length=0; phoenixAnim=null; fireBursts.length=0;
    updateBuffBadges(); computePaddleWidth(); paddle.x=1100/2-paddle.w/2; showCenter('按 Space 或點畫面開始','用 ←/→ 或 A/D 移動；手指拖曳畫面也可。'); countdownShow=0; }

  // === 存讀檔（含音效/BGM與影像選擇） ===
  function saveProgress(){ try{
      const data={level,score,lives,difficulty:difficultySel.value, imageChoice, soundsOn, bgmOn, bgmVol: parseFloat(bgmVol.value)};
      localStorage.setItem('breakout_save_v_final_cfg', JSON.stringify(data)); alert('已存檔！');
    }catch(e){ alert('存檔失敗：'+e); } }
  function loadProgress(){ try{ const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4'); if(!raw){ alert('沒有存檔'); return; } const data=JSON.parse(raw);
      difficultySel.value=data.difficulty||'normal'; level=data.level||1; score=data.score||0; lives=data.lives||3; if(Array.isArray(data.imageChoice)) imageChoice=data.imageChoice;
      soundsOn=!!data.soundsOn; soundBtn.textContent=`音效：${soundsOn?'開':'關'}`;
      if(typeof data.bgmOn==='boolean'){ bgmOn=data.bgmOn; } if(typeof data.bgmVol==='number'){ bgmVol.value=String(data.bgmVol); if(bgmGain) bgmGain.gain.value=data.bgmVol; localStorage.setItem('bgm_vol', data.bgmVol); }
      resetGame(true); updateHUD(); alert(`已讀檔：等級 ${level}，分數 ${score}，生命 ${lives}`);}catch(e){ alert('讀檔失敗：'+e); } }
  function clearSave(){ localStorage.removeItem('breakout_save_v_final_cfg'); alert('已清除存檔'); }

  // === 輸入（含觸控） ===
  let keyL=false, keyR=false; let touchActive=false;
  window.addEventListener('keydown',(e)=>{
    if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=true;
    if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=true;
    if(e.code==='Space'){ // 開始 / 暫停 / 倒數
      if(!running){ startGameWithCountdown(); } else { togglePause(); }
      return;
    }
    if((e.code==='ArrowUp' || e.key==='Shift') && !paused && running){
      let released=false;
      for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy = -Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
    if(e.key==='r'||e.key==='R'){ resetGame(); }
    if(e.key==='f'||e.key==='F'){ toggleFullscreen(); }
  });
  window.addEventListener('keyup',(e)=>{ if(e.code==='ArrowLeft'||e.key==='a'||e.key==='A') keyL=false; if(e.code==='ArrowRight'||e.key==='d'||e.key==='D') keyR=false; });
  canvas.addEventListener('mousemove',(e)=>{ const rect=canvas.getBoundingClientRect(); const x=(e.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); });
  canvas.addEventListener('click',()=>{
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  });
  canvas.addEventListener('touchstart',(e)=>{ touchActive=true; 
    if(!running){ startGameWithCountdown(); return; }
    if(running && !paused){
      let released=false; for(const b of balls){ if(b.stuck){ b.stuck=false; b.vy=-Math.abs(b.vy||6); released=true; } }
      if(released) return;
    }
  }, {passive:true});
  canvas.addEventListener('touchmove',(e)=>{ if(!touchActive) return; const t=e.touches[0]; const rect=canvas.getBoundingClientRect(); const x=(t.clientX-rect.left)*(1100/rect.width); paddle.x=Math.max(0, Math.min(1100-paddle.w, x - paddle.w/2)); }, {passive:true});
  canvas.addEventListener('touchend',()=>{ touchActive=false; }, {passive:true});
  pauseBtn.addEventListener('click',()=>togglePause()); resetBtn.addEventListener('click',()=>resetGame()); fsBtn.addEventListener('click',()=>toggleFullscreen());
  soundBtn.addEventListener('click',()=>{ soundsOn=!soundsOn; localStorage.setItem('sfx_on', soundsOn?'1':'0'); soundBtn.textContent=`音效：${soundsOn?'開':'關'}`; ensureAudio(); audioCtx?.resume?.(); beep(880,0.06,0.05); });
  difficultySel.addEventListener('change',()=>{ resetGame(); });
  saveBtn.addEventListener('click',saveProgress); loadBtn.addEventListener('click',loadProgress); clearSaveBtn.addEventListener('click',clearSave);
  tutorBtn.addEventListener('click', ()=> toggleHelp('tutor'));
  effectsBtn.addEventListener('click', ()=> toggleHelp('effects'));
  againBtn.addEventListener('click', ()=>{ win.classList.remove('show'); resetGame(); });

  // BGM UI
  bgmBtn.addEventListener('click', ()=>{
    bgmOn=!bgmOn; localStorage.setItem('bgm_on', bgmOn?'1':'0'); bgmBtn.textContent= bgmOn?'開':'關';
    if(bgmOn){ ensureAudio(); startBGM(); } else { stopBGM(); }
  });
  bgmVol.addEventListener('input', ()=>{
    ensureAudio(); const v=parseFloat(bgmVol.value||'0.5'); if(bgmGain) bgmGain.gain.value=v; localStorage.setItem('bgm_vol', v);
  });

  function togglePause(){
    if(!running){ startGameWithCountdown(); return; }
    paused=!paused;
    if(paused){ showCenter('已暫停','按 Space / 點畫面繼續'); }
    else { startCountdown(); }
  }

  function startGameWithCountdown(){
    running=true; paused=true; hideCenter();
    ensureAudio(); audioCtx?.resume?.();
    // 音效與BGM設定載入
    soundsOn = (localStorage.getItem('sfx_on')||'0')==='1';
    soundBtn.textContent=`音效：${soundsOn?'開':'關'}`;
    bgmOn = (localStorage.getItem('bgm_on')||'0')==='1';
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.5'); bgmVol.value=String(v); ensureAudio(); if(bgmGain) bgmGain.gain.value=v;
    bgmBtn.textContent = bgmOn?'開':'關';
    if(bgmOn) startBGM();
    startCountdown();
  }

  // === 教學/效果說明 ===
  let helpMode=null; // 'tutor' | 'effects' | null
  function toggleHelp(mode){
    if(helpMode===mode){ helpMode=null; hideCenter(); if(!running){ startCountdown(); } return; }
    helpMode=mode;
    paused=true;
    if(mode==='tutor'){
      showCenter('教學（按鈕再按一次關閉）', `
        <div class="cols">
          <div>
            <strong>操作</strong><br>
            電腦：<kbd>←</kbd>/<kbd>→</kbd> 或 <kbd>A</kbd>/<kbd>D</kbd> 移動；<kbd>Space</kbd> 開始/暫停。<br>
            釋放黏住的球：<kbd>↑</kbd> 或 <kbd>Shift</kbd>。<br>
            手機：手指拖曳擋板位置即可。<br>
            全螢幕：<kbd>F</kbd>。
          </div>
          <div>
            <strong>目標</strong><br>
            打破所有可破壞磚進入下一關。每 5 關有 Boss（只扣血不會被秒殺）。<br>
            第 1~10 關與 11~20 關會分別顯示同組照片的不同張，20 關結束播放通關畫面。
          </div>
          <div>
            <strong>存讀檔</strong><br>
            可儲存關卡/分數/生命、難度、照片選擇、音效/BGM 設定。
          </div>
        </div>`);
    }else{
      // 效果說明：從 powers 輸出
      let html = '<div class="cols">';
      html += '<div><strong>增益/稀有</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p=GAME_CONFIG.powers[k]; if(p.type==='debuff') continue;
        html += `${badgeIcon(k)} <em>${k}</em>：${p.label}<br>`;
      }
      html += '</div><div><strong>減益</strong><br>';
      for(const k of Object.keys(GAME_CONFIG.powers)){
        const p=GAME_CONFIG.powers[k]; if(p.type!=='debuff') continue;
        html += `${badgeIcon(k)} <em>${k}</em>：${p.label}<br>`;
      }
      html += '</div><div><strong>特殊磚</strong><br>不可破壞磚：只反彈不會壞；<br>移動磚：水平移動；<br>強反彈磚：反彈時加速更強；<br>Boss磚：大尺寸、只扣血，爆炸/神聖/鳳凰也不會被秒殺。</div>';
      html += '</div>';
      showCenter('效果說明（按鈕再按一次關閉）', html);
    }
  }

  // === 全螢幕 ===
  async function toggleFullscreen(){ const elem=document.documentElement; try{ if(!document.fullscreenElement){ await elem.requestFullscreen(); } else { await document.exitFullscreen(); } }catch(e){ console.warn('Fullscreen failed:', e); } }

  // === 擋板寬度 ===
  function computePaddleWidth(){ const now=performance.now(); buffs.LONG.stacks=buffs.LONG.stacks.filter(t=>t>now); const longStacks=Math.min(GAME_CONFIG.powers.LONG.stacksMax, buffs.LONG.stacks.length);
    const addLong=longStacks*(GAME_CONFIG.powers.LONG.longPerStackAdd||0); const addWide=(buffs.WIDE.active?(GAME_CONFIG.powers.WIDE.paddleWidthAdd||0):0); const base=getDiff().paddleBaseW;
    const newW=Math.min(GAME_CONFIG.caps.paddleMaxW, base+addWide+addLong); const center=paddle.x+paddle.w/2; paddle.w=newW; paddle.x=Math.max(0, Math.min(1100-paddle.w, center - paddle.w/2)); }

  function speedMultiplier(now){ let mul=1.0; if(buffs.SLOW.active){ mul*=(GAME_CONFIG.powers.SLOW.speedMul??1.0);} if(buffs.FAST.active){ mul*=(GAME_CONFIG.powers.FAST.globalSpeedMul??1.0);} if(buffs.WAVY.active){ const w=GAME_CONFIG.powers.WAVY.wavy||{amp:0.6,base:1.2,periodMs:200}; const phase=(now-(buffs.WAVY.start||now))/(w.periodMs); mul*=(w.base+w.amp*Math.sin(phase)); } return mul; }

  // === 背景裝飾 & LED 燈條 ===
  function ledColor(){
    if(buffs.HOLY.active) return '#ffe08a';
    if(buffs.PLASMA.active) return '#9fe8ff';
    if(buffs.FREEZE.active) return '#cfe9ff';
    if(buffs.RAMPAGE.active || buffs.PIERCE.active) return '#7fd8ff';
    if(buffs.FAST.active) return '#ffb37a';
    if(buffs.WAVY.active) return '#ba8fff';
    return '#8fb3ff';
  }
  function drawBGDecor(){ const w=canvas.width,h=canvas.height; bgTime+=0.003; ctx.save(); ctx.globalAlpha=0.12; ctx.translate(Math.sin(bgTime)*8, Math.cos(bgTime*0.7)*6); const step=40;
    for(let x=0;x<w;x+=step){ ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(x,0,1,h);} for(let y=0;y<h;y+=step){ ctx.fillStyle='rgba(255,255,255,.025)'; ctx.fillRect(0,y,w,1);} ctx.restore();
    const grad=ctx.createRadialGradient(w/2,h*0.2,0,w/2,h*0.5,Math.max(w,h)); grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(1,'rgba(0,0,0,0.35)'); ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
    if(buffs.SLOW.active){ ctx.fillStyle='rgba(80,140,255,0.08)'; ctx.fillRect(0,0,w,h); }

    // 鳳凰火焰殘留
    for(let i=fireBursts.length-1;i>=0;i--){ const f=fireBursts[i]; f.life-=16; if(f.life<=0){ fireBursts.splice(i,1); continue; } const a=Math.min(1, f.life/600); const rx= (f.x*scaleX), ry=(f.y*scaleY); const r=60*((scaleX+scaleY)/2); const g=ctx.createRadialGradient(rx,ry,1,rx,ry,r); g.addColorStop(0,`rgba(255,180,0,${0.6*a})`); g.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(rx,ry,r,0,Math.PI*2); ctx.fill(); }

    // LED 邊框
    const c=ledColor(); ctx.save(); ctx.globalAlpha=0.9; ctx.strokeStyle=c; ctx.lineWidth=6; ctx.shadowColor=c; ctx.shadowBlur=25; ctx.strokeRect(4,4,canvas.width-8,canvas.height-8); ctx.restore();
  }

  // 只在磚塊區域揭示圖片切片（依本關影像）
  function drawRevealTiles(){ const img=getLevelImage(level); if(!img || !(img.naturalWidth>0 && img.naturalHeight>0)) return; const L=layout();
    const area={x:L.pad,y:L.top,w:1100-L.pad*2,h:L.rows*(brickH+L.pad)-L.pad}; const rImg=img.naturalWidth/img.naturalHeight; const rArea=area.w/area.h; let dw,dh;
    if(rImg>rArea){ dh=area.h; dw=dh*rImg; } else { dw=area.w; dh=dw/rImg; } const dx=area.x+(area.w-dw)/2; const dy=area.y+(area.h-dh)/2;
    for(const r of revealRects){
      let sx=(r.x-dx)/dw*img.naturalWidth;
      let sy=(r.y-dy)/dh*img.naturalHeight;
      let sw=r.w/dw*img.naturalWidth;
      let sh=r.h/dh*img.naturalHeight;
      const sx0=Math.max(0, Math.min(img.naturalWidth, sx));
      const sy0=Math.max(0, Math.min(img.naturalHeight, sy));
      const sw0=Math.max(0, Math.min(img.naturalWidth - sx0, sw));
      const sh0=Math.max(0, Math.min(img.naturalHeight - sy0, sh));
      if(sw0>0 && sh0>0){
        ctx.drawImage(img, sx0,sy0,sw0,sh0, r.x*scaleX, r.y*scaleY, r.w*scaleX, r.h*scaleY);
      }
    } }

  function drawPlasmas(){ const now=performance.now(); ctx.save(); for(let i=plasmas.length-1;i>=0;i--){ const P=plasmas[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.995; P.vy*=0.995; if(now>P.until){ plasmas.splice(i,1); continue; }
      const x=P.x*scaleX, y=P.y*scaleY, r=P.radius*((scaleX+scaleY)/2); const grd=ctx.createRadialGradient(x,y,2,x,y,r); grd.addColorStop(0,'rgba(150,230,255,0.9)'); grd.addColorStop(0.4,'rgba(120,200,255,0.35)'); grd.addColorStop(1,'rgba(120,200,255,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(180,240,255,0.5)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,r*0.7,0,Math.PI*2); ctx.stroke();
      // 沿途清除磚塊（Boss/不可破壞豁免）
      for(let j=bricks.length-1;j>=0;j--){ const b=bricks[j]; const bx=b.x+b.w/2, by=b.y+b.h/2; if(Math.hypot(P.x-bx,P.y-by)<=P.radius){
          if(b.unbreakable) continue;
          if(b.boss){ b.hp-=1; if(b.hp<=0){ revealBrickArea(b); bricks.splice(j,1); score+=50; } }
          else { revealBrickArea(b); bricks.splice(j,1); score+=10; }
        }
      }
    } ctx.restore(); }

  function drawHoly(){ const now=performance.now(); for(let i=holyFlashes.length-1;i>=0;i--){ const H=holyFlashes[i]; if(now>H.until){ holyFlashes.splice(i,1); continue; } const a=Math.max(0, (H.until-now)/300); ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle=`rgba(255,240,180,${0.6*a})`; ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(0, H.y*scaleY); ctx.lineTo(canvas.width, H.y*scaleY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(H.x*scaleX, 0); ctx.lineTo(H.x*scaleX, canvas.height); ctx.stroke(); ctx.restore(); } }

  function drawPhoenix(){ if(!phoenixAnim) return; const now=performance.now(); const t=phoenixAnim; const prog=1-Math.max(0,(t.tEnd-now)/1200); const logicW=1100; const xLogic=(1-prog)*(logicW+200)-200; const x=xLogic*scaleX;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    // 身形光羽
    const grad=ctx.createLinearGradient((x+120),220*scaleY,x,260*scaleY); grad.addColorStop(0,'rgba(255,180,0,0.9)'); grad.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle=grad;
    ctx.beginPath(); ctx.moveTo((x+180), 220*scaleY); ctx.quadraticCurveTo((x+60), 180*scaleY, (x), 230*scaleY); ctx.quadraticCurveTo((x-40), 260*scaleY, (x+120), 260*scaleY); ctx.closePath(); ctx.fill();
    // 羽毛粒子
    for(let i=0;i<3;i++){ fireBursts.push({x:(x-40)+Math.random()*120,y:220+Math.random()*60,life:300+Math.random()*400}); }
    ctx.restore(); if(now>=t.tEnd) phoenixAnim=null; }

  function draw(){
    if(screenShake>0){ const s=screenShake*0.6; ctx.save(); ctx.translate((Math.random()-0.5)*s,(Math.random()-0.5)*s); screenShake*=0.9; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBGDecor();
    drawRevealTiles();

    // 磚塊
    for(const b of bricks){
      // 移動磚更新
      if(b.moving){
        b.x += b.vx;
        if(b.x<8){ b.x=8; b.vx=Math.abs(b.vx); }
        if(b.x+b.w>1100-8){ b.x=1100-8-b.w; b.vx=-Math.abs(b.vx); }
      }
      // 繪製
      let base = b.boss ? '#ff4d6d' : b.unbreakable ? '#888' : b.strong ? '#bb7aff' : b.moving ? '#6ec6ff' : b.explosive ? getVar('--expl') : brickColor(b.colorIdx);
      const g=ctx.createLinearGradient((b.x)*scaleX,(b.y)*scaleY,(b.x)*scaleX,(b.y+b.h)*scaleY); g.addColorStop(0,base); g.addColorStop(1,'#1a1f3a'); ctx.fillStyle=g; drawRoundedRect(b.x,b.y,b.w,b.h,6); ctx.fill();
      // 血條 / 面孔
      if(b.boss){
        ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect((b.x+6)*scaleX,(b.y+b.h-6)*scaleY,(b.w-12)*scaleX,4*scaleY);
        const ratio=Math.max(0, b.hp/40); ctx.fillStyle='rgba(255,220,220,.9)'; ctx.fillRect((b.x+6)*scaleX,(b.y+b.h-6)*scaleY,(b.w-12)*ratio*scaleX,4*scaleY);
        ctx.fillStyle='rgba(255,255,255,.85)'; ctx.font=`${Math.max(10,Math.round(18*scaleY))}px system-ui, sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(b.face, (b.x+b.w/2)*scaleX, (b.y+b.h/2)*scaleY);
      }else if(b.hp>1 && b.hp<99 && b.hp<Infinity){
        ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*scaleX,4*scaleY);
        ctx.fillStyle='rgba(255,255,255,.75)'; const ratio=Math.max(0,(b.hp-1))/3; ctx.fillRect((b.x+4)*scaleX,(b.y+b.h-6)*scaleY,(b.w-8)*ratio*scaleX,4*scaleY);
      }
    }

    drawPlasmas(); drawHoly(); drawPhoenix();

    // 擋板
    const padGlow=buffs.STICKY.active?'rgba(120,230,220,.6)':((buffs.WIDE.active||buffs.LONG.stacks.length)?'rgba(120,170,255,.6)':'rgba(200,210,255,.4)'); ctx.shadowColor=padGlow; ctx.shadowBlur=20;
    ctx.fillStyle='#9aaeff'; drawRoundedRect(paddle.x,paddle.y,paddle.w,paddle.h,8); ctx.fill(); ctx.shadowBlur=0;
    if(buffs.SHIELD.active){ const g=ctx.createLinearGradient(0,(700-10)*scaleY,0,700*scaleY); g.addColorStop(0,'rgba(120,220,255,0.35)'); g.addColorStop(1,'rgba(120,220,255,0.05)'); ctx.fillStyle=g; ctx.fillRect(0,(700-10)*scaleY,canvas.width,10*scaleY); }

    // 球與拖尾
    const nowT=performance.now();
    for(const b of balls){
      b.trail.push({x:b.x,y:b.y,t:nowT}); while(b.trail.length>12) b.trail.shift();
      for(let i=b.trail.length-1;i>=0;i--){ const p=b.trail[i]; const age=(nowT-p.t)/200; if(age>1) continue; const alpha=(1-age)*0.6;
        let color=( (b.rampageUntil&&nowT<b.rampageUntil)||b.piercing )?`rgba(120,220,255,${alpha})`:(buffs.FAST.active?`rgba(255,140,90,${alpha})`:`rgba(255,255,255,${alpha*0.6})`);
        if(buffs.PLASMA.active) color=`rgba(160,240,255,${alpha})`; if(buffs.FREEZE.active) color=`rgba(200,230,255,${alpha})`; if(buffs.HOLY.active) color=`rgba(255,240,180,${alpha})`;
        ctx.fillStyle=color; ctx.beginPath(); ctx.arc(p.x*scaleX,p.y*scaleY,(b.r*0.7)*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill();
      }
      const bx=b.x*scaleX, by=b.y*scaleY, br=b.r*((scaleX+scaleY)/2); const grad=ctx.createRadialGradient(bx-3,by-4,2,bx,by,br);
      let edge=(b.piercing||(b.rampageUntil&&nowT<b.rampageUntil))?'#9ff':(buffs.FAST.active?'#ff9a66':'#cbd4ff'); if(buffs.PLASMA.active) edge='#aff'; if(buffs.FREEZE.active) edge='#e8f8ff'; if(buffs.HOLY.active) edge='#fff0a0';
      grad.addColorStop(0,'#fff'); grad.addColorStop(1, edge); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();
      if(buffs.WAVY.active){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; const r1=br+2+2*Math.sin((nowT/100)+b.x*0.02); ctx.beginPath(); ctx.arc(bx,by,r1,0,Math.PI*2); ctx.stroke(); }
      if(b.stuck){ ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect((paddle.x+paddle.w/2-12)*scaleX,(paddle.y-6)*scaleY,24*scaleX,4*scaleY); }
    }

    // 掉落道具
    for(const p of powerups) drawPower(p);

    // 粒子
    for(let i=particles.length-1;i>=0;i--){ const P=particles[i]; P.x+=P.vx; P.y+=P.vy; P.vx*=0.98; P.vy*=0.98; P.life-=16; if(P.life<=0){ particles.splice(i,1); continue; }
      const a=Math.max(0, Math.min(1, P.life/500)); ctx.fillStyle=P.color||`rgba(255,220,180,${a*0.6})`; ctx.beginPath(); ctx.arc(P.x*scaleX,P.y*scaleY,P.size*((scaleX+scaleY)/2),0,Math.PI*2); ctx.fill(); }

    // 倒數提示
    if(countdownShow>0){
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.font=`${Math.round(96*((scaleX+scaleY)/2))}px system-ui, sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(countdownShow), canvas.width/2, canvas.height/2);
      ctx.restore();
    }

    if(screenShake>0){ ctx.restore(); }
  }

  function resetBalls(center=true){ balls=[makeBall(false)]; const base=getDiff().baseSpeed; const speed=base+Math.min(level*0.5,4); const angle=(-60-Math.random()*60)*Math.PI/180;
    balls[0].x=center?1100/2:paddle.x+paddle.w/2; balls[0].y=700-70; balls[0].vx=Math.cos(angle)*speed; balls[0].vy=Math.sin(angle)*speed; balls[0].piercing=buffs.PIERCE.active; }

  function startCountdown(){
    paused=true; countdownShow=3; showCenter('', ''); centerNote.style.display='none'; // 用畫面倒數
    resumePending=true;
    const tick=()=>{
      if(countdownShow<=0){ resumePending=false; paused=false; return; }
      beep(600 + (3-countdownShow)*100, 0.07, 0.05);
      setTimeout(()=>{ countdownShow--; if(countdownShow===0){ paused=false; } else { tick(); } }, 450);
    };
    tick();
  }

  function update(){
    const now=performance.now();
    // Buff 過期
    for(const key of Object.keys(GAME_CONFIG.powers)){
      if(key==='LONG') continue; 
      const b=buffs[key];
      if(b?.active && b.until && now>b.until){
        b.active=false;
        if(key==='PIERCE'){ for(const ball of balls) ball.piercing=false; }
        if(key==='STICKY'){
          for(const ball of balls){ if(ball.stuck){ ball.stuck=false; ball.vy = -Math.abs(ball.vy||6); } }
        }
      }
    }
    computePaddleWidth(); updateBuffBadges();

    if(keyL) paddle.x-=paddle.speed; if(keyR) paddle.x+=paddle.speed; paddle.x=Math.max(0, Math.min(1100-paddle.w, paddle.x));

    const mulGlobal=speedMultiplier(now);
    for(const b of balls){
      if(b.freeze.until && now<b.freeze.until){ continue; }
      if(b.freeze.until && now>=b.freeze.until){ b.vx=b.freeze.oldVX; b.vy=b.freeze.oldVY; b.freeze.until=0; }

      if(b.rampageUntil && now>b.rampageUntil){ b.rampageUntil=0; if(!buffs.PIERCE.active) b.piercing=false; }
      if(b.stuck){ b.x=paddle.x+paddle.w/2+b.offsetX; b.y=paddle.y-b.r-0.1; continue; }
      b.x+=b.vx*mulGlobal; b.y+=b.vy*mulGlobal;

      // 邊界
      if(b.x-b.r<0){ b.x=b.r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
      if(b.x+b.r>1100){ b.x=1100-b.r; b.vx*=-1; beep(780,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
      if(b.y-b.r<0){ b.y=b.r; b.vy*=-1; beep(700,0.03); spawnParticles(b.x,b.y,'rgba(153,187,255,.8)',5,1.2,1.2,2); }
      if(b.y-b.r>700){
        if(buffs.SHIELD.active){ buffs.SHIELD.active=false; b.y=700-b.r-1; b.vy=-Math.abs(b.vy); }
        else { const idx=balls.indexOf(b); if(idx>=0) balls.splice(idx,1); break; }
      }

      // 擋板
      if(b.y+b.r>=paddle.y && b.y+b.r<=paddle.y+paddle.h && b.x>=paddle.x && b.x<=paddle.x+paddle.w && b.vy>0){
        const hitPos=(b.x-(paddle.x+paddle.w/2))/(paddle.w/2); const sp=Math.min(Math.hypot(b.vx,b.vy)*1.02, b.speedCap); const angle=hitPos*(Math.PI/3);
        b.vx=Math.sin(angle)*sp; b.vy=-Math.cos(angle)*sp; b.y=paddle.y-b.r-0.1; beep(880,0.03); spawnParticles(b.x,b.y,'#caddff',8,1.3,1.5,2.5);
        if(buffs.STICKY.active){ b.stuck=true; b.offsetX=b.x-(paddle.x+paddle.w/2); }
      }

      // 碰磚
      let hit=-1; for(let i=0;i<bricks.length;i++){ const bk=bricks[i]; if(b.x+b.r>bk.x && b.x-b.r<bk.x+bk.w && b.y+b.r>bk.y && b.y-b.r<bk.y+bk.h){ hit=i; break; } }
      if(hit>=0){
        const bk=bricks[hit]; const inRampage=b.rampageUntil && now<b.rampageUntil;
        // 反彈計算
        const oL=(b.x+b.r)-bk.x, oR=(bk.x+bk.w)-(b.x-b.r), oT=(b.y+b.r)-bk.y, oB=(bk.y+bk.h)-(b.y-b.r); const m=Math.min(oL,oR,oT,oB);
        if(!inRampage && !b.piercing){
          if(m===oL){ b.x=bk.x-b.r; b.vx=-Math.abs(b.vx); } else if(m===oR){ b.x=bk.x+bk.w+b.r; b.vx=Math.abs(b.vx); } else if(m===oT){ b.y=bk.y-b.r; b.vy=-Math.abs(b.vy); } else { b.y=bk.y+bk.h+b.r; b.vy=Math.abs(b.vy); }
        }else{
          if(m===oL){ b.x=bk.x-b.r; b.vx=Math.abs(b.vx)||4; } else if(m===oR){ b.x=bk.x+bk.w+b.r; b.vx=-Math.abs(b.vx)||-4; } else if(m===oT){ b.y=bk.y-b.r; b.vy=Math.abs(b.vy)||4; } else { b.y=bk.y+bk.h+b.r; b.vy=-Math.abs(b.vy)||-4; }
          b.piercing=true;
        }

        // 強反彈：加速更多
        if(bk.strong){
          const sp=Math.min(Math.hypot(b.vx,b.vy)*1.15, b.speedCap+2); const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp; screenShake=Math.max(screenShake,3);
        }

        // 扣血 / 未破壞處理
        if(bk.unbreakable){
          // 只反彈，稍微加速
          const sp=Math.min(Math.hypot(b.vx,b.vy)*1.05, b.speedCap); const ang=Math.atan2(b.vy,b.vx); b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp;
        }else{
          // 一般或Boss
          if(buffs.PLASMA.active){ const cfg=GAME_CONFIG.powers.PLASMA.plasma; const ang=Math.random()*Math.PI*2; plasmas.push({x:bk.x+bk.w/2,y:bk.y+bk.h/2,vx:Math.cos(ang)*cfg.drift,vy:Math.sin(ang)*cfg.drift,until:now+cfg.lifeMs,radius:cfg.radius}); }
          if(buffs.FREEZE.active && !b.freeze.pending){
            const f=GAME_CONFIG.powers.FREEZE.freeze;
            b.freeze.pending = true;
            setTimeout(()=>{
              if(!buffs.FREEZE.active){ b.freeze.pending=false; return; }
              b.freeze.oldVX=b.vx; b.freeze.oldVY=b.vy;
              b.freeze.until=performance.now()+f.stopMs;
              b.vx=0; b.vy=0;
              b.freeze.pending=false;
              spawnParticles(b.x,b.y,'rgba(230,247,255,0.9)',16,1.2,1.0,2.5);
            }, f.delayMs);
          }
          if(buffs.HOLY.active){
            holyFlashes.push({x:bk.x+bk.w/2, y:bk.y+bk.h/2, until:now+350});
            for(let i=bricks.length-1;i>=0;i--){ const t=bricks[i]; const sameRow=Math.abs(t.y-bk.y)<1; const sameCol=Math.abs(t.x-bk.x)<1;
              if(sameRow||sameCol){
                if(t.unbreakable) continue;
                if(t.boss){ t.hp-=1; if(t.hp<=0){ revealBrickArea(t); bricks.splice(i,1); score+=50; } }
                else { revealBrickArea(t); bricks.splice(i,1); score+=10; }
              }
            }
            screenShake=Math.max(screenShake,4);
          }

          // 當前磚扣血
          bk.hp=(bk.hp||1)-1; score+=10; updateHUD();

          // 爆炸處理
          if(bk.hp<=0){
            const cx=bk.x+bk.w/2, cy=bk.y+bk.h/2;
            revealBrickArea(bk);
            if(Math.random()<getDiff().dropRate) spawnPower(cx-12,cy);
            if(bk.explosive){ explodeAt(cx,cy); } else { bricks.splice(hit,1); }
          }else{
            // Boss/多血，不移除
          }
        }
        beep(520+Math.random()*200,0.03,0.05);
      }
    }

    // 球全沒了
    if(balls.length===0){
      lives--; updateHUD();
      if(lives<=0){ running=false; paused=true; showCenter('遊戲結束', `分數：${score}<br>按 Space 或點畫面再來一局，或按 R 重開。`); return; }
      else { resetBalls(false); startCountdown(); return; }
    }

    // 掉落道具移動/撿取
    for(let i=powerups.length-1;i>=0;i--){ const p=powerups[i]; p.y+=p.vy; if(p.y+p.h>=paddle.y && p.x+p.w>=paddle.x && p.x<=paddle.x+paddle.w && p.y<=paddle.y+paddle.h){ applyPower(p.type); powerups.splice(i,1); continue; } if(p.y>710) powerups.splice(i,1); }

    // 清關（進入畫廊或通關）
    if(!hasBreakables()){
      paused=true; running=false;
      if(level>=GAME_CONFIG.totalLevels){
        // 通關
        finalScore.textContent=String(score);
        ring.innerHTML='';
        // 依序 1..10 用第一輪使用的 / 第二輪用補足另一張，展示 20 張縮圖
        for(let i=1;i<=GAME_CONFIG.totalLevels;i++){
          const im=getLevelImage(i);
          const th=document.createElement('img'); th.src=im.src; ring.appendChild(th);
        }
        win.classList.add('show');
        // 小短號角
        ensureAudio(); if(audioCtx){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(659, audioCtx.currentTime); g.gain.value=0.04; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{ o.frequency.value=880; }, 200); setTimeout(()=>{ o.stop(); }, 600); }
      }else{
        // 畫廊預覽
        galleryImg.src=getLevelImage(level).src;
        gallery.style.display='flex'; requestAnimationFrame(()=>gallery.classList.add('show'));
        const proceed=()=>{ gallery.classList.remove('show'); setTimeout(()=>{ gallery.style.display='none'; gallery.removeEventListener('click',proceed); },200); level++; updateHUD(); initBricks(); resetBalls(); paused=true; running=false; showCenter(`進入關卡 ${level}`,'按 Space 或點畫面開始'); };
        gallery.addEventListener('click',proceed,{once:true}); return;
      }
    }
  }

  function loop(){ if(!paused && running) update(); draw(); requestAnimationFrame(loop); }
  function boot(){
    resetGame(); updateHUD(); loop();
    // 自動讀取音效/BGM偏好
    soundsOn = (localStorage.getItem('sfx_on')||'0')==='1'; soundBtn.textContent=`音效：${soundsOn?'開':'關'}`;
    const v = parseFloat(localStorage.getItem('bgm_vol')||'0.5'); bgmVol.value=String(v);
    bgmOn = (localStorage.getItem('bgm_on')||'0')==='1'; bgmBtn.textContent = bgmOn?'開':'關';
    // 若有存檔給提示
    const raw=localStorage.getItem('breakout_save_v_final_cfg')||localStorage.getItem('breakout_save_v4');
    if(raw){ setTimeout(()=>{ if(confirm('偵測到存檔，要讀取進度嗎？')) loadProgress(); }, 400); }
  }
  boot();
})();
</script>
</body>
</html>
